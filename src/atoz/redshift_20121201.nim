
import
  json, options, hashes, uri, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: Amazon Redshift
## version: 2012-12-01
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>Amazon Redshift</fullname> <p> <b>Overview</b> </p> <p>This is an interface reference for Amazon Redshift. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Redshift clusters. Note that Amazon Redshift is asynchronous, which means that some interfaces may require techniques, such as polling or asynchronous callback handlers, to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a change is applied immediately, on the next instance reboot, or during the next maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the Amazon Redshift Management Interfaces</a>.</p> <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data warehouse: provisioning capacity, monitoring and backing up the cluster, and applying patches and upgrades to the Amazon Redshift engine. You can focus on using your data to acquire new insights for your business and customers.</p> <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p> <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design, build, query, and maintain the databases that make up your data warehouse. </p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/redshift/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_593421 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_593421](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_593421): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    if js.kind notin {JString, JInt, JFloat, JNull, JBool}:
      return
    head = $js
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com", "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
                           "us-west-2": "redshift.us-west-2.amazonaws.com",
                           "eu-west-2": "redshift.eu-west-2.amazonaws.com", "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com", "eu-central-1": "redshift.eu-central-1.amazonaws.com",
                           "us-east-2": "redshift.us-east-2.amazonaws.com",
                           "us-east-1": "redshift.us-east-1.amazonaws.com", "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "redshift.ap-south-1.amazonaws.com",
                           "eu-north-1": "redshift.eu-north-1.amazonaws.com", "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
                           "us-west-1": "redshift.us-west-1.amazonaws.com", "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "redshift.eu-west-3.amazonaws.com", "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "redshift.sa-east-1.amazonaws.com",
                           "eu-west-1": "redshift.eu-west-1.amazonaws.com", "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com", "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com", "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
      "us-west-2": "redshift.us-west-2.amazonaws.com",
      "eu-west-2": "redshift.eu-west-2.amazonaws.com",
      "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com",
      "eu-central-1": "redshift.eu-central-1.amazonaws.com",
      "us-east-2": "redshift.us-east-2.amazonaws.com",
      "us-east-1": "redshift.us-east-1.amazonaws.com",
      "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "redshift.ap-south-1.amazonaws.com",
      "eu-north-1": "redshift.eu-north-1.amazonaws.com",
      "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
      "us-west-1": "redshift.us-west-1.amazonaws.com",
      "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
      "eu-west-3": "redshift.eu-west-3.amazonaws.com",
      "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "redshift.sa-east-1.amazonaws.com",
      "eu-west-1": "redshift.eu-west-1.amazonaws.com",
      "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com",
      "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "redshift"
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_PostAcceptReservedNodeExchange_594030 = ref object of OpenApiRestCall_593421
proc url_PostAcceptReservedNodeExchange_594032(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostAcceptReservedNodeExchange_594031(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594033 = query.getOrDefault("Action")
  valid_594033 = validateParameter(valid_594033, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_594033 != nil:
    section.add "Action", valid_594033
  var valid_594034 = query.getOrDefault("Version")
  valid_594034 = validateParameter(valid_594034, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594034 != nil:
    section.add "Version", valid_594034
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594035 = header.getOrDefault("X-Amz-Date")
  valid_594035 = validateParameter(valid_594035, JString, required = false,
                                 default = nil)
  if valid_594035 != nil:
    section.add "X-Amz-Date", valid_594035
  var valid_594036 = header.getOrDefault("X-Amz-Security-Token")
  valid_594036 = validateParameter(valid_594036, JString, required = false,
                                 default = nil)
  if valid_594036 != nil:
    section.add "X-Amz-Security-Token", valid_594036
  var valid_594037 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594037 = validateParameter(valid_594037, JString, required = false,
                                 default = nil)
  if valid_594037 != nil:
    section.add "X-Amz-Content-Sha256", valid_594037
  var valid_594038 = header.getOrDefault("X-Amz-Algorithm")
  valid_594038 = validateParameter(valid_594038, JString, required = false,
                                 default = nil)
  if valid_594038 != nil:
    section.add "X-Amz-Algorithm", valid_594038
  var valid_594039 = header.getOrDefault("X-Amz-Signature")
  valid_594039 = validateParameter(valid_594039, JString, required = false,
                                 default = nil)
  if valid_594039 != nil:
    section.add "X-Amz-Signature", valid_594039
  var valid_594040 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594040 = validateParameter(valid_594040, JString, required = false,
                                 default = nil)
  if valid_594040 != nil:
    section.add "X-Amz-SignedHeaders", valid_594040
  var valid_594041 = header.getOrDefault("X-Amz-Credential")
  valid_594041 = validateParameter(valid_594041, JString, required = false,
                                 default = nil)
  if valid_594041 != nil:
    section.add "X-Amz-Credential", valid_594041
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_594042 = formData.getOrDefault("ReservedNodeId")
  valid_594042 = validateParameter(valid_594042, JString, required = true,
                                 default = nil)
  if valid_594042 != nil:
    section.add "ReservedNodeId", valid_594042
  var valid_594043 = formData.getOrDefault("TargetReservedNodeOfferingId")
  valid_594043 = validateParameter(valid_594043, JString, required = true,
                                 default = nil)
  if valid_594043 != nil:
    section.add "TargetReservedNodeOfferingId", valid_594043
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594044: Call_PostAcceptReservedNodeExchange_594030; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_594044.validator(path, query, header, formData, body)
  let scheme = call_594044.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594044.url(scheme.get, call_594044.host, call_594044.base,
                         call_594044.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594044, url, valid)

proc call*(call_594045: Call_PostAcceptReservedNodeExchange_594030;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## postAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594046 = newJObject()
  var formData_594047 = newJObject()
  add(formData_594047, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_594047, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_594046, "Action", newJString(Action))
  add(query_594046, "Version", newJString(Version))
  result = call_594045.call(nil, query_594046, nil, formData_594047, nil)

var postAcceptReservedNodeExchange* = Call_PostAcceptReservedNodeExchange_594030(
    name: "postAcceptReservedNodeExchange", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_PostAcceptReservedNodeExchange_594031, base: "/",
    url: url_PostAcceptReservedNodeExchange_594032,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAcceptReservedNodeExchange_593758 = ref object of OpenApiRestCall_593421
proc url_GetAcceptReservedNodeExchange_593760(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAcceptReservedNodeExchange_593759(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Version: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593885 = query.getOrDefault("Action")
  valid_593885 = validateParameter(valid_593885, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_593885 != nil:
    section.add "Action", valid_593885
  var valid_593886 = query.getOrDefault("TargetReservedNodeOfferingId")
  valid_593886 = validateParameter(valid_593886, JString, required = true,
                                 default = nil)
  if valid_593886 != nil:
    section.add "TargetReservedNodeOfferingId", valid_593886
  var valid_593887 = query.getOrDefault("Version")
  valid_593887 = validateParameter(valid_593887, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593887 != nil:
    section.add "Version", valid_593887
  var valid_593888 = query.getOrDefault("ReservedNodeId")
  valid_593888 = validateParameter(valid_593888, JString, required = true,
                                 default = nil)
  if valid_593888 != nil:
    section.add "ReservedNodeId", valid_593888
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_593889 = header.getOrDefault("X-Amz-Date")
  valid_593889 = validateParameter(valid_593889, JString, required = false,
                                 default = nil)
  if valid_593889 != nil:
    section.add "X-Amz-Date", valid_593889
  var valid_593890 = header.getOrDefault("X-Amz-Security-Token")
  valid_593890 = validateParameter(valid_593890, JString, required = false,
                                 default = nil)
  if valid_593890 != nil:
    section.add "X-Amz-Security-Token", valid_593890
  var valid_593891 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593891 = validateParameter(valid_593891, JString, required = false,
                                 default = nil)
  if valid_593891 != nil:
    section.add "X-Amz-Content-Sha256", valid_593891
  var valid_593892 = header.getOrDefault("X-Amz-Algorithm")
  valid_593892 = validateParameter(valid_593892, JString, required = false,
                                 default = nil)
  if valid_593892 != nil:
    section.add "X-Amz-Algorithm", valid_593892
  var valid_593893 = header.getOrDefault("X-Amz-Signature")
  valid_593893 = validateParameter(valid_593893, JString, required = false,
                                 default = nil)
  if valid_593893 != nil:
    section.add "X-Amz-Signature", valid_593893
  var valid_593894 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593894 = validateParameter(valid_593894, JString, required = false,
                                 default = nil)
  if valid_593894 != nil:
    section.add "X-Amz-SignedHeaders", valid_593894
  var valid_593895 = header.getOrDefault("X-Amz-Credential")
  valid_593895 = validateParameter(valid_593895, JString, required = false,
                                 default = nil)
  if valid_593895 != nil:
    section.add "X-Amz-Credential", valid_593895
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593918: Call_GetAcceptReservedNodeExchange_593758; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_593918.validator(path, query, header, formData, body)
  let scheme = call_593918.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593918.url(scheme.get, call_593918.host, call_593918.base,
                         call_593918.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593918, url, valid)

proc call*(call_593989: Call_GetAcceptReservedNodeExchange_593758;
          TargetReservedNodeOfferingId: string; ReservedNodeId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## getAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   Action: string (required)
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Version: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  var query_593990 = newJObject()
  add(query_593990, "Action", newJString(Action))
  add(query_593990, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_593990, "Version", newJString(Version))
  add(query_593990, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_593989.call(nil, query_593990, nil, nil, nil)

var getAcceptReservedNodeExchange* = Call_GetAcceptReservedNodeExchange_593758(
    name: "getAcceptReservedNodeExchange", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_GetAcceptReservedNodeExchange_593759, base: "/",
    url: url_GetAcceptReservedNodeExchange_593760,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeClusterSecurityGroupIngress_594067 = ref object of OpenApiRestCall_593421
proc url_PostAuthorizeClusterSecurityGroupIngress_594069(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostAuthorizeClusterSecurityGroupIngress_594068(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594070 = query.getOrDefault("Action")
  valid_594070 = validateParameter(valid_594070, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_594070 != nil:
    section.add "Action", valid_594070
  var valid_594071 = query.getOrDefault("Version")
  valid_594071 = validateParameter(valid_594071, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594071 != nil:
    section.add "Version", valid_594071
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594072 = header.getOrDefault("X-Amz-Date")
  valid_594072 = validateParameter(valid_594072, JString, required = false,
                                 default = nil)
  if valid_594072 != nil:
    section.add "X-Amz-Date", valid_594072
  var valid_594073 = header.getOrDefault("X-Amz-Security-Token")
  valid_594073 = validateParameter(valid_594073, JString, required = false,
                                 default = nil)
  if valid_594073 != nil:
    section.add "X-Amz-Security-Token", valid_594073
  var valid_594074 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594074 = validateParameter(valid_594074, JString, required = false,
                                 default = nil)
  if valid_594074 != nil:
    section.add "X-Amz-Content-Sha256", valid_594074
  var valid_594075 = header.getOrDefault("X-Amz-Algorithm")
  valid_594075 = validateParameter(valid_594075, JString, required = false,
                                 default = nil)
  if valid_594075 != nil:
    section.add "X-Amz-Algorithm", valid_594075
  var valid_594076 = header.getOrDefault("X-Amz-Signature")
  valid_594076 = validateParameter(valid_594076, JString, required = false,
                                 default = nil)
  if valid_594076 != nil:
    section.add "X-Amz-Signature", valid_594076
  var valid_594077 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594077 = validateParameter(valid_594077, JString, required = false,
                                 default = nil)
  if valid_594077 != nil:
    section.add "X-Amz-SignedHeaders", valid_594077
  var valid_594078 = header.getOrDefault("X-Amz-Credential")
  valid_594078 = validateParameter(valid_594078, JString, required = false,
                                 default = nil)
  if valid_594078 != nil:
    section.add "X-Amz-Credential", valid_594078
  result.add "header", section
  ## parameters in `formData` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  section = newJObject()
  var valid_594079 = formData.getOrDefault("EC2SecurityGroupName")
  valid_594079 = validateParameter(valid_594079, JString, required = false,
                                 default = nil)
  if valid_594079 != nil:
    section.add "EC2SecurityGroupName", valid_594079
  var valid_594080 = formData.getOrDefault("CIDRIP")
  valid_594080 = validateParameter(valid_594080, JString, required = false,
                                 default = nil)
  if valid_594080 != nil:
    section.add "CIDRIP", valid_594080
  var valid_594081 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_594081 = validateParameter(valid_594081, JString, required = false,
                                 default = nil)
  if valid_594081 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_594081
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_594082 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_594082 = validateParameter(valid_594082, JString, required = true,
                                 default = nil)
  if valid_594082 != nil:
    section.add "ClusterSecurityGroupName", valid_594082
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594083: Call_PostAuthorizeClusterSecurityGroupIngress_594067;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594083.validator(path, query, header, formData, body)
  let scheme = call_594083.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594083.url(scheme.get, call_594083.host, call_594083.base,
                         call_594083.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594083, url, valid)

proc call*(call_594084: Call_PostAuthorizeClusterSecurityGroupIngress_594067;
          ClusterSecurityGroupName: string;
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          EC2SecurityGroupName: string = ""; CIDRIP: string = "";
          Version: string = "2012-12-01"; EC2SecurityGroupOwnerId: string = ""): Recallable =
  ## postAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   Version: string (required)
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  var query_594085 = newJObject()
  var formData_594086 = newJObject()
  add(query_594085, "Action", newJString(Action))
  add(formData_594086, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_594086, "CIDRIP", newJString(CIDRIP))
  add(query_594085, "Version", newJString(Version))
  add(formData_594086, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_594086, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_594084.call(nil, query_594085, nil, formData_594086, nil)

var postAuthorizeClusterSecurityGroupIngress* = Call_PostAuthorizeClusterSecurityGroupIngress_594067(
    name: "postAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_PostAuthorizeClusterSecurityGroupIngress_594068,
    base: "/", url: url_PostAuthorizeClusterSecurityGroupIngress_594069,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeClusterSecurityGroupIngress_594048 = ref object of OpenApiRestCall_593421
proc url_GetAuthorizeClusterSecurityGroupIngress_594050(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAuthorizeClusterSecurityGroupIngress_594049(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_594051 = query.getOrDefault("ClusterSecurityGroupName")
  valid_594051 = validateParameter(valid_594051, JString, required = true,
                                 default = nil)
  if valid_594051 != nil:
    section.add "ClusterSecurityGroupName", valid_594051
  var valid_594052 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_594052 = validateParameter(valid_594052, JString, required = false,
                                 default = nil)
  if valid_594052 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_594052
  var valid_594053 = query.getOrDefault("Action")
  valid_594053 = validateParameter(valid_594053, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_594053 != nil:
    section.add "Action", valid_594053
  var valid_594054 = query.getOrDefault("CIDRIP")
  valid_594054 = validateParameter(valid_594054, JString, required = false,
                                 default = nil)
  if valid_594054 != nil:
    section.add "CIDRIP", valid_594054
  var valid_594055 = query.getOrDefault("EC2SecurityGroupName")
  valid_594055 = validateParameter(valid_594055, JString, required = false,
                                 default = nil)
  if valid_594055 != nil:
    section.add "EC2SecurityGroupName", valid_594055
  var valid_594056 = query.getOrDefault("Version")
  valid_594056 = validateParameter(valid_594056, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594056 != nil:
    section.add "Version", valid_594056
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594057 = header.getOrDefault("X-Amz-Date")
  valid_594057 = validateParameter(valid_594057, JString, required = false,
                                 default = nil)
  if valid_594057 != nil:
    section.add "X-Amz-Date", valid_594057
  var valid_594058 = header.getOrDefault("X-Amz-Security-Token")
  valid_594058 = validateParameter(valid_594058, JString, required = false,
                                 default = nil)
  if valid_594058 != nil:
    section.add "X-Amz-Security-Token", valid_594058
  var valid_594059 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594059 = validateParameter(valid_594059, JString, required = false,
                                 default = nil)
  if valid_594059 != nil:
    section.add "X-Amz-Content-Sha256", valid_594059
  var valid_594060 = header.getOrDefault("X-Amz-Algorithm")
  valid_594060 = validateParameter(valid_594060, JString, required = false,
                                 default = nil)
  if valid_594060 != nil:
    section.add "X-Amz-Algorithm", valid_594060
  var valid_594061 = header.getOrDefault("X-Amz-Signature")
  valid_594061 = validateParameter(valid_594061, JString, required = false,
                                 default = nil)
  if valid_594061 != nil:
    section.add "X-Amz-Signature", valid_594061
  var valid_594062 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594062 = validateParameter(valid_594062, JString, required = false,
                                 default = nil)
  if valid_594062 != nil:
    section.add "X-Amz-SignedHeaders", valid_594062
  var valid_594063 = header.getOrDefault("X-Amz-Credential")
  valid_594063 = validateParameter(valid_594063, JString, required = false,
                                 default = nil)
  if valid_594063 != nil:
    section.add "X-Amz-Credential", valid_594063
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594064: Call_GetAuthorizeClusterSecurityGroupIngress_594048;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594064.validator(path, query, header, formData, body)
  let scheme = call_594064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594064.url(scheme.get, call_594064.host, call_594064.base,
                         call_594064.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594064, url, valid)

proc call*(call_594065: Call_GetAuthorizeClusterSecurityGroupIngress_594048;
          ClusterSecurityGroupName: string; EC2SecurityGroupOwnerId: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          CIDRIP: string = ""; EC2SecurityGroupName: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: string (required)
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   Version: string (required)
  var query_594066 = newJObject()
  add(query_594066, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_594066, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_594066, "Action", newJString(Action))
  add(query_594066, "CIDRIP", newJString(CIDRIP))
  add(query_594066, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_594066, "Version", newJString(Version))
  result = call_594065.call(nil, query_594066, nil, nil, nil)

var getAuthorizeClusterSecurityGroupIngress* = Call_GetAuthorizeClusterSecurityGroupIngress_594048(
    name: "getAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_GetAuthorizeClusterSecurityGroupIngress_594049, base: "/",
    url: url_GetAuthorizeClusterSecurityGroupIngress_594050,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeSnapshotAccess_594105 = ref object of OpenApiRestCall_593421
proc url_PostAuthorizeSnapshotAccess_594107(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostAuthorizeSnapshotAccess_594106(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594108 = query.getOrDefault("Action")
  valid_594108 = validateParameter(valid_594108, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_594108 != nil:
    section.add "Action", valid_594108
  var valid_594109 = query.getOrDefault("Version")
  valid_594109 = validateParameter(valid_594109, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594109 != nil:
    section.add "Version", valid_594109
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594110 = header.getOrDefault("X-Amz-Date")
  valid_594110 = validateParameter(valid_594110, JString, required = false,
                                 default = nil)
  if valid_594110 != nil:
    section.add "X-Amz-Date", valid_594110
  var valid_594111 = header.getOrDefault("X-Amz-Security-Token")
  valid_594111 = validateParameter(valid_594111, JString, required = false,
                                 default = nil)
  if valid_594111 != nil:
    section.add "X-Amz-Security-Token", valid_594111
  var valid_594112 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594112 = validateParameter(valid_594112, JString, required = false,
                                 default = nil)
  if valid_594112 != nil:
    section.add "X-Amz-Content-Sha256", valid_594112
  var valid_594113 = header.getOrDefault("X-Amz-Algorithm")
  valid_594113 = validateParameter(valid_594113, JString, required = false,
                                 default = nil)
  if valid_594113 != nil:
    section.add "X-Amz-Algorithm", valid_594113
  var valid_594114 = header.getOrDefault("X-Amz-Signature")
  valid_594114 = validateParameter(valid_594114, JString, required = false,
                                 default = nil)
  if valid_594114 != nil:
    section.add "X-Amz-Signature", valid_594114
  var valid_594115 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594115 = validateParameter(valid_594115, JString, required = false,
                                 default = nil)
  if valid_594115 != nil:
    section.add "X-Amz-SignedHeaders", valid_594115
  var valid_594116 = header.getOrDefault("X-Amz-Credential")
  valid_594116 = validateParameter(valid_594116, JString, required = false,
                                 default = nil)
  if valid_594116 != nil:
    section.add "X-Amz-Credential", valid_594116
  result.add "header", section
  ## parameters in `formData` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_594117 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_594117 = validateParameter(valid_594117, JString, required = true,
                                 default = nil)
  if valid_594117 != nil:
    section.add "AccountWithRestoreAccess", valid_594117
  var valid_594118 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_594118 = validateParameter(valid_594118, JString, required = false,
                                 default = nil)
  if valid_594118 != nil:
    section.add "SnapshotClusterIdentifier", valid_594118
  var valid_594119 = formData.getOrDefault("SnapshotIdentifier")
  valid_594119 = validateParameter(valid_594119, JString, required = true,
                                 default = nil)
  if valid_594119 != nil:
    section.add "SnapshotIdentifier", valid_594119
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594120: Call_PostAuthorizeSnapshotAccess_594105; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594120.validator(path, query, header, formData, body)
  let scheme = call_594120.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594120.url(scheme.get, call_594120.host, call_594120.base,
                         call_594120.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594120, url, valid)

proc call*(call_594121: Call_PostAuthorizeSnapshotAccess_594105;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "AuthorizeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: string (required)
  var query_594122 = newJObject()
  var formData_594123 = newJObject()
  add(formData_594123, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_594123, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_594122, "Action", newJString(Action))
  add(formData_594123, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_594122, "Version", newJString(Version))
  result = call_594121.call(nil, query_594122, nil, formData_594123, nil)

var postAuthorizeSnapshotAccess* = Call_PostAuthorizeSnapshotAccess_594105(
    name: "postAuthorizeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_PostAuthorizeSnapshotAccess_594106, base: "/",
    url: url_PostAuthorizeSnapshotAccess_594107,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeSnapshotAccess_594087 = ref object of OpenApiRestCall_593421
proc url_GetAuthorizeSnapshotAccess_594089(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAuthorizeSnapshotAccess_594088(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_594090 = query.getOrDefault("AccountWithRestoreAccess")
  valid_594090 = validateParameter(valid_594090, JString, required = true,
                                 default = nil)
  if valid_594090 != nil:
    section.add "AccountWithRestoreAccess", valid_594090
  var valid_594091 = query.getOrDefault("Action")
  valid_594091 = validateParameter(valid_594091, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_594091 != nil:
    section.add "Action", valid_594091
  var valid_594092 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_594092 = validateParameter(valid_594092, JString, required = false,
                                 default = nil)
  if valid_594092 != nil:
    section.add "SnapshotClusterIdentifier", valid_594092
  var valid_594093 = query.getOrDefault("SnapshotIdentifier")
  valid_594093 = validateParameter(valid_594093, JString, required = true,
                                 default = nil)
  if valid_594093 != nil:
    section.add "SnapshotIdentifier", valid_594093
  var valid_594094 = query.getOrDefault("Version")
  valid_594094 = validateParameter(valid_594094, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594094 != nil:
    section.add "Version", valid_594094
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594095 = header.getOrDefault("X-Amz-Date")
  valid_594095 = validateParameter(valid_594095, JString, required = false,
                                 default = nil)
  if valid_594095 != nil:
    section.add "X-Amz-Date", valid_594095
  var valid_594096 = header.getOrDefault("X-Amz-Security-Token")
  valid_594096 = validateParameter(valid_594096, JString, required = false,
                                 default = nil)
  if valid_594096 != nil:
    section.add "X-Amz-Security-Token", valid_594096
  var valid_594097 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594097 = validateParameter(valid_594097, JString, required = false,
                                 default = nil)
  if valid_594097 != nil:
    section.add "X-Amz-Content-Sha256", valid_594097
  var valid_594098 = header.getOrDefault("X-Amz-Algorithm")
  valid_594098 = validateParameter(valid_594098, JString, required = false,
                                 default = nil)
  if valid_594098 != nil:
    section.add "X-Amz-Algorithm", valid_594098
  var valid_594099 = header.getOrDefault("X-Amz-Signature")
  valid_594099 = validateParameter(valid_594099, JString, required = false,
                                 default = nil)
  if valid_594099 != nil:
    section.add "X-Amz-Signature", valid_594099
  var valid_594100 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594100 = validateParameter(valid_594100, JString, required = false,
                                 default = nil)
  if valid_594100 != nil:
    section.add "X-Amz-SignedHeaders", valid_594100
  var valid_594101 = header.getOrDefault("X-Amz-Credential")
  valid_594101 = validateParameter(valid_594101, JString, required = false,
                                 default = nil)
  if valid_594101 != nil:
    section.add "X-Amz-Credential", valid_594101
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594102: Call_GetAuthorizeSnapshotAccess_594087; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594102.validator(path, query, header, formData, body)
  let scheme = call_594102.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594102.url(scheme.get, call_594102.host, call_594102.base,
                         call_594102.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594102, url, valid)

proc call*(call_594103: Call_GetAuthorizeSnapshotAccess_594087;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          Action: string = "AuthorizeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: string (required)
  var query_594104 = newJObject()
  add(query_594104, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_594104, "Action", newJString(Action))
  add(query_594104, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_594104, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_594104, "Version", newJString(Version))
  result = call_594103.call(nil, query_594104, nil, nil, nil)

var getAuthorizeSnapshotAccess* = Call_GetAuthorizeSnapshotAccess_594087(
    name: "getAuthorizeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_GetAuthorizeSnapshotAccess_594088, base: "/",
    url: url_GetAuthorizeSnapshotAccess_594089,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchDeleteClusterSnapshots_594140 = ref object of OpenApiRestCall_593421
proc url_PostBatchDeleteClusterSnapshots_594142(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostBatchDeleteClusterSnapshots_594141(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594143 = query.getOrDefault("Action")
  valid_594143 = validateParameter(valid_594143, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_594143 != nil:
    section.add "Action", valid_594143
  var valid_594144 = query.getOrDefault("Version")
  valid_594144 = validateParameter(valid_594144, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594144 != nil:
    section.add "Version", valid_594144
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594145 = header.getOrDefault("X-Amz-Date")
  valid_594145 = validateParameter(valid_594145, JString, required = false,
                                 default = nil)
  if valid_594145 != nil:
    section.add "X-Amz-Date", valid_594145
  var valid_594146 = header.getOrDefault("X-Amz-Security-Token")
  valid_594146 = validateParameter(valid_594146, JString, required = false,
                                 default = nil)
  if valid_594146 != nil:
    section.add "X-Amz-Security-Token", valid_594146
  var valid_594147 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594147 = validateParameter(valid_594147, JString, required = false,
                                 default = nil)
  if valid_594147 != nil:
    section.add "X-Amz-Content-Sha256", valid_594147
  var valid_594148 = header.getOrDefault("X-Amz-Algorithm")
  valid_594148 = validateParameter(valid_594148, JString, required = false,
                                 default = nil)
  if valid_594148 != nil:
    section.add "X-Amz-Algorithm", valid_594148
  var valid_594149 = header.getOrDefault("X-Amz-Signature")
  valid_594149 = validateParameter(valid_594149, JString, required = false,
                                 default = nil)
  if valid_594149 != nil:
    section.add "X-Amz-Signature", valid_594149
  var valid_594150 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594150 = validateParameter(valid_594150, JString, required = false,
                                 default = nil)
  if valid_594150 != nil:
    section.add "X-Amz-SignedHeaders", valid_594150
  var valid_594151 = header.getOrDefault("X-Amz-Credential")
  valid_594151 = validateParameter(valid_594151, JString, required = false,
                                 default = nil)
  if valid_594151 != nil:
    section.add "X-Amz-Credential", valid_594151
  result.add "header", section
  ## parameters in `formData` object:
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Identifiers` field"
  var valid_594152 = formData.getOrDefault("Identifiers")
  valid_594152 = validateParameter(valid_594152, JArray, required = true, default = nil)
  if valid_594152 != nil:
    section.add "Identifiers", valid_594152
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594153: Call_PostBatchDeleteClusterSnapshots_594140;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_594153.validator(path, query, header, formData, body)
  let scheme = call_594153.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594153.url(scheme.get, call_594153.host, call_594153.base,
                         call_594153.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594153, url, valid)

proc call*(call_594154: Call_PostBatchDeleteClusterSnapshots_594140;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## postBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594155 = newJObject()
  var formData_594156 = newJObject()
  if Identifiers != nil:
    formData_594156.add "Identifiers", Identifiers
  add(query_594155, "Action", newJString(Action))
  add(query_594155, "Version", newJString(Version))
  result = call_594154.call(nil, query_594155, nil, formData_594156, nil)

var postBatchDeleteClusterSnapshots* = Call_PostBatchDeleteClusterSnapshots_594140(
    name: "postBatchDeleteClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_PostBatchDeleteClusterSnapshots_594141, base: "/",
    url: url_PostBatchDeleteClusterSnapshots_594142,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchDeleteClusterSnapshots_594124 = ref object of OpenApiRestCall_593421
proc url_GetBatchDeleteClusterSnapshots_594126(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetBatchDeleteClusterSnapshots_594125(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594127 = query.getOrDefault("Action")
  valid_594127 = validateParameter(valid_594127, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_594127 != nil:
    section.add "Action", valid_594127
  var valid_594128 = query.getOrDefault("Identifiers")
  valid_594128 = validateParameter(valid_594128, JArray, required = true, default = nil)
  if valid_594128 != nil:
    section.add "Identifiers", valid_594128
  var valid_594129 = query.getOrDefault("Version")
  valid_594129 = validateParameter(valid_594129, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594129 != nil:
    section.add "Version", valid_594129
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594130 = header.getOrDefault("X-Amz-Date")
  valid_594130 = validateParameter(valid_594130, JString, required = false,
                                 default = nil)
  if valid_594130 != nil:
    section.add "X-Amz-Date", valid_594130
  var valid_594131 = header.getOrDefault("X-Amz-Security-Token")
  valid_594131 = validateParameter(valid_594131, JString, required = false,
                                 default = nil)
  if valid_594131 != nil:
    section.add "X-Amz-Security-Token", valid_594131
  var valid_594132 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594132 = validateParameter(valid_594132, JString, required = false,
                                 default = nil)
  if valid_594132 != nil:
    section.add "X-Amz-Content-Sha256", valid_594132
  var valid_594133 = header.getOrDefault("X-Amz-Algorithm")
  valid_594133 = validateParameter(valid_594133, JString, required = false,
                                 default = nil)
  if valid_594133 != nil:
    section.add "X-Amz-Algorithm", valid_594133
  var valid_594134 = header.getOrDefault("X-Amz-Signature")
  valid_594134 = validateParameter(valid_594134, JString, required = false,
                                 default = nil)
  if valid_594134 != nil:
    section.add "X-Amz-Signature", valid_594134
  var valid_594135 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594135 = validateParameter(valid_594135, JString, required = false,
                                 default = nil)
  if valid_594135 != nil:
    section.add "X-Amz-SignedHeaders", valid_594135
  var valid_594136 = header.getOrDefault("X-Amz-Credential")
  valid_594136 = validateParameter(valid_594136, JString, required = false,
                                 default = nil)
  if valid_594136 != nil:
    section.add "X-Amz-Credential", valid_594136
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594137: Call_GetBatchDeleteClusterSnapshots_594124; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_594137.validator(path, query, header, formData, body)
  let scheme = call_594137.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594137.url(scheme.get, call_594137.host, call_594137.base,
                         call_594137.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594137, url, valid)

proc call*(call_594138: Call_GetBatchDeleteClusterSnapshots_594124;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Action: string (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: string (required)
  var query_594139 = newJObject()
  add(query_594139, "Action", newJString(Action))
  if Identifiers != nil:
    query_594139.add "Identifiers", Identifiers
  add(query_594139, "Version", newJString(Version))
  result = call_594138.call(nil, query_594139, nil, nil, nil)

var getBatchDeleteClusterSnapshots* = Call_GetBatchDeleteClusterSnapshots_594124(
    name: "getBatchDeleteClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_GetBatchDeleteClusterSnapshots_594125, base: "/",
    url: url_GetBatchDeleteClusterSnapshots_594126,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchModifyClusterSnapshots_594175 = ref object of OpenApiRestCall_593421
proc url_PostBatchModifyClusterSnapshots_594177(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostBatchModifyClusterSnapshots_594176(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594178 = query.getOrDefault("Action")
  valid_594178 = validateParameter(valid_594178, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_594178 != nil:
    section.add "Action", valid_594178
  var valid_594179 = query.getOrDefault("Version")
  valid_594179 = validateParameter(valid_594179, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594179 != nil:
    section.add "Version", valid_594179
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594180 = header.getOrDefault("X-Amz-Date")
  valid_594180 = validateParameter(valid_594180, JString, required = false,
                                 default = nil)
  if valid_594180 != nil:
    section.add "X-Amz-Date", valid_594180
  var valid_594181 = header.getOrDefault("X-Amz-Security-Token")
  valid_594181 = validateParameter(valid_594181, JString, required = false,
                                 default = nil)
  if valid_594181 != nil:
    section.add "X-Amz-Security-Token", valid_594181
  var valid_594182 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594182 = validateParameter(valid_594182, JString, required = false,
                                 default = nil)
  if valid_594182 != nil:
    section.add "X-Amz-Content-Sha256", valid_594182
  var valid_594183 = header.getOrDefault("X-Amz-Algorithm")
  valid_594183 = validateParameter(valid_594183, JString, required = false,
                                 default = nil)
  if valid_594183 != nil:
    section.add "X-Amz-Algorithm", valid_594183
  var valid_594184 = header.getOrDefault("X-Amz-Signature")
  valid_594184 = validateParameter(valid_594184, JString, required = false,
                                 default = nil)
  if valid_594184 != nil:
    section.add "X-Amz-Signature", valid_594184
  var valid_594185 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594185 = validateParameter(valid_594185, JString, required = false,
                                 default = nil)
  if valid_594185 != nil:
    section.add "X-Amz-SignedHeaders", valid_594185
  var valid_594186 = header.getOrDefault("X-Amz-Credential")
  valid_594186 = validateParameter(valid_594186, JString, required = false,
                                 default = nil)
  if valid_594186 != nil:
    section.add "X-Amz-Credential", valid_594186
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  var valid_594187 = formData.getOrDefault("Force")
  valid_594187 = validateParameter(valid_594187, JBool, required = false, default = nil)
  if valid_594187 != nil:
    section.add "Force", valid_594187
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_594188 = formData.getOrDefault("SnapshotIdentifierList")
  valid_594188 = validateParameter(valid_594188, JArray, required = true, default = nil)
  if valid_594188 != nil:
    section.add "SnapshotIdentifierList", valid_594188
  var valid_594189 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_594189 = validateParameter(valid_594189, JInt, required = false, default = nil)
  if valid_594189 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_594189
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594190: Call_PostBatchModifyClusterSnapshots_594175;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_594190.validator(path, query, header, formData, body)
  let scheme = call_594190.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594190.url(scheme.get, call_594190.host, call_594190.base,
                         call_594190.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594190, url, valid)

proc call*(call_594191: Call_PostBatchModifyClusterSnapshots_594175;
          SnapshotIdentifierList: JsonNode; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Version: string (required)
  var query_594192 = newJObject()
  var formData_594193 = newJObject()
  add(formData_594193, "Force", newJBool(Force))
  if SnapshotIdentifierList != nil:
    formData_594193.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_594192, "Action", newJString(Action))
  add(formData_594193, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_594192, "Version", newJString(Version))
  result = call_594191.call(nil, query_594192, nil, formData_594193, nil)

var postBatchModifyClusterSnapshots* = Call_PostBatchModifyClusterSnapshots_594175(
    name: "postBatchModifyClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_PostBatchModifyClusterSnapshots_594176, base: "/",
    url: url_PostBatchModifyClusterSnapshots_594177,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchModifyClusterSnapshots_594157 = ref object of OpenApiRestCall_593421
proc url_GetBatchModifyClusterSnapshots_594159(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetBatchModifyClusterSnapshots_594158(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_594160 = query.getOrDefault("SnapshotIdentifierList")
  valid_594160 = validateParameter(valid_594160, JArray, required = true, default = nil)
  if valid_594160 != nil:
    section.add "SnapshotIdentifierList", valid_594160
  var valid_594161 = query.getOrDefault("Action")
  valid_594161 = validateParameter(valid_594161, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_594161 != nil:
    section.add "Action", valid_594161
  var valid_594162 = query.getOrDefault("Version")
  valid_594162 = validateParameter(valid_594162, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594162 != nil:
    section.add "Version", valid_594162
  var valid_594163 = query.getOrDefault("Force")
  valid_594163 = validateParameter(valid_594163, JBool, required = false, default = nil)
  if valid_594163 != nil:
    section.add "Force", valid_594163
  var valid_594164 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_594164 = validateParameter(valid_594164, JInt, required = false, default = nil)
  if valid_594164 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_594164
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594165 = header.getOrDefault("X-Amz-Date")
  valid_594165 = validateParameter(valid_594165, JString, required = false,
                                 default = nil)
  if valid_594165 != nil:
    section.add "X-Amz-Date", valid_594165
  var valid_594166 = header.getOrDefault("X-Amz-Security-Token")
  valid_594166 = validateParameter(valid_594166, JString, required = false,
                                 default = nil)
  if valid_594166 != nil:
    section.add "X-Amz-Security-Token", valid_594166
  var valid_594167 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594167 = validateParameter(valid_594167, JString, required = false,
                                 default = nil)
  if valid_594167 != nil:
    section.add "X-Amz-Content-Sha256", valid_594167
  var valid_594168 = header.getOrDefault("X-Amz-Algorithm")
  valid_594168 = validateParameter(valid_594168, JString, required = false,
                                 default = nil)
  if valid_594168 != nil:
    section.add "X-Amz-Algorithm", valid_594168
  var valid_594169 = header.getOrDefault("X-Amz-Signature")
  valid_594169 = validateParameter(valid_594169, JString, required = false,
                                 default = nil)
  if valid_594169 != nil:
    section.add "X-Amz-Signature", valid_594169
  var valid_594170 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594170 = validateParameter(valid_594170, JString, required = false,
                                 default = nil)
  if valid_594170 != nil:
    section.add "X-Amz-SignedHeaders", valid_594170
  var valid_594171 = header.getOrDefault("X-Amz-Credential")
  valid_594171 = validateParameter(valid_594171, JString, required = false,
                                 default = nil)
  if valid_594171 != nil:
    section.add "X-Amz-Credential", valid_594171
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594172: Call_GetBatchModifyClusterSnapshots_594157; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_594172.validator(path, query, header, formData, body)
  let scheme = call_594172.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594172.url(scheme.get, call_594172.host, call_594172.base,
                         call_594172.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594172, url, valid)

proc call*(call_594173: Call_GetBatchModifyClusterSnapshots_594157;
          SnapshotIdentifierList: JsonNode;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"; Force: bool = false;
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  var query_594174 = newJObject()
  if SnapshotIdentifierList != nil:
    query_594174.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_594174, "Action", newJString(Action))
  add(query_594174, "Version", newJString(Version))
  add(query_594174, "Force", newJBool(Force))
  add(query_594174, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_594173.call(nil, query_594174, nil, nil, nil)

var getBatchModifyClusterSnapshots* = Call_GetBatchModifyClusterSnapshots_594157(
    name: "getBatchModifyClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_GetBatchModifyClusterSnapshots_594158, base: "/",
    url: url_GetBatchModifyClusterSnapshots_594159,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCancelResize_594210 = ref object of OpenApiRestCall_593421
proc url_PostCancelResize_594212(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCancelResize_594211(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594213 = query.getOrDefault("Action")
  valid_594213 = validateParameter(valid_594213, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_594213 != nil:
    section.add "Action", valid_594213
  var valid_594214 = query.getOrDefault("Version")
  valid_594214 = validateParameter(valid_594214, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594214 != nil:
    section.add "Version", valid_594214
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594215 = header.getOrDefault("X-Amz-Date")
  valid_594215 = validateParameter(valid_594215, JString, required = false,
                                 default = nil)
  if valid_594215 != nil:
    section.add "X-Amz-Date", valid_594215
  var valid_594216 = header.getOrDefault("X-Amz-Security-Token")
  valid_594216 = validateParameter(valid_594216, JString, required = false,
                                 default = nil)
  if valid_594216 != nil:
    section.add "X-Amz-Security-Token", valid_594216
  var valid_594217 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594217 = validateParameter(valid_594217, JString, required = false,
                                 default = nil)
  if valid_594217 != nil:
    section.add "X-Amz-Content-Sha256", valid_594217
  var valid_594218 = header.getOrDefault("X-Amz-Algorithm")
  valid_594218 = validateParameter(valid_594218, JString, required = false,
                                 default = nil)
  if valid_594218 != nil:
    section.add "X-Amz-Algorithm", valid_594218
  var valid_594219 = header.getOrDefault("X-Amz-Signature")
  valid_594219 = validateParameter(valid_594219, JString, required = false,
                                 default = nil)
  if valid_594219 != nil:
    section.add "X-Amz-Signature", valid_594219
  var valid_594220 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594220 = validateParameter(valid_594220, JString, required = false,
                                 default = nil)
  if valid_594220 != nil:
    section.add "X-Amz-SignedHeaders", valid_594220
  var valid_594221 = header.getOrDefault("X-Amz-Credential")
  valid_594221 = validateParameter(valid_594221, JString, required = false,
                                 default = nil)
  if valid_594221 != nil:
    section.add "X-Amz-Credential", valid_594221
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_594222 = formData.getOrDefault("ClusterIdentifier")
  valid_594222 = validateParameter(valid_594222, JString, required = true,
                                 default = nil)
  if valid_594222 != nil:
    section.add "ClusterIdentifier", valid_594222
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594223: Call_PostCancelResize_594210; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_594223.validator(path, query, header, formData, body)
  let scheme = call_594223.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594223.url(scheme.get, call_594223.host, call_594223.base,
                         call_594223.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594223, url, valid)

proc call*(call_594224: Call_PostCancelResize_594210; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## postCancelResize
  ## Cancels a resize operation.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_594225 = newJObject()
  var formData_594226 = newJObject()
  add(query_594225, "Action", newJString(Action))
  add(formData_594226, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594225, "Version", newJString(Version))
  result = call_594224.call(nil, query_594225, nil, formData_594226, nil)

var postCancelResize* = Call_PostCancelResize_594210(name: "postCancelResize",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_PostCancelResize_594211,
    base: "/", url: url_PostCancelResize_594212,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCancelResize_594194 = ref object of OpenApiRestCall_593421
proc url_GetCancelResize_594196(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCancelResize_594195(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594197 = query.getOrDefault("Action")
  valid_594197 = validateParameter(valid_594197, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_594197 != nil:
    section.add "Action", valid_594197
  var valid_594198 = query.getOrDefault("ClusterIdentifier")
  valid_594198 = validateParameter(valid_594198, JString, required = true,
                                 default = nil)
  if valid_594198 != nil:
    section.add "ClusterIdentifier", valid_594198
  var valid_594199 = query.getOrDefault("Version")
  valid_594199 = validateParameter(valid_594199, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594199 != nil:
    section.add "Version", valid_594199
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594200 = header.getOrDefault("X-Amz-Date")
  valid_594200 = validateParameter(valid_594200, JString, required = false,
                                 default = nil)
  if valid_594200 != nil:
    section.add "X-Amz-Date", valid_594200
  var valid_594201 = header.getOrDefault("X-Amz-Security-Token")
  valid_594201 = validateParameter(valid_594201, JString, required = false,
                                 default = nil)
  if valid_594201 != nil:
    section.add "X-Amz-Security-Token", valid_594201
  var valid_594202 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594202 = validateParameter(valid_594202, JString, required = false,
                                 default = nil)
  if valid_594202 != nil:
    section.add "X-Amz-Content-Sha256", valid_594202
  var valid_594203 = header.getOrDefault("X-Amz-Algorithm")
  valid_594203 = validateParameter(valid_594203, JString, required = false,
                                 default = nil)
  if valid_594203 != nil:
    section.add "X-Amz-Algorithm", valid_594203
  var valid_594204 = header.getOrDefault("X-Amz-Signature")
  valid_594204 = validateParameter(valid_594204, JString, required = false,
                                 default = nil)
  if valid_594204 != nil:
    section.add "X-Amz-Signature", valid_594204
  var valid_594205 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594205 = validateParameter(valid_594205, JString, required = false,
                                 default = nil)
  if valid_594205 != nil:
    section.add "X-Amz-SignedHeaders", valid_594205
  var valid_594206 = header.getOrDefault("X-Amz-Credential")
  valid_594206 = validateParameter(valid_594206, JString, required = false,
                                 default = nil)
  if valid_594206 != nil:
    section.add "X-Amz-Credential", valid_594206
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594207: Call_GetCancelResize_594194; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_594207.validator(path, query, header, formData, body)
  let scheme = call_594207.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594207.url(scheme.get, call_594207.host, call_594207.base,
                         call_594207.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594207, url, valid)

proc call*(call_594208: Call_GetCancelResize_594194; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## getCancelResize
  ## Cancels a resize operation.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_594209 = newJObject()
  add(query_594209, "Action", newJString(Action))
  add(query_594209, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594209, "Version", newJString(Version))
  result = call_594208.call(nil, query_594209, nil, nil, nil)

var getCancelResize* = Call_GetCancelResize_594194(name: "getCancelResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_GetCancelResize_594195,
    base: "/", url: url_GetCancelResize_594196, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCopyClusterSnapshot_594246 = ref object of OpenApiRestCall_593421
proc url_PostCopyClusterSnapshot_594248(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCopyClusterSnapshot_594247(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594249 = query.getOrDefault("Action")
  valid_594249 = validateParameter(valid_594249, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_594249 != nil:
    section.add "Action", valid_594249
  var valid_594250 = query.getOrDefault("Version")
  valid_594250 = validateParameter(valid_594250, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594250 != nil:
    section.add "Version", valid_594250
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594251 = header.getOrDefault("X-Amz-Date")
  valid_594251 = validateParameter(valid_594251, JString, required = false,
                                 default = nil)
  if valid_594251 != nil:
    section.add "X-Amz-Date", valid_594251
  var valid_594252 = header.getOrDefault("X-Amz-Security-Token")
  valid_594252 = validateParameter(valid_594252, JString, required = false,
                                 default = nil)
  if valid_594252 != nil:
    section.add "X-Amz-Security-Token", valid_594252
  var valid_594253 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594253 = validateParameter(valid_594253, JString, required = false,
                                 default = nil)
  if valid_594253 != nil:
    section.add "X-Amz-Content-Sha256", valid_594253
  var valid_594254 = header.getOrDefault("X-Amz-Algorithm")
  valid_594254 = validateParameter(valid_594254, JString, required = false,
                                 default = nil)
  if valid_594254 != nil:
    section.add "X-Amz-Algorithm", valid_594254
  var valid_594255 = header.getOrDefault("X-Amz-Signature")
  valid_594255 = validateParameter(valid_594255, JString, required = false,
                                 default = nil)
  if valid_594255 != nil:
    section.add "X-Amz-Signature", valid_594255
  var valid_594256 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594256 = validateParameter(valid_594256, JString, required = false,
                                 default = nil)
  if valid_594256 != nil:
    section.add "X-Amz-SignedHeaders", valid_594256
  var valid_594257 = header.getOrDefault("X-Amz-Credential")
  valid_594257 = validateParameter(valid_594257, JString, required = false,
                                 default = nil)
  if valid_594257 != nil:
    section.add "X-Amz-Credential", valid_594257
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_594258 = formData.getOrDefault("SourceSnapshotIdentifier")
  valid_594258 = validateParameter(valid_594258, JString, required = true,
                                 default = nil)
  if valid_594258 != nil:
    section.add "SourceSnapshotIdentifier", valid_594258
  var valid_594259 = formData.getOrDefault("TargetSnapshotIdentifier")
  valid_594259 = validateParameter(valid_594259, JString, required = true,
                                 default = nil)
  if valid_594259 != nil:
    section.add "TargetSnapshotIdentifier", valid_594259
  var valid_594260 = formData.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_594260 = validateParameter(valid_594260, JString, required = false,
                                 default = nil)
  if valid_594260 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_594260
  var valid_594261 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_594261 = validateParameter(valid_594261, JInt, required = false, default = nil)
  if valid_594261 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_594261
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594262: Call_PostCopyClusterSnapshot_594246; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594262.validator(path, query, header, formData, body)
  let scheme = call_594262.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594262.url(scheme.get, call_594262.host, call_594262.base,
                         call_594262.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594262, url, valid)

proc call*(call_594263: Call_PostCopyClusterSnapshot_594246;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          Action: string = "CopyClusterSnapshot";
          SourceSnapshotClusterIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  var query_594264 = newJObject()
  var formData_594265 = newJObject()
  add(formData_594265, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(formData_594265, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_594264, "Action", newJString(Action))
  add(formData_594265, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(formData_594265, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_594264, "Version", newJString(Version))
  result = call_594263.call(nil, query_594264, nil, formData_594265, nil)

var postCopyClusterSnapshot* = Call_PostCopyClusterSnapshot_594246(
    name: "postCopyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_PostCopyClusterSnapshot_594247, base: "/",
    url: url_PostCopyClusterSnapshot_594248, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCopyClusterSnapshot_594227 = ref object of OpenApiRestCall_593421
proc url_GetCopyClusterSnapshot_594229(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCopyClusterSnapshot_594228(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   Action: JString (required)
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Version: JString (required)
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_594230 = query.getOrDefault("SourceSnapshotIdentifier")
  valid_594230 = validateParameter(valid_594230, JString, required = true,
                                 default = nil)
  if valid_594230 != nil:
    section.add "SourceSnapshotIdentifier", valid_594230
  var valid_594231 = query.getOrDefault("Action")
  valid_594231 = validateParameter(valid_594231, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_594231 != nil:
    section.add "Action", valid_594231
  var valid_594232 = query.getOrDefault("TargetSnapshotIdentifier")
  valid_594232 = validateParameter(valid_594232, JString, required = true,
                                 default = nil)
  if valid_594232 != nil:
    section.add "TargetSnapshotIdentifier", valid_594232
  var valid_594233 = query.getOrDefault("Version")
  valid_594233 = validateParameter(valid_594233, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594233 != nil:
    section.add "Version", valid_594233
  var valid_594234 = query.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_594234 = validateParameter(valid_594234, JString, required = false,
                                 default = nil)
  if valid_594234 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_594234
  var valid_594235 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_594235 = validateParameter(valid_594235, JInt, required = false, default = nil)
  if valid_594235 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_594235
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594236 = header.getOrDefault("X-Amz-Date")
  valid_594236 = validateParameter(valid_594236, JString, required = false,
                                 default = nil)
  if valid_594236 != nil:
    section.add "X-Amz-Date", valid_594236
  var valid_594237 = header.getOrDefault("X-Amz-Security-Token")
  valid_594237 = validateParameter(valid_594237, JString, required = false,
                                 default = nil)
  if valid_594237 != nil:
    section.add "X-Amz-Security-Token", valid_594237
  var valid_594238 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594238 = validateParameter(valid_594238, JString, required = false,
                                 default = nil)
  if valid_594238 != nil:
    section.add "X-Amz-Content-Sha256", valid_594238
  var valid_594239 = header.getOrDefault("X-Amz-Algorithm")
  valid_594239 = validateParameter(valid_594239, JString, required = false,
                                 default = nil)
  if valid_594239 != nil:
    section.add "X-Amz-Algorithm", valid_594239
  var valid_594240 = header.getOrDefault("X-Amz-Signature")
  valid_594240 = validateParameter(valid_594240, JString, required = false,
                                 default = nil)
  if valid_594240 != nil:
    section.add "X-Amz-Signature", valid_594240
  var valid_594241 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594241 = validateParameter(valid_594241, JString, required = false,
                                 default = nil)
  if valid_594241 != nil:
    section.add "X-Amz-SignedHeaders", valid_594241
  var valid_594242 = header.getOrDefault("X-Amz-Credential")
  valid_594242 = validateParameter(valid_594242, JString, required = false,
                                 default = nil)
  if valid_594242 != nil:
    section.add "X-Amz-Credential", valid_594242
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594243: Call_GetCopyClusterSnapshot_594227; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594243.validator(path, query, header, formData, body)
  let scheme = call_594243.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594243.url(scheme.get, call_594243.host, call_594243.base,
                         call_594243.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594243, url, valid)

proc call*(call_594244: Call_GetCopyClusterSnapshot_594227;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          SourceSnapshotClusterIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   Action: string (required)
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Version: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_594245 = newJObject()
  add(query_594245, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(query_594245, "Action", newJString(Action))
  add(query_594245, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_594245, "Version", newJString(Version))
  add(query_594245, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(query_594245, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_594244.call(nil, query_594245, nil, nil, nil)

var getCopyClusterSnapshot* = Call_GetCopyClusterSnapshot_594227(
    name: "getCopyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_GetCopyClusterSnapshot_594228, base: "/",
    url: url_GetCopyClusterSnapshot_594229, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateCluster_594311 = ref object of OpenApiRestCall_593421
proc url_PostCreateCluster_594313(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateCluster_594312(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594314 = query.getOrDefault("Action")
  valid_594314 = validateParameter(valid_594314, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_594314 != nil:
    section.add "Action", valid_594314
  var valid_594315 = query.getOrDefault("Version")
  valid_594315 = validateParameter(valid_594315, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594315 != nil:
    section.add "Version", valid_594315
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594316 = header.getOrDefault("X-Amz-Date")
  valid_594316 = validateParameter(valid_594316, JString, required = false,
                                 default = nil)
  if valid_594316 != nil:
    section.add "X-Amz-Date", valid_594316
  var valid_594317 = header.getOrDefault("X-Amz-Security-Token")
  valid_594317 = validateParameter(valid_594317, JString, required = false,
                                 default = nil)
  if valid_594317 != nil:
    section.add "X-Amz-Security-Token", valid_594317
  var valid_594318 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594318 = validateParameter(valid_594318, JString, required = false,
                                 default = nil)
  if valid_594318 != nil:
    section.add "X-Amz-Content-Sha256", valid_594318
  var valid_594319 = header.getOrDefault("X-Amz-Algorithm")
  valid_594319 = validateParameter(valid_594319, JString, required = false,
                                 default = nil)
  if valid_594319 != nil:
    section.add "X-Amz-Algorithm", valid_594319
  var valid_594320 = header.getOrDefault("X-Amz-Signature")
  valid_594320 = validateParameter(valid_594320, JString, required = false,
                                 default = nil)
  if valid_594320 != nil:
    section.add "X-Amz-Signature", valid_594320
  var valid_594321 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594321 = validateParameter(valid_594321, JString, required = false,
                                 default = nil)
  if valid_594321 != nil:
    section.add "X-Amz-SignedHeaders", valid_594321
  var valid_594322 = header.getOrDefault("X-Amz-Credential")
  valid_594322 = validateParameter(valid_594322, JString, required = false,
                                 default = nil)
  if valid_594322 != nil:
    section.add "X-Amz-Credential", valid_594322
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  section = newJObject()
  var valid_594323 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_594323 = validateParameter(valid_594323, JString, required = false,
                                 default = nil)
  if valid_594323 != nil:
    section.add "PreferredMaintenanceWindow", valid_594323
  var valid_594324 = formData.getOrDefault("EnhancedVpcRouting")
  valid_594324 = validateParameter(valid_594324, JBool, required = false, default = nil)
  if valid_594324 != nil:
    section.add "EnhancedVpcRouting", valid_594324
  var valid_594325 = formData.getOrDefault("Port")
  valid_594325 = validateParameter(valid_594325, JInt, required = false, default = nil)
  if valid_594325 != nil:
    section.add "Port", valid_594325
  var valid_594326 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_594326 = validateParameter(valid_594326, JArray, required = false,
                                 default = nil)
  if valid_594326 != nil:
    section.add "VpcSecurityGroupIds", valid_594326
  var valid_594327 = formData.getOrDefault("DBName")
  valid_594327 = validateParameter(valid_594327, JString, required = false,
                                 default = nil)
  if valid_594327 != nil:
    section.add "DBName", valid_594327
  var valid_594328 = formData.getOrDefault("ClusterVersion")
  valid_594328 = validateParameter(valid_594328, JString, required = false,
                                 default = nil)
  if valid_594328 != nil:
    section.add "ClusterVersion", valid_594328
  var valid_594329 = formData.getOrDefault("ClusterType")
  valid_594329 = validateParameter(valid_594329, JString, required = false,
                                 default = nil)
  if valid_594329 != nil:
    section.add "ClusterType", valid_594329
  assert formData != nil, "formData argument is necessary due to required `MasterUserPassword` field"
  var valid_594330 = formData.getOrDefault("MasterUserPassword")
  valid_594330 = validateParameter(valid_594330, JString, required = true,
                                 default = nil)
  if valid_594330 != nil:
    section.add "MasterUserPassword", valid_594330
  var valid_594331 = formData.getOrDefault("Tags")
  valid_594331 = validateParameter(valid_594331, JArray, required = false,
                                 default = nil)
  if valid_594331 != nil:
    section.add "Tags", valid_594331
  var valid_594332 = formData.getOrDefault("AdditionalInfo")
  valid_594332 = validateParameter(valid_594332, JString, required = false,
                                 default = nil)
  if valid_594332 != nil:
    section.add "AdditionalInfo", valid_594332
  var valid_594333 = formData.getOrDefault("ClusterSecurityGroups")
  valid_594333 = validateParameter(valid_594333, JArray, required = false,
                                 default = nil)
  if valid_594333 != nil:
    section.add "ClusterSecurityGroups", valid_594333
  var valid_594334 = formData.getOrDefault("AvailabilityZone")
  valid_594334 = validateParameter(valid_594334, JString, required = false,
                                 default = nil)
  if valid_594334 != nil:
    section.add "AvailabilityZone", valid_594334
  var valid_594335 = formData.getOrDefault("Encrypted")
  valid_594335 = validateParameter(valid_594335, JBool, required = false, default = nil)
  if valid_594335 != nil:
    section.add "Encrypted", valid_594335
  var valid_594336 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_594336 = validateParameter(valid_594336, JString, required = false,
                                 default = nil)
  if valid_594336 != nil:
    section.add "HsmConfigurationIdentifier", valid_594336
  var valid_594337 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_594337 = validateParameter(valid_594337, JString, required = false,
                                 default = nil)
  if valid_594337 != nil:
    section.add "HsmClientCertificateIdentifier", valid_594337
  var valid_594338 = formData.getOrDefault("PubliclyAccessible")
  valid_594338 = validateParameter(valid_594338, JBool, required = false, default = nil)
  if valid_594338 != nil:
    section.add "PubliclyAccessible", valid_594338
  var valid_594339 = formData.getOrDefault("ClusterIdentifier")
  valid_594339 = validateParameter(valid_594339, JString, required = true,
                                 default = nil)
  if valid_594339 != nil:
    section.add "ClusterIdentifier", valid_594339
  var valid_594340 = formData.getOrDefault("MasterUsername")
  valid_594340 = validateParameter(valid_594340, JString, required = true,
                                 default = nil)
  if valid_594340 != nil:
    section.add "MasterUsername", valid_594340
  var valid_594341 = formData.getOrDefault("NumberOfNodes")
  valid_594341 = validateParameter(valid_594341, JInt, required = false, default = nil)
  if valid_594341 != nil:
    section.add "NumberOfNodes", valid_594341
  var valid_594342 = formData.getOrDefault("IamRoles")
  valid_594342 = validateParameter(valid_594342, JArray, required = false,
                                 default = nil)
  if valid_594342 != nil:
    section.add "IamRoles", valid_594342
  var valid_594343 = formData.getOrDefault("ClusterParameterGroupName")
  valid_594343 = validateParameter(valid_594343, JString, required = false,
                                 default = nil)
  if valid_594343 != nil:
    section.add "ClusterParameterGroupName", valid_594343
  var valid_594344 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_594344 = validateParameter(valid_594344, JString, required = false,
                                 default = nil)
  if valid_594344 != nil:
    section.add "SnapshotScheduleIdentifier", valid_594344
  var valid_594345 = formData.getOrDefault("KmsKeyId")
  valid_594345 = validateParameter(valid_594345, JString, required = false,
                                 default = nil)
  if valid_594345 != nil:
    section.add "KmsKeyId", valid_594345
  var valid_594346 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_594346 = validateParameter(valid_594346, JInt, required = false, default = nil)
  if valid_594346 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_594346
  var valid_594347 = formData.getOrDefault("ElasticIp")
  valid_594347 = validateParameter(valid_594347, JString, required = false,
                                 default = nil)
  if valid_594347 != nil:
    section.add "ElasticIp", valid_594347
  var valid_594348 = formData.getOrDefault("AllowVersionUpgrade")
  valid_594348 = validateParameter(valid_594348, JBool, required = false, default = nil)
  if valid_594348 != nil:
    section.add "AllowVersionUpgrade", valid_594348
  var valid_594349 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_594349 = validateParameter(valid_594349, JInt, required = false, default = nil)
  if valid_594349 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_594349
  var valid_594350 = formData.getOrDefault("NodeType")
  valid_594350 = validateParameter(valid_594350, JString, required = true,
                                 default = nil)
  if valid_594350 != nil:
    section.add "NodeType", valid_594350
  var valid_594351 = formData.getOrDefault("MaintenanceTrackName")
  valid_594351 = validateParameter(valid_594351, JString, required = false,
                                 default = nil)
  if valid_594351 != nil:
    section.add "MaintenanceTrackName", valid_594351
  var valid_594352 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_594352 = validateParameter(valid_594352, JString, required = false,
                                 default = nil)
  if valid_594352 != nil:
    section.add "ClusterSubnetGroupName", valid_594352
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594353: Call_PostCreateCluster_594311; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594353.validator(path, query, header, formData, body)
  let scheme = call_594353.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594353.url(scheme.get, call_594353.host, call_594353.base,
                         call_594353.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594353, url, valid)

proc call*(call_594354: Call_PostCreateCluster_594311; MasterUserPassword: string;
          ClusterIdentifier: string; MasterUsername: string; NodeType: string;
          PreferredMaintenanceWindow: string = ""; EnhancedVpcRouting: bool = false;
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil; DBName: string = "";
          ClusterVersion: string = ""; ClusterType: string = ""; Tags: JsonNode = nil;
          AdditionalInfo: string = ""; ClusterSecurityGroups: JsonNode = nil;
          AvailabilityZone: string = ""; Encrypted: bool = false;
          HsmConfigurationIdentifier: string = ""; Action: string = "CreateCluster";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          IamRoles: JsonNode = nil; ClusterParameterGroupName: string = "";
          SnapshotScheduleIdentifier: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          MaintenanceTrackName: string = ""; ClusterSubnetGroupName: string = ""): Recallable =
  ## postCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  var query_594355 = newJObject()
  var formData_594356 = newJObject()
  add(formData_594356, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_594356, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_594356, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    formData_594356.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_594356, "DBName", newJString(DBName))
  add(formData_594356, "ClusterVersion", newJString(ClusterVersion))
  add(formData_594356, "ClusterType", newJString(ClusterType))
  add(formData_594356, "MasterUserPassword", newJString(MasterUserPassword))
  if Tags != nil:
    formData_594356.add "Tags", Tags
  add(formData_594356, "AdditionalInfo", newJString(AdditionalInfo))
  if ClusterSecurityGroups != nil:
    formData_594356.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_594356, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_594356, "Encrypted", newJBool(Encrypted))
  add(formData_594356, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_594355, "Action", newJString(Action))
  add(formData_594356, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_594356, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_594356, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_594356, "MasterUsername", newJString(MasterUsername))
  add(formData_594356, "NumberOfNodes", newJInt(NumberOfNodes))
  if IamRoles != nil:
    formData_594356.add "IamRoles", IamRoles
  add(formData_594356, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_594356, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(formData_594356, "KmsKeyId", newJString(KmsKeyId))
  add(formData_594356, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_594356, "ElasticIp", newJString(ElasticIp))
  add(formData_594356, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_594356, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_594355, "Version", newJString(Version))
  add(formData_594356, "NodeType", newJString(NodeType))
  add(formData_594356, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_594356, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_594354.call(nil, query_594355, nil, formData_594356, nil)

var postCreateCluster* = Call_PostCreateCluster_594311(name: "postCreateCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_PostCreateCluster_594312,
    base: "/", url: url_PostCreateCluster_594313,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateCluster_594266 = ref object of OpenApiRestCall_593421
proc url_GetCreateCluster_594268(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateCluster_594267(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_594269 = query.getOrDefault("ClusterSecurityGroups")
  valid_594269 = validateParameter(valid_594269, JArray, required = false,
                                 default = nil)
  if valid_594269 != nil:
    section.add "ClusterSecurityGroups", valid_594269
  assert query != nil,
        "query argument is necessary due to required `MasterUsername` field"
  var valid_594270 = query.getOrDefault("MasterUsername")
  valid_594270 = validateParameter(valid_594270, JString, required = true,
                                 default = nil)
  if valid_594270 != nil:
    section.add "MasterUsername", valid_594270
  var valid_594271 = query.getOrDefault("ClusterSubnetGroupName")
  valid_594271 = validateParameter(valid_594271, JString, required = false,
                                 default = nil)
  if valid_594271 != nil:
    section.add "ClusterSubnetGroupName", valid_594271
  var valid_594272 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_594272 = validateParameter(valid_594272, JString, required = false,
                                 default = nil)
  if valid_594272 != nil:
    section.add "HsmClientCertificateIdentifier", valid_594272
  var valid_594273 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_594273 = validateParameter(valid_594273, JString, required = false,
                                 default = nil)
  if valid_594273 != nil:
    section.add "PreferredMaintenanceWindow", valid_594273
  var valid_594274 = query.getOrDefault("Encrypted")
  valid_594274 = validateParameter(valid_594274, JBool, required = false, default = nil)
  if valid_594274 != nil:
    section.add "Encrypted", valid_594274
  var valid_594275 = query.getOrDefault("MaintenanceTrackName")
  valid_594275 = validateParameter(valid_594275, JString, required = false,
                                 default = nil)
  if valid_594275 != nil:
    section.add "MaintenanceTrackName", valid_594275
  var valid_594276 = query.getOrDefault("IamRoles")
  valid_594276 = validateParameter(valid_594276, JArray, required = false,
                                 default = nil)
  if valid_594276 != nil:
    section.add "IamRoles", valid_594276
  var valid_594277 = query.getOrDefault("AvailabilityZone")
  valid_594277 = validateParameter(valid_594277, JString, required = false,
                                 default = nil)
  if valid_594277 != nil:
    section.add "AvailabilityZone", valid_594277
  var valid_594278 = query.getOrDefault("MasterUserPassword")
  valid_594278 = validateParameter(valid_594278, JString, required = true,
                                 default = nil)
  if valid_594278 != nil:
    section.add "MasterUserPassword", valid_594278
  var valid_594279 = query.getOrDefault("AllowVersionUpgrade")
  valid_594279 = validateParameter(valid_594279, JBool, required = false, default = nil)
  if valid_594279 != nil:
    section.add "AllowVersionUpgrade", valid_594279
  var valid_594280 = query.getOrDefault("EnhancedVpcRouting")
  valid_594280 = validateParameter(valid_594280, JBool, required = false, default = nil)
  if valid_594280 != nil:
    section.add "EnhancedVpcRouting", valid_594280
  var valid_594281 = query.getOrDefault("VpcSecurityGroupIds")
  valid_594281 = validateParameter(valid_594281, JArray, required = false,
                                 default = nil)
  if valid_594281 != nil:
    section.add "VpcSecurityGroupIds", valid_594281
  var valid_594282 = query.getOrDefault("ClusterParameterGroupName")
  valid_594282 = validateParameter(valid_594282, JString, required = false,
                                 default = nil)
  if valid_594282 != nil:
    section.add "ClusterParameterGroupName", valid_594282
  var valid_594283 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_594283 = validateParameter(valid_594283, JString, required = false,
                                 default = nil)
  if valid_594283 != nil:
    section.add "HsmConfigurationIdentifier", valid_594283
  var valid_594284 = query.getOrDefault("Tags")
  valid_594284 = validateParameter(valid_594284, JArray, required = false,
                                 default = nil)
  if valid_594284 != nil:
    section.add "Tags", valid_594284
  var valid_594285 = query.getOrDefault("DBName")
  valid_594285 = validateParameter(valid_594285, JString, required = false,
                                 default = nil)
  if valid_594285 != nil:
    section.add "DBName", valid_594285
  var valid_594286 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_594286 = validateParameter(valid_594286, JString, required = false,
                                 default = nil)
  if valid_594286 != nil:
    section.add "SnapshotScheduleIdentifier", valid_594286
  var valid_594287 = query.getOrDefault("AdditionalInfo")
  valid_594287 = validateParameter(valid_594287, JString, required = false,
                                 default = nil)
  if valid_594287 != nil:
    section.add "AdditionalInfo", valid_594287
  var valid_594288 = query.getOrDefault("ElasticIp")
  valid_594288 = validateParameter(valid_594288, JString, required = false,
                                 default = nil)
  if valid_594288 != nil:
    section.add "ElasticIp", valid_594288
  var valid_594289 = query.getOrDefault("ClusterIdentifier")
  valid_594289 = validateParameter(valid_594289, JString, required = true,
                                 default = nil)
  if valid_594289 != nil:
    section.add "ClusterIdentifier", valid_594289
  var valid_594290 = query.getOrDefault("Action")
  valid_594290 = validateParameter(valid_594290, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_594290 != nil:
    section.add "Action", valid_594290
  var valid_594291 = query.getOrDefault("KmsKeyId")
  valid_594291 = validateParameter(valid_594291, JString, required = false,
                                 default = nil)
  if valid_594291 != nil:
    section.add "KmsKeyId", valid_594291
  var valid_594292 = query.getOrDefault("PubliclyAccessible")
  valid_594292 = validateParameter(valid_594292, JBool, required = false, default = nil)
  if valid_594292 != nil:
    section.add "PubliclyAccessible", valid_594292
  var valid_594293 = query.getOrDefault("Port")
  valid_594293 = validateParameter(valid_594293, JInt, required = false, default = nil)
  if valid_594293 != nil:
    section.add "Port", valid_594293
  var valid_594294 = query.getOrDefault("NumberOfNodes")
  valid_594294 = validateParameter(valid_594294, JInt, required = false, default = nil)
  if valid_594294 != nil:
    section.add "NumberOfNodes", valid_594294
  var valid_594295 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_594295 = validateParameter(valid_594295, JInt, required = false, default = nil)
  if valid_594295 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_594295
  var valid_594296 = query.getOrDefault("NodeType")
  valid_594296 = validateParameter(valid_594296, JString, required = true,
                                 default = nil)
  if valid_594296 != nil:
    section.add "NodeType", valid_594296
  var valid_594297 = query.getOrDefault("ClusterVersion")
  valid_594297 = validateParameter(valid_594297, JString, required = false,
                                 default = nil)
  if valid_594297 != nil:
    section.add "ClusterVersion", valid_594297
  var valid_594298 = query.getOrDefault("Version")
  valid_594298 = validateParameter(valid_594298, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594298 != nil:
    section.add "Version", valid_594298
  var valid_594299 = query.getOrDefault("ClusterType")
  valid_594299 = validateParameter(valid_594299, JString, required = false,
                                 default = nil)
  if valid_594299 != nil:
    section.add "ClusterType", valid_594299
  var valid_594300 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_594300 = validateParameter(valid_594300, JInt, required = false, default = nil)
  if valid_594300 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_594300
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594301 = header.getOrDefault("X-Amz-Date")
  valid_594301 = validateParameter(valid_594301, JString, required = false,
                                 default = nil)
  if valid_594301 != nil:
    section.add "X-Amz-Date", valid_594301
  var valid_594302 = header.getOrDefault("X-Amz-Security-Token")
  valid_594302 = validateParameter(valid_594302, JString, required = false,
                                 default = nil)
  if valid_594302 != nil:
    section.add "X-Amz-Security-Token", valid_594302
  var valid_594303 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594303 = validateParameter(valid_594303, JString, required = false,
                                 default = nil)
  if valid_594303 != nil:
    section.add "X-Amz-Content-Sha256", valid_594303
  var valid_594304 = header.getOrDefault("X-Amz-Algorithm")
  valid_594304 = validateParameter(valid_594304, JString, required = false,
                                 default = nil)
  if valid_594304 != nil:
    section.add "X-Amz-Algorithm", valid_594304
  var valid_594305 = header.getOrDefault("X-Amz-Signature")
  valid_594305 = validateParameter(valid_594305, JString, required = false,
                                 default = nil)
  if valid_594305 != nil:
    section.add "X-Amz-Signature", valid_594305
  var valid_594306 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594306 = validateParameter(valid_594306, JString, required = false,
                                 default = nil)
  if valid_594306 != nil:
    section.add "X-Amz-SignedHeaders", valid_594306
  var valid_594307 = header.getOrDefault("X-Amz-Credential")
  valid_594307 = validateParameter(valid_594307, JString, required = false,
                                 default = nil)
  if valid_594307 != nil:
    section.add "X-Amz-Credential", valid_594307
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594308: Call_GetCreateCluster_594266; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594308.validator(path, query, header, formData, body)
  let scheme = call_594308.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594308.url(scheme.get, call_594308.host, call_594308.base,
                         call_594308.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594308, url, valid)

proc call*(call_594309: Call_GetCreateCluster_594266; MasterUsername: string;
          MasterUserPassword: string; ClusterIdentifier: string; NodeType: string;
          ClusterSecurityGroups: JsonNode = nil;
          ClusterSubnetGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = ""; Encrypted: bool = false;
          MaintenanceTrackName: string = ""; IamRoles: JsonNode = nil;
          AvailabilityZone: string = ""; AllowVersionUpgrade: bool = false;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = ""; Tags: JsonNode = nil;
          DBName: string = ""; SnapshotScheduleIdentifier: string = "";
          AdditionalInfo: string = ""; ElasticIp: string = "";
          Action: string = "CreateCluster"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; Port: int = 0; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; ClusterVersion: string = "";
          Version: string = "2012-12-01"; ClusterType: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_594310 = newJObject()
  if ClusterSecurityGroups != nil:
    query_594310.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_594310, "MasterUsername", newJString(MasterUsername))
  add(query_594310, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_594310, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_594310, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_594310, "Encrypted", newJBool(Encrypted))
  add(query_594310, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if IamRoles != nil:
    query_594310.add "IamRoles", IamRoles
  add(query_594310, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_594310, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_594310, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_594310, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_594310.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_594310, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_594310, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  if Tags != nil:
    query_594310.add "Tags", Tags
  add(query_594310, "DBName", newJString(DBName))
  add(query_594310, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_594310, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_594310, "ElasticIp", newJString(ElasticIp))
  add(query_594310, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594310, "Action", newJString(Action))
  add(query_594310, "KmsKeyId", newJString(KmsKeyId))
  add(query_594310, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_594310, "Port", newJInt(Port))
  add(query_594310, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_594310, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_594310, "NodeType", newJString(NodeType))
  add(query_594310, "ClusterVersion", newJString(ClusterVersion))
  add(query_594310, "Version", newJString(Version))
  add(query_594310, "ClusterType", newJString(ClusterType))
  add(query_594310, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_594309.call(nil, query_594310, nil, nil, nil)

var getCreateCluster* = Call_GetCreateCluster_594266(name: "getCreateCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_GetCreateCluster_594267,
    base: "/", url: url_GetCreateCluster_594268,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterParameterGroup_594376 = ref object of OpenApiRestCall_593421
proc url_PostCreateClusterParameterGroup_594378(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterParameterGroup_594377(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594379 = query.getOrDefault("Action")
  valid_594379 = validateParameter(valid_594379, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_594379 != nil:
    section.add "Action", valid_594379
  var valid_594380 = query.getOrDefault("Version")
  valid_594380 = validateParameter(valid_594380, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594380 != nil:
    section.add "Version", valid_594380
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594381 = header.getOrDefault("X-Amz-Date")
  valid_594381 = validateParameter(valid_594381, JString, required = false,
                                 default = nil)
  if valid_594381 != nil:
    section.add "X-Amz-Date", valid_594381
  var valid_594382 = header.getOrDefault("X-Amz-Security-Token")
  valid_594382 = validateParameter(valid_594382, JString, required = false,
                                 default = nil)
  if valid_594382 != nil:
    section.add "X-Amz-Security-Token", valid_594382
  var valid_594383 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594383 = validateParameter(valid_594383, JString, required = false,
                                 default = nil)
  if valid_594383 != nil:
    section.add "X-Amz-Content-Sha256", valid_594383
  var valid_594384 = header.getOrDefault("X-Amz-Algorithm")
  valid_594384 = validateParameter(valid_594384, JString, required = false,
                                 default = nil)
  if valid_594384 != nil:
    section.add "X-Amz-Algorithm", valid_594384
  var valid_594385 = header.getOrDefault("X-Amz-Signature")
  valid_594385 = validateParameter(valid_594385, JString, required = false,
                                 default = nil)
  if valid_594385 != nil:
    section.add "X-Amz-Signature", valid_594385
  var valid_594386 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594386 = validateParameter(valid_594386, JString, required = false,
                                 default = nil)
  if valid_594386 != nil:
    section.add "X-Amz-SignedHeaders", valid_594386
  var valid_594387 = header.getOrDefault("X-Amz-Credential")
  valid_594387 = validateParameter(valid_594387, JString, required = false,
                                 default = nil)
  if valid_594387 != nil:
    section.add "X-Amz-Credential", valid_594387
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_594388 = formData.getOrDefault("ParameterGroupName")
  valid_594388 = validateParameter(valid_594388, JString, required = true,
                                 default = nil)
  if valid_594388 != nil:
    section.add "ParameterGroupName", valid_594388
  var valid_594389 = formData.getOrDefault("Tags")
  valid_594389 = validateParameter(valid_594389, JArray, required = false,
                                 default = nil)
  if valid_594389 != nil:
    section.add "Tags", valid_594389
  var valid_594390 = formData.getOrDefault("ParameterGroupFamily")
  valid_594390 = validateParameter(valid_594390, JString, required = true,
                                 default = nil)
  if valid_594390 != nil:
    section.add "ParameterGroupFamily", valid_594390
  var valid_594391 = formData.getOrDefault("Description")
  valid_594391 = validateParameter(valid_594391, JString, required = true,
                                 default = nil)
  if valid_594391 != nil:
    section.add "Description", valid_594391
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594392: Call_PostCreateClusterParameterGroup_594376;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594392.validator(path, query, header, formData, body)
  let scheme = call_594392.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594392.url(scheme.get, call_594392.host, call_594392.base,
                         call_594392.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594392, url, valid)

proc call*(call_594393: Call_PostCreateClusterParameterGroup_594376;
          ParameterGroupName: string; ParameterGroupFamily: string;
          Description: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description of the parameter group.
  var query_594394 = newJObject()
  var formData_594395 = newJObject()
  add(formData_594395, "ParameterGroupName", newJString(ParameterGroupName))
  if Tags != nil:
    formData_594395.add "Tags", Tags
  add(query_594394, "Action", newJString(Action))
  add(formData_594395, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_594394, "Version", newJString(Version))
  add(formData_594395, "Description", newJString(Description))
  result = call_594393.call(nil, query_594394, nil, formData_594395, nil)

var postCreateClusterParameterGroup* = Call_PostCreateClusterParameterGroup_594376(
    name: "postCreateClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_PostCreateClusterParameterGroup_594377, base: "/",
    url: url_PostCreateClusterParameterGroup_594378,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterParameterGroup_594357 = ref object of OpenApiRestCall_593421
proc url_GetCreateClusterParameterGroup_594359(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterParameterGroup_594358(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Action: JString (required)
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Description` field"
  var valid_594360 = query.getOrDefault("Description")
  valid_594360 = validateParameter(valid_594360, JString, required = true,
                                 default = nil)
  if valid_594360 != nil:
    section.add "Description", valid_594360
  var valid_594361 = query.getOrDefault("Tags")
  valid_594361 = validateParameter(valid_594361, JArray, required = false,
                                 default = nil)
  if valid_594361 != nil:
    section.add "Tags", valid_594361
  var valid_594362 = query.getOrDefault("ParameterGroupName")
  valid_594362 = validateParameter(valid_594362, JString, required = true,
                                 default = nil)
  if valid_594362 != nil:
    section.add "ParameterGroupName", valid_594362
  var valid_594363 = query.getOrDefault("Action")
  valid_594363 = validateParameter(valid_594363, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_594363 != nil:
    section.add "Action", valid_594363
  var valid_594364 = query.getOrDefault("ParameterGroupFamily")
  valid_594364 = validateParameter(valid_594364, JString, required = true,
                                 default = nil)
  if valid_594364 != nil:
    section.add "ParameterGroupFamily", valid_594364
  var valid_594365 = query.getOrDefault("Version")
  valid_594365 = validateParameter(valid_594365, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594365 != nil:
    section.add "Version", valid_594365
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594366 = header.getOrDefault("X-Amz-Date")
  valid_594366 = validateParameter(valid_594366, JString, required = false,
                                 default = nil)
  if valid_594366 != nil:
    section.add "X-Amz-Date", valid_594366
  var valid_594367 = header.getOrDefault("X-Amz-Security-Token")
  valid_594367 = validateParameter(valid_594367, JString, required = false,
                                 default = nil)
  if valid_594367 != nil:
    section.add "X-Amz-Security-Token", valid_594367
  var valid_594368 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594368 = validateParameter(valid_594368, JString, required = false,
                                 default = nil)
  if valid_594368 != nil:
    section.add "X-Amz-Content-Sha256", valid_594368
  var valid_594369 = header.getOrDefault("X-Amz-Algorithm")
  valid_594369 = validateParameter(valid_594369, JString, required = false,
                                 default = nil)
  if valid_594369 != nil:
    section.add "X-Amz-Algorithm", valid_594369
  var valid_594370 = header.getOrDefault("X-Amz-Signature")
  valid_594370 = validateParameter(valid_594370, JString, required = false,
                                 default = nil)
  if valid_594370 != nil:
    section.add "X-Amz-Signature", valid_594370
  var valid_594371 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594371 = validateParameter(valid_594371, JString, required = false,
                                 default = nil)
  if valid_594371 != nil:
    section.add "X-Amz-SignedHeaders", valid_594371
  var valid_594372 = header.getOrDefault("X-Amz-Credential")
  valid_594372 = validateParameter(valid_594372, JString, required = false,
                                 default = nil)
  if valid_594372 != nil:
    section.add "X-Amz-Credential", valid_594372
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594373: Call_GetCreateClusterParameterGroup_594357; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594373.validator(path, query, header, formData, body)
  let scheme = call_594373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594373.url(scheme.get, call_594373.host, call_594373.base,
                         call_594373.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594373, url, valid)

proc call*(call_594374: Call_GetCreateClusterParameterGroup_594357;
          Description: string; ParameterGroupName: string;
          ParameterGroupFamily: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: string (required)
  var query_594375 = newJObject()
  add(query_594375, "Description", newJString(Description))
  if Tags != nil:
    query_594375.add "Tags", Tags
  add(query_594375, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_594375, "Action", newJString(Action))
  add(query_594375, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_594375, "Version", newJString(Version))
  result = call_594374.call(nil, query_594375, nil, nil, nil)

var getCreateClusterParameterGroup* = Call_GetCreateClusterParameterGroup_594357(
    name: "getCreateClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_GetCreateClusterParameterGroup_594358, base: "/",
    url: url_GetCreateClusterParameterGroup_594359,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSecurityGroup_594414 = ref object of OpenApiRestCall_593421
proc url_PostCreateClusterSecurityGroup_594416(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterSecurityGroup_594415(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594417 = query.getOrDefault("Action")
  valid_594417 = validateParameter(valid_594417, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_594417 != nil:
    section.add "Action", valid_594417
  var valid_594418 = query.getOrDefault("Version")
  valid_594418 = validateParameter(valid_594418, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594418 != nil:
    section.add "Version", valid_594418
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594419 = header.getOrDefault("X-Amz-Date")
  valid_594419 = validateParameter(valid_594419, JString, required = false,
                                 default = nil)
  if valid_594419 != nil:
    section.add "X-Amz-Date", valid_594419
  var valid_594420 = header.getOrDefault("X-Amz-Security-Token")
  valid_594420 = validateParameter(valid_594420, JString, required = false,
                                 default = nil)
  if valid_594420 != nil:
    section.add "X-Amz-Security-Token", valid_594420
  var valid_594421 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594421 = validateParameter(valid_594421, JString, required = false,
                                 default = nil)
  if valid_594421 != nil:
    section.add "X-Amz-Content-Sha256", valid_594421
  var valid_594422 = header.getOrDefault("X-Amz-Algorithm")
  valid_594422 = validateParameter(valid_594422, JString, required = false,
                                 default = nil)
  if valid_594422 != nil:
    section.add "X-Amz-Algorithm", valid_594422
  var valid_594423 = header.getOrDefault("X-Amz-Signature")
  valid_594423 = validateParameter(valid_594423, JString, required = false,
                                 default = nil)
  if valid_594423 != nil:
    section.add "X-Amz-Signature", valid_594423
  var valid_594424 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594424 = validateParameter(valid_594424, JString, required = false,
                                 default = nil)
  if valid_594424 != nil:
    section.add "X-Amz-SignedHeaders", valid_594424
  var valid_594425 = header.getOrDefault("X-Amz-Credential")
  valid_594425 = validateParameter(valid_594425, JString, required = false,
                                 default = nil)
  if valid_594425 != nil:
    section.add "X-Amz-Credential", valid_594425
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  section = newJObject()
  var valid_594426 = formData.getOrDefault("Tags")
  valid_594426 = validateParameter(valid_594426, JArray, required = false,
                                 default = nil)
  if valid_594426 != nil:
    section.add "Tags", valid_594426
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_594427 = formData.getOrDefault("Description")
  valid_594427 = validateParameter(valid_594427, JString, required = true,
                                 default = nil)
  if valid_594427 != nil:
    section.add "Description", valid_594427
  var valid_594428 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_594428 = validateParameter(valid_594428, JString, required = true,
                                 default = nil)
  if valid_594428 != nil:
    section.add "ClusterSecurityGroupName", valid_594428
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594429: Call_PostCreateClusterSecurityGroup_594414; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594429.validator(path, query, header, formData, body)
  let scheme = call_594429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594429.url(scheme.get, call_594429.host, call_594429.base,
                         call_594429.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594429, url, valid)

proc call*(call_594430: Call_PostCreateClusterSecurityGroup_594414;
          Description: string; ClusterSecurityGroupName: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  var query_594431 = newJObject()
  var formData_594432 = newJObject()
  if Tags != nil:
    formData_594432.add "Tags", Tags
  add(query_594431, "Action", newJString(Action))
  add(query_594431, "Version", newJString(Version))
  add(formData_594432, "Description", newJString(Description))
  add(formData_594432, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_594430.call(nil, query_594431, nil, formData_594432, nil)

var postCreateClusterSecurityGroup* = Call_PostCreateClusterSecurityGroup_594414(
    name: "postCreateClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_PostCreateClusterSecurityGroup_594415, base: "/",
    url: url_PostCreateClusterSecurityGroup_594416,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSecurityGroup_594396 = ref object of OpenApiRestCall_593421
proc url_GetCreateClusterSecurityGroup_594398(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterSecurityGroup_594397(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_594399 = query.getOrDefault("ClusterSecurityGroupName")
  valid_594399 = validateParameter(valid_594399, JString, required = true,
                                 default = nil)
  if valid_594399 != nil:
    section.add "ClusterSecurityGroupName", valid_594399
  var valid_594400 = query.getOrDefault("Description")
  valid_594400 = validateParameter(valid_594400, JString, required = true,
                                 default = nil)
  if valid_594400 != nil:
    section.add "Description", valid_594400
  var valid_594401 = query.getOrDefault("Tags")
  valid_594401 = validateParameter(valid_594401, JArray, required = false,
                                 default = nil)
  if valid_594401 != nil:
    section.add "Tags", valid_594401
  var valid_594402 = query.getOrDefault("Action")
  valid_594402 = validateParameter(valid_594402, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_594402 != nil:
    section.add "Action", valid_594402
  var valid_594403 = query.getOrDefault("Version")
  valid_594403 = validateParameter(valid_594403, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594403 != nil:
    section.add "Version", valid_594403
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594404 = header.getOrDefault("X-Amz-Date")
  valid_594404 = validateParameter(valid_594404, JString, required = false,
                                 default = nil)
  if valid_594404 != nil:
    section.add "X-Amz-Date", valid_594404
  var valid_594405 = header.getOrDefault("X-Amz-Security-Token")
  valid_594405 = validateParameter(valid_594405, JString, required = false,
                                 default = nil)
  if valid_594405 != nil:
    section.add "X-Amz-Security-Token", valid_594405
  var valid_594406 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594406 = validateParameter(valid_594406, JString, required = false,
                                 default = nil)
  if valid_594406 != nil:
    section.add "X-Amz-Content-Sha256", valid_594406
  var valid_594407 = header.getOrDefault("X-Amz-Algorithm")
  valid_594407 = validateParameter(valid_594407, JString, required = false,
                                 default = nil)
  if valid_594407 != nil:
    section.add "X-Amz-Algorithm", valid_594407
  var valid_594408 = header.getOrDefault("X-Amz-Signature")
  valid_594408 = validateParameter(valid_594408, JString, required = false,
                                 default = nil)
  if valid_594408 != nil:
    section.add "X-Amz-Signature", valid_594408
  var valid_594409 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594409 = validateParameter(valid_594409, JString, required = false,
                                 default = nil)
  if valid_594409 != nil:
    section.add "X-Amz-SignedHeaders", valid_594409
  var valid_594410 = header.getOrDefault("X-Amz-Credential")
  valid_594410 = validateParameter(valid_594410, JString, required = false,
                                 default = nil)
  if valid_594410 != nil:
    section.add "X-Amz-Credential", valid_594410
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594411: Call_GetCreateClusterSecurityGroup_594396; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594411.validator(path, query, header, formData, body)
  let scheme = call_594411.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594411.url(scheme.get, call_594411.host, call_594411.base,
                         call_594411.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594411, url, valid)

proc call*(call_594412: Call_GetCreateClusterSecurityGroup_594396;
          ClusterSecurityGroupName: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594413 = newJObject()
  add(query_594413, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_594413, "Description", newJString(Description))
  if Tags != nil:
    query_594413.add "Tags", Tags
  add(query_594413, "Action", newJString(Action))
  add(query_594413, "Version", newJString(Version))
  result = call_594412.call(nil, query_594413, nil, nil, nil)

var getCreateClusterSecurityGroup* = Call_GetCreateClusterSecurityGroup_594396(
    name: "getCreateClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_GetCreateClusterSecurityGroup_594397, base: "/",
    url: url_GetCreateClusterSecurityGroup_594398,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSnapshot_594452 = ref object of OpenApiRestCall_593421
proc url_PostCreateClusterSnapshot_594454(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterSnapshot_594453(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594455 = query.getOrDefault("Action")
  valid_594455 = validateParameter(valid_594455, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_594455 != nil:
    section.add "Action", valid_594455
  var valid_594456 = query.getOrDefault("Version")
  valid_594456 = validateParameter(valid_594456, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594456 != nil:
    section.add "Version", valid_594456
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594457 = header.getOrDefault("X-Amz-Date")
  valid_594457 = validateParameter(valid_594457, JString, required = false,
                                 default = nil)
  if valid_594457 != nil:
    section.add "X-Amz-Date", valid_594457
  var valid_594458 = header.getOrDefault("X-Amz-Security-Token")
  valid_594458 = validateParameter(valid_594458, JString, required = false,
                                 default = nil)
  if valid_594458 != nil:
    section.add "X-Amz-Security-Token", valid_594458
  var valid_594459 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594459 = validateParameter(valid_594459, JString, required = false,
                                 default = nil)
  if valid_594459 != nil:
    section.add "X-Amz-Content-Sha256", valid_594459
  var valid_594460 = header.getOrDefault("X-Amz-Algorithm")
  valid_594460 = validateParameter(valid_594460, JString, required = false,
                                 default = nil)
  if valid_594460 != nil:
    section.add "X-Amz-Algorithm", valid_594460
  var valid_594461 = header.getOrDefault("X-Amz-Signature")
  valid_594461 = validateParameter(valid_594461, JString, required = false,
                                 default = nil)
  if valid_594461 != nil:
    section.add "X-Amz-Signature", valid_594461
  var valid_594462 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594462 = validateParameter(valid_594462, JString, required = false,
                                 default = nil)
  if valid_594462 != nil:
    section.add "X-Amz-SignedHeaders", valid_594462
  var valid_594463 = header.getOrDefault("X-Amz-Credential")
  valid_594463 = validateParameter(valid_594463, JString, required = false,
                                 default = nil)
  if valid_594463 != nil:
    section.add "X-Amz-Credential", valid_594463
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_594464 = formData.getOrDefault("Tags")
  valid_594464 = validateParameter(valid_594464, JArray, required = false,
                                 default = nil)
  if valid_594464 != nil:
    section.add "Tags", valid_594464
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_594465 = formData.getOrDefault("ClusterIdentifier")
  valid_594465 = validateParameter(valid_594465, JString, required = true,
                                 default = nil)
  if valid_594465 != nil:
    section.add "ClusterIdentifier", valid_594465
  var valid_594466 = formData.getOrDefault("SnapshotIdentifier")
  valid_594466 = validateParameter(valid_594466, JString, required = true,
                                 default = nil)
  if valid_594466 != nil:
    section.add "SnapshotIdentifier", valid_594466
  var valid_594467 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_594467 = validateParameter(valid_594467, JInt, required = false, default = nil)
  if valid_594467 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_594467
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594468: Call_PostCreateClusterSnapshot_594452; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594468.validator(path, query, header, formData, body)
  let scheme = call_594468.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594468.url(scheme.get, call_594468.host, call_594468.base,
                         call_594468.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594468, url, valid)

proc call*(call_594469: Call_PostCreateClusterSnapshot_594452;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSnapshot";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  var query_594470 = newJObject()
  var formData_594471 = newJObject()
  if Tags != nil:
    formData_594471.add "Tags", Tags
  add(query_594470, "Action", newJString(Action))
  add(formData_594471, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_594471, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_594471, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_594470, "Version", newJString(Version))
  result = call_594469.call(nil, query_594470, nil, formData_594471, nil)

var postCreateClusterSnapshot* = Call_PostCreateClusterSnapshot_594452(
    name: "postCreateClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_PostCreateClusterSnapshot_594453, base: "/",
    url: url_PostCreateClusterSnapshot_594454,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSnapshot_594433 = ref object of OpenApiRestCall_593421
proc url_GetCreateClusterSnapshot_594435(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterSnapshot_594434(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_594436 = query.getOrDefault("Tags")
  valid_594436 = validateParameter(valid_594436, JArray, required = false,
                                 default = nil)
  if valid_594436 != nil:
    section.add "Tags", valid_594436
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594437 = query.getOrDefault("Action")
  valid_594437 = validateParameter(valid_594437, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_594437 != nil:
    section.add "Action", valid_594437
  var valid_594438 = query.getOrDefault("ClusterIdentifier")
  valid_594438 = validateParameter(valid_594438, JString, required = true,
                                 default = nil)
  if valid_594438 != nil:
    section.add "ClusterIdentifier", valid_594438
  var valid_594439 = query.getOrDefault("SnapshotIdentifier")
  valid_594439 = validateParameter(valid_594439, JString, required = true,
                                 default = nil)
  if valid_594439 != nil:
    section.add "SnapshotIdentifier", valid_594439
  var valid_594440 = query.getOrDefault("Version")
  valid_594440 = validateParameter(valid_594440, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594440 != nil:
    section.add "Version", valid_594440
  var valid_594441 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_594441 = validateParameter(valid_594441, JInt, required = false, default = nil)
  if valid_594441 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_594441
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594442 = header.getOrDefault("X-Amz-Date")
  valid_594442 = validateParameter(valid_594442, JString, required = false,
                                 default = nil)
  if valid_594442 != nil:
    section.add "X-Amz-Date", valid_594442
  var valid_594443 = header.getOrDefault("X-Amz-Security-Token")
  valid_594443 = validateParameter(valid_594443, JString, required = false,
                                 default = nil)
  if valid_594443 != nil:
    section.add "X-Amz-Security-Token", valid_594443
  var valid_594444 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594444 = validateParameter(valid_594444, JString, required = false,
                                 default = nil)
  if valid_594444 != nil:
    section.add "X-Amz-Content-Sha256", valid_594444
  var valid_594445 = header.getOrDefault("X-Amz-Algorithm")
  valid_594445 = validateParameter(valid_594445, JString, required = false,
                                 default = nil)
  if valid_594445 != nil:
    section.add "X-Amz-Algorithm", valid_594445
  var valid_594446 = header.getOrDefault("X-Amz-Signature")
  valid_594446 = validateParameter(valid_594446, JString, required = false,
                                 default = nil)
  if valid_594446 != nil:
    section.add "X-Amz-Signature", valid_594446
  var valid_594447 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594447 = validateParameter(valid_594447, JString, required = false,
                                 default = nil)
  if valid_594447 != nil:
    section.add "X-Amz-SignedHeaders", valid_594447
  var valid_594448 = header.getOrDefault("X-Amz-Credential")
  valid_594448 = validateParameter(valid_594448, JString, required = false,
                                 default = nil)
  if valid_594448 != nil:
    section.add "X-Amz-Credential", valid_594448
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594449: Call_GetCreateClusterSnapshot_594433; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594449.validator(path, query, header, formData, body)
  let scheme = call_594449.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594449.url(scheme.get, call_594449.host, call_594449.base,
                         call_594449.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594449, url, valid)

proc call*(call_594450: Call_GetCreateClusterSnapshot_594433;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSnapshot";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_594451 = newJObject()
  if Tags != nil:
    query_594451.add "Tags", Tags
  add(query_594451, "Action", newJString(Action))
  add(query_594451, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594451, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_594451, "Version", newJString(Version))
  add(query_594451, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_594450.call(nil, query_594451, nil, nil, nil)

var getCreateClusterSnapshot* = Call_GetCreateClusterSnapshot_594433(
    name: "getCreateClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_GetCreateClusterSnapshot_594434, base: "/",
    url: url_GetCreateClusterSnapshot_594435, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSubnetGroup_594491 = ref object of OpenApiRestCall_593421
proc url_PostCreateClusterSubnetGroup_594493(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterSubnetGroup_594492(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594494 = query.getOrDefault("Action")
  valid_594494 = validateParameter(valid_594494, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_594494 != nil:
    section.add "Action", valid_594494
  var valid_594495 = query.getOrDefault("Version")
  valid_594495 = validateParameter(valid_594495, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594495 != nil:
    section.add "Version", valid_594495
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594496 = header.getOrDefault("X-Amz-Date")
  valid_594496 = validateParameter(valid_594496, JString, required = false,
                                 default = nil)
  if valid_594496 != nil:
    section.add "X-Amz-Date", valid_594496
  var valid_594497 = header.getOrDefault("X-Amz-Security-Token")
  valid_594497 = validateParameter(valid_594497, JString, required = false,
                                 default = nil)
  if valid_594497 != nil:
    section.add "X-Amz-Security-Token", valid_594497
  var valid_594498 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594498 = validateParameter(valid_594498, JString, required = false,
                                 default = nil)
  if valid_594498 != nil:
    section.add "X-Amz-Content-Sha256", valid_594498
  var valid_594499 = header.getOrDefault("X-Amz-Algorithm")
  valid_594499 = validateParameter(valid_594499, JString, required = false,
                                 default = nil)
  if valid_594499 != nil:
    section.add "X-Amz-Algorithm", valid_594499
  var valid_594500 = header.getOrDefault("X-Amz-Signature")
  valid_594500 = validateParameter(valid_594500, JString, required = false,
                                 default = nil)
  if valid_594500 != nil:
    section.add "X-Amz-Signature", valid_594500
  var valid_594501 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594501 = validateParameter(valid_594501, JString, required = false,
                                 default = nil)
  if valid_594501 != nil:
    section.add "X-Amz-SignedHeaders", valid_594501
  var valid_594502 = header.getOrDefault("X-Amz-Credential")
  valid_594502 = validateParameter(valid_594502, JString, required = false,
                                 default = nil)
  if valid_594502 != nil:
    section.add "X-Amz-Credential", valid_594502
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  section = newJObject()
  var valid_594503 = formData.getOrDefault("Tags")
  valid_594503 = validateParameter(valid_594503, JArray, required = false,
                                 default = nil)
  if valid_594503 != nil:
    section.add "Tags", valid_594503
  assert formData != nil,
        "formData argument is necessary due to required `SubnetIds` field"
  var valid_594504 = formData.getOrDefault("SubnetIds")
  valid_594504 = validateParameter(valid_594504, JArray, required = true, default = nil)
  if valid_594504 != nil:
    section.add "SubnetIds", valid_594504
  var valid_594505 = formData.getOrDefault("Description")
  valid_594505 = validateParameter(valid_594505, JString, required = true,
                                 default = nil)
  if valid_594505 != nil:
    section.add "Description", valid_594505
  var valid_594506 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_594506 = validateParameter(valid_594506, JString, required = true,
                                 default = nil)
  if valid_594506 != nil:
    section.add "ClusterSubnetGroupName", valid_594506
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594507: Call_PostCreateClusterSubnetGroup_594491; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594507.validator(path, query, header, formData, body)
  let scheme = call_594507.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594507.url(scheme.get, call_594507.host, call_594507.base,
                         call_594507.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594507, url, valid)

proc call*(call_594508: Call_PostCreateClusterSubnetGroup_594491;
          SubnetIds: JsonNode; Description: string; ClusterSubnetGroupName: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  var query_594509 = newJObject()
  var formData_594510 = newJObject()
  if Tags != nil:
    formData_594510.add "Tags", Tags
  if SubnetIds != nil:
    formData_594510.add "SubnetIds", SubnetIds
  add(query_594509, "Action", newJString(Action))
  add(query_594509, "Version", newJString(Version))
  add(formData_594510, "Description", newJString(Description))
  add(formData_594510, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_594508.call(nil, query_594509, nil, formData_594510, nil)

var postCreateClusterSubnetGroup* = Call_PostCreateClusterSubnetGroup_594491(
    name: "postCreateClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_PostCreateClusterSubnetGroup_594492, base: "/",
    url: url_PostCreateClusterSubnetGroup_594493,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSubnetGroup_594472 = ref object of OpenApiRestCall_593421
proc url_GetCreateClusterSubnetGroup_594474(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterSubnetGroup_594473(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_594475 = query.getOrDefault("ClusterSubnetGroupName")
  valid_594475 = validateParameter(valid_594475, JString, required = true,
                                 default = nil)
  if valid_594475 != nil:
    section.add "ClusterSubnetGroupName", valid_594475
  var valid_594476 = query.getOrDefault("Description")
  valid_594476 = validateParameter(valid_594476, JString, required = true,
                                 default = nil)
  if valid_594476 != nil:
    section.add "Description", valid_594476
  var valid_594477 = query.getOrDefault("Tags")
  valid_594477 = validateParameter(valid_594477, JArray, required = false,
                                 default = nil)
  if valid_594477 != nil:
    section.add "Tags", valid_594477
  var valid_594478 = query.getOrDefault("Action")
  valid_594478 = validateParameter(valid_594478, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_594478 != nil:
    section.add "Action", valid_594478
  var valid_594479 = query.getOrDefault("SubnetIds")
  valid_594479 = validateParameter(valid_594479, JArray, required = true, default = nil)
  if valid_594479 != nil:
    section.add "SubnetIds", valid_594479
  var valid_594480 = query.getOrDefault("Version")
  valid_594480 = validateParameter(valid_594480, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594480 != nil:
    section.add "Version", valid_594480
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594481 = header.getOrDefault("X-Amz-Date")
  valid_594481 = validateParameter(valid_594481, JString, required = false,
                                 default = nil)
  if valid_594481 != nil:
    section.add "X-Amz-Date", valid_594481
  var valid_594482 = header.getOrDefault("X-Amz-Security-Token")
  valid_594482 = validateParameter(valid_594482, JString, required = false,
                                 default = nil)
  if valid_594482 != nil:
    section.add "X-Amz-Security-Token", valid_594482
  var valid_594483 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594483 = validateParameter(valid_594483, JString, required = false,
                                 default = nil)
  if valid_594483 != nil:
    section.add "X-Amz-Content-Sha256", valid_594483
  var valid_594484 = header.getOrDefault("X-Amz-Algorithm")
  valid_594484 = validateParameter(valid_594484, JString, required = false,
                                 default = nil)
  if valid_594484 != nil:
    section.add "X-Amz-Algorithm", valid_594484
  var valid_594485 = header.getOrDefault("X-Amz-Signature")
  valid_594485 = validateParameter(valid_594485, JString, required = false,
                                 default = nil)
  if valid_594485 != nil:
    section.add "X-Amz-Signature", valid_594485
  var valid_594486 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594486 = validateParameter(valid_594486, JString, required = false,
                                 default = nil)
  if valid_594486 != nil:
    section.add "X-Amz-SignedHeaders", valid_594486
  var valid_594487 = header.getOrDefault("X-Amz-Credential")
  valid_594487 = validateParameter(valid_594487, JString, required = false,
                                 default = nil)
  if valid_594487 != nil:
    section.add "X-Amz-Credential", valid_594487
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594488: Call_GetCreateClusterSubnetGroup_594472; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594488.validator(path, query, header, formData, body)
  let scheme = call_594488.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594488.url(scheme.get, call_594488.host, call_594488.base,
                         call_594488.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594488, url, valid)

proc call*(call_594489: Call_GetCreateClusterSubnetGroup_594472;
          ClusterSubnetGroupName: string; Description: string; SubnetIds: JsonNode;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: string (required)
  var query_594490 = newJObject()
  add(query_594490, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_594490, "Description", newJString(Description))
  if Tags != nil:
    query_594490.add "Tags", Tags
  add(query_594490, "Action", newJString(Action))
  if SubnetIds != nil:
    query_594490.add "SubnetIds", SubnetIds
  add(query_594490, "Version", newJString(Version))
  result = call_594489.call(nil, query_594490, nil, nil, nil)

var getCreateClusterSubnetGroup* = Call_GetCreateClusterSubnetGroup_594472(
    name: "getCreateClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_GetCreateClusterSubnetGroup_594473, base: "/",
    url: url_GetCreateClusterSubnetGroup_594474,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateEventSubscription_594534 = ref object of OpenApiRestCall_593421
proc url_PostCreateEventSubscription_594536(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateEventSubscription_594535(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594537 = query.getOrDefault("Action")
  valid_594537 = validateParameter(valid_594537, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_594537 != nil:
    section.add "Action", valid_594537
  var valid_594538 = query.getOrDefault("Version")
  valid_594538 = validateParameter(valid_594538, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594538 != nil:
    section.add "Version", valid_594538
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594539 = header.getOrDefault("X-Amz-Date")
  valid_594539 = validateParameter(valid_594539, JString, required = false,
                                 default = nil)
  if valid_594539 != nil:
    section.add "X-Amz-Date", valid_594539
  var valid_594540 = header.getOrDefault("X-Amz-Security-Token")
  valid_594540 = validateParameter(valid_594540, JString, required = false,
                                 default = nil)
  if valid_594540 != nil:
    section.add "X-Amz-Security-Token", valid_594540
  var valid_594541 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594541 = validateParameter(valid_594541, JString, required = false,
                                 default = nil)
  if valid_594541 != nil:
    section.add "X-Amz-Content-Sha256", valid_594541
  var valid_594542 = header.getOrDefault("X-Amz-Algorithm")
  valid_594542 = validateParameter(valid_594542, JString, required = false,
                                 default = nil)
  if valid_594542 != nil:
    section.add "X-Amz-Algorithm", valid_594542
  var valid_594543 = header.getOrDefault("X-Amz-Signature")
  valid_594543 = validateParameter(valid_594543, JString, required = false,
                                 default = nil)
  if valid_594543 != nil:
    section.add "X-Amz-Signature", valid_594543
  var valid_594544 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594544 = validateParameter(valid_594544, JString, required = false,
                                 default = nil)
  if valid_594544 != nil:
    section.add "X-Amz-SignedHeaders", valid_594544
  var valid_594545 = header.getOrDefault("X-Amz-Credential")
  valid_594545 = validateParameter(valid_594545, JString, required = false,
                                 default = nil)
  if valid_594545 != nil:
    section.add "X-Amz-Credential", valid_594545
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  section = newJObject()
  var valid_594546 = formData.getOrDefault("Enabled")
  valid_594546 = validateParameter(valid_594546, JBool, required = false, default = nil)
  if valid_594546 != nil:
    section.add "Enabled", valid_594546
  var valid_594547 = formData.getOrDefault("EventCategories")
  valid_594547 = validateParameter(valid_594547, JArray, required = false,
                                 default = nil)
  if valid_594547 != nil:
    section.add "EventCategories", valid_594547
  assert formData != nil,
        "formData argument is necessary due to required `SnsTopicArn` field"
  var valid_594548 = formData.getOrDefault("SnsTopicArn")
  valid_594548 = validateParameter(valid_594548, JString, required = true,
                                 default = nil)
  if valid_594548 != nil:
    section.add "SnsTopicArn", valid_594548
  var valid_594549 = formData.getOrDefault("Severity")
  valid_594549 = validateParameter(valid_594549, JString, required = false,
                                 default = nil)
  if valid_594549 != nil:
    section.add "Severity", valid_594549
  var valid_594550 = formData.getOrDefault("SourceIds")
  valid_594550 = validateParameter(valid_594550, JArray, required = false,
                                 default = nil)
  if valid_594550 != nil:
    section.add "SourceIds", valid_594550
  var valid_594551 = formData.getOrDefault("Tags")
  valid_594551 = validateParameter(valid_594551, JArray, required = false,
                                 default = nil)
  if valid_594551 != nil:
    section.add "Tags", valid_594551
  var valid_594552 = formData.getOrDefault("SubscriptionName")
  valid_594552 = validateParameter(valid_594552, JString, required = true,
                                 default = nil)
  if valid_594552 != nil:
    section.add "SubscriptionName", valid_594552
  var valid_594553 = formData.getOrDefault("SourceType")
  valid_594553 = validateParameter(valid_594553, JString, required = false,
                                 default = nil)
  if valid_594553 != nil:
    section.add "SourceType", valid_594553
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594554: Call_PostCreateEventSubscription_594534; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_594554.validator(path, query, header, formData, body)
  let scheme = call_594554.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594554.url(scheme.get, call_594554.host, call_594554.base,
                         call_594554.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594554, url, valid)

proc call*(call_594555: Call_PostCreateEventSubscription_594534;
          SnsTopicArn: string; SubscriptionName: string; Enabled: bool = false;
          EventCategories: JsonNode = nil; Severity: string = "";
          SourceIds: JsonNode = nil; Tags: JsonNode = nil;
          Action: string = "CreateEventSubscription";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  var query_594556 = newJObject()
  var formData_594557 = newJObject()
  add(formData_594557, "Enabled", newJBool(Enabled))
  if EventCategories != nil:
    formData_594557.add "EventCategories", EventCategories
  add(formData_594557, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_594557, "Severity", newJString(Severity))
  if SourceIds != nil:
    formData_594557.add "SourceIds", SourceIds
  if Tags != nil:
    formData_594557.add "Tags", Tags
  add(formData_594557, "SubscriptionName", newJString(SubscriptionName))
  add(query_594556, "Action", newJString(Action))
  add(query_594556, "Version", newJString(Version))
  add(formData_594557, "SourceType", newJString(SourceType))
  result = call_594555.call(nil, query_594556, nil, formData_594557, nil)

var postCreateEventSubscription* = Call_PostCreateEventSubscription_594534(
    name: "postCreateEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_PostCreateEventSubscription_594535, base: "/",
    url: url_PostCreateEventSubscription_594536,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateEventSubscription_594511 = ref object of OpenApiRestCall_593421
proc url_GetCreateEventSubscription_594513(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateEventSubscription_594512(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_594514 = query.getOrDefault("SourceType")
  valid_594514 = validateParameter(valid_594514, JString, required = false,
                                 default = nil)
  if valid_594514 != nil:
    section.add "SourceType", valid_594514
  var valid_594515 = query.getOrDefault("SourceIds")
  valid_594515 = validateParameter(valid_594515, JArray, required = false,
                                 default = nil)
  if valid_594515 != nil:
    section.add "SourceIds", valid_594515
  var valid_594516 = query.getOrDefault("Enabled")
  valid_594516 = validateParameter(valid_594516, JBool, required = false, default = nil)
  if valid_594516 != nil:
    section.add "Enabled", valid_594516
  var valid_594517 = query.getOrDefault("Tags")
  valid_594517 = validateParameter(valid_594517, JArray, required = false,
                                 default = nil)
  if valid_594517 != nil:
    section.add "Tags", valid_594517
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594518 = query.getOrDefault("Action")
  valid_594518 = validateParameter(valid_594518, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_594518 != nil:
    section.add "Action", valid_594518
  var valid_594519 = query.getOrDefault("SnsTopicArn")
  valid_594519 = validateParameter(valid_594519, JString, required = true,
                                 default = nil)
  if valid_594519 != nil:
    section.add "SnsTopicArn", valid_594519
  var valid_594520 = query.getOrDefault("EventCategories")
  valid_594520 = validateParameter(valid_594520, JArray, required = false,
                                 default = nil)
  if valid_594520 != nil:
    section.add "EventCategories", valid_594520
  var valid_594521 = query.getOrDefault("SubscriptionName")
  valid_594521 = validateParameter(valid_594521, JString, required = true,
                                 default = nil)
  if valid_594521 != nil:
    section.add "SubscriptionName", valid_594521
  var valid_594522 = query.getOrDefault("Severity")
  valid_594522 = validateParameter(valid_594522, JString, required = false,
                                 default = nil)
  if valid_594522 != nil:
    section.add "Severity", valid_594522
  var valid_594523 = query.getOrDefault("Version")
  valid_594523 = validateParameter(valid_594523, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594523 != nil:
    section.add "Version", valid_594523
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594524 = header.getOrDefault("X-Amz-Date")
  valid_594524 = validateParameter(valid_594524, JString, required = false,
                                 default = nil)
  if valid_594524 != nil:
    section.add "X-Amz-Date", valid_594524
  var valid_594525 = header.getOrDefault("X-Amz-Security-Token")
  valid_594525 = validateParameter(valid_594525, JString, required = false,
                                 default = nil)
  if valid_594525 != nil:
    section.add "X-Amz-Security-Token", valid_594525
  var valid_594526 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594526 = validateParameter(valid_594526, JString, required = false,
                                 default = nil)
  if valid_594526 != nil:
    section.add "X-Amz-Content-Sha256", valid_594526
  var valid_594527 = header.getOrDefault("X-Amz-Algorithm")
  valid_594527 = validateParameter(valid_594527, JString, required = false,
                                 default = nil)
  if valid_594527 != nil:
    section.add "X-Amz-Algorithm", valid_594527
  var valid_594528 = header.getOrDefault("X-Amz-Signature")
  valid_594528 = validateParameter(valid_594528, JString, required = false,
                                 default = nil)
  if valid_594528 != nil:
    section.add "X-Amz-Signature", valid_594528
  var valid_594529 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594529 = validateParameter(valid_594529, JString, required = false,
                                 default = nil)
  if valid_594529 != nil:
    section.add "X-Amz-SignedHeaders", valid_594529
  var valid_594530 = header.getOrDefault("X-Amz-Credential")
  valid_594530 = validateParameter(valid_594530, JString, required = false,
                                 default = nil)
  if valid_594530 != nil:
    section.add "X-Amz-Credential", valid_594530
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594531: Call_GetCreateEventSubscription_594511; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_594531.validator(path, query, header, formData, body)
  let scheme = call_594531.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594531.url(scheme.get, call_594531.host, call_594531.base,
                         call_594531.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594531, url, valid)

proc call*(call_594532: Call_GetCreateEventSubscription_594511;
          SnsTopicArn: string; SubscriptionName: string; SourceType: string = "";
          SourceIds: JsonNode = nil; Enabled: bool = false; Tags: JsonNode = nil;
          Action: string = "CreateEventSubscription";
          EventCategories: JsonNode = nil; Severity: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: string (required)
  var query_594533 = newJObject()
  add(query_594533, "SourceType", newJString(SourceType))
  if SourceIds != nil:
    query_594533.add "SourceIds", SourceIds
  add(query_594533, "Enabled", newJBool(Enabled))
  if Tags != nil:
    query_594533.add "Tags", Tags
  add(query_594533, "Action", newJString(Action))
  add(query_594533, "SnsTopicArn", newJString(SnsTopicArn))
  if EventCategories != nil:
    query_594533.add "EventCategories", EventCategories
  add(query_594533, "SubscriptionName", newJString(SubscriptionName))
  add(query_594533, "Severity", newJString(Severity))
  add(query_594533, "Version", newJString(Version))
  result = call_594532.call(nil, query_594533, nil, nil, nil)

var getCreateEventSubscription* = Call_GetCreateEventSubscription_594511(
    name: "getCreateEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_GetCreateEventSubscription_594512, base: "/",
    url: url_GetCreateEventSubscription_594513,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmClientCertificate_594575 = ref object of OpenApiRestCall_593421
proc url_PostCreateHsmClientCertificate_594577(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateHsmClientCertificate_594576(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594578 = query.getOrDefault("Action")
  valid_594578 = validateParameter(valid_594578, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_594578 != nil:
    section.add "Action", valid_594578
  var valid_594579 = query.getOrDefault("Version")
  valid_594579 = validateParameter(valid_594579, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594579 != nil:
    section.add "Version", valid_594579
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594580 = header.getOrDefault("X-Amz-Date")
  valid_594580 = validateParameter(valid_594580, JString, required = false,
                                 default = nil)
  if valid_594580 != nil:
    section.add "X-Amz-Date", valid_594580
  var valid_594581 = header.getOrDefault("X-Amz-Security-Token")
  valid_594581 = validateParameter(valid_594581, JString, required = false,
                                 default = nil)
  if valid_594581 != nil:
    section.add "X-Amz-Security-Token", valid_594581
  var valid_594582 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594582 = validateParameter(valid_594582, JString, required = false,
                                 default = nil)
  if valid_594582 != nil:
    section.add "X-Amz-Content-Sha256", valid_594582
  var valid_594583 = header.getOrDefault("X-Amz-Algorithm")
  valid_594583 = validateParameter(valid_594583, JString, required = false,
                                 default = nil)
  if valid_594583 != nil:
    section.add "X-Amz-Algorithm", valid_594583
  var valid_594584 = header.getOrDefault("X-Amz-Signature")
  valid_594584 = validateParameter(valid_594584, JString, required = false,
                                 default = nil)
  if valid_594584 != nil:
    section.add "X-Amz-Signature", valid_594584
  var valid_594585 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594585 = validateParameter(valid_594585, JString, required = false,
                                 default = nil)
  if valid_594585 != nil:
    section.add "X-Amz-SignedHeaders", valid_594585
  var valid_594586 = header.getOrDefault("X-Amz-Credential")
  valid_594586 = validateParameter(valid_594586, JString, required = false,
                                 default = nil)
  if valid_594586 != nil:
    section.add "X-Amz-Credential", valid_594586
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  section = newJObject()
  var valid_594587 = formData.getOrDefault("Tags")
  valid_594587 = validateParameter(valid_594587, JArray, required = false,
                                 default = nil)
  if valid_594587 != nil:
    section.add "Tags", valid_594587
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_594588 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_594588 = validateParameter(valid_594588, JString, required = true,
                                 default = nil)
  if valid_594588 != nil:
    section.add "HsmClientCertificateIdentifier", valid_594588
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594589: Call_PostCreateHsmClientCertificate_594575; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_594589.validator(path, query, header, formData, body)
  let scheme = call_594589.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594589.url(scheme.get, call_594589.host, call_594589.base,
                         call_594589.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594589, url, valid)

proc call*(call_594590: Call_PostCreateHsmClientCertificate_594575;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Version: string (required)
  var query_594591 = newJObject()
  var formData_594592 = newJObject()
  if Tags != nil:
    formData_594592.add "Tags", Tags
  add(query_594591, "Action", newJString(Action))
  add(formData_594592, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_594591, "Version", newJString(Version))
  result = call_594590.call(nil, query_594591, nil, formData_594592, nil)

var postCreateHsmClientCertificate* = Call_PostCreateHsmClientCertificate_594575(
    name: "postCreateHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_PostCreateHsmClientCertificate_594576, base: "/",
    url: url_PostCreateHsmClientCertificate_594577,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmClientCertificate_594558 = ref object of OpenApiRestCall_593421
proc url_GetCreateHsmClientCertificate_594560(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateHsmClientCertificate_594559(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_594561 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_594561 = validateParameter(valid_594561, JString, required = true,
                                 default = nil)
  if valid_594561 != nil:
    section.add "HsmClientCertificateIdentifier", valid_594561
  var valid_594562 = query.getOrDefault("Tags")
  valid_594562 = validateParameter(valid_594562, JArray, required = false,
                                 default = nil)
  if valid_594562 != nil:
    section.add "Tags", valid_594562
  var valid_594563 = query.getOrDefault("Action")
  valid_594563 = validateParameter(valid_594563, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_594563 != nil:
    section.add "Action", valid_594563
  var valid_594564 = query.getOrDefault("Version")
  valid_594564 = validateParameter(valid_594564, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594564 != nil:
    section.add "Version", valid_594564
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594565 = header.getOrDefault("X-Amz-Date")
  valid_594565 = validateParameter(valid_594565, JString, required = false,
                                 default = nil)
  if valid_594565 != nil:
    section.add "X-Amz-Date", valid_594565
  var valid_594566 = header.getOrDefault("X-Amz-Security-Token")
  valid_594566 = validateParameter(valid_594566, JString, required = false,
                                 default = nil)
  if valid_594566 != nil:
    section.add "X-Amz-Security-Token", valid_594566
  var valid_594567 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594567 = validateParameter(valid_594567, JString, required = false,
                                 default = nil)
  if valid_594567 != nil:
    section.add "X-Amz-Content-Sha256", valid_594567
  var valid_594568 = header.getOrDefault("X-Amz-Algorithm")
  valid_594568 = validateParameter(valid_594568, JString, required = false,
                                 default = nil)
  if valid_594568 != nil:
    section.add "X-Amz-Algorithm", valid_594568
  var valid_594569 = header.getOrDefault("X-Amz-Signature")
  valid_594569 = validateParameter(valid_594569, JString, required = false,
                                 default = nil)
  if valid_594569 != nil:
    section.add "X-Amz-Signature", valid_594569
  var valid_594570 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594570 = validateParameter(valid_594570, JString, required = false,
                                 default = nil)
  if valid_594570 != nil:
    section.add "X-Amz-SignedHeaders", valid_594570
  var valid_594571 = header.getOrDefault("X-Amz-Credential")
  valid_594571 = validateParameter(valid_594571, JString, required = false,
                                 default = nil)
  if valid_594571 != nil:
    section.add "X-Amz-Credential", valid_594571
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594572: Call_GetCreateHsmClientCertificate_594558; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_594572.validator(path, query, header, formData, body)
  let scheme = call_594572.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594572.url(scheme.get, call_594572.host, call_594572.base,
                         call_594572.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594572, url, valid)

proc call*(call_594573: Call_GetCreateHsmClientCertificate_594558;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594574 = newJObject()
  add(query_594574, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    query_594574.add "Tags", Tags
  add(query_594574, "Action", newJString(Action))
  add(query_594574, "Version", newJString(Version))
  result = call_594573.call(nil, query_594574, nil, nil, nil)

var getCreateHsmClientCertificate* = Call_GetCreateHsmClientCertificate_594558(
    name: "getCreateHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_GetCreateHsmClientCertificate_594559, base: "/",
    url: url_GetCreateHsmClientCertificate_594560,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmConfiguration_594615 = ref object of OpenApiRestCall_593421
proc url_PostCreateHsmConfiguration_594617(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateHsmConfiguration_594616(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594618 = query.getOrDefault("Action")
  valid_594618 = validateParameter(valid_594618, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_594618 != nil:
    section.add "Action", valid_594618
  var valid_594619 = query.getOrDefault("Version")
  valid_594619 = validateParameter(valid_594619, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594619 != nil:
    section.add "Version", valid_594619
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594620 = header.getOrDefault("X-Amz-Date")
  valid_594620 = validateParameter(valid_594620, JString, required = false,
                                 default = nil)
  if valid_594620 != nil:
    section.add "X-Amz-Date", valid_594620
  var valid_594621 = header.getOrDefault("X-Amz-Security-Token")
  valid_594621 = validateParameter(valid_594621, JString, required = false,
                                 default = nil)
  if valid_594621 != nil:
    section.add "X-Amz-Security-Token", valid_594621
  var valid_594622 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594622 = validateParameter(valid_594622, JString, required = false,
                                 default = nil)
  if valid_594622 != nil:
    section.add "X-Amz-Content-Sha256", valid_594622
  var valid_594623 = header.getOrDefault("X-Amz-Algorithm")
  valid_594623 = validateParameter(valid_594623, JString, required = false,
                                 default = nil)
  if valid_594623 != nil:
    section.add "X-Amz-Algorithm", valid_594623
  var valid_594624 = header.getOrDefault("X-Amz-Signature")
  valid_594624 = validateParameter(valid_594624, JString, required = false,
                                 default = nil)
  if valid_594624 != nil:
    section.add "X-Amz-Signature", valid_594624
  var valid_594625 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594625 = validateParameter(valid_594625, JString, required = false,
                                 default = nil)
  if valid_594625 != nil:
    section.add "X-Amz-SignedHeaders", valid_594625
  var valid_594626 = header.getOrDefault("X-Amz-Credential")
  valid_594626 = validateParameter(valid_594626, JString, required = false,
                                 default = nil)
  if valid_594626 != nil:
    section.add "X-Amz-Credential", valid_594626
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `HsmIpAddress` field"
  var valid_594627 = formData.getOrDefault("HsmIpAddress")
  valid_594627 = validateParameter(valid_594627, JString, required = true,
                                 default = nil)
  if valid_594627 != nil:
    section.add "HsmIpAddress", valid_594627
  var valid_594628 = formData.getOrDefault("HsmPartitionName")
  valid_594628 = validateParameter(valid_594628, JString, required = true,
                                 default = nil)
  if valid_594628 != nil:
    section.add "HsmPartitionName", valid_594628
  var valid_594629 = formData.getOrDefault("Tags")
  valid_594629 = validateParameter(valid_594629, JArray, required = false,
                                 default = nil)
  if valid_594629 != nil:
    section.add "Tags", valid_594629
  var valid_594630 = formData.getOrDefault("HsmPartitionPassword")
  valid_594630 = validateParameter(valid_594630, JString, required = true,
                                 default = nil)
  if valid_594630 != nil:
    section.add "HsmPartitionPassword", valid_594630
  var valid_594631 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_594631 = validateParameter(valid_594631, JString, required = true,
                                 default = nil)
  if valid_594631 != nil:
    section.add "HsmConfigurationIdentifier", valid_594631
  var valid_594632 = formData.getOrDefault("HsmServerPublicCertificate")
  valid_594632 = validateParameter(valid_594632, JString, required = true,
                                 default = nil)
  if valid_594632 != nil:
    section.add "HsmServerPublicCertificate", valid_594632
  var valid_594633 = formData.getOrDefault("Description")
  valid_594633 = validateParameter(valid_594633, JString, required = true,
                                 default = nil)
  if valid_594633 != nil:
    section.add "Description", valid_594633
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594634: Call_PostCreateHsmConfiguration_594615; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_594634.validator(path, query, header, formData, body)
  let scheme = call_594634.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594634.url(scheme.get, call_594634.host, call_594634.base,
                         call_594634.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594634, url, valid)

proc call*(call_594635: Call_PostCreateHsmConfiguration_594615;
          HsmIpAddress: string; HsmPartitionName: string;
          HsmPartitionPassword: string; HsmConfigurationIdentifier: string;
          HsmServerPublicCertificate: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  var query_594636 = newJObject()
  var formData_594637 = newJObject()
  add(formData_594637, "HsmIpAddress", newJString(HsmIpAddress))
  add(formData_594637, "HsmPartitionName", newJString(HsmPartitionName))
  if Tags != nil:
    formData_594637.add "Tags", Tags
  add(formData_594637, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(formData_594637, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_594636, "Action", newJString(Action))
  add(formData_594637, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_594636, "Version", newJString(Version))
  add(formData_594637, "Description", newJString(Description))
  result = call_594635.call(nil, query_594636, nil, formData_594637, nil)

var postCreateHsmConfiguration* = Call_PostCreateHsmConfiguration_594615(
    name: "postCreateHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_PostCreateHsmConfiguration_594616, base: "/",
    url: url_PostCreateHsmConfiguration_594617,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmConfiguration_594593 = ref object of OpenApiRestCall_593421
proc url_GetCreateHsmConfiguration_594595(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateHsmConfiguration_594594(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmPartitionPassword` field"
  var valid_594596 = query.getOrDefault("HsmPartitionPassword")
  valid_594596 = validateParameter(valid_594596, JString, required = true,
                                 default = nil)
  if valid_594596 != nil:
    section.add "HsmPartitionPassword", valid_594596
  var valid_594597 = query.getOrDefault("Description")
  valid_594597 = validateParameter(valid_594597, JString, required = true,
                                 default = nil)
  if valid_594597 != nil:
    section.add "Description", valid_594597
  var valid_594598 = query.getOrDefault("HsmPartitionName")
  valid_594598 = validateParameter(valid_594598, JString, required = true,
                                 default = nil)
  if valid_594598 != nil:
    section.add "HsmPartitionName", valid_594598
  var valid_594599 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_594599 = validateParameter(valid_594599, JString, required = true,
                                 default = nil)
  if valid_594599 != nil:
    section.add "HsmConfigurationIdentifier", valid_594599
  var valid_594600 = query.getOrDefault("Tags")
  valid_594600 = validateParameter(valid_594600, JArray, required = false,
                                 default = nil)
  if valid_594600 != nil:
    section.add "Tags", valid_594600
  var valid_594601 = query.getOrDefault("Action")
  valid_594601 = validateParameter(valid_594601, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_594601 != nil:
    section.add "Action", valid_594601
  var valid_594602 = query.getOrDefault("HsmServerPublicCertificate")
  valid_594602 = validateParameter(valid_594602, JString, required = true,
                                 default = nil)
  if valid_594602 != nil:
    section.add "HsmServerPublicCertificate", valid_594602
  var valid_594603 = query.getOrDefault("HsmIpAddress")
  valid_594603 = validateParameter(valid_594603, JString, required = true,
                                 default = nil)
  if valid_594603 != nil:
    section.add "HsmIpAddress", valid_594603
  var valid_594604 = query.getOrDefault("Version")
  valid_594604 = validateParameter(valid_594604, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594604 != nil:
    section.add "Version", valid_594604
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594605 = header.getOrDefault("X-Amz-Date")
  valid_594605 = validateParameter(valid_594605, JString, required = false,
                                 default = nil)
  if valid_594605 != nil:
    section.add "X-Amz-Date", valid_594605
  var valid_594606 = header.getOrDefault("X-Amz-Security-Token")
  valid_594606 = validateParameter(valid_594606, JString, required = false,
                                 default = nil)
  if valid_594606 != nil:
    section.add "X-Amz-Security-Token", valid_594606
  var valid_594607 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594607 = validateParameter(valid_594607, JString, required = false,
                                 default = nil)
  if valid_594607 != nil:
    section.add "X-Amz-Content-Sha256", valid_594607
  var valid_594608 = header.getOrDefault("X-Amz-Algorithm")
  valid_594608 = validateParameter(valid_594608, JString, required = false,
                                 default = nil)
  if valid_594608 != nil:
    section.add "X-Amz-Algorithm", valid_594608
  var valid_594609 = header.getOrDefault("X-Amz-Signature")
  valid_594609 = validateParameter(valid_594609, JString, required = false,
                                 default = nil)
  if valid_594609 != nil:
    section.add "X-Amz-Signature", valid_594609
  var valid_594610 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594610 = validateParameter(valid_594610, JString, required = false,
                                 default = nil)
  if valid_594610 != nil:
    section.add "X-Amz-SignedHeaders", valid_594610
  var valid_594611 = header.getOrDefault("X-Amz-Credential")
  valid_594611 = validateParameter(valid_594611, JString, required = false,
                                 default = nil)
  if valid_594611 != nil:
    section.add "X-Amz-Credential", valid_594611
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594612: Call_GetCreateHsmConfiguration_594593; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_594612.validator(path, query, header, formData, body)
  let scheme = call_594612.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594612.url(scheme.get, call_594612.host, call_594612.base,
                         call_594612.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594612, url, valid)

proc call*(call_594613: Call_GetCreateHsmConfiguration_594593;
          HsmPartitionPassword: string; Description: string;
          HsmPartitionName: string; HsmConfigurationIdentifier: string;
          HsmServerPublicCertificate: string; HsmIpAddress: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   Version: string (required)
  var query_594614 = newJObject()
  add(query_594614, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_594614, "Description", newJString(Description))
  add(query_594614, "HsmPartitionName", newJString(HsmPartitionName))
  add(query_594614, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  if Tags != nil:
    query_594614.add "Tags", Tags
  add(query_594614, "Action", newJString(Action))
  add(query_594614, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_594614, "HsmIpAddress", newJString(HsmIpAddress))
  add(query_594614, "Version", newJString(Version))
  result = call_594613.call(nil, query_594614, nil, nil, nil)

var getCreateHsmConfiguration* = Call_GetCreateHsmConfiguration_594593(
    name: "getCreateHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_GetCreateHsmConfiguration_594594, base: "/",
    url: url_GetCreateHsmConfiguration_594595,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotCopyGrant_594656 = ref object of OpenApiRestCall_593421
proc url_PostCreateSnapshotCopyGrant_594658(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateSnapshotCopyGrant_594657(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594659 = query.getOrDefault("Action")
  valid_594659 = validateParameter(valid_594659, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_594659 != nil:
    section.add "Action", valid_594659
  var valid_594660 = query.getOrDefault("Version")
  valid_594660 = validateParameter(valid_594660, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594660 != nil:
    section.add "Version", valid_594660
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594661 = header.getOrDefault("X-Amz-Date")
  valid_594661 = validateParameter(valid_594661, JString, required = false,
                                 default = nil)
  if valid_594661 != nil:
    section.add "X-Amz-Date", valid_594661
  var valid_594662 = header.getOrDefault("X-Amz-Security-Token")
  valid_594662 = validateParameter(valid_594662, JString, required = false,
                                 default = nil)
  if valid_594662 != nil:
    section.add "X-Amz-Security-Token", valid_594662
  var valid_594663 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594663 = validateParameter(valid_594663, JString, required = false,
                                 default = nil)
  if valid_594663 != nil:
    section.add "X-Amz-Content-Sha256", valid_594663
  var valid_594664 = header.getOrDefault("X-Amz-Algorithm")
  valid_594664 = validateParameter(valid_594664, JString, required = false,
                                 default = nil)
  if valid_594664 != nil:
    section.add "X-Amz-Algorithm", valid_594664
  var valid_594665 = header.getOrDefault("X-Amz-Signature")
  valid_594665 = validateParameter(valid_594665, JString, required = false,
                                 default = nil)
  if valid_594665 != nil:
    section.add "X-Amz-Signature", valid_594665
  var valid_594666 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594666 = validateParameter(valid_594666, JString, required = false,
                                 default = nil)
  if valid_594666 != nil:
    section.add "X-Amz-SignedHeaders", valid_594666
  var valid_594667 = header.getOrDefault("X-Amz-Credential")
  valid_594667 = validateParameter(valid_594667, JString, required = false,
                                 default = nil)
  if valid_594667 != nil:
    section.add "X-Amz-Credential", valid_594667
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  section = newJObject()
  var valid_594668 = formData.getOrDefault("Tags")
  valid_594668 = validateParameter(valid_594668, JArray, required = false,
                                 default = nil)
  if valid_594668 != nil:
    section.add "Tags", valid_594668
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_594669 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_594669 = validateParameter(valid_594669, JString, required = true,
                                 default = nil)
  if valid_594669 != nil:
    section.add "SnapshotCopyGrantName", valid_594669
  var valid_594670 = formData.getOrDefault("KmsKeyId")
  valid_594670 = validateParameter(valid_594670, JString, required = false,
                                 default = nil)
  if valid_594670 != nil:
    section.add "KmsKeyId", valid_594670
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594671: Call_PostCreateSnapshotCopyGrant_594656; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_594671.validator(path, query, header, formData, body)
  let scheme = call_594671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594671.url(scheme.get, call_594671.host, call_594671.base,
                         call_594671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594671, url, valid)

proc call*(call_594672: Call_PostCreateSnapshotCopyGrant_594656;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil;
          Action: string = "CreateSnapshotCopyGrant"; KmsKeyId: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Version: string (required)
  var query_594673 = newJObject()
  var formData_594674 = newJObject()
  if Tags != nil:
    formData_594674.add "Tags", Tags
  add(query_594673, "Action", newJString(Action))
  add(formData_594674, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(formData_594674, "KmsKeyId", newJString(KmsKeyId))
  add(query_594673, "Version", newJString(Version))
  result = call_594672.call(nil, query_594673, nil, formData_594674, nil)

var postCreateSnapshotCopyGrant* = Call_PostCreateSnapshotCopyGrant_594656(
    name: "postCreateSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_PostCreateSnapshotCopyGrant_594657, base: "/",
    url: url_PostCreateSnapshotCopyGrant_594658,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotCopyGrant_594638 = ref object of OpenApiRestCall_593421
proc url_GetCreateSnapshotCopyGrant_594640(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateSnapshotCopyGrant_594639(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_594641 = query.getOrDefault("Tags")
  valid_594641 = validateParameter(valid_594641, JArray, required = false,
                                 default = nil)
  if valid_594641 != nil:
    section.add "Tags", valid_594641
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594642 = query.getOrDefault("Action")
  valid_594642 = validateParameter(valid_594642, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_594642 != nil:
    section.add "Action", valid_594642
  var valid_594643 = query.getOrDefault("KmsKeyId")
  valid_594643 = validateParameter(valid_594643, JString, required = false,
                                 default = nil)
  if valid_594643 != nil:
    section.add "KmsKeyId", valid_594643
  var valid_594644 = query.getOrDefault("SnapshotCopyGrantName")
  valid_594644 = validateParameter(valid_594644, JString, required = true,
                                 default = nil)
  if valid_594644 != nil:
    section.add "SnapshotCopyGrantName", valid_594644
  var valid_594645 = query.getOrDefault("Version")
  valid_594645 = validateParameter(valid_594645, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594645 != nil:
    section.add "Version", valid_594645
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594646 = header.getOrDefault("X-Amz-Date")
  valid_594646 = validateParameter(valid_594646, JString, required = false,
                                 default = nil)
  if valid_594646 != nil:
    section.add "X-Amz-Date", valid_594646
  var valid_594647 = header.getOrDefault("X-Amz-Security-Token")
  valid_594647 = validateParameter(valid_594647, JString, required = false,
                                 default = nil)
  if valid_594647 != nil:
    section.add "X-Amz-Security-Token", valid_594647
  var valid_594648 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594648 = validateParameter(valid_594648, JString, required = false,
                                 default = nil)
  if valid_594648 != nil:
    section.add "X-Amz-Content-Sha256", valid_594648
  var valid_594649 = header.getOrDefault("X-Amz-Algorithm")
  valid_594649 = validateParameter(valid_594649, JString, required = false,
                                 default = nil)
  if valid_594649 != nil:
    section.add "X-Amz-Algorithm", valid_594649
  var valid_594650 = header.getOrDefault("X-Amz-Signature")
  valid_594650 = validateParameter(valid_594650, JString, required = false,
                                 default = nil)
  if valid_594650 != nil:
    section.add "X-Amz-Signature", valid_594650
  var valid_594651 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594651 = validateParameter(valid_594651, JString, required = false,
                                 default = nil)
  if valid_594651 != nil:
    section.add "X-Amz-SignedHeaders", valid_594651
  var valid_594652 = header.getOrDefault("X-Amz-Credential")
  valid_594652 = validateParameter(valid_594652, JString, required = false,
                                 default = nil)
  if valid_594652 != nil:
    section.add "X-Amz-Credential", valid_594652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594653: Call_GetCreateSnapshotCopyGrant_594638; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_594653.validator(path, query, header, formData, body)
  let scheme = call_594653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594653.url(scheme.get, call_594653.host, call_594653.base,
                         call_594653.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594653, url, valid)

proc call*(call_594654: Call_GetCreateSnapshotCopyGrant_594638;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil;
          Action: string = "CreateSnapshotCopyGrant"; KmsKeyId: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: string (required)
  var query_594655 = newJObject()
  if Tags != nil:
    query_594655.add "Tags", Tags
  add(query_594655, "Action", newJString(Action))
  add(query_594655, "KmsKeyId", newJString(KmsKeyId))
  add(query_594655, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_594655, "Version", newJString(Version))
  result = call_594654.call(nil, query_594655, nil, nil, nil)

var getCreateSnapshotCopyGrant* = Call_GetCreateSnapshotCopyGrant_594638(
    name: "getCreateSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_GetCreateSnapshotCopyGrant_594639, base: "/",
    url: url_GetCreateSnapshotCopyGrant_594640,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotSchedule_594696 = ref object of OpenApiRestCall_593421
proc url_PostCreateSnapshotSchedule_594698(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateSnapshotSchedule_594697(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594699 = query.getOrDefault("Action")
  valid_594699 = validateParameter(valid_594699, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_594699 != nil:
    section.add "Action", valid_594699
  var valid_594700 = query.getOrDefault("Version")
  valid_594700 = validateParameter(valid_594700, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594700 != nil:
    section.add "Version", valid_594700
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594701 = header.getOrDefault("X-Amz-Date")
  valid_594701 = validateParameter(valid_594701, JString, required = false,
                                 default = nil)
  if valid_594701 != nil:
    section.add "X-Amz-Date", valid_594701
  var valid_594702 = header.getOrDefault("X-Amz-Security-Token")
  valid_594702 = validateParameter(valid_594702, JString, required = false,
                                 default = nil)
  if valid_594702 != nil:
    section.add "X-Amz-Security-Token", valid_594702
  var valid_594703 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594703 = validateParameter(valid_594703, JString, required = false,
                                 default = nil)
  if valid_594703 != nil:
    section.add "X-Amz-Content-Sha256", valid_594703
  var valid_594704 = header.getOrDefault("X-Amz-Algorithm")
  valid_594704 = validateParameter(valid_594704, JString, required = false,
                                 default = nil)
  if valid_594704 != nil:
    section.add "X-Amz-Algorithm", valid_594704
  var valid_594705 = header.getOrDefault("X-Amz-Signature")
  valid_594705 = validateParameter(valid_594705, JString, required = false,
                                 default = nil)
  if valid_594705 != nil:
    section.add "X-Amz-Signature", valid_594705
  var valid_594706 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594706 = validateParameter(valid_594706, JString, required = false,
                                 default = nil)
  if valid_594706 != nil:
    section.add "X-Amz-SignedHeaders", valid_594706
  var valid_594707 = header.getOrDefault("X-Amz-Credential")
  valid_594707 = validateParameter(valid_594707, JString, required = false,
                                 default = nil)
  if valid_594707 != nil:
    section.add "X-Amz-Credential", valid_594707
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   DryRun: JBool
  ##         : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   NextInvocations: JInt
  ##                  : <p/>
  section = newJObject()
  var valid_594708 = formData.getOrDefault("ScheduleDefinitions")
  valid_594708 = validateParameter(valid_594708, JArray, required = false,
                                 default = nil)
  if valid_594708 != nil:
    section.add "ScheduleDefinitions", valid_594708
  var valid_594709 = formData.getOrDefault("DryRun")
  valid_594709 = validateParameter(valid_594709, JBool, required = false, default = nil)
  if valid_594709 != nil:
    section.add "DryRun", valid_594709
  var valid_594710 = formData.getOrDefault("Tags")
  valid_594710 = validateParameter(valid_594710, JArray, required = false,
                                 default = nil)
  if valid_594710 != nil:
    section.add "Tags", valid_594710
  var valid_594711 = formData.getOrDefault("ScheduleDescription")
  valid_594711 = validateParameter(valid_594711, JString, required = false,
                                 default = nil)
  if valid_594711 != nil:
    section.add "ScheduleDescription", valid_594711
  var valid_594712 = formData.getOrDefault("ScheduleIdentifier")
  valid_594712 = validateParameter(valid_594712, JString, required = false,
                                 default = nil)
  if valid_594712 != nil:
    section.add "ScheduleIdentifier", valid_594712
  var valid_594713 = formData.getOrDefault("NextInvocations")
  valid_594713 = validateParameter(valid_594713, JInt, required = false, default = nil)
  if valid_594713 != nil:
    section.add "NextInvocations", valid_594713
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594714: Call_PostCreateSnapshotSchedule_594696; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_594714.validator(path, query, header, formData, body)
  let scheme = call_594714.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594714.url(scheme.get, call_594714.host, call_594714.base,
                         call_594714.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594714, url, valid)

proc call*(call_594715: Call_PostCreateSnapshotSchedule_594696;
          ScheduleDefinitions: JsonNode = nil; DryRun: bool = false;
          Tags: JsonNode = nil; ScheduleDescription: string = "";
          Action: string = "CreateSnapshotSchedule";
          ScheduleIdentifier: string = ""; NextInvocations: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   DryRun: bool
  ##         : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Version: string (required)
  var query_594716 = newJObject()
  var formData_594717 = newJObject()
  if ScheduleDefinitions != nil:
    formData_594717.add "ScheduleDefinitions", ScheduleDefinitions
  add(formData_594717, "DryRun", newJBool(DryRun))
  if Tags != nil:
    formData_594717.add "Tags", Tags
  add(formData_594717, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_594716, "Action", newJString(Action))
  add(formData_594717, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(formData_594717, "NextInvocations", newJInt(NextInvocations))
  add(query_594716, "Version", newJString(Version))
  result = call_594715.call(nil, query_594716, nil, formData_594717, nil)

var postCreateSnapshotSchedule* = Call_PostCreateSnapshotSchedule_594696(
    name: "postCreateSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_PostCreateSnapshotSchedule_594697, base: "/",
    url: url_PostCreateSnapshotSchedule_594698,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotSchedule_594675 = ref object of OpenApiRestCall_593421
proc url_GetCreateSnapshotSchedule_594677(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateSnapshotSchedule_594676(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DryRun: JBool
  ##         : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   Version: JString (required)
  section = newJObject()
  var valid_594678 = query.getOrDefault("DryRun")
  valid_594678 = validateParameter(valid_594678, JBool, required = false, default = nil)
  if valid_594678 != nil:
    section.add "DryRun", valid_594678
  var valid_594679 = query.getOrDefault("ScheduleDefinitions")
  valid_594679 = validateParameter(valid_594679, JArray, required = false,
                                 default = nil)
  if valid_594679 != nil:
    section.add "ScheduleDefinitions", valid_594679
  var valid_594680 = query.getOrDefault("Tags")
  valid_594680 = validateParameter(valid_594680, JArray, required = false,
                                 default = nil)
  if valid_594680 != nil:
    section.add "Tags", valid_594680
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594681 = query.getOrDefault("Action")
  valid_594681 = validateParameter(valid_594681, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_594681 != nil:
    section.add "Action", valid_594681
  var valid_594682 = query.getOrDefault("ScheduleIdentifier")
  valid_594682 = validateParameter(valid_594682, JString, required = false,
                                 default = nil)
  if valid_594682 != nil:
    section.add "ScheduleIdentifier", valid_594682
  var valid_594683 = query.getOrDefault("ScheduleDescription")
  valid_594683 = validateParameter(valid_594683, JString, required = false,
                                 default = nil)
  if valid_594683 != nil:
    section.add "ScheduleDescription", valid_594683
  var valid_594684 = query.getOrDefault("NextInvocations")
  valid_594684 = validateParameter(valid_594684, JInt, required = false, default = nil)
  if valid_594684 != nil:
    section.add "NextInvocations", valid_594684
  var valid_594685 = query.getOrDefault("Version")
  valid_594685 = validateParameter(valid_594685, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594685 != nil:
    section.add "Version", valid_594685
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594686 = header.getOrDefault("X-Amz-Date")
  valid_594686 = validateParameter(valid_594686, JString, required = false,
                                 default = nil)
  if valid_594686 != nil:
    section.add "X-Amz-Date", valid_594686
  var valid_594687 = header.getOrDefault("X-Amz-Security-Token")
  valid_594687 = validateParameter(valid_594687, JString, required = false,
                                 default = nil)
  if valid_594687 != nil:
    section.add "X-Amz-Security-Token", valid_594687
  var valid_594688 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594688 = validateParameter(valid_594688, JString, required = false,
                                 default = nil)
  if valid_594688 != nil:
    section.add "X-Amz-Content-Sha256", valid_594688
  var valid_594689 = header.getOrDefault("X-Amz-Algorithm")
  valid_594689 = validateParameter(valid_594689, JString, required = false,
                                 default = nil)
  if valid_594689 != nil:
    section.add "X-Amz-Algorithm", valid_594689
  var valid_594690 = header.getOrDefault("X-Amz-Signature")
  valid_594690 = validateParameter(valid_594690, JString, required = false,
                                 default = nil)
  if valid_594690 != nil:
    section.add "X-Amz-Signature", valid_594690
  var valid_594691 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594691 = validateParameter(valid_594691, JString, required = false,
                                 default = nil)
  if valid_594691 != nil:
    section.add "X-Amz-SignedHeaders", valid_594691
  var valid_594692 = header.getOrDefault("X-Amz-Credential")
  valid_594692 = validateParameter(valid_594692, JString, required = false,
                                 default = nil)
  if valid_594692 != nil:
    section.add "X-Amz-Credential", valid_594692
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594693: Call_GetCreateSnapshotSchedule_594675; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_594693.validator(path, query, header, formData, body)
  let scheme = call_594693.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594693.url(scheme.get, call_594693.host, call_594693.base,
                         call_594693.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594693, url, valid)

proc call*(call_594694: Call_GetCreateSnapshotSchedule_594675;
          DryRun: bool = false; ScheduleDefinitions: JsonNode = nil;
          Tags: JsonNode = nil; Action: string = "CreateSnapshotSchedule";
          ScheduleIdentifier: string = ""; ScheduleDescription: string = "";
          NextInvocations: int = 0; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   DryRun: bool
  ##         : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Version: string (required)
  var query_594695 = newJObject()
  add(query_594695, "DryRun", newJBool(DryRun))
  if ScheduleDefinitions != nil:
    query_594695.add "ScheduleDefinitions", ScheduleDefinitions
  if Tags != nil:
    query_594695.add "Tags", Tags
  add(query_594695, "Action", newJString(Action))
  add(query_594695, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_594695, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_594695, "NextInvocations", newJInt(NextInvocations))
  add(query_594695, "Version", newJString(Version))
  result = call_594694.call(nil, query_594695, nil, nil, nil)

var getCreateSnapshotSchedule* = Call_GetCreateSnapshotSchedule_594675(
    name: "getCreateSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_GetCreateSnapshotSchedule_594676, base: "/",
    url: url_GetCreateSnapshotSchedule_594677,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateTags_594735 = ref object of OpenApiRestCall_593421
proc url_PostCreateTags_594737(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateTags_594736(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594738 = query.getOrDefault("Action")
  valid_594738 = validateParameter(valid_594738, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_594738 != nil:
    section.add "Action", valid_594738
  var valid_594739 = query.getOrDefault("Version")
  valid_594739 = validateParameter(valid_594739, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594739 != nil:
    section.add "Version", valid_594739
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594740 = header.getOrDefault("X-Amz-Date")
  valid_594740 = validateParameter(valid_594740, JString, required = false,
                                 default = nil)
  if valid_594740 != nil:
    section.add "X-Amz-Date", valid_594740
  var valid_594741 = header.getOrDefault("X-Amz-Security-Token")
  valid_594741 = validateParameter(valid_594741, JString, required = false,
                                 default = nil)
  if valid_594741 != nil:
    section.add "X-Amz-Security-Token", valid_594741
  var valid_594742 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594742 = validateParameter(valid_594742, JString, required = false,
                                 default = nil)
  if valid_594742 != nil:
    section.add "X-Amz-Content-Sha256", valid_594742
  var valid_594743 = header.getOrDefault("X-Amz-Algorithm")
  valid_594743 = validateParameter(valid_594743, JString, required = false,
                                 default = nil)
  if valid_594743 != nil:
    section.add "X-Amz-Algorithm", valid_594743
  var valid_594744 = header.getOrDefault("X-Amz-Signature")
  valid_594744 = validateParameter(valid_594744, JString, required = false,
                                 default = nil)
  if valid_594744 != nil:
    section.add "X-Amz-Signature", valid_594744
  var valid_594745 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594745 = validateParameter(valid_594745, JString, required = false,
                                 default = nil)
  if valid_594745 != nil:
    section.add "X-Amz-SignedHeaders", valid_594745
  var valid_594746 = header.getOrDefault("X-Amz-Credential")
  valid_594746 = validateParameter(valid_594746, JString, required = false,
                                 default = nil)
  if valid_594746 != nil:
    section.add "X-Amz-Credential", valid_594746
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Tags` field"
  var valid_594747 = formData.getOrDefault("Tags")
  valid_594747 = validateParameter(valid_594747, JArray, required = true, default = nil)
  if valid_594747 != nil:
    section.add "Tags", valid_594747
  var valid_594748 = formData.getOrDefault("ResourceName")
  valid_594748 = validateParameter(valid_594748, JString, required = true,
                                 default = nil)
  if valid_594748 != nil:
    section.add "ResourceName", valid_594748
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594749: Call_PostCreateTags_594735; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_594749.validator(path, query, header, formData, body)
  let scheme = call_594749.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594749.url(scheme.get, call_594749.host, call_594749.base,
                         call_594749.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594749, url, valid)

proc call*(call_594750: Call_PostCreateTags_594735; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Action: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Version: string (required)
  var query_594751 = newJObject()
  var formData_594752 = newJObject()
  if Tags != nil:
    formData_594752.add "Tags", Tags
  add(query_594751, "Action", newJString(Action))
  add(formData_594752, "ResourceName", newJString(ResourceName))
  add(query_594751, "Version", newJString(Version))
  result = call_594750.call(nil, query_594751, nil, formData_594752, nil)

var postCreateTags* = Call_PostCreateTags_594735(name: "postCreateTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_PostCreateTags_594736,
    base: "/", url: url_PostCreateTags_594737, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateTags_594718 = ref object of OpenApiRestCall_593421
proc url_GetCreateTags_594720(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateTags_594719(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Tags` field"
  var valid_594721 = query.getOrDefault("Tags")
  valid_594721 = validateParameter(valid_594721, JArray, required = true, default = nil)
  if valid_594721 != nil:
    section.add "Tags", valid_594721
  var valid_594722 = query.getOrDefault("ResourceName")
  valid_594722 = validateParameter(valid_594722, JString, required = true,
                                 default = nil)
  if valid_594722 != nil:
    section.add "ResourceName", valid_594722
  var valid_594723 = query.getOrDefault("Action")
  valid_594723 = validateParameter(valid_594723, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_594723 != nil:
    section.add "Action", valid_594723
  var valid_594724 = query.getOrDefault("Version")
  valid_594724 = validateParameter(valid_594724, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594724 != nil:
    section.add "Version", valid_594724
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594725 = header.getOrDefault("X-Amz-Date")
  valid_594725 = validateParameter(valid_594725, JString, required = false,
                                 default = nil)
  if valid_594725 != nil:
    section.add "X-Amz-Date", valid_594725
  var valid_594726 = header.getOrDefault("X-Amz-Security-Token")
  valid_594726 = validateParameter(valid_594726, JString, required = false,
                                 default = nil)
  if valid_594726 != nil:
    section.add "X-Amz-Security-Token", valid_594726
  var valid_594727 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594727 = validateParameter(valid_594727, JString, required = false,
                                 default = nil)
  if valid_594727 != nil:
    section.add "X-Amz-Content-Sha256", valid_594727
  var valid_594728 = header.getOrDefault("X-Amz-Algorithm")
  valid_594728 = validateParameter(valid_594728, JString, required = false,
                                 default = nil)
  if valid_594728 != nil:
    section.add "X-Amz-Algorithm", valid_594728
  var valid_594729 = header.getOrDefault("X-Amz-Signature")
  valid_594729 = validateParameter(valid_594729, JString, required = false,
                                 default = nil)
  if valid_594729 != nil:
    section.add "X-Amz-Signature", valid_594729
  var valid_594730 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594730 = validateParameter(valid_594730, JString, required = false,
                                 default = nil)
  if valid_594730 != nil:
    section.add "X-Amz-SignedHeaders", valid_594730
  var valid_594731 = header.getOrDefault("X-Amz-Credential")
  valid_594731 = validateParameter(valid_594731, JString, required = false,
                                 default = nil)
  if valid_594731 != nil:
    section.add "X-Amz-Credential", valid_594731
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594732: Call_GetCreateTags_594718; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_594732.validator(path, query, header, formData, body)
  let scheme = call_594732.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594732.url(scheme.get, call_594732.host, call_594732.base,
                         call_594732.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594732, url, valid)

proc call*(call_594733: Call_GetCreateTags_594718; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594734 = newJObject()
  if Tags != nil:
    query_594734.add "Tags", Tags
  add(query_594734, "ResourceName", newJString(ResourceName))
  add(query_594734, "Action", newJString(Action))
  add(query_594734, "Version", newJString(Version))
  result = call_594733.call(nil, query_594734, nil, nil, nil)

var getCreateTags* = Call_GetCreateTags_594718(name: "getCreateTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_GetCreateTags_594719,
    base: "/", url: url_GetCreateTags_594720, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteCluster_594772 = ref object of OpenApiRestCall_593421
proc url_PostDeleteCluster_594774(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteCluster_594773(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594775 = query.getOrDefault("Action")
  valid_594775 = validateParameter(valid_594775, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_594775 != nil:
    section.add "Action", valid_594775
  var valid_594776 = query.getOrDefault("Version")
  valid_594776 = validateParameter(valid_594776, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594776 != nil:
    section.add "Version", valid_594776
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594777 = header.getOrDefault("X-Amz-Date")
  valid_594777 = validateParameter(valid_594777, JString, required = false,
                                 default = nil)
  if valid_594777 != nil:
    section.add "X-Amz-Date", valid_594777
  var valid_594778 = header.getOrDefault("X-Amz-Security-Token")
  valid_594778 = validateParameter(valid_594778, JString, required = false,
                                 default = nil)
  if valid_594778 != nil:
    section.add "X-Amz-Security-Token", valid_594778
  var valid_594779 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594779 = validateParameter(valid_594779, JString, required = false,
                                 default = nil)
  if valid_594779 != nil:
    section.add "X-Amz-Content-Sha256", valid_594779
  var valid_594780 = header.getOrDefault("X-Amz-Algorithm")
  valid_594780 = validateParameter(valid_594780, JString, required = false,
                                 default = nil)
  if valid_594780 != nil:
    section.add "X-Amz-Algorithm", valid_594780
  var valid_594781 = header.getOrDefault("X-Amz-Signature")
  valid_594781 = validateParameter(valid_594781, JString, required = false,
                                 default = nil)
  if valid_594781 != nil:
    section.add "X-Amz-Signature", valid_594781
  var valid_594782 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594782 = validateParameter(valid_594782, JString, required = false,
                                 default = nil)
  if valid_594782 != nil:
    section.add "X-Amz-SignedHeaders", valid_594782
  var valid_594783 = header.getOrDefault("X-Amz-Credential")
  valid_594783 = validateParameter(valid_594783, JString, required = false,
                                 default = nil)
  if valid_594783 != nil:
    section.add "X-Amz-Credential", valid_594783
  result.add "header", section
  ## parameters in `formData` object:
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  section = newJObject()
  var valid_594784 = formData.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_594784 = validateParameter(valid_594784, JString, required = false,
                                 default = nil)
  if valid_594784 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_594784
  var valid_594785 = formData.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_594785 = validateParameter(valid_594785, JInt, required = false, default = nil)
  if valid_594785 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_594785
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_594786 = formData.getOrDefault("ClusterIdentifier")
  valid_594786 = validateParameter(valid_594786, JString, required = true,
                                 default = nil)
  if valid_594786 != nil:
    section.add "ClusterIdentifier", valid_594786
  var valid_594787 = formData.getOrDefault("SkipFinalClusterSnapshot")
  valid_594787 = validateParameter(valid_594787, JBool, required = false, default = nil)
  if valid_594787 != nil:
    section.add "SkipFinalClusterSnapshot", valid_594787
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594788: Call_PostDeleteCluster_594772; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594788.validator(path, query, header, formData, body)
  let scheme = call_594788.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594788.url(scheme.get, call_594788.host, call_594788.base,
                         call_594788.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594788, url, valid)

proc call*(call_594789: Call_PostDeleteCluster_594772; ClusterIdentifier: string;
          FinalClusterSnapshotIdentifier: string = "";
          Action: string = "DeleteCluster";
          FinalClusterSnapshotRetentionPeriod: int = 0;
          SkipFinalClusterSnapshot: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   Version: string (required)
  var query_594790 = newJObject()
  var formData_594791 = newJObject()
  add(formData_594791, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_594790, "Action", newJString(Action))
  add(formData_594791, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(formData_594791, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_594791, "SkipFinalClusterSnapshot",
      newJBool(SkipFinalClusterSnapshot))
  add(query_594790, "Version", newJString(Version))
  result = call_594789.call(nil, query_594790, nil, formData_594791, nil)

var postDeleteCluster* = Call_PostDeleteCluster_594772(name: "postDeleteCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_PostDeleteCluster_594773,
    base: "/", url: url_PostDeleteCluster_594774,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteCluster_594753 = ref object of OpenApiRestCall_593421
proc url_GetDeleteCluster_594755(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteCluster_594754(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_594756 = query.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_594756 = validateParameter(valid_594756, JInt, required = false, default = nil)
  if valid_594756 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_594756
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594757 = query.getOrDefault("Action")
  valid_594757 = validateParameter(valid_594757, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_594757 != nil:
    section.add "Action", valid_594757
  var valid_594758 = query.getOrDefault("ClusterIdentifier")
  valid_594758 = validateParameter(valid_594758, JString, required = true,
                                 default = nil)
  if valid_594758 != nil:
    section.add "ClusterIdentifier", valid_594758
  var valid_594759 = query.getOrDefault("SkipFinalClusterSnapshot")
  valid_594759 = validateParameter(valid_594759, JBool, required = false, default = nil)
  if valid_594759 != nil:
    section.add "SkipFinalClusterSnapshot", valid_594759
  var valid_594760 = query.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_594760 = validateParameter(valid_594760, JString, required = false,
                                 default = nil)
  if valid_594760 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_594760
  var valid_594761 = query.getOrDefault("Version")
  valid_594761 = validateParameter(valid_594761, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594761 != nil:
    section.add "Version", valid_594761
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594762 = header.getOrDefault("X-Amz-Date")
  valid_594762 = validateParameter(valid_594762, JString, required = false,
                                 default = nil)
  if valid_594762 != nil:
    section.add "X-Amz-Date", valid_594762
  var valid_594763 = header.getOrDefault("X-Amz-Security-Token")
  valid_594763 = validateParameter(valid_594763, JString, required = false,
                                 default = nil)
  if valid_594763 != nil:
    section.add "X-Amz-Security-Token", valid_594763
  var valid_594764 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594764 = validateParameter(valid_594764, JString, required = false,
                                 default = nil)
  if valid_594764 != nil:
    section.add "X-Amz-Content-Sha256", valid_594764
  var valid_594765 = header.getOrDefault("X-Amz-Algorithm")
  valid_594765 = validateParameter(valid_594765, JString, required = false,
                                 default = nil)
  if valid_594765 != nil:
    section.add "X-Amz-Algorithm", valid_594765
  var valid_594766 = header.getOrDefault("X-Amz-Signature")
  valid_594766 = validateParameter(valid_594766, JString, required = false,
                                 default = nil)
  if valid_594766 != nil:
    section.add "X-Amz-Signature", valid_594766
  var valid_594767 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594767 = validateParameter(valid_594767, JString, required = false,
                                 default = nil)
  if valid_594767 != nil:
    section.add "X-Amz-SignedHeaders", valid_594767
  var valid_594768 = header.getOrDefault("X-Amz-Credential")
  valid_594768 = validateParameter(valid_594768, JString, required = false,
                                 default = nil)
  if valid_594768 != nil:
    section.add "X-Amz-Credential", valid_594768
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594769: Call_GetDeleteCluster_594753; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594769.validator(path, query, header, formData, body)
  let scheme = call_594769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594769.url(scheme.get, call_594769.host, call_594769.base,
                         call_594769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594769, url, valid)

proc call*(call_594770: Call_GetDeleteCluster_594753; ClusterIdentifier: string;
          FinalClusterSnapshotRetentionPeriod: int = 0;
          Action: string = "DeleteCluster"; SkipFinalClusterSnapshot: bool = false;
          FinalClusterSnapshotIdentifier: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: string (required)
  var query_594771 = newJObject()
  add(query_594771, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(query_594771, "Action", newJString(Action))
  add(query_594771, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594771, "SkipFinalClusterSnapshot", newJBool(SkipFinalClusterSnapshot))
  add(query_594771, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_594771, "Version", newJString(Version))
  result = call_594770.call(nil, query_594771, nil, nil, nil)

var getDeleteCluster* = Call_GetDeleteCluster_594753(name: "getDeleteCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_GetDeleteCluster_594754,
    base: "/", url: url_GetDeleteCluster_594755,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterParameterGroup_594808 = ref object of OpenApiRestCall_593421
proc url_PostDeleteClusterParameterGroup_594810(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterParameterGroup_594809(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594811 = query.getOrDefault("Action")
  valid_594811 = validateParameter(valid_594811, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_594811 != nil:
    section.add "Action", valid_594811
  var valid_594812 = query.getOrDefault("Version")
  valid_594812 = validateParameter(valid_594812, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594812 != nil:
    section.add "Version", valid_594812
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594813 = header.getOrDefault("X-Amz-Date")
  valid_594813 = validateParameter(valid_594813, JString, required = false,
                                 default = nil)
  if valid_594813 != nil:
    section.add "X-Amz-Date", valid_594813
  var valid_594814 = header.getOrDefault("X-Amz-Security-Token")
  valid_594814 = validateParameter(valid_594814, JString, required = false,
                                 default = nil)
  if valid_594814 != nil:
    section.add "X-Amz-Security-Token", valid_594814
  var valid_594815 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594815 = validateParameter(valid_594815, JString, required = false,
                                 default = nil)
  if valid_594815 != nil:
    section.add "X-Amz-Content-Sha256", valid_594815
  var valid_594816 = header.getOrDefault("X-Amz-Algorithm")
  valid_594816 = validateParameter(valid_594816, JString, required = false,
                                 default = nil)
  if valid_594816 != nil:
    section.add "X-Amz-Algorithm", valid_594816
  var valid_594817 = header.getOrDefault("X-Amz-Signature")
  valid_594817 = validateParameter(valid_594817, JString, required = false,
                                 default = nil)
  if valid_594817 != nil:
    section.add "X-Amz-Signature", valid_594817
  var valid_594818 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594818 = validateParameter(valid_594818, JString, required = false,
                                 default = nil)
  if valid_594818 != nil:
    section.add "X-Amz-SignedHeaders", valid_594818
  var valid_594819 = header.getOrDefault("X-Amz-Credential")
  valid_594819 = validateParameter(valid_594819, JString, required = false,
                                 default = nil)
  if valid_594819 != nil:
    section.add "X-Amz-Credential", valid_594819
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_594820 = formData.getOrDefault("ParameterGroupName")
  valid_594820 = validateParameter(valid_594820, JString, required = true,
                                 default = nil)
  if valid_594820 != nil:
    section.add "ParameterGroupName", valid_594820
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594821: Call_PostDeleteClusterParameterGroup_594808;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_594821.validator(path, query, header, formData, body)
  let scheme = call_594821.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594821.url(scheme.get, call_594821.host, call_594821.base,
                         call_594821.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594821, url, valid)

proc call*(call_594822: Call_PostDeleteClusterParameterGroup_594808;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594823 = newJObject()
  var formData_594824 = newJObject()
  add(formData_594824, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_594823, "Action", newJString(Action))
  add(query_594823, "Version", newJString(Version))
  result = call_594822.call(nil, query_594823, nil, formData_594824, nil)

var postDeleteClusterParameterGroup* = Call_PostDeleteClusterParameterGroup_594808(
    name: "postDeleteClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_PostDeleteClusterParameterGroup_594809, base: "/",
    url: url_PostDeleteClusterParameterGroup_594810,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterParameterGroup_594792 = ref object of OpenApiRestCall_593421
proc url_GetDeleteClusterParameterGroup_594794(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterParameterGroup_594793(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_594795 = query.getOrDefault("ParameterGroupName")
  valid_594795 = validateParameter(valid_594795, JString, required = true,
                                 default = nil)
  if valid_594795 != nil:
    section.add "ParameterGroupName", valid_594795
  var valid_594796 = query.getOrDefault("Action")
  valid_594796 = validateParameter(valid_594796, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_594796 != nil:
    section.add "Action", valid_594796
  var valid_594797 = query.getOrDefault("Version")
  valid_594797 = validateParameter(valid_594797, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594797 != nil:
    section.add "Version", valid_594797
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594798 = header.getOrDefault("X-Amz-Date")
  valid_594798 = validateParameter(valid_594798, JString, required = false,
                                 default = nil)
  if valid_594798 != nil:
    section.add "X-Amz-Date", valid_594798
  var valid_594799 = header.getOrDefault("X-Amz-Security-Token")
  valid_594799 = validateParameter(valid_594799, JString, required = false,
                                 default = nil)
  if valid_594799 != nil:
    section.add "X-Amz-Security-Token", valid_594799
  var valid_594800 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594800 = validateParameter(valid_594800, JString, required = false,
                                 default = nil)
  if valid_594800 != nil:
    section.add "X-Amz-Content-Sha256", valid_594800
  var valid_594801 = header.getOrDefault("X-Amz-Algorithm")
  valid_594801 = validateParameter(valid_594801, JString, required = false,
                                 default = nil)
  if valid_594801 != nil:
    section.add "X-Amz-Algorithm", valid_594801
  var valid_594802 = header.getOrDefault("X-Amz-Signature")
  valid_594802 = validateParameter(valid_594802, JString, required = false,
                                 default = nil)
  if valid_594802 != nil:
    section.add "X-Amz-Signature", valid_594802
  var valid_594803 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594803 = validateParameter(valid_594803, JString, required = false,
                                 default = nil)
  if valid_594803 != nil:
    section.add "X-Amz-SignedHeaders", valid_594803
  var valid_594804 = header.getOrDefault("X-Amz-Credential")
  valid_594804 = validateParameter(valid_594804, JString, required = false,
                                 default = nil)
  if valid_594804 != nil:
    section.add "X-Amz-Credential", valid_594804
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594805: Call_GetDeleteClusterParameterGroup_594792; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_594805.validator(path, query, header, formData, body)
  let scheme = call_594805.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594805.url(scheme.get, call_594805.host, call_594805.base,
                         call_594805.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594805, url, valid)

proc call*(call_594806: Call_GetDeleteClusterParameterGroup_594792;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594807 = newJObject()
  add(query_594807, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_594807, "Action", newJString(Action))
  add(query_594807, "Version", newJString(Version))
  result = call_594806.call(nil, query_594807, nil, nil, nil)

var getDeleteClusterParameterGroup* = Call_GetDeleteClusterParameterGroup_594792(
    name: "getDeleteClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_GetDeleteClusterParameterGroup_594793, base: "/",
    url: url_GetDeleteClusterParameterGroup_594794,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSecurityGroup_594841 = ref object of OpenApiRestCall_593421
proc url_PostDeleteClusterSecurityGroup_594843(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterSecurityGroup_594842(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594844 = query.getOrDefault("Action")
  valid_594844 = validateParameter(valid_594844, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_594844 != nil:
    section.add "Action", valid_594844
  var valid_594845 = query.getOrDefault("Version")
  valid_594845 = validateParameter(valid_594845, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594845 != nil:
    section.add "Version", valid_594845
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594846 = header.getOrDefault("X-Amz-Date")
  valid_594846 = validateParameter(valid_594846, JString, required = false,
                                 default = nil)
  if valid_594846 != nil:
    section.add "X-Amz-Date", valid_594846
  var valid_594847 = header.getOrDefault("X-Amz-Security-Token")
  valid_594847 = validateParameter(valid_594847, JString, required = false,
                                 default = nil)
  if valid_594847 != nil:
    section.add "X-Amz-Security-Token", valid_594847
  var valid_594848 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594848 = validateParameter(valid_594848, JString, required = false,
                                 default = nil)
  if valid_594848 != nil:
    section.add "X-Amz-Content-Sha256", valid_594848
  var valid_594849 = header.getOrDefault("X-Amz-Algorithm")
  valid_594849 = validateParameter(valid_594849, JString, required = false,
                                 default = nil)
  if valid_594849 != nil:
    section.add "X-Amz-Algorithm", valid_594849
  var valid_594850 = header.getOrDefault("X-Amz-Signature")
  valid_594850 = validateParameter(valid_594850, JString, required = false,
                                 default = nil)
  if valid_594850 != nil:
    section.add "X-Amz-Signature", valid_594850
  var valid_594851 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594851 = validateParameter(valid_594851, JString, required = false,
                                 default = nil)
  if valid_594851 != nil:
    section.add "X-Amz-SignedHeaders", valid_594851
  var valid_594852 = header.getOrDefault("X-Amz-Credential")
  valid_594852 = validateParameter(valid_594852, JString, required = false,
                                 default = nil)
  if valid_594852 != nil:
    section.add "X-Amz-Credential", valid_594852
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_594853 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_594853 = validateParameter(valid_594853, JString, required = true,
                                 default = nil)
  if valid_594853 != nil:
    section.add "ClusterSecurityGroupName", valid_594853
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594854: Call_PostDeleteClusterSecurityGroup_594841; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594854.validator(path, query, header, formData, body)
  let scheme = call_594854.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594854.url(scheme.get, call_594854.host, call_594854.base,
                         call_594854.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594854, url, valid)

proc call*(call_594855: Call_PostDeleteClusterSecurityGroup_594841;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  var query_594856 = newJObject()
  var formData_594857 = newJObject()
  add(query_594856, "Action", newJString(Action))
  add(query_594856, "Version", newJString(Version))
  add(formData_594857, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_594855.call(nil, query_594856, nil, formData_594857, nil)

var postDeleteClusterSecurityGroup* = Call_PostDeleteClusterSecurityGroup_594841(
    name: "postDeleteClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_PostDeleteClusterSecurityGroup_594842, base: "/",
    url: url_PostDeleteClusterSecurityGroup_594843,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSecurityGroup_594825 = ref object of OpenApiRestCall_593421
proc url_GetDeleteClusterSecurityGroup_594827(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterSecurityGroup_594826(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_594828 = query.getOrDefault("ClusterSecurityGroupName")
  valid_594828 = validateParameter(valid_594828, JString, required = true,
                                 default = nil)
  if valid_594828 != nil:
    section.add "ClusterSecurityGroupName", valid_594828
  var valid_594829 = query.getOrDefault("Action")
  valid_594829 = validateParameter(valid_594829, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_594829 != nil:
    section.add "Action", valid_594829
  var valid_594830 = query.getOrDefault("Version")
  valid_594830 = validateParameter(valid_594830, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594830 != nil:
    section.add "Version", valid_594830
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594831 = header.getOrDefault("X-Amz-Date")
  valid_594831 = validateParameter(valid_594831, JString, required = false,
                                 default = nil)
  if valid_594831 != nil:
    section.add "X-Amz-Date", valid_594831
  var valid_594832 = header.getOrDefault("X-Amz-Security-Token")
  valid_594832 = validateParameter(valid_594832, JString, required = false,
                                 default = nil)
  if valid_594832 != nil:
    section.add "X-Amz-Security-Token", valid_594832
  var valid_594833 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594833 = validateParameter(valid_594833, JString, required = false,
                                 default = nil)
  if valid_594833 != nil:
    section.add "X-Amz-Content-Sha256", valid_594833
  var valid_594834 = header.getOrDefault("X-Amz-Algorithm")
  valid_594834 = validateParameter(valid_594834, JString, required = false,
                                 default = nil)
  if valid_594834 != nil:
    section.add "X-Amz-Algorithm", valid_594834
  var valid_594835 = header.getOrDefault("X-Amz-Signature")
  valid_594835 = validateParameter(valid_594835, JString, required = false,
                                 default = nil)
  if valid_594835 != nil:
    section.add "X-Amz-Signature", valid_594835
  var valid_594836 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594836 = validateParameter(valid_594836, JString, required = false,
                                 default = nil)
  if valid_594836 != nil:
    section.add "X-Amz-SignedHeaders", valid_594836
  var valid_594837 = header.getOrDefault("X-Amz-Credential")
  valid_594837 = validateParameter(valid_594837, JString, required = false,
                                 default = nil)
  if valid_594837 != nil:
    section.add "X-Amz-Credential", valid_594837
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594838: Call_GetDeleteClusterSecurityGroup_594825; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594838.validator(path, query, header, formData, body)
  let scheme = call_594838.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594838.url(scheme.get, call_594838.host, call_594838.base,
                         call_594838.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594838, url, valid)

proc call*(call_594839: Call_GetDeleteClusterSecurityGroup_594825;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594840 = newJObject()
  add(query_594840, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_594840, "Action", newJString(Action))
  add(query_594840, "Version", newJString(Version))
  result = call_594839.call(nil, query_594840, nil, nil, nil)

var getDeleteClusterSecurityGroup* = Call_GetDeleteClusterSecurityGroup_594825(
    name: "getDeleteClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_GetDeleteClusterSecurityGroup_594826, base: "/",
    url: url_GetDeleteClusterSecurityGroup_594827,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSnapshot_594875 = ref object of OpenApiRestCall_593421
proc url_PostDeleteClusterSnapshot_594877(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterSnapshot_594876(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594878 = query.getOrDefault("Action")
  valid_594878 = validateParameter(valid_594878, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_594878 != nil:
    section.add "Action", valid_594878
  var valid_594879 = query.getOrDefault("Version")
  valid_594879 = validateParameter(valid_594879, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594879 != nil:
    section.add "Version", valid_594879
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594880 = header.getOrDefault("X-Amz-Date")
  valid_594880 = validateParameter(valid_594880, JString, required = false,
                                 default = nil)
  if valid_594880 != nil:
    section.add "X-Amz-Date", valid_594880
  var valid_594881 = header.getOrDefault("X-Amz-Security-Token")
  valid_594881 = validateParameter(valid_594881, JString, required = false,
                                 default = nil)
  if valid_594881 != nil:
    section.add "X-Amz-Security-Token", valid_594881
  var valid_594882 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594882 = validateParameter(valid_594882, JString, required = false,
                                 default = nil)
  if valid_594882 != nil:
    section.add "X-Amz-Content-Sha256", valid_594882
  var valid_594883 = header.getOrDefault("X-Amz-Algorithm")
  valid_594883 = validateParameter(valid_594883, JString, required = false,
                                 default = nil)
  if valid_594883 != nil:
    section.add "X-Amz-Algorithm", valid_594883
  var valid_594884 = header.getOrDefault("X-Amz-Signature")
  valid_594884 = validateParameter(valid_594884, JString, required = false,
                                 default = nil)
  if valid_594884 != nil:
    section.add "X-Amz-Signature", valid_594884
  var valid_594885 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594885 = validateParameter(valid_594885, JString, required = false,
                                 default = nil)
  if valid_594885 != nil:
    section.add "X-Amz-SignedHeaders", valid_594885
  var valid_594886 = header.getOrDefault("X-Amz-Credential")
  valid_594886 = validateParameter(valid_594886, JString, required = false,
                                 default = nil)
  if valid_594886 != nil:
    section.add "X-Amz-Credential", valid_594886
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  section = newJObject()
  var valid_594887 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_594887 = validateParameter(valid_594887, JString, required = false,
                                 default = nil)
  if valid_594887 != nil:
    section.add "SnapshotClusterIdentifier", valid_594887
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_594888 = formData.getOrDefault("SnapshotIdentifier")
  valid_594888 = validateParameter(valid_594888, JString, required = true,
                                 default = nil)
  if valid_594888 != nil:
    section.add "SnapshotIdentifier", valid_594888
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594889: Call_PostDeleteClusterSnapshot_594875; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_594889.validator(path, query, header, formData, body)
  let scheme = call_594889.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594889.url(scheme.get, call_594889.host, call_594889.base,
                         call_594889.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594889, url, valid)

proc call*(call_594890: Call_PostDeleteClusterSnapshot_594875;
          SnapshotIdentifier: string; SnapshotClusterIdentifier: string = "";
          Action: string = "DeleteClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: string (required)
  var query_594891 = newJObject()
  var formData_594892 = newJObject()
  add(formData_594892, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_594891, "Action", newJString(Action))
  add(formData_594892, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_594891, "Version", newJString(Version))
  result = call_594890.call(nil, query_594891, nil, formData_594892, nil)

var postDeleteClusterSnapshot* = Call_PostDeleteClusterSnapshot_594875(
    name: "postDeleteClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_PostDeleteClusterSnapshot_594876, base: "/",
    url: url_PostDeleteClusterSnapshot_594877,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSnapshot_594858 = ref object of OpenApiRestCall_593421
proc url_GetDeleteClusterSnapshot_594860(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterSnapshot_594859(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594861 = query.getOrDefault("Action")
  valid_594861 = validateParameter(valid_594861, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_594861 != nil:
    section.add "Action", valid_594861
  var valid_594862 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_594862 = validateParameter(valid_594862, JString, required = false,
                                 default = nil)
  if valid_594862 != nil:
    section.add "SnapshotClusterIdentifier", valid_594862
  var valid_594863 = query.getOrDefault("SnapshotIdentifier")
  valid_594863 = validateParameter(valid_594863, JString, required = true,
                                 default = nil)
  if valid_594863 != nil:
    section.add "SnapshotIdentifier", valid_594863
  var valid_594864 = query.getOrDefault("Version")
  valid_594864 = validateParameter(valid_594864, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594864 != nil:
    section.add "Version", valid_594864
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594865 = header.getOrDefault("X-Amz-Date")
  valid_594865 = validateParameter(valid_594865, JString, required = false,
                                 default = nil)
  if valid_594865 != nil:
    section.add "X-Amz-Date", valid_594865
  var valid_594866 = header.getOrDefault("X-Amz-Security-Token")
  valid_594866 = validateParameter(valid_594866, JString, required = false,
                                 default = nil)
  if valid_594866 != nil:
    section.add "X-Amz-Security-Token", valid_594866
  var valid_594867 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594867 = validateParameter(valid_594867, JString, required = false,
                                 default = nil)
  if valid_594867 != nil:
    section.add "X-Amz-Content-Sha256", valid_594867
  var valid_594868 = header.getOrDefault("X-Amz-Algorithm")
  valid_594868 = validateParameter(valid_594868, JString, required = false,
                                 default = nil)
  if valid_594868 != nil:
    section.add "X-Amz-Algorithm", valid_594868
  var valid_594869 = header.getOrDefault("X-Amz-Signature")
  valid_594869 = validateParameter(valid_594869, JString, required = false,
                                 default = nil)
  if valid_594869 != nil:
    section.add "X-Amz-Signature", valid_594869
  var valid_594870 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594870 = validateParameter(valid_594870, JString, required = false,
                                 default = nil)
  if valid_594870 != nil:
    section.add "X-Amz-SignedHeaders", valid_594870
  var valid_594871 = header.getOrDefault("X-Amz-Credential")
  valid_594871 = validateParameter(valid_594871, JString, required = false,
                                 default = nil)
  if valid_594871 != nil:
    section.add "X-Amz-Credential", valid_594871
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594872: Call_GetDeleteClusterSnapshot_594858; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_594872.validator(path, query, header, formData, body)
  let scheme = call_594872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594872.url(scheme.get, call_594872.host, call_594872.base,
                         call_594872.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594872, url, valid)

proc call*(call_594873: Call_GetDeleteClusterSnapshot_594858;
          SnapshotIdentifier: string; Action: string = "DeleteClusterSnapshot";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: string (required)
  var query_594874 = newJObject()
  add(query_594874, "Action", newJString(Action))
  add(query_594874, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_594874, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_594874, "Version", newJString(Version))
  result = call_594873.call(nil, query_594874, nil, nil, nil)

var getDeleteClusterSnapshot* = Call_GetDeleteClusterSnapshot_594858(
    name: "getDeleteClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_GetDeleteClusterSnapshot_594859, base: "/",
    url: url_GetDeleteClusterSnapshot_594860, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSubnetGroup_594909 = ref object of OpenApiRestCall_593421
proc url_PostDeleteClusterSubnetGroup_594911(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterSubnetGroup_594910(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594912 = query.getOrDefault("Action")
  valid_594912 = validateParameter(valid_594912, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_594912 != nil:
    section.add "Action", valid_594912
  var valid_594913 = query.getOrDefault("Version")
  valid_594913 = validateParameter(valid_594913, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594913 != nil:
    section.add "Version", valid_594913
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594914 = header.getOrDefault("X-Amz-Date")
  valid_594914 = validateParameter(valid_594914, JString, required = false,
                                 default = nil)
  if valid_594914 != nil:
    section.add "X-Amz-Date", valid_594914
  var valid_594915 = header.getOrDefault("X-Amz-Security-Token")
  valid_594915 = validateParameter(valid_594915, JString, required = false,
                                 default = nil)
  if valid_594915 != nil:
    section.add "X-Amz-Security-Token", valid_594915
  var valid_594916 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594916 = validateParameter(valid_594916, JString, required = false,
                                 default = nil)
  if valid_594916 != nil:
    section.add "X-Amz-Content-Sha256", valid_594916
  var valid_594917 = header.getOrDefault("X-Amz-Algorithm")
  valid_594917 = validateParameter(valid_594917, JString, required = false,
                                 default = nil)
  if valid_594917 != nil:
    section.add "X-Amz-Algorithm", valid_594917
  var valid_594918 = header.getOrDefault("X-Amz-Signature")
  valid_594918 = validateParameter(valid_594918, JString, required = false,
                                 default = nil)
  if valid_594918 != nil:
    section.add "X-Amz-Signature", valid_594918
  var valid_594919 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594919 = validateParameter(valid_594919, JString, required = false,
                                 default = nil)
  if valid_594919 != nil:
    section.add "X-Amz-SignedHeaders", valid_594919
  var valid_594920 = header.getOrDefault("X-Amz-Credential")
  valid_594920 = validateParameter(valid_594920, JString, required = false,
                                 default = nil)
  if valid_594920 != nil:
    section.add "X-Amz-Credential", valid_594920
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_594921 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_594921 = validateParameter(valid_594921, JString, required = true,
                                 default = nil)
  if valid_594921 != nil:
    section.add "ClusterSubnetGroupName", valid_594921
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594922: Call_PostDeleteClusterSubnetGroup_594909; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_594922.validator(path, query, header, formData, body)
  let scheme = call_594922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594922.url(scheme.get, call_594922.host, call_594922.base,
                         call_594922.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594922, url, valid)

proc call*(call_594923: Call_PostDeleteClusterSubnetGroup_594909;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  var query_594924 = newJObject()
  var formData_594925 = newJObject()
  add(query_594924, "Action", newJString(Action))
  add(query_594924, "Version", newJString(Version))
  add(formData_594925, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_594923.call(nil, query_594924, nil, formData_594925, nil)

var postDeleteClusterSubnetGroup* = Call_PostDeleteClusterSubnetGroup_594909(
    name: "postDeleteClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_PostDeleteClusterSubnetGroup_594910, base: "/",
    url: url_PostDeleteClusterSubnetGroup_594911,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSubnetGroup_594893 = ref object of OpenApiRestCall_593421
proc url_GetDeleteClusterSubnetGroup_594895(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterSubnetGroup_594894(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_594896 = query.getOrDefault("ClusterSubnetGroupName")
  valid_594896 = validateParameter(valid_594896, JString, required = true,
                                 default = nil)
  if valid_594896 != nil:
    section.add "ClusterSubnetGroupName", valid_594896
  var valid_594897 = query.getOrDefault("Action")
  valid_594897 = validateParameter(valid_594897, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_594897 != nil:
    section.add "Action", valid_594897
  var valid_594898 = query.getOrDefault("Version")
  valid_594898 = validateParameter(valid_594898, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594898 != nil:
    section.add "Version", valid_594898
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594899 = header.getOrDefault("X-Amz-Date")
  valid_594899 = validateParameter(valid_594899, JString, required = false,
                                 default = nil)
  if valid_594899 != nil:
    section.add "X-Amz-Date", valid_594899
  var valid_594900 = header.getOrDefault("X-Amz-Security-Token")
  valid_594900 = validateParameter(valid_594900, JString, required = false,
                                 default = nil)
  if valid_594900 != nil:
    section.add "X-Amz-Security-Token", valid_594900
  var valid_594901 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594901 = validateParameter(valid_594901, JString, required = false,
                                 default = nil)
  if valid_594901 != nil:
    section.add "X-Amz-Content-Sha256", valid_594901
  var valid_594902 = header.getOrDefault("X-Amz-Algorithm")
  valid_594902 = validateParameter(valid_594902, JString, required = false,
                                 default = nil)
  if valid_594902 != nil:
    section.add "X-Amz-Algorithm", valid_594902
  var valid_594903 = header.getOrDefault("X-Amz-Signature")
  valid_594903 = validateParameter(valid_594903, JString, required = false,
                                 default = nil)
  if valid_594903 != nil:
    section.add "X-Amz-Signature", valid_594903
  var valid_594904 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594904 = validateParameter(valid_594904, JString, required = false,
                                 default = nil)
  if valid_594904 != nil:
    section.add "X-Amz-SignedHeaders", valid_594904
  var valid_594905 = header.getOrDefault("X-Amz-Credential")
  valid_594905 = validateParameter(valid_594905, JString, required = false,
                                 default = nil)
  if valid_594905 != nil:
    section.add "X-Amz-Credential", valid_594905
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594906: Call_GetDeleteClusterSubnetGroup_594893; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_594906.validator(path, query, header, formData, body)
  let scheme = call_594906.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594906.url(scheme.get, call_594906.host, call_594906.base,
                         call_594906.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594906, url, valid)

proc call*(call_594907: Call_GetDeleteClusterSubnetGroup_594893;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594908 = newJObject()
  add(query_594908, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_594908, "Action", newJString(Action))
  add(query_594908, "Version", newJString(Version))
  result = call_594907.call(nil, query_594908, nil, nil, nil)

var getDeleteClusterSubnetGroup* = Call_GetDeleteClusterSubnetGroup_594893(
    name: "getDeleteClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_GetDeleteClusterSubnetGroup_594894, base: "/",
    url: url_GetDeleteClusterSubnetGroup_594895,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteEventSubscription_594942 = ref object of OpenApiRestCall_593421
proc url_PostDeleteEventSubscription_594944(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteEventSubscription_594943(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594945 = query.getOrDefault("Action")
  valid_594945 = validateParameter(valid_594945, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_594945 != nil:
    section.add "Action", valid_594945
  var valid_594946 = query.getOrDefault("Version")
  valid_594946 = validateParameter(valid_594946, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594946 != nil:
    section.add "Version", valid_594946
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594947 = header.getOrDefault("X-Amz-Date")
  valid_594947 = validateParameter(valid_594947, JString, required = false,
                                 default = nil)
  if valid_594947 != nil:
    section.add "X-Amz-Date", valid_594947
  var valid_594948 = header.getOrDefault("X-Amz-Security-Token")
  valid_594948 = validateParameter(valid_594948, JString, required = false,
                                 default = nil)
  if valid_594948 != nil:
    section.add "X-Amz-Security-Token", valid_594948
  var valid_594949 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594949 = validateParameter(valid_594949, JString, required = false,
                                 default = nil)
  if valid_594949 != nil:
    section.add "X-Amz-Content-Sha256", valid_594949
  var valid_594950 = header.getOrDefault("X-Amz-Algorithm")
  valid_594950 = validateParameter(valid_594950, JString, required = false,
                                 default = nil)
  if valid_594950 != nil:
    section.add "X-Amz-Algorithm", valid_594950
  var valid_594951 = header.getOrDefault("X-Amz-Signature")
  valid_594951 = validateParameter(valid_594951, JString, required = false,
                                 default = nil)
  if valid_594951 != nil:
    section.add "X-Amz-Signature", valid_594951
  var valid_594952 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594952 = validateParameter(valid_594952, JString, required = false,
                                 default = nil)
  if valid_594952 != nil:
    section.add "X-Amz-SignedHeaders", valid_594952
  var valid_594953 = header.getOrDefault("X-Amz-Credential")
  valid_594953 = validateParameter(valid_594953, JString, required = false,
                                 default = nil)
  if valid_594953 != nil:
    section.add "X-Amz-Credential", valid_594953
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_594954 = formData.getOrDefault("SubscriptionName")
  valid_594954 = validateParameter(valid_594954, JString, required = true,
                                 default = nil)
  if valid_594954 != nil:
    section.add "SubscriptionName", valid_594954
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594955: Call_PostDeleteEventSubscription_594942; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_594955.validator(path, query, header, formData, body)
  let scheme = call_594955.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594955.url(scheme.get, call_594955.host, call_594955.base,
                         call_594955.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594955, url, valid)

proc call*(call_594956: Call_PostDeleteEventSubscription_594942;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594957 = newJObject()
  var formData_594958 = newJObject()
  add(formData_594958, "SubscriptionName", newJString(SubscriptionName))
  add(query_594957, "Action", newJString(Action))
  add(query_594957, "Version", newJString(Version))
  result = call_594956.call(nil, query_594957, nil, formData_594958, nil)

var postDeleteEventSubscription* = Call_PostDeleteEventSubscription_594942(
    name: "postDeleteEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_PostDeleteEventSubscription_594943, base: "/",
    url: url_PostDeleteEventSubscription_594944,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteEventSubscription_594926 = ref object of OpenApiRestCall_593421
proc url_GetDeleteEventSubscription_594928(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteEventSubscription_594927(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594929 = query.getOrDefault("Action")
  valid_594929 = validateParameter(valid_594929, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_594929 != nil:
    section.add "Action", valid_594929
  var valid_594930 = query.getOrDefault("SubscriptionName")
  valid_594930 = validateParameter(valid_594930, JString, required = true,
                                 default = nil)
  if valid_594930 != nil:
    section.add "SubscriptionName", valid_594930
  var valid_594931 = query.getOrDefault("Version")
  valid_594931 = validateParameter(valid_594931, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594931 != nil:
    section.add "Version", valid_594931
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594932 = header.getOrDefault("X-Amz-Date")
  valid_594932 = validateParameter(valid_594932, JString, required = false,
                                 default = nil)
  if valid_594932 != nil:
    section.add "X-Amz-Date", valid_594932
  var valid_594933 = header.getOrDefault("X-Amz-Security-Token")
  valid_594933 = validateParameter(valid_594933, JString, required = false,
                                 default = nil)
  if valid_594933 != nil:
    section.add "X-Amz-Security-Token", valid_594933
  var valid_594934 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594934 = validateParameter(valid_594934, JString, required = false,
                                 default = nil)
  if valid_594934 != nil:
    section.add "X-Amz-Content-Sha256", valid_594934
  var valid_594935 = header.getOrDefault("X-Amz-Algorithm")
  valid_594935 = validateParameter(valid_594935, JString, required = false,
                                 default = nil)
  if valid_594935 != nil:
    section.add "X-Amz-Algorithm", valid_594935
  var valid_594936 = header.getOrDefault("X-Amz-Signature")
  valid_594936 = validateParameter(valid_594936, JString, required = false,
                                 default = nil)
  if valid_594936 != nil:
    section.add "X-Amz-Signature", valid_594936
  var valid_594937 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594937 = validateParameter(valid_594937, JString, required = false,
                                 default = nil)
  if valid_594937 != nil:
    section.add "X-Amz-SignedHeaders", valid_594937
  var valid_594938 = header.getOrDefault("X-Amz-Credential")
  valid_594938 = validateParameter(valid_594938, JString, required = false,
                                 default = nil)
  if valid_594938 != nil:
    section.add "X-Amz-Credential", valid_594938
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594939: Call_GetDeleteEventSubscription_594926; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_594939.validator(path, query, header, formData, body)
  let scheme = call_594939.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594939.url(scheme.get, call_594939.host, call_594939.base,
                         call_594939.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594939, url, valid)

proc call*(call_594940: Call_GetDeleteEventSubscription_594926;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   Action: string (required)
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Version: string (required)
  var query_594941 = newJObject()
  add(query_594941, "Action", newJString(Action))
  add(query_594941, "SubscriptionName", newJString(SubscriptionName))
  add(query_594941, "Version", newJString(Version))
  result = call_594940.call(nil, query_594941, nil, nil, nil)

var getDeleteEventSubscription* = Call_GetDeleteEventSubscription_594926(
    name: "getDeleteEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_GetDeleteEventSubscription_594927, base: "/",
    url: url_GetDeleteEventSubscription_594928,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmClientCertificate_594975 = ref object of OpenApiRestCall_593421
proc url_PostDeleteHsmClientCertificate_594977(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteHsmClientCertificate_594976(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594978 = query.getOrDefault("Action")
  valid_594978 = validateParameter(valid_594978, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_594978 != nil:
    section.add "Action", valid_594978
  var valid_594979 = query.getOrDefault("Version")
  valid_594979 = validateParameter(valid_594979, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594979 != nil:
    section.add "Version", valid_594979
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594980 = header.getOrDefault("X-Amz-Date")
  valid_594980 = validateParameter(valid_594980, JString, required = false,
                                 default = nil)
  if valid_594980 != nil:
    section.add "X-Amz-Date", valid_594980
  var valid_594981 = header.getOrDefault("X-Amz-Security-Token")
  valid_594981 = validateParameter(valid_594981, JString, required = false,
                                 default = nil)
  if valid_594981 != nil:
    section.add "X-Amz-Security-Token", valid_594981
  var valid_594982 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594982 = validateParameter(valid_594982, JString, required = false,
                                 default = nil)
  if valid_594982 != nil:
    section.add "X-Amz-Content-Sha256", valid_594982
  var valid_594983 = header.getOrDefault("X-Amz-Algorithm")
  valid_594983 = validateParameter(valid_594983, JString, required = false,
                                 default = nil)
  if valid_594983 != nil:
    section.add "X-Amz-Algorithm", valid_594983
  var valid_594984 = header.getOrDefault("X-Amz-Signature")
  valid_594984 = validateParameter(valid_594984, JString, required = false,
                                 default = nil)
  if valid_594984 != nil:
    section.add "X-Amz-Signature", valid_594984
  var valid_594985 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594985 = validateParameter(valid_594985, JString, required = false,
                                 default = nil)
  if valid_594985 != nil:
    section.add "X-Amz-SignedHeaders", valid_594985
  var valid_594986 = header.getOrDefault("X-Amz-Credential")
  valid_594986 = validateParameter(valid_594986, JString, required = false,
                                 default = nil)
  if valid_594986 != nil:
    section.add "X-Amz-Credential", valid_594986
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_594987 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_594987 = validateParameter(valid_594987, JString, required = true,
                                 default = nil)
  if valid_594987 != nil:
    section.add "HsmClientCertificateIdentifier", valid_594987
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594988: Call_PostDeleteHsmClientCertificate_594975; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_594988.validator(path, query, header, formData, body)
  let scheme = call_594988.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594988.url(scheme.get, call_594988.host, call_594988.base,
                         call_594988.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594988, url, valid)

proc call*(call_594989: Call_PostDeleteHsmClientCertificate_594975;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Version: string (required)
  var query_594990 = newJObject()
  var formData_594991 = newJObject()
  add(query_594990, "Action", newJString(Action))
  add(formData_594991, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_594990, "Version", newJString(Version))
  result = call_594989.call(nil, query_594990, nil, formData_594991, nil)

var postDeleteHsmClientCertificate* = Call_PostDeleteHsmClientCertificate_594975(
    name: "postDeleteHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_PostDeleteHsmClientCertificate_594976, base: "/",
    url: url_PostDeleteHsmClientCertificate_594977,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmClientCertificate_594959 = ref object of OpenApiRestCall_593421
proc url_GetDeleteHsmClientCertificate_594961(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteHsmClientCertificate_594960(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_594962 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_594962 = validateParameter(valid_594962, JString, required = true,
                                 default = nil)
  if valid_594962 != nil:
    section.add "HsmClientCertificateIdentifier", valid_594962
  var valid_594963 = query.getOrDefault("Action")
  valid_594963 = validateParameter(valid_594963, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_594963 != nil:
    section.add "Action", valid_594963
  var valid_594964 = query.getOrDefault("Version")
  valid_594964 = validateParameter(valid_594964, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594964 != nil:
    section.add "Version", valid_594964
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594965 = header.getOrDefault("X-Amz-Date")
  valid_594965 = validateParameter(valid_594965, JString, required = false,
                                 default = nil)
  if valid_594965 != nil:
    section.add "X-Amz-Date", valid_594965
  var valid_594966 = header.getOrDefault("X-Amz-Security-Token")
  valid_594966 = validateParameter(valid_594966, JString, required = false,
                                 default = nil)
  if valid_594966 != nil:
    section.add "X-Amz-Security-Token", valid_594966
  var valid_594967 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594967 = validateParameter(valid_594967, JString, required = false,
                                 default = nil)
  if valid_594967 != nil:
    section.add "X-Amz-Content-Sha256", valid_594967
  var valid_594968 = header.getOrDefault("X-Amz-Algorithm")
  valid_594968 = validateParameter(valid_594968, JString, required = false,
                                 default = nil)
  if valid_594968 != nil:
    section.add "X-Amz-Algorithm", valid_594968
  var valid_594969 = header.getOrDefault("X-Amz-Signature")
  valid_594969 = validateParameter(valid_594969, JString, required = false,
                                 default = nil)
  if valid_594969 != nil:
    section.add "X-Amz-Signature", valid_594969
  var valid_594970 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594970 = validateParameter(valid_594970, JString, required = false,
                                 default = nil)
  if valid_594970 != nil:
    section.add "X-Amz-SignedHeaders", valid_594970
  var valid_594971 = header.getOrDefault("X-Amz-Credential")
  valid_594971 = validateParameter(valid_594971, JString, required = false,
                                 default = nil)
  if valid_594971 != nil:
    section.add "X-Amz-Credential", valid_594971
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594972: Call_GetDeleteHsmClientCertificate_594959; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_594972.validator(path, query, header, formData, body)
  let scheme = call_594972.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594972.url(scheme.get, call_594972.host, call_594972.base,
                         call_594972.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594972, url, valid)

proc call*(call_594973: Call_GetDeleteHsmClientCertificate_594959;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594974 = newJObject()
  add(query_594974, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_594974, "Action", newJString(Action))
  add(query_594974, "Version", newJString(Version))
  result = call_594973.call(nil, query_594974, nil, nil, nil)

var getDeleteHsmClientCertificate* = Call_GetDeleteHsmClientCertificate_594959(
    name: "getDeleteHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_GetDeleteHsmClientCertificate_594960, base: "/",
    url: url_GetDeleteHsmClientCertificate_594961,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmConfiguration_595008 = ref object of OpenApiRestCall_593421
proc url_PostDeleteHsmConfiguration_595010(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteHsmConfiguration_595009(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595011 = query.getOrDefault("Action")
  valid_595011 = validateParameter(valid_595011, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_595011 != nil:
    section.add "Action", valid_595011
  var valid_595012 = query.getOrDefault("Version")
  valid_595012 = validateParameter(valid_595012, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595012 != nil:
    section.add "Version", valid_595012
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595013 = header.getOrDefault("X-Amz-Date")
  valid_595013 = validateParameter(valid_595013, JString, required = false,
                                 default = nil)
  if valid_595013 != nil:
    section.add "X-Amz-Date", valid_595013
  var valid_595014 = header.getOrDefault("X-Amz-Security-Token")
  valid_595014 = validateParameter(valid_595014, JString, required = false,
                                 default = nil)
  if valid_595014 != nil:
    section.add "X-Amz-Security-Token", valid_595014
  var valid_595015 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595015 = validateParameter(valid_595015, JString, required = false,
                                 default = nil)
  if valid_595015 != nil:
    section.add "X-Amz-Content-Sha256", valid_595015
  var valid_595016 = header.getOrDefault("X-Amz-Algorithm")
  valid_595016 = validateParameter(valid_595016, JString, required = false,
                                 default = nil)
  if valid_595016 != nil:
    section.add "X-Amz-Algorithm", valid_595016
  var valid_595017 = header.getOrDefault("X-Amz-Signature")
  valid_595017 = validateParameter(valid_595017, JString, required = false,
                                 default = nil)
  if valid_595017 != nil:
    section.add "X-Amz-Signature", valid_595017
  var valid_595018 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595018 = validateParameter(valid_595018, JString, required = false,
                                 default = nil)
  if valid_595018 != nil:
    section.add "X-Amz-SignedHeaders", valid_595018
  var valid_595019 = header.getOrDefault("X-Amz-Credential")
  valid_595019 = validateParameter(valid_595019, JString, required = false,
                                 default = nil)
  if valid_595019 != nil:
    section.add "X-Amz-Credential", valid_595019
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_595020 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_595020 = validateParameter(valid_595020, JString, required = true,
                                 default = nil)
  if valid_595020 != nil:
    section.add "HsmConfigurationIdentifier", valid_595020
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595021: Call_PostDeleteHsmConfiguration_595008; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_595021.validator(path, query, header, formData, body)
  let scheme = call_595021.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595021.url(scheme.get, call_595021.host, call_595021.base,
                         call_595021.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595021, url, valid)

proc call*(call_595022: Call_PostDeleteHsmConfiguration_595008;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595023 = newJObject()
  var formData_595024 = newJObject()
  add(formData_595024, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_595023, "Action", newJString(Action))
  add(query_595023, "Version", newJString(Version))
  result = call_595022.call(nil, query_595023, nil, formData_595024, nil)

var postDeleteHsmConfiguration* = Call_PostDeleteHsmConfiguration_595008(
    name: "postDeleteHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_PostDeleteHsmConfiguration_595009, base: "/",
    url: url_PostDeleteHsmConfiguration_595010,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmConfiguration_594992 = ref object of OpenApiRestCall_593421
proc url_GetDeleteHsmConfiguration_594994(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteHsmConfiguration_594993(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_594995 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_594995 = validateParameter(valid_594995, JString, required = true,
                                 default = nil)
  if valid_594995 != nil:
    section.add "HsmConfigurationIdentifier", valid_594995
  var valid_594996 = query.getOrDefault("Action")
  valid_594996 = validateParameter(valid_594996, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_594996 != nil:
    section.add "Action", valid_594996
  var valid_594997 = query.getOrDefault("Version")
  valid_594997 = validateParameter(valid_594997, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594997 != nil:
    section.add "Version", valid_594997
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_594998 = header.getOrDefault("X-Amz-Date")
  valid_594998 = validateParameter(valid_594998, JString, required = false,
                                 default = nil)
  if valid_594998 != nil:
    section.add "X-Amz-Date", valid_594998
  var valid_594999 = header.getOrDefault("X-Amz-Security-Token")
  valid_594999 = validateParameter(valid_594999, JString, required = false,
                                 default = nil)
  if valid_594999 != nil:
    section.add "X-Amz-Security-Token", valid_594999
  var valid_595000 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595000 = validateParameter(valid_595000, JString, required = false,
                                 default = nil)
  if valid_595000 != nil:
    section.add "X-Amz-Content-Sha256", valid_595000
  var valid_595001 = header.getOrDefault("X-Amz-Algorithm")
  valid_595001 = validateParameter(valid_595001, JString, required = false,
                                 default = nil)
  if valid_595001 != nil:
    section.add "X-Amz-Algorithm", valid_595001
  var valid_595002 = header.getOrDefault("X-Amz-Signature")
  valid_595002 = validateParameter(valid_595002, JString, required = false,
                                 default = nil)
  if valid_595002 != nil:
    section.add "X-Amz-Signature", valid_595002
  var valid_595003 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595003 = validateParameter(valid_595003, JString, required = false,
                                 default = nil)
  if valid_595003 != nil:
    section.add "X-Amz-SignedHeaders", valid_595003
  var valid_595004 = header.getOrDefault("X-Amz-Credential")
  valid_595004 = validateParameter(valid_595004, JString, required = false,
                                 default = nil)
  if valid_595004 != nil:
    section.add "X-Amz-Credential", valid_595004
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595005: Call_GetDeleteHsmConfiguration_594992; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_595005.validator(path, query, header, formData, body)
  let scheme = call_595005.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595005.url(scheme.get, call_595005.host, call_595005.base,
                         call_595005.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595005, url, valid)

proc call*(call_595006: Call_GetDeleteHsmConfiguration_594992;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595007 = newJObject()
  add(query_595007, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_595007, "Action", newJString(Action))
  add(query_595007, "Version", newJString(Version))
  result = call_595006.call(nil, query_595007, nil, nil, nil)

var getDeleteHsmConfiguration* = Call_GetDeleteHsmConfiguration_594992(
    name: "getDeleteHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_GetDeleteHsmConfiguration_594993, base: "/",
    url: url_GetDeleteHsmConfiguration_594994,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotCopyGrant_595041 = ref object of OpenApiRestCall_593421
proc url_PostDeleteSnapshotCopyGrant_595043(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteSnapshotCopyGrant_595042(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595044 = query.getOrDefault("Action")
  valid_595044 = validateParameter(valid_595044, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_595044 != nil:
    section.add "Action", valid_595044
  var valid_595045 = query.getOrDefault("Version")
  valid_595045 = validateParameter(valid_595045, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595045 != nil:
    section.add "Version", valid_595045
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595046 = header.getOrDefault("X-Amz-Date")
  valid_595046 = validateParameter(valid_595046, JString, required = false,
                                 default = nil)
  if valid_595046 != nil:
    section.add "X-Amz-Date", valid_595046
  var valid_595047 = header.getOrDefault("X-Amz-Security-Token")
  valid_595047 = validateParameter(valid_595047, JString, required = false,
                                 default = nil)
  if valid_595047 != nil:
    section.add "X-Amz-Security-Token", valid_595047
  var valid_595048 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595048 = validateParameter(valid_595048, JString, required = false,
                                 default = nil)
  if valid_595048 != nil:
    section.add "X-Amz-Content-Sha256", valid_595048
  var valid_595049 = header.getOrDefault("X-Amz-Algorithm")
  valid_595049 = validateParameter(valid_595049, JString, required = false,
                                 default = nil)
  if valid_595049 != nil:
    section.add "X-Amz-Algorithm", valid_595049
  var valid_595050 = header.getOrDefault("X-Amz-Signature")
  valid_595050 = validateParameter(valid_595050, JString, required = false,
                                 default = nil)
  if valid_595050 != nil:
    section.add "X-Amz-Signature", valid_595050
  var valid_595051 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595051 = validateParameter(valid_595051, JString, required = false,
                                 default = nil)
  if valid_595051 != nil:
    section.add "X-Amz-SignedHeaders", valid_595051
  var valid_595052 = header.getOrDefault("X-Amz-Credential")
  valid_595052 = validateParameter(valid_595052, JString, required = false,
                                 default = nil)
  if valid_595052 != nil:
    section.add "X-Amz-Credential", valid_595052
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_595053 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_595053 = validateParameter(valid_595053, JString, required = true,
                                 default = nil)
  if valid_595053 != nil:
    section.add "SnapshotCopyGrantName", valid_595053
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595054: Call_PostDeleteSnapshotCopyGrant_595041; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_595054.validator(path, query, header, formData, body)
  let scheme = call_595054.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595054.url(scheme.get, call_595054.host, call_595054.base,
                         call_595054.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595054, url, valid)

proc call*(call_595055: Call_PostDeleteSnapshotCopyGrant_595041;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_595056 = newJObject()
  var formData_595057 = newJObject()
  add(query_595056, "Action", newJString(Action))
  add(formData_595057, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_595056, "Version", newJString(Version))
  result = call_595055.call(nil, query_595056, nil, formData_595057, nil)

var postDeleteSnapshotCopyGrant* = Call_PostDeleteSnapshotCopyGrant_595041(
    name: "postDeleteSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_PostDeleteSnapshotCopyGrant_595042, base: "/",
    url: url_PostDeleteSnapshotCopyGrant_595043,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotCopyGrant_595025 = ref object of OpenApiRestCall_593421
proc url_GetDeleteSnapshotCopyGrant_595027(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteSnapshotCopyGrant_595026(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595028 = query.getOrDefault("Action")
  valid_595028 = validateParameter(valid_595028, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_595028 != nil:
    section.add "Action", valid_595028
  var valid_595029 = query.getOrDefault("SnapshotCopyGrantName")
  valid_595029 = validateParameter(valid_595029, JString, required = true,
                                 default = nil)
  if valid_595029 != nil:
    section.add "SnapshotCopyGrantName", valid_595029
  var valid_595030 = query.getOrDefault("Version")
  valid_595030 = validateParameter(valid_595030, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595030 != nil:
    section.add "Version", valid_595030
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595031 = header.getOrDefault("X-Amz-Date")
  valid_595031 = validateParameter(valid_595031, JString, required = false,
                                 default = nil)
  if valid_595031 != nil:
    section.add "X-Amz-Date", valid_595031
  var valid_595032 = header.getOrDefault("X-Amz-Security-Token")
  valid_595032 = validateParameter(valid_595032, JString, required = false,
                                 default = nil)
  if valid_595032 != nil:
    section.add "X-Amz-Security-Token", valid_595032
  var valid_595033 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595033 = validateParameter(valid_595033, JString, required = false,
                                 default = nil)
  if valid_595033 != nil:
    section.add "X-Amz-Content-Sha256", valid_595033
  var valid_595034 = header.getOrDefault("X-Amz-Algorithm")
  valid_595034 = validateParameter(valid_595034, JString, required = false,
                                 default = nil)
  if valid_595034 != nil:
    section.add "X-Amz-Algorithm", valid_595034
  var valid_595035 = header.getOrDefault("X-Amz-Signature")
  valid_595035 = validateParameter(valid_595035, JString, required = false,
                                 default = nil)
  if valid_595035 != nil:
    section.add "X-Amz-Signature", valid_595035
  var valid_595036 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595036 = validateParameter(valid_595036, JString, required = false,
                                 default = nil)
  if valid_595036 != nil:
    section.add "X-Amz-SignedHeaders", valid_595036
  var valid_595037 = header.getOrDefault("X-Amz-Credential")
  valid_595037 = validateParameter(valid_595037, JString, required = false,
                                 default = nil)
  if valid_595037 != nil:
    section.add "X-Amz-Credential", valid_595037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595038: Call_GetDeleteSnapshotCopyGrant_595025; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_595038.validator(path, query, header, formData, body)
  let scheme = call_595038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595038.url(scheme.get, call_595038.host, call_595038.base,
                         call_595038.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595038, url, valid)

proc call*(call_595039: Call_GetDeleteSnapshotCopyGrant_595025;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_595040 = newJObject()
  add(query_595040, "Action", newJString(Action))
  add(query_595040, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_595040, "Version", newJString(Version))
  result = call_595039.call(nil, query_595040, nil, nil, nil)

var getDeleteSnapshotCopyGrant* = Call_GetDeleteSnapshotCopyGrant_595025(
    name: "getDeleteSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_GetDeleteSnapshotCopyGrant_595026, base: "/",
    url: url_GetDeleteSnapshotCopyGrant_595027,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotSchedule_595074 = ref object of OpenApiRestCall_593421
proc url_PostDeleteSnapshotSchedule_595076(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteSnapshotSchedule_595075(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595077 = query.getOrDefault("Action")
  valid_595077 = validateParameter(valid_595077, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_595077 != nil:
    section.add "Action", valid_595077
  var valid_595078 = query.getOrDefault("Version")
  valid_595078 = validateParameter(valid_595078, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595078 != nil:
    section.add "Version", valid_595078
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595079 = header.getOrDefault("X-Amz-Date")
  valid_595079 = validateParameter(valid_595079, JString, required = false,
                                 default = nil)
  if valid_595079 != nil:
    section.add "X-Amz-Date", valid_595079
  var valid_595080 = header.getOrDefault("X-Amz-Security-Token")
  valid_595080 = validateParameter(valid_595080, JString, required = false,
                                 default = nil)
  if valid_595080 != nil:
    section.add "X-Amz-Security-Token", valid_595080
  var valid_595081 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595081 = validateParameter(valid_595081, JString, required = false,
                                 default = nil)
  if valid_595081 != nil:
    section.add "X-Amz-Content-Sha256", valid_595081
  var valid_595082 = header.getOrDefault("X-Amz-Algorithm")
  valid_595082 = validateParameter(valid_595082, JString, required = false,
                                 default = nil)
  if valid_595082 != nil:
    section.add "X-Amz-Algorithm", valid_595082
  var valid_595083 = header.getOrDefault("X-Amz-Signature")
  valid_595083 = validateParameter(valid_595083, JString, required = false,
                                 default = nil)
  if valid_595083 != nil:
    section.add "X-Amz-Signature", valid_595083
  var valid_595084 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595084 = validateParameter(valid_595084, JString, required = false,
                                 default = nil)
  if valid_595084 != nil:
    section.add "X-Amz-SignedHeaders", valid_595084
  var valid_595085 = header.getOrDefault("X-Amz-Credential")
  valid_595085 = validateParameter(valid_595085, JString, required = false,
                                 default = nil)
  if valid_595085 != nil:
    section.add "X-Amz-Credential", valid_595085
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleIdentifier` field"
  var valid_595086 = formData.getOrDefault("ScheduleIdentifier")
  valid_595086 = validateParameter(valid_595086, JString, required = true,
                                 default = nil)
  if valid_595086 != nil:
    section.add "ScheduleIdentifier", valid_595086
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595087: Call_PostDeleteSnapshotSchedule_595074; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_595087.validator(path, query, header, formData, body)
  let scheme = call_595087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595087.url(scheme.get, call_595087.host, call_595087.base,
                         call_595087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595087, url, valid)

proc call*(call_595088: Call_PostDeleteSnapshotSchedule_595074;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_595089 = newJObject()
  var formData_595090 = newJObject()
  add(query_595089, "Action", newJString(Action))
  add(formData_595090, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_595089, "Version", newJString(Version))
  result = call_595088.call(nil, query_595089, nil, formData_595090, nil)

var postDeleteSnapshotSchedule* = Call_PostDeleteSnapshotSchedule_595074(
    name: "postDeleteSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_PostDeleteSnapshotSchedule_595075, base: "/",
    url: url_PostDeleteSnapshotSchedule_595076,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotSchedule_595058 = ref object of OpenApiRestCall_593421
proc url_GetDeleteSnapshotSchedule_595060(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteSnapshotSchedule_595059(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595061 = query.getOrDefault("Action")
  valid_595061 = validateParameter(valid_595061, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_595061 != nil:
    section.add "Action", valid_595061
  var valid_595062 = query.getOrDefault("ScheduleIdentifier")
  valid_595062 = validateParameter(valid_595062, JString, required = true,
                                 default = nil)
  if valid_595062 != nil:
    section.add "ScheduleIdentifier", valid_595062
  var valid_595063 = query.getOrDefault("Version")
  valid_595063 = validateParameter(valid_595063, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595063 != nil:
    section.add "Version", valid_595063
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595064 = header.getOrDefault("X-Amz-Date")
  valid_595064 = validateParameter(valid_595064, JString, required = false,
                                 default = nil)
  if valid_595064 != nil:
    section.add "X-Amz-Date", valid_595064
  var valid_595065 = header.getOrDefault("X-Amz-Security-Token")
  valid_595065 = validateParameter(valid_595065, JString, required = false,
                                 default = nil)
  if valid_595065 != nil:
    section.add "X-Amz-Security-Token", valid_595065
  var valid_595066 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595066 = validateParameter(valid_595066, JString, required = false,
                                 default = nil)
  if valid_595066 != nil:
    section.add "X-Amz-Content-Sha256", valid_595066
  var valid_595067 = header.getOrDefault("X-Amz-Algorithm")
  valid_595067 = validateParameter(valid_595067, JString, required = false,
                                 default = nil)
  if valid_595067 != nil:
    section.add "X-Amz-Algorithm", valid_595067
  var valid_595068 = header.getOrDefault("X-Amz-Signature")
  valid_595068 = validateParameter(valid_595068, JString, required = false,
                                 default = nil)
  if valid_595068 != nil:
    section.add "X-Amz-Signature", valid_595068
  var valid_595069 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595069 = validateParameter(valid_595069, JString, required = false,
                                 default = nil)
  if valid_595069 != nil:
    section.add "X-Amz-SignedHeaders", valid_595069
  var valid_595070 = header.getOrDefault("X-Amz-Credential")
  valid_595070 = validateParameter(valid_595070, JString, required = false,
                                 default = nil)
  if valid_595070 != nil:
    section.add "X-Amz-Credential", valid_595070
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595071: Call_GetDeleteSnapshotSchedule_595058; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_595071.validator(path, query, header, formData, body)
  let scheme = call_595071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595071.url(scheme.get, call_595071.host, call_595071.base,
                         call_595071.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595071, url, valid)

proc call*(call_595072: Call_GetDeleteSnapshotSchedule_595058;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_595073 = newJObject()
  add(query_595073, "Action", newJString(Action))
  add(query_595073, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_595073, "Version", newJString(Version))
  result = call_595072.call(nil, query_595073, nil, nil, nil)

var getDeleteSnapshotSchedule* = Call_GetDeleteSnapshotSchedule_595058(
    name: "getDeleteSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_GetDeleteSnapshotSchedule_595059, base: "/",
    url: url_GetDeleteSnapshotSchedule_595060,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteTags_595108 = ref object of OpenApiRestCall_593421
proc url_PostDeleteTags_595110(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteTags_595109(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595111 = query.getOrDefault("Action")
  valid_595111 = validateParameter(valid_595111, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_595111 != nil:
    section.add "Action", valid_595111
  var valid_595112 = query.getOrDefault("Version")
  valid_595112 = validateParameter(valid_595112, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595112 != nil:
    section.add "Version", valid_595112
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595113 = header.getOrDefault("X-Amz-Date")
  valid_595113 = validateParameter(valid_595113, JString, required = false,
                                 default = nil)
  if valid_595113 != nil:
    section.add "X-Amz-Date", valid_595113
  var valid_595114 = header.getOrDefault("X-Amz-Security-Token")
  valid_595114 = validateParameter(valid_595114, JString, required = false,
                                 default = nil)
  if valid_595114 != nil:
    section.add "X-Amz-Security-Token", valid_595114
  var valid_595115 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595115 = validateParameter(valid_595115, JString, required = false,
                                 default = nil)
  if valid_595115 != nil:
    section.add "X-Amz-Content-Sha256", valid_595115
  var valid_595116 = header.getOrDefault("X-Amz-Algorithm")
  valid_595116 = validateParameter(valid_595116, JString, required = false,
                                 default = nil)
  if valid_595116 != nil:
    section.add "X-Amz-Algorithm", valid_595116
  var valid_595117 = header.getOrDefault("X-Amz-Signature")
  valid_595117 = validateParameter(valid_595117, JString, required = false,
                                 default = nil)
  if valid_595117 != nil:
    section.add "X-Amz-Signature", valid_595117
  var valid_595118 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595118 = validateParameter(valid_595118, JString, required = false,
                                 default = nil)
  if valid_595118 != nil:
    section.add "X-Amz-SignedHeaders", valid_595118
  var valid_595119 = header.getOrDefault("X-Amz-Credential")
  valid_595119 = validateParameter(valid_595119, JString, required = false,
                                 default = nil)
  if valid_595119 != nil:
    section.add "X-Amz-Credential", valid_595119
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `TagKeys` field"
  var valid_595120 = formData.getOrDefault("TagKeys")
  valid_595120 = validateParameter(valid_595120, JArray, required = true, default = nil)
  if valid_595120 != nil:
    section.add "TagKeys", valid_595120
  var valid_595121 = formData.getOrDefault("ResourceName")
  valid_595121 = validateParameter(valid_595121, JString, required = true,
                                 default = nil)
  if valid_595121 != nil:
    section.add "ResourceName", valid_595121
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595122: Call_PostDeleteTags_595108; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_595122.validator(path, query, header, formData, body)
  let scheme = call_595122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595122.url(scheme.get, call_595122.host, call_595122.base,
                         call_595122.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595122, url, valid)

proc call*(call_595123: Call_PostDeleteTags_595108; TagKeys: JsonNode;
          ResourceName: string; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   Action: string (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Version: string (required)
  var query_595124 = newJObject()
  var formData_595125 = newJObject()
  add(query_595124, "Action", newJString(Action))
  if TagKeys != nil:
    formData_595125.add "TagKeys", TagKeys
  add(formData_595125, "ResourceName", newJString(ResourceName))
  add(query_595124, "Version", newJString(Version))
  result = call_595123.call(nil, query_595124, nil, formData_595125, nil)

var postDeleteTags* = Call_PostDeleteTags_595108(name: "postDeleteTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_PostDeleteTags_595109,
    base: "/", url: url_PostDeleteTags_595110, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteTags_595091 = ref object of OpenApiRestCall_593421
proc url_GetDeleteTags_595093(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteTags_595092(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `ResourceName` field"
  var valid_595094 = query.getOrDefault("ResourceName")
  valid_595094 = validateParameter(valid_595094, JString, required = true,
                                 default = nil)
  if valid_595094 != nil:
    section.add "ResourceName", valid_595094
  var valid_595095 = query.getOrDefault("Action")
  valid_595095 = validateParameter(valid_595095, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_595095 != nil:
    section.add "Action", valid_595095
  var valid_595096 = query.getOrDefault("TagKeys")
  valid_595096 = validateParameter(valid_595096, JArray, required = true, default = nil)
  if valid_595096 != nil:
    section.add "TagKeys", valid_595096
  var valid_595097 = query.getOrDefault("Version")
  valid_595097 = validateParameter(valid_595097, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595097 != nil:
    section.add "Version", valid_595097
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595098 = header.getOrDefault("X-Amz-Date")
  valid_595098 = validateParameter(valid_595098, JString, required = false,
                                 default = nil)
  if valid_595098 != nil:
    section.add "X-Amz-Date", valid_595098
  var valid_595099 = header.getOrDefault("X-Amz-Security-Token")
  valid_595099 = validateParameter(valid_595099, JString, required = false,
                                 default = nil)
  if valid_595099 != nil:
    section.add "X-Amz-Security-Token", valid_595099
  var valid_595100 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595100 = validateParameter(valid_595100, JString, required = false,
                                 default = nil)
  if valid_595100 != nil:
    section.add "X-Amz-Content-Sha256", valid_595100
  var valid_595101 = header.getOrDefault("X-Amz-Algorithm")
  valid_595101 = validateParameter(valid_595101, JString, required = false,
                                 default = nil)
  if valid_595101 != nil:
    section.add "X-Amz-Algorithm", valid_595101
  var valid_595102 = header.getOrDefault("X-Amz-Signature")
  valid_595102 = validateParameter(valid_595102, JString, required = false,
                                 default = nil)
  if valid_595102 != nil:
    section.add "X-Amz-Signature", valid_595102
  var valid_595103 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595103 = validateParameter(valid_595103, JString, required = false,
                                 default = nil)
  if valid_595103 != nil:
    section.add "X-Amz-SignedHeaders", valid_595103
  var valid_595104 = header.getOrDefault("X-Amz-Credential")
  valid_595104 = validateParameter(valid_595104, JString, required = false,
                                 default = nil)
  if valid_595104 != nil:
    section.add "X-Amz-Credential", valid_595104
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595105: Call_GetDeleteTags_595091; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_595105.validator(path, query, header, formData, body)
  let scheme = call_595105.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595105.url(scheme.get, call_595105.host, call_595105.base,
                         call_595105.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595105, url, valid)

proc call*(call_595106: Call_GetDeleteTags_595091; ResourceName: string;
          TagKeys: JsonNode; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Version: string (required)
  var query_595107 = newJObject()
  add(query_595107, "ResourceName", newJString(ResourceName))
  add(query_595107, "Action", newJString(Action))
  if TagKeys != nil:
    query_595107.add "TagKeys", TagKeys
  add(query_595107, "Version", newJString(Version))
  result = call_595106.call(nil, query_595107, nil, nil, nil)

var getDeleteTags* = Call_GetDeleteTags_595091(name: "getDeleteTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_GetDeleteTags_595092,
    base: "/", url: url_GetDeleteTags_595093, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeAccountAttributes_595142 = ref object of OpenApiRestCall_593421
proc url_PostDescribeAccountAttributes_595144(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeAccountAttributes_595143(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595145 = query.getOrDefault("Action")
  valid_595145 = validateParameter(valid_595145, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_595145 != nil:
    section.add "Action", valid_595145
  var valid_595146 = query.getOrDefault("Version")
  valid_595146 = validateParameter(valid_595146, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595146 != nil:
    section.add "Version", valid_595146
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595147 = header.getOrDefault("X-Amz-Date")
  valid_595147 = validateParameter(valid_595147, JString, required = false,
                                 default = nil)
  if valid_595147 != nil:
    section.add "X-Amz-Date", valid_595147
  var valid_595148 = header.getOrDefault("X-Amz-Security-Token")
  valid_595148 = validateParameter(valid_595148, JString, required = false,
                                 default = nil)
  if valid_595148 != nil:
    section.add "X-Amz-Security-Token", valid_595148
  var valid_595149 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595149 = validateParameter(valid_595149, JString, required = false,
                                 default = nil)
  if valid_595149 != nil:
    section.add "X-Amz-Content-Sha256", valid_595149
  var valid_595150 = header.getOrDefault("X-Amz-Algorithm")
  valid_595150 = validateParameter(valid_595150, JString, required = false,
                                 default = nil)
  if valid_595150 != nil:
    section.add "X-Amz-Algorithm", valid_595150
  var valid_595151 = header.getOrDefault("X-Amz-Signature")
  valid_595151 = validateParameter(valid_595151, JString, required = false,
                                 default = nil)
  if valid_595151 != nil:
    section.add "X-Amz-Signature", valid_595151
  var valid_595152 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595152 = validateParameter(valid_595152, JString, required = false,
                                 default = nil)
  if valid_595152 != nil:
    section.add "X-Amz-SignedHeaders", valid_595152
  var valid_595153 = header.getOrDefault("X-Amz-Credential")
  valid_595153 = validateParameter(valid_595153, JString, required = false,
                                 default = nil)
  if valid_595153 != nil:
    section.add "X-Amz-Credential", valid_595153
  result.add "header", section
  ## parameters in `formData` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  section = newJObject()
  var valid_595154 = formData.getOrDefault("AttributeNames")
  valid_595154 = validateParameter(valid_595154, JArray, required = false,
                                 default = nil)
  if valid_595154 != nil:
    section.add "AttributeNames", valid_595154
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595155: Call_PostDescribeAccountAttributes_595142; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_595155.validator(path, query, header, formData, body)
  let scheme = call_595155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595155.url(scheme.get, call_595155.host, call_595155.base,
                         call_595155.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595155, url, valid)

proc call*(call_595156: Call_PostDescribeAccountAttributes_595142;
          Action: string = "DescribeAccountAttributes";
          AttributeNames: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   Action: string (required)
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Version: string (required)
  var query_595157 = newJObject()
  var formData_595158 = newJObject()
  add(query_595157, "Action", newJString(Action))
  if AttributeNames != nil:
    formData_595158.add "AttributeNames", AttributeNames
  add(query_595157, "Version", newJString(Version))
  result = call_595156.call(nil, query_595157, nil, formData_595158, nil)

var postDescribeAccountAttributes* = Call_PostDescribeAccountAttributes_595142(
    name: "postDescribeAccountAttributes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_PostDescribeAccountAttributes_595143, base: "/",
    url: url_PostDescribeAccountAttributes_595144,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeAccountAttributes_595126 = ref object of OpenApiRestCall_593421
proc url_GetDescribeAccountAttributes_595128(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeAccountAttributes_595127(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_595129 = query.getOrDefault("AttributeNames")
  valid_595129 = validateParameter(valid_595129, JArray, required = false,
                                 default = nil)
  if valid_595129 != nil:
    section.add "AttributeNames", valid_595129
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595130 = query.getOrDefault("Action")
  valid_595130 = validateParameter(valid_595130, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_595130 != nil:
    section.add "Action", valid_595130
  var valid_595131 = query.getOrDefault("Version")
  valid_595131 = validateParameter(valid_595131, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595131 != nil:
    section.add "Version", valid_595131
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595132 = header.getOrDefault("X-Amz-Date")
  valid_595132 = validateParameter(valid_595132, JString, required = false,
                                 default = nil)
  if valid_595132 != nil:
    section.add "X-Amz-Date", valid_595132
  var valid_595133 = header.getOrDefault("X-Amz-Security-Token")
  valid_595133 = validateParameter(valid_595133, JString, required = false,
                                 default = nil)
  if valid_595133 != nil:
    section.add "X-Amz-Security-Token", valid_595133
  var valid_595134 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595134 = validateParameter(valid_595134, JString, required = false,
                                 default = nil)
  if valid_595134 != nil:
    section.add "X-Amz-Content-Sha256", valid_595134
  var valid_595135 = header.getOrDefault("X-Amz-Algorithm")
  valid_595135 = validateParameter(valid_595135, JString, required = false,
                                 default = nil)
  if valid_595135 != nil:
    section.add "X-Amz-Algorithm", valid_595135
  var valid_595136 = header.getOrDefault("X-Amz-Signature")
  valid_595136 = validateParameter(valid_595136, JString, required = false,
                                 default = nil)
  if valid_595136 != nil:
    section.add "X-Amz-Signature", valid_595136
  var valid_595137 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595137 = validateParameter(valid_595137, JString, required = false,
                                 default = nil)
  if valid_595137 != nil:
    section.add "X-Amz-SignedHeaders", valid_595137
  var valid_595138 = header.getOrDefault("X-Amz-Credential")
  valid_595138 = validateParameter(valid_595138, JString, required = false,
                                 default = nil)
  if valid_595138 != nil:
    section.add "X-Amz-Credential", valid_595138
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595139: Call_GetDescribeAccountAttributes_595126; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_595139.validator(path, query, header, formData, body)
  let scheme = call_595139.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595139.url(scheme.get, call_595139.host, call_595139.base,
                         call_595139.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595139, url, valid)

proc call*(call_595140: Call_GetDescribeAccountAttributes_595126;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595141 = newJObject()
  if AttributeNames != nil:
    query_595141.add "AttributeNames", AttributeNames
  add(query_595141, "Action", newJString(Action))
  add(query_595141, "Version", newJString(Version))
  result = call_595140.call(nil, query_595141, nil, nil, nil)

var getDescribeAccountAttributes* = Call_GetDescribeAccountAttributes_595126(
    name: "getDescribeAccountAttributes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_GetDescribeAccountAttributes_595127, base: "/",
    url: url_GetDescribeAccountAttributes_595128,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterDbRevisions_595177 = ref object of OpenApiRestCall_593421
proc url_PostDescribeClusterDbRevisions_595179(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterDbRevisions_595178(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595180 = query.getOrDefault("Action")
  valid_595180 = validateParameter(valid_595180, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_595180 != nil:
    section.add "Action", valid_595180
  var valid_595181 = query.getOrDefault("Version")
  valid_595181 = validateParameter(valid_595181, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595181 != nil:
    section.add "Version", valid_595181
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595182 = header.getOrDefault("X-Amz-Date")
  valid_595182 = validateParameter(valid_595182, JString, required = false,
                                 default = nil)
  if valid_595182 != nil:
    section.add "X-Amz-Date", valid_595182
  var valid_595183 = header.getOrDefault("X-Amz-Security-Token")
  valid_595183 = validateParameter(valid_595183, JString, required = false,
                                 default = nil)
  if valid_595183 != nil:
    section.add "X-Amz-Security-Token", valid_595183
  var valid_595184 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595184 = validateParameter(valid_595184, JString, required = false,
                                 default = nil)
  if valid_595184 != nil:
    section.add "X-Amz-Content-Sha256", valid_595184
  var valid_595185 = header.getOrDefault("X-Amz-Algorithm")
  valid_595185 = validateParameter(valid_595185, JString, required = false,
                                 default = nil)
  if valid_595185 != nil:
    section.add "X-Amz-Algorithm", valid_595185
  var valid_595186 = header.getOrDefault("X-Amz-Signature")
  valid_595186 = validateParameter(valid_595186, JString, required = false,
                                 default = nil)
  if valid_595186 != nil:
    section.add "X-Amz-Signature", valid_595186
  var valid_595187 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595187 = validateParameter(valid_595187, JString, required = false,
                                 default = nil)
  if valid_595187 != nil:
    section.add "X-Amz-SignedHeaders", valid_595187
  var valid_595188 = header.getOrDefault("X-Amz-Credential")
  valid_595188 = validateParameter(valid_595188, JString, required = false,
                                 default = nil)
  if valid_595188 != nil:
    section.add "X-Amz-Credential", valid_595188
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_595189 = formData.getOrDefault("Marker")
  valid_595189 = validateParameter(valid_595189, JString, required = false,
                                 default = nil)
  if valid_595189 != nil:
    section.add "Marker", valid_595189
  var valid_595190 = formData.getOrDefault("ClusterIdentifier")
  valid_595190 = validateParameter(valid_595190, JString, required = false,
                                 default = nil)
  if valid_595190 != nil:
    section.add "ClusterIdentifier", valid_595190
  var valid_595191 = formData.getOrDefault("MaxRecords")
  valid_595191 = validateParameter(valid_595191, JInt, required = false, default = nil)
  if valid_595191 != nil:
    section.add "MaxRecords", valid_595191
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595192: Call_PostDescribeClusterDbRevisions_595177; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_595192.validator(path, query, header, formData, body)
  let scheme = call_595192.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595192.url(scheme.get, call_595192.host, call_595192.base,
                         call_595192.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595192, url, valid)

proc call*(call_595193: Call_PostDescribeClusterDbRevisions_595177;
          Marker: string = ""; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_595194 = newJObject()
  var formData_595195 = newJObject()
  add(formData_595195, "Marker", newJString(Marker))
  add(query_595194, "Action", newJString(Action))
  add(formData_595195, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_595195, "MaxRecords", newJInt(MaxRecords))
  add(query_595194, "Version", newJString(Version))
  result = call_595193.call(nil, query_595194, nil, formData_595195, nil)

var postDescribeClusterDbRevisions* = Call_PostDescribeClusterDbRevisions_595177(
    name: "postDescribeClusterDbRevisions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_PostDescribeClusterDbRevisions_595178, base: "/",
    url: url_PostDescribeClusterDbRevisions_595179,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterDbRevisions_595159 = ref object of OpenApiRestCall_593421
proc url_GetDescribeClusterDbRevisions_595161(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterDbRevisions_595160(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_595162 = query.getOrDefault("MaxRecords")
  valid_595162 = validateParameter(valid_595162, JInt, required = false, default = nil)
  if valid_595162 != nil:
    section.add "MaxRecords", valid_595162
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595163 = query.getOrDefault("Action")
  valid_595163 = validateParameter(valid_595163, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_595163 != nil:
    section.add "Action", valid_595163
  var valid_595164 = query.getOrDefault("ClusterIdentifier")
  valid_595164 = validateParameter(valid_595164, JString, required = false,
                                 default = nil)
  if valid_595164 != nil:
    section.add "ClusterIdentifier", valid_595164
  var valid_595165 = query.getOrDefault("Marker")
  valid_595165 = validateParameter(valid_595165, JString, required = false,
                                 default = nil)
  if valid_595165 != nil:
    section.add "Marker", valid_595165
  var valid_595166 = query.getOrDefault("Version")
  valid_595166 = validateParameter(valid_595166, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595166 != nil:
    section.add "Version", valid_595166
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595167 = header.getOrDefault("X-Amz-Date")
  valid_595167 = validateParameter(valid_595167, JString, required = false,
                                 default = nil)
  if valid_595167 != nil:
    section.add "X-Amz-Date", valid_595167
  var valid_595168 = header.getOrDefault("X-Amz-Security-Token")
  valid_595168 = validateParameter(valid_595168, JString, required = false,
                                 default = nil)
  if valid_595168 != nil:
    section.add "X-Amz-Security-Token", valid_595168
  var valid_595169 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595169 = validateParameter(valid_595169, JString, required = false,
                                 default = nil)
  if valid_595169 != nil:
    section.add "X-Amz-Content-Sha256", valid_595169
  var valid_595170 = header.getOrDefault("X-Amz-Algorithm")
  valid_595170 = validateParameter(valid_595170, JString, required = false,
                                 default = nil)
  if valid_595170 != nil:
    section.add "X-Amz-Algorithm", valid_595170
  var valid_595171 = header.getOrDefault("X-Amz-Signature")
  valid_595171 = validateParameter(valid_595171, JString, required = false,
                                 default = nil)
  if valid_595171 != nil:
    section.add "X-Amz-Signature", valid_595171
  var valid_595172 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595172 = validateParameter(valid_595172, JString, required = false,
                                 default = nil)
  if valid_595172 != nil:
    section.add "X-Amz-SignedHeaders", valid_595172
  var valid_595173 = header.getOrDefault("X-Amz-Credential")
  valid_595173 = validateParameter(valid_595173, JString, required = false,
                                 default = nil)
  if valid_595173 != nil:
    section.add "X-Amz-Credential", valid_595173
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595174: Call_GetDescribeClusterDbRevisions_595159; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_595174.validator(path, query, header, formData, body)
  let scheme = call_595174.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595174.url(scheme.get, call_595174.host, call_595174.base,
                         call_595174.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595174, url, valid)

proc call*(call_595175: Call_GetDescribeClusterDbRevisions_595159;
          MaxRecords: int = 0; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Version: string (required)
  var query_595176 = newJObject()
  add(query_595176, "MaxRecords", newJInt(MaxRecords))
  add(query_595176, "Action", newJString(Action))
  add(query_595176, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595176, "Marker", newJString(Marker))
  add(query_595176, "Version", newJString(Version))
  result = call_595175.call(nil, query_595176, nil, nil, nil)

var getDescribeClusterDbRevisions* = Call_GetDescribeClusterDbRevisions_595159(
    name: "getDescribeClusterDbRevisions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_GetDescribeClusterDbRevisions_595160, base: "/",
    url: url_GetDescribeClusterDbRevisions_595161,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameterGroups_595216 = ref object of OpenApiRestCall_593421
proc url_PostDescribeClusterParameterGroups_595218(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterParameterGroups_595217(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595219 = query.getOrDefault("Action")
  valid_595219 = validateParameter(valid_595219, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_595219 != nil:
    section.add "Action", valid_595219
  var valid_595220 = query.getOrDefault("Version")
  valid_595220 = validateParameter(valid_595220, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595220 != nil:
    section.add "Version", valid_595220
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595221 = header.getOrDefault("X-Amz-Date")
  valid_595221 = validateParameter(valid_595221, JString, required = false,
                                 default = nil)
  if valid_595221 != nil:
    section.add "X-Amz-Date", valid_595221
  var valid_595222 = header.getOrDefault("X-Amz-Security-Token")
  valid_595222 = validateParameter(valid_595222, JString, required = false,
                                 default = nil)
  if valid_595222 != nil:
    section.add "X-Amz-Security-Token", valid_595222
  var valid_595223 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595223 = validateParameter(valid_595223, JString, required = false,
                                 default = nil)
  if valid_595223 != nil:
    section.add "X-Amz-Content-Sha256", valid_595223
  var valid_595224 = header.getOrDefault("X-Amz-Algorithm")
  valid_595224 = validateParameter(valid_595224, JString, required = false,
                                 default = nil)
  if valid_595224 != nil:
    section.add "X-Amz-Algorithm", valid_595224
  var valid_595225 = header.getOrDefault("X-Amz-Signature")
  valid_595225 = validateParameter(valid_595225, JString, required = false,
                                 default = nil)
  if valid_595225 != nil:
    section.add "X-Amz-Signature", valid_595225
  var valid_595226 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595226 = validateParameter(valid_595226, JString, required = false,
                                 default = nil)
  if valid_595226 != nil:
    section.add "X-Amz-SignedHeaders", valid_595226
  var valid_595227 = header.getOrDefault("X-Amz-Credential")
  valid_595227 = validateParameter(valid_595227, JString, required = false,
                                 default = nil)
  if valid_595227 != nil:
    section.add "X-Amz-Credential", valid_595227
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_595228 = formData.getOrDefault("ParameterGroupName")
  valid_595228 = validateParameter(valid_595228, JString, required = false,
                                 default = nil)
  if valid_595228 != nil:
    section.add "ParameterGroupName", valid_595228
  var valid_595229 = formData.getOrDefault("Marker")
  valid_595229 = validateParameter(valid_595229, JString, required = false,
                                 default = nil)
  if valid_595229 != nil:
    section.add "Marker", valid_595229
  var valid_595230 = formData.getOrDefault("TagKeys")
  valid_595230 = validateParameter(valid_595230, JArray, required = false,
                                 default = nil)
  if valid_595230 != nil:
    section.add "TagKeys", valid_595230
  var valid_595231 = formData.getOrDefault("MaxRecords")
  valid_595231 = validateParameter(valid_595231, JInt, required = false, default = nil)
  if valid_595231 != nil:
    section.add "MaxRecords", valid_595231
  var valid_595232 = formData.getOrDefault("TagValues")
  valid_595232 = validateParameter(valid_595232, JArray, required = false,
                                 default = nil)
  if valid_595232 != nil:
    section.add "TagValues", valid_595232
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595233: Call_PostDescribeClusterParameterGroups_595216;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595233.validator(path, query, header, formData, body)
  let scheme = call_595233.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595233.url(scheme.get, call_595233.host, call_595233.base,
                         call_595233.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595233, url, valid)

proc call*(call_595234: Call_PostDescribeClusterParameterGroups_595216;
          ParameterGroupName: string = ""; Marker: string = "";
          Action: string = "DescribeClusterParameterGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_595235 = newJObject()
  var formData_595236 = newJObject()
  add(formData_595236, "ParameterGroupName", newJString(ParameterGroupName))
  add(formData_595236, "Marker", newJString(Marker))
  add(query_595235, "Action", newJString(Action))
  if TagKeys != nil:
    formData_595236.add "TagKeys", TagKeys
  add(formData_595236, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_595236.add "TagValues", TagValues
  add(query_595235, "Version", newJString(Version))
  result = call_595234.call(nil, query_595235, nil, formData_595236, nil)

var postDescribeClusterParameterGroups* = Call_PostDescribeClusterParameterGroups_595216(
    name: "postDescribeClusterParameterGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_PostDescribeClusterParameterGroups_595217, base: "/",
    url: url_PostDescribeClusterParameterGroups_595218,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameterGroups_595196 = ref object of OpenApiRestCall_593421
proc url_GetDescribeClusterParameterGroups_595198(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterParameterGroups_595197(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595199 = query.getOrDefault("TagValues")
  valid_595199 = validateParameter(valid_595199, JArray, required = false,
                                 default = nil)
  if valid_595199 != nil:
    section.add "TagValues", valid_595199
  var valid_595200 = query.getOrDefault("MaxRecords")
  valid_595200 = validateParameter(valid_595200, JInt, required = false, default = nil)
  if valid_595200 != nil:
    section.add "MaxRecords", valid_595200
  var valid_595201 = query.getOrDefault("ParameterGroupName")
  valid_595201 = validateParameter(valid_595201, JString, required = false,
                                 default = nil)
  if valid_595201 != nil:
    section.add "ParameterGroupName", valid_595201
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595202 = query.getOrDefault("Action")
  valid_595202 = validateParameter(valid_595202, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_595202 != nil:
    section.add "Action", valid_595202
  var valid_595203 = query.getOrDefault("Marker")
  valid_595203 = validateParameter(valid_595203, JString, required = false,
                                 default = nil)
  if valid_595203 != nil:
    section.add "Marker", valid_595203
  var valid_595204 = query.getOrDefault("TagKeys")
  valid_595204 = validateParameter(valid_595204, JArray, required = false,
                                 default = nil)
  if valid_595204 != nil:
    section.add "TagKeys", valid_595204
  var valid_595205 = query.getOrDefault("Version")
  valid_595205 = validateParameter(valid_595205, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595205 != nil:
    section.add "Version", valid_595205
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595206 = header.getOrDefault("X-Amz-Date")
  valid_595206 = validateParameter(valid_595206, JString, required = false,
                                 default = nil)
  if valid_595206 != nil:
    section.add "X-Amz-Date", valid_595206
  var valid_595207 = header.getOrDefault("X-Amz-Security-Token")
  valid_595207 = validateParameter(valid_595207, JString, required = false,
                                 default = nil)
  if valid_595207 != nil:
    section.add "X-Amz-Security-Token", valid_595207
  var valid_595208 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595208 = validateParameter(valid_595208, JString, required = false,
                                 default = nil)
  if valid_595208 != nil:
    section.add "X-Amz-Content-Sha256", valid_595208
  var valid_595209 = header.getOrDefault("X-Amz-Algorithm")
  valid_595209 = validateParameter(valid_595209, JString, required = false,
                                 default = nil)
  if valid_595209 != nil:
    section.add "X-Amz-Algorithm", valid_595209
  var valid_595210 = header.getOrDefault("X-Amz-Signature")
  valid_595210 = validateParameter(valid_595210, JString, required = false,
                                 default = nil)
  if valid_595210 != nil:
    section.add "X-Amz-Signature", valid_595210
  var valid_595211 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595211 = validateParameter(valid_595211, JString, required = false,
                                 default = nil)
  if valid_595211 != nil:
    section.add "X-Amz-SignedHeaders", valid_595211
  var valid_595212 = header.getOrDefault("X-Amz-Credential")
  valid_595212 = validateParameter(valid_595212, JString, required = false,
                                 default = nil)
  if valid_595212 != nil:
    section.add "X-Amz-Credential", valid_595212
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595213: Call_GetDescribeClusterParameterGroups_595196;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595213.validator(path, query, header, formData, body)
  let scheme = call_595213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595213.url(scheme.get, call_595213.host, call_595213.base,
                         call_595213.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595213, url, valid)

proc call*(call_595214: Call_GetDescribeClusterParameterGroups_595196;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          ParameterGroupName: string = "";
          Action: string = "DescribeClusterParameterGroups"; Marker: string = "";
          TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_595215 = newJObject()
  if TagValues != nil:
    query_595215.add "TagValues", TagValues
  add(query_595215, "MaxRecords", newJInt(MaxRecords))
  add(query_595215, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_595215, "Action", newJString(Action))
  add(query_595215, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_595215.add "TagKeys", TagKeys
  add(query_595215, "Version", newJString(Version))
  result = call_595214.call(nil, query_595215, nil, nil, nil)

var getDescribeClusterParameterGroups* = Call_GetDescribeClusterParameterGroups_595196(
    name: "getDescribeClusterParameterGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_GetDescribeClusterParameterGroups_595197, base: "/",
    url: url_GetDescribeClusterParameterGroups_595198,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameters_595256 = ref object of OpenApiRestCall_593421
proc url_PostDescribeClusterParameters_595258(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterParameters_595257(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595259 = query.getOrDefault("Action")
  valid_595259 = validateParameter(valid_595259, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_595259 != nil:
    section.add "Action", valid_595259
  var valid_595260 = query.getOrDefault("Version")
  valid_595260 = validateParameter(valid_595260, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595260 != nil:
    section.add "Version", valid_595260
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595261 = header.getOrDefault("X-Amz-Date")
  valid_595261 = validateParameter(valid_595261, JString, required = false,
                                 default = nil)
  if valid_595261 != nil:
    section.add "X-Amz-Date", valid_595261
  var valid_595262 = header.getOrDefault("X-Amz-Security-Token")
  valid_595262 = validateParameter(valid_595262, JString, required = false,
                                 default = nil)
  if valid_595262 != nil:
    section.add "X-Amz-Security-Token", valid_595262
  var valid_595263 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595263 = validateParameter(valid_595263, JString, required = false,
                                 default = nil)
  if valid_595263 != nil:
    section.add "X-Amz-Content-Sha256", valid_595263
  var valid_595264 = header.getOrDefault("X-Amz-Algorithm")
  valid_595264 = validateParameter(valid_595264, JString, required = false,
                                 default = nil)
  if valid_595264 != nil:
    section.add "X-Amz-Algorithm", valid_595264
  var valid_595265 = header.getOrDefault("X-Amz-Signature")
  valid_595265 = validateParameter(valid_595265, JString, required = false,
                                 default = nil)
  if valid_595265 != nil:
    section.add "X-Amz-Signature", valid_595265
  var valid_595266 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595266 = validateParameter(valid_595266, JString, required = false,
                                 default = nil)
  if valid_595266 != nil:
    section.add "X-Amz-SignedHeaders", valid_595266
  var valid_595267 = header.getOrDefault("X-Amz-Credential")
  valid_595267 = validateParameter(valid_595267, JString, required = false,
                                 default = nil)
  if valid_595267 != nil:
    section.add "X-Amz-Credential", valid_595267
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_595268 = formData.getOrDefault("ParameterGroupName")
  valid_595268 = validateParameter(valid_595268, JString, required = true,
                                 default = nil)
  if valid_595268 != nil:
    section.add "ParameterGroupName", valid_595268
  var valid_595269 = formData.getOrDefault("Marker")
  valid_595269 = validateParameter(valid_595269, JString, required = false,
                                 default = nil)
  if valid_595269 != nil:
    section.add "Marker", valid_595269
  var valid_595270 = formData.getOrDefault("MaxRecords")
  valid_595270 = validateParameter(valid_595270, JInt, required = false, default = nil)
  if valid_595270 != nil:
    section.add "MaxRecords", valid_595270
  var valid_595271 = formData.getOrDefault("Source")
  valid_595271 = validateParameter(valid_595271, JString, required = false,
                                 default = nil)
  if valid_595271 != nil:
    section.add "Source", valid_595271
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595272: Call_PostDescribeClusterParameters_595256; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_595272.validator(path, query, header, formData, body)
  let scheme = call_595272.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595272.url(scheme.get, call_595272.host, call_595272.base,
                         call_595272.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595272, url, valid)

proc call*(call_595273: Call_PostDescribeClusterParameters_595256;
          ParameterGroupName: string; Marker: string = "";
          Action: string = "DescribeClusterParameters"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; Source: string = ""): Recallable =
  ## postDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  var query_595274 = newJObject()
  var formData_595275 = newJObject()
  add(formData_595275, "ParameterGroupName", newJString(ParameterGroupName))
  add(formData_595275, "Marker", newJString(Marker))
  add(query_595274, "Action", newJString(Action))
  add(formData_595275, "MaxRecords", newJInt(MaxRecords))
  add(query_595274, "Version", newJString(Version))
  add(formData_595275, "Source", newJString(Source))
  result = call_595273.call(nil, query_595274, nil, formData_595275, nil)

var postDescribeClusterParameters* = Call_PostDescribeClusterParameters_595256(
    name: "postDescribeClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_PostDescribeClusterParameters_595257, base: "/",
    url: url_PostDescribeClusterParameters_595258,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameters_595237 = ref object of OpenApiRestCall_593421
proc url_GetDescribeClusterParameters_595239(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterParameters_595238(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_595240 = query.getOrDefault("MaxRecords")
  valid_595240 = validateParameter(valid_595240, JInt, required = false, default = nil)
  if valid_595240 != nil:
    section.add "MaxRecords", valid_595240
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_595241 = query.getOrDefault("ParameterGroupName")
  valid_595241 = validateParameter(valid_595241, JString, required = true,
                                 default = nil)
  if valid_595241 != nil:
    section.add "ParameterGroupName", valid_595241
  var valid_595242 = query.getOrDefault("Action")
  valid_595242 = validateParameter(valid_595242, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_595242 != nil:
    section.add "Action", valid_595242
  var valid_595243 = query.getOrDefault("Marker")
  valid_595243 = validateParameter(valid_595243, JString, required = false,
                                 default = nil)
  if valid_595243 != nil:
    section.add "Marker", valid_595243
  var valid_595244 = query.getOrDefault("Source")
  valid_595244 = validateParameter(valid_595244, JString, required = false,
                                 default = nil)
  if valid_595244 != nil:
    section.add "Source", valid_595244
  var valid_595245 = query.getOrDefault("Version")
  valid_595245 = validateParameter(valid_595245, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595245 != nil:
    section.add "Version", valid_595245
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595246 = header.getOrDefault("X-Amz-Date")
  valid_595246 = validateParameter(valid_595246, JString, required = false,
                                 default = nil)
  if valid_595246 != nil:
    section.add "X-Amz-Date", valid_595246
  var valid_595247 = header.getOrDefault("X-Amz-Security-Token")
  valid_595247 = validateParameter(valid_595247, JString, required = false,
                                 default = nil)
  if valid_595247 != nil:
    section.add "X-Amz-Security-Token", valid_595247
  var valid_595248 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595248 = validateParameter(valid_595248, JString, required = false,
                                 default = nil)
  if valid_595248 != nil:
    section.add "X-Amz-Content-Sha256", valid_595248
  var valid_595249 = header.getOrDefault("X-Amz-Algorithm")
  valid_595249 = validateParameter(valid_595249, JString, required = false,
                                 default = nil)
  if valid_595249 != nil:
    section.add "X-Amz-Algorithm", valid_595249
  var valid_595250 = header.getOrDefault("X-Amz-Signature")
  valid_595250 = validateParameter(valid_595250, JString, required = false,
                                 default = nil)
  if valid_595250 != nil:
    section.add "X-Amz-Signature", valid_595250
  var valid_595251 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595251 = validateParameter(valid_595251, JString, required = false,
                                 default = nil)
  if valid_595251 != nil:
    section.add "X-Amz-SignedHeaders", valid_595251
  var valid_595252 = header.getOrDefault("X-Amz-Credential")
  valid_595252 = validateParameter(valid_595252, JString, required = false,
                                 default = nil)
  if valid_595252 != nil:
    section.add "X-Amz-Credential", valid_595252
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595253: Call_GetDescribeClusterParameters_595237; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_595253.validator(path, query, header, formData, body)
  let scheme = call_595253.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595253.url(scheme.get, call_595253.host, call_595253.base,
                         call_595253.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595253, url, valid)

proc call*(call_595254: Call_GetDescribeClusterParameters_595237;
          ParameterGroupName: string; MaxRecords: int = 0;
          Action: string = "DescribeClusterParameters"; Marker: string = "";
          Source: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Version: string (required)
  var query_595255 = newJObject()
  add(query_595255, "MaxRecords", newJInt(MaxRecords))
  add(query_595255, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_595255, "Action", newJString(Action))
  add(query_595255, "Marker", newJString(Marker))
  add(query_595255, "Source", newJString(Source))
  add(query_595255, "Version", newJString(Version))
  result = call_595254.call(nil, query_595255, nil, nil, nil)

var getDescribeClusterParameters* = Call_GetDescribeClusterParameters_595237(
    name: "getDescribeClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_GetDescribeClusterParameters_595238, base: "/",
    url: url_GetDescribeClusterParameters_595239,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSecurityGroups_595296 = ref object of OpenApiRestCall_593421
proc url_PostDescribeClusterSecurityGroups_595298(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterSecurityGroups_595297(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595299 = query.getOrDefault("Action")
  valid_595299 = validateParameter(valid_595299, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_595299 != nil:
    section.add "Action", valid_595299
  var valid_595300 = query.getOrDefault("Version")
  valid_595300 = validateParameter(valid_595300, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595300 != nil:
    section.add "Version", valid_595300
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595301 = header.getOrDefault("X-Amz-Date")
  valid_595301 = validateParameter(valid_595301, JString, required = false,
                                 default = nil)
  if valid_595301 != nil:
    section.add "X-Amz-Date", valid_595301
  var valid_595302 = header.getOrDefault("X-Amz-Security-Token")
  valid_595302 = validateParameter(valid_595302, JString, required = false,
                                 default = nil)
  if valid_595302 != nil:
    section.add "X-Amz-Security-Token", valid_595302
  var valid_595303 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595303 = validateParameter(valid_595303, JString, required = false,
                                 default = nil)
  if valid_595303 != nil:
    section.add "X-Amz-Content-Sha256", valid_595303
  var valid_595304 = header.getOrDefault("X-Amz-Algorithm")
  valid_595304 = validateParameter(valid_595304, JString, required = false,
                                 default = nil)
  if valid_595304 != nil:
    section.add "X-Amz-Algorithm", valid_595304
  var valid_595305 = header.getOrDefault("X-Amz-Signature")
  valid_595305 = validateParameter(valid_595305, JString, required = false,
                                 default = nil)
  if valid_595305 != nil:
    section.add "X-Amz-Signature", valid_595305
  var valid_595306 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595306 = validateParameter(valid_595306, JString, required = false,
                                 default = nil)
  if valid_595306 != nil:
    section.add "X-Amz-SignedHeaders", valid_595306
  var valid_595307 = header.getOrDefault("X-Amz-Credential")
  valid_595307 = validateParameter(valid_595307, JString, required = false,
                                 default = nil)
  if valid_595307 != nil:
    section.add "X-Amz-Credential", valid_595307
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  section = newJObject()
  var valid_595308 = formData.getOrDefault("Marker")
  valid_595308 = validateParameter(valid_595308, JString, required = false,
                                 default = nil)
  if valid_595308 != nil:
    section.add "Marker", valid_595308
  var valid_595309 = formData.getOrDefault("TagKeys")
  valid_595309 = validateParameter(valid_595309, JArray, required = false,
                                 default = nil)
  if valid_595309 != nil:
    section.add "TagKeys", valid_595309
  var valid_595310 = formData.getOrDefault("MaxRecords")
  valid_595310 = validateParameter(valid_595310, JInt, required = false, default = nil)
  if valid_595310 != nil:
    section.add "MaxRecords", valid_595310
  var valid_595311 = formData.getOrDefault("TagValues")
  valid_595311 = validateParameter(valid_595311, JArray, required = false,
                                 default = nil)
  if valid_595311 != nil:
    section.add "TagValues", valid_595311
  var valid_595312 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_595312 = validateParameter(valid_595312, JString, required = false,
                                 default = nil)
  if valid_595312 != nil:
    section.add "ClusterSecurityGroupName", valid_595312
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595313: Call_PostDescribeClusterSecurityGroups_595296;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595313.validator(path, query, header, formData, body)
  let scheme = call_595313.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595313.url(scheme.get, call_595313.host, call_595313.base,
                         call_595313.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595313, url, valid)

proc call*(call_595314: Call_PostDescribeClusterSecurityGroups_595296;
          Marker: string = ""; Action: string = "DescribeClusterSecurityGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"; ClusterSecurityGroupName: string = ""): Recallable =
  ## postDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  var query_595315 = newJObject()
  var formData_595316 = newJObject()
  add(formData_595316, "Marker", newJString(Marker))
  add(query_595315, "Action", newJString(Action))
  if TagKeys != nil:
    formData_595316.add "TagKeys", TagKeys
  add(formData_595316, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_595316.add "TagValues", TagValues
  add(query_595315, "Version", newJString(Version))
  add(formData_595316, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_595314.call(nil, query_595315, nil, formData_595316, nil)

var postDescribeClusterSecurityGroups* = Call_PostDescribeClusterSecurityGroups_595296(
    name: "postDescribeClusterSecurityGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_PostDescribeClusterSecurityGroups_595297, base: "/",
    url: url_PostDescribeClusterSecurityGroups_595298,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSecurityGroups_595276 = ref object of OpenApiRestCall_593421
proc url_GetDescribeClusterSecurityGroups_595278(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterSecurityGroups_595277(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595279 = query.getOrDefault("TagValues")
  valid_595279 = validateParameter(valid_595279, JArray, required = false,
                                 default = nil)
  if valid_595279 != nil:
    section.add "TagValues", valid_595279
  var valid_595280 = query.getOrDefault("ClusterSecurityGroupName")
  valid_595280 = validateParameter(valid_595280, JString, required = false,
                                 default = nil)
  if valid_595280 != nil:
    section.add "ClusterSecurityGroupName", valid_595280
  var valid_595281 = query.getOrDefault("MaxRecords")
  valid_595281 = validateParameter(valid_595281, JInt, required = false, default = nil)
  if valid_595281 != nil:
    section.add "MaxRecords", valid_595281
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595282 = query.getOrDefault("Action")
  valid_595282 = validateParameter(valid_595282, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_595282 != nil:
    section.add "Action", valid_595282
  var valid_595283 = query.getOrDefault("Marker")
  valid_595283 = validateParameter(valid_595283, JString, required = false,
                                 default = nil)
  if valid_595283 != nil:
    section.add "Marker", valid_595283
  var valid_595284 = query.getOrDefault("TagKeys")
  valid_595284 = validateParameter(valid_595284, JArray, required = false,
                                 default = nil)
  if valid_595284 != nil:
    section.add "TagKeys", valid_595284
  var valid_595285 = query.getOrDefault("Version")
  valid_595285 = validateParameter(valid_595285, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595285 != nil:
    section.add "Version", valid_595285
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595286 = header.getOrDefault("X-Amz-Date")
  valid_595286 = validateParameter(valid_595286, JString, required = false,
                                 default = nil)
  if valid_595286 != nil:
    section.add "X-Amz-Date", valid_595286
  var valid_595287 = header.getOrDefault("X-Amz-Security-Token")
  valid_595287 = validateParameter(valid_595287, JString, required = false,
                                 default = nil)
  if valid_595287 != nil:
    section.add "X-Amz-Security-Token", valid_595287
  var valid_595288 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595288 = validateParameter(valid_595288, JString, required = false,
                                 default = nil)
  if valid_595288 != nil:
    section.add "X-Amz-Content-Sha256", valid_595288
  var valid_595289 = header.getOrDefault("X-Amz-Algorithm")
  valid_595289 = validateParameter(valid_595289, JString, required = false,
                                 default = nil)
  if valid_595289 != nil:
    section.add "X-Amz-Algorithm", valid_595289
  var valid_595290 = header.getOrDefault("X-Amz-Signature")
  valid_595290 = validateParameter(valid_595290, JString, required = false,
                                 default = nil)
  if valid_595290 != nil:
    section.add "X-Amz-Signature", valid_595290
  var valid_595291 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595291 = validateParameter(valid_595291, JString, required = false,
                                 default = nil)
  if valid_595291 != nil:
    section.add "X-Amz-SignedHeaders", valid_595291
  var valid_595292 = header.getOrDefault("X-Amz-Credential")
  valid_595292 = validateParameter(valid_595292, JString, required = false,
                                 default = nil)
  if valid_595292 != nil:
    section.add "X-Amz-Credential", valid_595292
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595293: Call_GetDescribeClusterSecurityGroups_595276;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595293.validator(path, query, header, formData, body)
  let scheme = call_595293.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595293.url(scheme.get, call_595293.host, call_595293.base,
                         call_595293.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595293, url, valid)

proc call*(call_595294: Call_GetDescribeClusterSecurityGroups_595276;
          TagValues: JsonNode = nil; ClusterSecurityGroupName: string = "";
          MaxRecords: int = 0; Action: string = "DescribeClusterSecurityGroups";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_595295 = newJObject()
  if TagValues != nil:
    query_595295.add "TagValues", TagValues
  add(query_595295, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_595295, "MaxRecords", newJInt(MaxRecords))
  add(query_595295, "Action", newJString(Action))
  add(query_595295, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_595295.add "TagKeys", TagKeys
  add(query_595295, "Version", newJString(Version))
  result = call_595294.call(nil, query_595295, nil, nil, nil)

var getDescribeClusterSecurityGroups* = Call_GetDescribeClusterSecurityGroups_595276(
    name: "getDescribeClusterSecurityGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_GetDescribeClusterSecurityGroups_595277, base: "/",
    url: url_GetDescribeClusterSecurityGroups_595278,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSnapshots_595344 = ref object of OpenApiRestCall_593421
proc url_PostDescribeClusterSnapshots_595346(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterSnapshots_595345(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595347 = query.getOrDefault("Action")
  valid_595347 = validateParameter(valid_595347, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_595347 != nil:
    section.add "Action", valid_595347
  var valid_595348 = query.getOrDefault("Version")
  valid_595348 = validateParameter(valid_595348, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595348 != nil:
    section.add "Version", valid_595348
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595349 = header.getOrDefault("X-Amz-Date")
  valid_595349 = validateParameter(valid_595349, JString, required = false,
                                 default = nil)
  if valid_595349 != nil:
    section.add "X-Amz-Date", valid_595349
  var valid_595350 = header.getOrDefault("X-Amz-Security-Token")
  valid_595350 = validateParameter(valid_595350, JString, required = false,
                                 default = nil)
  if valid_595350 != nil:
    section.add "X-Amz-Security-Token", valid_595350
  var valid_595351 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595351 = validateParameter(valid_595351, JString, required = false,
                                 default = nil)
  if valid_595351 != nil:
    section.add "X-Amz-Content-Sha256", valid_595351
  var valid_595352 = header.getOrDefault("X-Amz-Algorithm")
  valid_595352 = validateParameter(valid_595352, JString, required = false,
                                 default = nil)
  if valid_595352 != nil:
    section.add "X-Amz-Algorithm", valid_595352
  var valid_595353 = header.getOrDefault("X-Amz-Signature")
  valid_595353 = validateParameter(valid_595353, JString, required = false,
                                 default = nil)
  if valid_595353 != nil:
    section.add "X-Amz-Signature", valid_595353
  var valid_595354 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595354 = validateParameter(valid_595354, JString, required = false,
                                 default = nil)
  if valid_595354 != nil:
    section.add "X-Amz-SignedHeaders", valid_595354
  var valid_595355 = header.getOrDefault("X-Amz-Credential")
  valid_595355 = validateParameter(valid_595355, JString, required = false,
                                 default = nil)
  if valid_595355 != nil:
    section.add "X-Amz-Credential", valid_595355
  result.add "header", section
  ## parameters in `formData` object:
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_595356 = formData.getOrDefault("SortingEntities")
  valid_595356 = validateParameter(valid_595356, JArray, required = false,
                                 default = nil)
  if valid_595356 != nil:
    section.add "SortingEntities", valid_595356
  var valid_595357 = formData.getOrDefault("SnapshotType")
  valid_595357 = validateParameter(valid_595357, JString, required = false,
                                 default = nil)
  if valid_595357 != nil:
    section.add "SnapshotType", valid_595357
  var valid_595358 = formData.getOrDefault("Marker")
  valid_595358 = validateParameter(valid_595358, JString, required = false,
                                 default = nil)
  if valid_595358 != nil:
    section.add "Marker", valid_595358
  var valid_595359 = formData.getOrDefault("StartTime")
  valid_595359 = validateParameter(valid_595359, JString, required = false,
                                 default = nil)
  if valid_595359 != nil:
    section.add "StartTime", valid_595359
  var valid_595360 = formData.getOrDefault("OwnerAccount")
  valid_595360 = validateParameter(valid_595360, JString, required = false,
                                 default = nil)
  if valid_595360 != nil:
    section.add "OwnerAccount", valid_595360
  var valid_595361 = formData.getOrDefault("ClusterIdentifier")
  valid_595361 = validateParameter(valid_595361, JString, required = false,
                                 default = nil)
  if valid_595361 != nil:
    section.add "ClusterIdentifier", valid_595361
  var valid_595362 = formData.getOrDefault("TagKeys")
  valid_595362 = validateParameter(valid_595362, JArray, required = false,
                                 default = nil)
  if valid_595362 != nil:
    section.add "TagKeys", valid_595362
  var valid_595363 = formData.getOrDefault("EndTime")
  valid_595363 = validateParameter(valid_595363, JString, required = false,
                                 default = nil)
  if valid_595363 != nil:
    section.add "EndTime", valid_595363
  var valid_595364 = formData.getOrDefault("ClusterExists")
  valid_595364 = validateParameter(valid_595364, JBool, required = false, default = nil)
  if valid_595364 != nil:
    section.add "ClusterExists", valid_595364
  var valid_595365 = formData.getOrDefault("SnapshotIdentifier")
  valid_595365 = validateParameter(valid_595365, JString, required = false,
                                 default = nil)
  if valid_595365 != nil:
    section.add "SnapshotIdentifier", valid_595365
  var valid_595366 = formData.getOrDefault("MaxRecords")
  valid_595366 = validateParameter(valid_595366, JInt, required = false, default = nil)
  if valid_595366 != nil:
    section.add "MaxRecords", valid_595366
  var valid_595367 = formData.getOrDefault("TagValues")
  valid_595367 = validateParameter(valid_595367, JArray, required = false,
                                 default = nil)
  if valid_595367 != nil:
    section.add "TagValues", valid_595367
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595368: Call_PostDescribeClusterSnapshots_595344; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595368.validator(path, query, header, formData, body)
  let scheme = call_595368.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595368.url(scheme.get, call_595368.host, call_595368.base,
                         call_595368.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595368, url, valid)

proc call*(call_595369: Call_PostDescribeClusterSnapshots_595344;
          SortingEntities: JsonNode = nil; SnapshotType: string = "";
          Marker: string = ""; StartTime: string = "";
          Action: string = "DescribeClusterSnapshots"; OwnerAccount: string = "";
          ClusterIdentifier: string = ""; TagKeys: JsonNode = nil; EndTime: string = "";
          ClusterExists: bool = false; SnapshotIdentifier: string = "";
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_595370 = newJObject()
  var formData_595371 = newJObject()
  if SortingEntities != nil:
    formData_595371.add "SortingEntities", SortingEntities
  add(formData_595371, "SnapshotType", newJString(SnapshotType))
  add(formData_595371, "Marker", newJString(Marker))
  add(formData_595371, "StartTime", newJString(StartTime))
  add(query_595370, "Action", newJString(Action))
  add(formData_595371, "OwnerAccount", newJString(OwnerAccount))
  add(formData_595371, "ClusterIdentifier", newJString(ClusterIdentifier))
  if TagKeys != nil:
    formData_595371.add "TagKeys", TagKeys
  add(formData_595371, "EndTime", newJString(EndTime))
  add(formData_595371, "ClusterExists", newJBool(ClusterExists))
  add(formData_595371, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_595371, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_595371.add "TagValues", TagValues
  add(query_595370, "Version", newJString(Version))
  result = call_595369.call(nil, query_595370, nil, formData_595371, nil)

var postDescribeClusterSnapshots* = Call_PostDescribeClusterSnapshots_595344(
    name: "postDescribeClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_PostDescribeClusterSnapshots_595345, base: "/",
    url: url_PostDescribeClusterSnapshots_595346,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSnapshots_595317 = ref object of OpenApiRestCall_593421
proc url_GetDescribeClusterSnapshots_595319(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterSnapshots_595318(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_595320 = query.getOrDefault("TagValues")
  valid_595320 = validateParameter(valid_595320, JArray, required = false,
                                 default = nil)
  if valid_595320 != nil:
    section.add "TagValues", valid_595320
  var valid_595321 = query.getOrDefault("SortingEntities")
  valid_595321 = validateParameter(valid_595321, JArray, required = false,
                                 default = nil)
  if valid_595321 != nil:
    section.add "SortingEntities", valid_595321
  var valid_595322 = query.getOrDefault("MaxRecords")
  valid_595322 = validateParameter(valid_595322, JInt, required = false, default = nil)
  if valid_595322 != nil:
    section.add "MaxRecords", valid_595322
  var valid_595323 = query.getOrDefault("StartTime")
  valid_595323 = validateParameter(valid_595323, JString, required = false,
                                 default = nil)
  if valid_595323 != nil:
    section.add "StartTime", valid_595323
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595324 = query.getOrDefault("Action")
  valid_595324 = validateParameter(valid_595324, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_595324 != nil:
    section.add "Action", valid_595324
  var valid_595325 = query.getOrDefault("ClusterIdentifier")
  valid_595325 = validateParameter(valid_595325, JString, required = false,
                                 default = nil)
  if valid_595325 != nil:
    section.add "ClusterIdentifier", valid_595325
  var valid_595326 = query.getOrDefault("Marker")
  valid_595326 = validateParameter(valid_595326, JString, required = false,
                                 default = nil)
  if valid_595326 != nil:
    section.add "Marker", valid_595326
  var valid_595327 = query.getOrDefault("OwnerAccount")
  valid_595327 = validateParameter(valid_595327, JString, required = false,
                                 default = nil)
  if valid_595327 != nil:
    section.add "OwnerAccount", valid_595327
  var valid_595328 = query.getOrDefault("ClusterExists")
  valid_595328 = validateParameter(valid_595328, JBool, required = false, default = nil)
  if valid_595328 != nil:
    section.add "ClusterExists", valid_595328
  var valid_595329 = query.getOrDefault("SnapshotIdentifier")
  valid_595329 = validateParameter(valid_595329, JString, required = false,
                                 default = nil)
  if valid_595329 != nil:
    section.add "SnapshotIdentifier", valid_595329
  var valid_595330 = query.getOrDefault("TagKeys")
  valid_595330 = validateParameter(valid_595330, JArray, required = false,
                                 default = nil)
  if valid_595330 != nil:
    section.add "TagKeys", valid_595330
  var valid_595331 = query.getOrDefault("SnapshotType")
  valid_595331 = validateParameter(valid_595331, JString, required = false,
                                 default = nil)
  if valid_595331 != nil:
    section.add "SnapshotType", valid_595331
  var valid_595332 = query.getOrDefault("EndTime")
  valid_595332 = validateParameter(valid_595332, JString, required = false,
                                 default = nil)
  if valid_595332 != nil:
    section.add "EndTime", valid_595332
  var valid_595333 = query.getOrDefault("Version")
  valid_595333 = validateParameter(valid_595333, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595333 != nil:
    section.add "Version", valid_595333
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595334 = header.getOrDefault("X-Amz-Date")
  valid_595334 = validateParameter(valid_595334, JString, required = false,
                                 default = nil)
  if valid_595334 != nil:
    section.add "X-Amz-Date", valid_595334
  var valid_595335 = header.getOrDefault("X-Amz-Security-Token")
  valid_595335 = validateParameter(valid_595335, JString, required = false,
                                 default = nil)
  if valid_595335 != nil:
    section.add "X-Amz-Security-Token", valid_595335
  var valid_595336 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595336 = validateParameter(valid_595336, JString, required = false,
                                 default = nil)
  if valid_595336 != nil:
    section.add "X-Amz-Content-Sha256", valid_595336
  var valid_595337 = header.getOrDefault("X-Amz-Algorithm")
  valid_595337 = validateParameter(valid_595337, JString, required = false,
                                 default = nil)
  if valid_595337 != nil:
    section.add "X-Amz-Algorithm", valid_595337
  var valid_595338 = header.getOrDefault("X-Amz-Signature")
  valid_595338 = validateParameter(valid_595338, JString, required = false,
                                 default = nil)
  if valid_595338 != nil:
    section.add "X-Amz-Signature", valid_595338
  var valid_595339 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595339 = validateParameter(valid_595339, JString, required = false,
                                 default = nil)
  if valid_595339 != nil:
    section.add "X-Amz-SignedHeaders", valid_595339
  var valid_595340 = header.getOrDefault("X-Amz-Credential")
  valid_595340 = validateParameter(valid_595340, JString, required = false,
                                 default = nil)
  if valid_595340 != nil:
    section.add "X-Amz-Credential", valid_595340
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595341: Call_GetDescribeClusterSnapshots_595317; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595341.validator(path, query, header, formData, body)
  let scheme = call_595341.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595341.url(scheme.get, call_595341.host, call_595341.base,
                         call_595341.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595341, url, valid)

proc call*(call_595342: Call_GetDescribeClusterSnapshots_595317;
          TagValues: JsonNode = nil; SortingEntities: JsonNode = nil;
          MaxRecords: int = 0; StartTime: string = "";
          Action: string = "DescribeClusterSnapshots";
          ClusterIdentifier: string = ""; Marker: string = "";
          OwnerAccount: string = ""; ClusterExists: bool = false;
          SnapshotIdentifier: string = ""; TagKeys: JsonNode = nil;
          SnapshotType: string = ""; EndTime: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Version: string (required)
  var query_595343 = newJObject()
  if TagValues != nil:
    query_595343.add "TagValues", TagValues
  if SortingEntities != nil:
    query_595343.add "SortingEntities", SortingEntities
  add(query_595343, "MaxRecords", newJInt(MaxRecords))
  add(query_595343, "StartTime", newJString(StartTime))
  add(query_595343, "Action", newJString(Action))
  add(query_595343, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595343, "Marker", newJString(Marker))
  add(query_595343, "OwnerAccount", newJString(OwnerAccount))
  add(query_595343, "ClusterExists", newJBool(ClusterExists))
  add(query_595343, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  if TagKeys != nil:
    query_595343.add "TagKeys", TagKeys
  add(query_595343, "SnapshotType", newJString(SnapshotType))
  add(query_595343, "EndTime", newJString(EndTime))
  add(query_595343, "Version", newJString(Version))
  result = call_595342.call(nil, query_595343, nil, nil, nil)

var getDescribeClusterSnapshots* = Call_GetDescribeClusterSnapshots_595317(
    name: "getDescribeClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_GetDescribeClusterSnapshots_595318, base: "/",
    url: url_GetDescribeClusterSnapshots_595319,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSubnetGroups_595392 = ref object of OpenApiRestCall_593421
proc url_PostDescribeClusterSubnetGroups_595394(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterSubnetGroups_595393(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595395 = query.getOrDefault("Action")
  valid_595395 = validateParameter(valid_595395, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_595395 != nil:
    section.add "Action", valid_595395
  var valid_595396 = query.getOrDefault("Version")
  valid_595396 = validateParameter(valid_595396, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595396 != nil:
    section.add "Version", valid_595396
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595397 = header.getOrDefault("X-Amz-Date")
  valid_595397 = validateParameter(valid_595397, JString, required = false,
                                 default = nil)
  if valid_595397 != nil:
    section.add "X-Amz-Date", valid_595397
  var valid_595398 = header.getOrDefault("X-Amz-Security-Token")
  valid_595398 = validateParameter(valid_595398, JString, required = false,
                                 default = nil)
  if valid_595398 != nil:
    section.add "X-Amz-Security-Token", valid_595398
  var valid_595399 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595399 = validateParameter(valid_595399, JString, required = false,
                                 default = nil)
  if valid_595399 != nil:
    section.add "X-Amz-Content-Sha256", valid_595399
  var valid_595400 = header.getOrDefault("X-Amz-Algorithm")
  valid_595400 = validateParameter(valid_595400, JString, required = false,
                                 default = nil)
  if valid_595400 != nil:
    section.add "X-Amz-Algorithm", valid_595400
  var valid_595401 = header.getOrDefault("X-Amz-Signature")
  valid_595401 = validateParameter(valid_595401, JString, required = false,
                                 default = nil)
  if valid_595401 != nil:
    section.add "X-Amz-Signature", valid_595401
  var valid_595402 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595402 = validateParameter(valid_595402, JString, required = false,
                                 default = nil)
  if valid_595402 != nil:
    section.add "X-Amz-SignedHeaders", valid_595402
  var valid_595403 = header.getOrDefault("X-Amz-Credential")
  valid_595403 = validateParameter(valid_595403, JString, required = false,
                                 default = nil)
  if valid_595403 != nil:
    section.add "X-Amz-Credential", valid_595403
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  section = newJObject()
  var valid_595404 = formData.getOrDefault("Marker")
  valid_595404 = validateParameter(valid_595404, JString, required = false,
                                 default = nil)
  if valid_595404 != nil:
    section.add "Marker", valid_595404
  var valid_595405 = formData.getOrDefault("TagKeys")
  valid_595405 = validateParameter(valid_595405, JArray, required = false,
                                 default = nil)
  if valid_595405 != nil:
    section.add "TagKeys", valid_595405
  var valid_595406 = formData.getOrDefault("MaxRecords")
  valid_595406 = validateParameter(valid_595406, JInt, required = false, default = nil)
  if valid_595406 != nil:
    section.add "MaxRecords", valid_595406
  var valid_595407 = formData.getOrDefault("TagValues")
  valid_595407 = validateParameter(valid_595407, JArray, required = false,
                                 default = nil)
  if valid_595407 != nil:
    section.add "TagValues", valid_595407
  var valid_595408 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_595408 = validateParameter(valid_595408, JString, required = false,
                                 default = nil)
  if valid_595408 != nil:
    section.add "ClusterSubnetGroupName", valid_595408
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595409: Call_PostDescribeClusterSubnetGroups_595392;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595409.validator(path, query, header, formData, body)
  let scheme = call_595409.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595409.url(scheme.get, call_595409.host, call_595409.base,
                         call_595409.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595409, url, valid)

proc call*(call_595410: Call_PostDescribeClusterSubnetGroups_595392;
          Marker: string = ""; Action: string = "DescribeClusterSubnetGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"; ClusterSubnetGroupName: string = ""): Recallable =
  ## postDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  var query_595411 = newJObject()
  var formData_595412 = newJObject()
  add(formData_595412, "Marker", newJString(Marker))
  add(query_595411, "Action", newJString(Action))
  if TagKeys != nil:
    formData_595412.add "TagKeys", TagKeys
  add(formData_595412, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_595412.add "TagValues", TagValues
  add(query_595411, "Version", newJString(Version))
  add(formData_595412, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_595410.call(nil, query_595411, nil, formData_595412, nil)

var postDescribeClusterSubnetGroups* = Call_PostDescribeClusterSubnetGroups_595392(
    name: "postDescribeClusterSubnetGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_PostDescribeClusterSubnetGroups_595393, base: "/",
    url: url_PostDescribeClusterSubnetGroups_595394,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSubnetGroups_595372 = ref object of OpenApiRestCall_593421
proc url_GetDescribeClusterSubnetGroups_595374(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterSubnetGroups_595373(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595375 = query.getOrDefault("TagValues")
  valid_595375 = validateParameter(valid_595375, JArray, required = false,
                                 default = nil)
  if valid_595375 != nil:
    section.add "TagValues", valid_595375
  var valid_595376 = query.getOrDefault("ClusterSubnetGroupName")
  valid_595376 = validateParameter(valid_595376, JString, required = false,
                                 default = nil)
  if valid_595376 != nil:
    section.add "ClusterSubnetGroupName", valid_595376
  var valid_595377 = query.getOrDefault("MaxRecords")
  valid_595377 = validateParameter(valid_595377, JInt, required = false, default = nil)
  if valid_595377 != nil:
    section.add "MaxRecords", valid_595377
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595378 = query.getOrDefault("Action")
  valid_595378 = validateParameter(valid_595378, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_595378 != nil:
    section.add "Action", valid_595378
  var valid_595379 = query.getOrDefault("Marker")
  valid_595379 = validateParameter(valid_595379, JString, required = false,
                                 default = nil)
  if valid_595379 != nil:
    section.add "Marker", valid_595379
  var valid_595380 = query.getOrDefault("TagKeys")
  valid_595380 = validateParameter(valid_595380, JArray, required = false,
                                 default = nil)
  if valid_595380 != nil:
    section.add "TagKeys", valid_595380
  var valid_595381 = query.getOrDefault("Version")
  valid_595381 = validateParameter(valid_595381, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595381 != nil:
    section.add "Version", valid_595381
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595382 = header.getOrDefault("X-Amz-Date")
  valid_595382 = validateParameter(valid_595382, JString, required = false,
                                 default = nil)
  if valid_595382 != nil:
    section.add "X-Amz-Date", valid_595382
  var valid_595383 = header.getOrDefault("X-Amz-Security-Token")
  valid_595383 = validateParameter(valid_595383, JString, required = false,
                                 default = nil)
  if valid_595383 != nil:
    section.add "X-Amz-Security-Token", valid_595383
  var valid_595384 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595384 = validateParameter(valid_595384, JString, required = false,
                                 default = nil)
  if valid_595384 != nil:
    section.add "X-Amz-Content-Sha256", valid_595384
  var valid_595385 = header.getOrDefault("X-Amz-Algorithm")
  valid_595385 = validateParameter(valid_595385, JString, required = false,
                                 default = nil)
  if valid_595385 != nil:
    section.add "X-Amz-Algorithm", valid_595385
  var valid_595386 = header.getOrDefault("X-Amz-Signature")
  valid_595386 = validateParameter(valid_595386, JString, required = false,
                                 default = nil)
  if valid_595386 != nil:
    section.add "X-Amz-Signature", valid_595386
  var valid_595387 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595387 = validateParameter(valid_595387, JString, required = false,
                                 default = nil)
  if valid_595387 != nil:
    section.add "X-Amz-SignedHeaders", valid_595387
  var valid_595388 = header.getOrDefault("X-Amz-Credential")
  valid_595388 = validateParameter(valid_595388, JString, required = false,
                                 default = nil)
  if valid_595388 != nil:
    section.add "X-Amz-Credential", valid_595388
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595389: Call_GetDescribeClusterSubnetGroups_595372; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595389.validator(path, query, header, formData, body)
  let scheme = call_595389.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595389.url(scheme.get, call_595389.host, call_595389.base,
                         call_595389.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595389, url, valid)

proc call*(call_595390: Call_GetDescribeClusterSubnetGroups_595372;
          TagValues: JsonNode = nil; ClusterSubnetGroupName: string = "";
          MaxRecords: int = 0; Action: string = "DescribeClusterSubnetGroups";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_595391 = newJObject()
  if TagValues != nil:
    query_595391.add "TagValues", TagValues
  add(query_595391, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_595391, "MaxRecords", newJInt(MaxRecords))
  add(query_595391, "Action", newJString(Action))
  add(query_595391, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_595391.add "TagKeys", TagKeys
  add(query_595391, "Version", newJString(Version))
  result = call_595390.call(nil, query_595391, nil, nil, nil)

var getDescribeClusterSubnetGroups* = Call_GetDescribeClusterSubnetGroups_595372(
    name: "getDescribeClusterSubnetGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_GetDescribeClusterSubnetGroups_595373, base: "/",
    url: url_GetDescribeClusterSubnetGroups_595374,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterTracks_595431 = ref object of OpenApiRestCall_593421
proc url_PostDescribeClusterTracks_595433(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterTracks_595432(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595434 = query.getOrDefault("Action")
  valid_595434 = validateParameter(valid_595434, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_595434 != nil:
    section.add "Action", valid_595434
  var valid_595435 = query.getOrDefault("Version")
  valid_595435 = validateParameter(valid_595435, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595435 != nil:
    section.add "Version", valid_595435
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595436 = header.getOrDefault("X-Amz-Date")
  valid_595436 = validateParameter(valid_595436, JString, required = false,
                                 default = nil)
  if valid_595436 != nil:
    section.add "X-Amz-Date", valid_595436
  var valid_595437 = header.getOrDefault("X-Amz-Security-Token")
  valid_595437 = validateParameter(valid_595437, JString, required = false,
                                 default = nil)
  if valid_595437 != nil:
    section.add "X-Amz-Security-Token", valid_595437
  var valid_595438 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595438 = validateParameter(valid_595438, JString, required = false,
                                 default = nil)
  if valid_595438 != nil:
    section.add "X-Amz-Content-Sha256", valid_595438
  var valid_595439 = header.getOrDefault("X-Amz-Algorithm")
  valid_595439 = validateParameter(valid_595439, JString, required = false,
                                 default = nil)
  if valid_595439 != nil:
    section.add "X-Amz-Algorithm", valid_595439
  var valid_595440 = header.getOrDefault("X-Amz-Signature")
  valid_595440 = validateParameter(valid_595440, JString, required = false,
                                 default = nil)
  if valid_595440 != nil:
    section.add "X-Amz-Signature", valid_595440
  var valid_595441 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595441 = validateParameter(valid_595441, JString, required = false,
                                 default = nil)
  if valid_595441 != nil:
    section.add "X-Amz-SignedHeaders", valid_595441
  var valid_595442 = header.getOrDefault("X-Amz-Credential")
  valid_595442 = validateParameter(valid_595442, JString, required = false,
                                 default = nil)
  if valid_595442 != nil:
    section.add "X-Amz-Credential", valid_595442
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  section = newJObject()
  var valid_595443 = formData.getOrDefault("Marker")
  valid_595443 = validateParameter(valid_595443, JString, required = false,
                                 default = nil)
  if valid_595443 != nil:
    section.add "Marker", valid_595443
  var valid_595444 = formData.getOrDefault("MaxRecords")
  valid_595444 = validateParameter(valid_595444, JInt, required = false, default = nil)
  if valid_595444 != nil:
    section.add "MaxRecords", valid_595444
  var valid_595445 = formData.getOrDefault("MaintenanceTrackName")
  valid_595445 = validateParameter(valid_595445, JString, required = false,
                                 default = nil)
  if valid_595445 != nil:
    section.add "MaintenanceTrackName", valid_595445
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595446: Call_PostDescribeClusterTracks_595431; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_595446.validator(path, query, header, formData, body)
  let scheme = call_595446.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595446.url(scheme.get, call_595446.host, call_595446.base,
                         call_595446.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595446, url, valid)

proc call*(call_595447: Call_PostDescribeClusterTracks_595431; Marker: string = "";
          Action: string = "DescribeClusterTracks"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; MaintenanceTrackName: string = ""): Recallable =
  ## postDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Version: string (required)
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  var query_595448 = newJObject()
  var formData_595449 = newJObject()
  add(formData_595449, "Marker", newJString(Marker))
  add(query_595448, "Action", newJString(Action))
  add(formData_595449, "MaxRecords", newJInt(MaxRecords))
  add(query_595448, "Version", newJString(Version))
  add(formData_595449, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  result = call_595447.call(nil, query_595448, nil, formData_595449, nil)

var postDescribeClusterTracks* = Call_PostDescribeClusterTracks_595431(
    name: "postDescribeClusterTracks", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_PostDescribeClusterTracks_595432, base: "/",
    url: url_PostDescribeClusterTracks_595433,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterTracks_595413 = ref object of OpenApiRestCall_593421
proc url_GetDescribeClusterTracks_595415(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterTracks_595414(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_595416 = query.getOrDefault("MaintenanceTrackName")
  valid_595416 = validateParameter(valid_595416, JString, required = false,
                                 default = nil)
  if valid_595416 != nil:
    section.add "MaintenanceTrackName", valid_595416
  var valid_595417 = query.getOrDefault("MaxRecords")
  valid_595417 = validateParameter(valid_595417, JInt, required = false, default = nil)
  if valid_595417 != nil:
    section.add "MaxRecords", valid_595417
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595418 = query.getOrDefault("Action")
  valid_595418 = validateParameter(valid_595418, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_595418 != nil:
    section.add "Action", valid_595418
  var valid_595419 = query.getOrDefault("Marker")
  valid_595419 = validateParameter(valid_595419, JString, required = false,
                                 default = nil)
  if valid_595419 != nil:
    section.add "Marker", valid_595419
  var valid_595420 = query.getOrDefault("Version")
  valid_595420 = validateParameter(valid_595420, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595420 != nil:
    section.add "Version", valid_595420
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595421 = header.getOrDefault("X-Amz-Date")
  valid_595421 = validateParameter(valid_595421, JString, required = false,
                                 default = nil)
  if valid_595421 != nil:
    section.add "X-Amz-Date", valid_595421
  var valid_595422 = header.getOrDefault("X-Amz-Security-Token")
  valid_595422 = validateParameter(valid_595422, JString, required = false,
                                 default = nil)
  if valid_595422 != nil:
    section.add "X-Amz-Security-Token", valid_595422
  var valid_595423 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595423 = validateParameter(valid_595423, JString, required = false,
                                 default = nil)
  if valid_595423 != nil:
    section.add "X-Amz-Content-Sha256", valid_595423
  var valid_595424 = header.getOrDefault("X-Amz-Algorithm")
  valid_595424 = validateParameter(valid_595424, JString, required = false,
                                 default = nil)
  if valid_595424 != nil:
    section.add "X-Amz-Algorithm", valid_595424
  var valid_595425 = header.getOrDefault("X-Amz-Signature")
  valid_595425 = validateParameter(valid_595425, JString, required = false,
                                 default = nil)
  if valid_595425 != nil:
    section.add "X-Amz-Signature", valid_595425
  var valid_595426 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595426 = validateParameter(valid_595426, JString, required = false,
                                 default = nil)
  if valid_595426 != nil:
    section.add "X-Amz-SignedHeaders", valid_595426
  var valid_595427 = header.getOrDefault("X-Amz-Credential")
  valid_595427 = validateParameter(valid_595427, JString, required = false,
                                 default = nil)
  if valid_595427 != nil:
    section.add "X-Amz-Credential", valid_595427
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595428: Call_GetDescribeClusterTracks_595413; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_595428.validator(path, query, header, formData, body)
  let scheme = call_595428.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595428.url(scheme.get, call_595428.host, call_595428.base,
                         call_595428.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595428, url, valid)

proc call*(call_595429: Call_GetDescribeClusterTracks_595413;
          MaintenanceTrackName: string = ""; MaxRecords: int = 0;
          Action: string = "DescribeClusterTracks"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  var query_595430 = newJObject()
  add(query_595430, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_595430, "MaxRecords", newJInt(MaxRecords))
  add(query_595430, "Action", newJString(Action))
  add(query_595430, "Marker", newJString(Marker))
  add(query_595430, "Version", newJString(Version))
  result = call_595429.call(nil, query_595430, nil, nil, nil)

var getDescribeClusterTracks* = Call_GetDescribeClusterTracks_595413(
    name: "getDescribeClusterTracks", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_GetDescribeClusterTracks_595414, base: "/",
    url: url_GetDescribeClusterTracks_595415, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterVersions_595469 = ref object of OpenApiRestCall_593421
proc url_PostDescribeClusterVersions_595471(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterVersions_595470(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595472 = query.getOrDefault("Action")
  valid_595472 = validateParameter(valid_595472, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_595472 != nil:
    section.add "Action", valid_595472
  var valid_595473 = query.getOrDefault("Version")
  valid_595473 = validateParameter(valid_595473, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595473 != nil:
    section.add "Version", valid_595473
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595474 = header.getOrDefault("X-Amz-Date")
  valid_595474 = validateParameter(valid_595474, JString, required = false,
                                 default = nil)
  if valid_595474 != nil:
    section.add "X-Amz-Date", valid_595474
  var valid_595475 = header.getOrDefault("X-Amz-Security-Token")
  valid_595475 = validateParameter(valid_595475, JString, required = false,
                                 default = nil)
  if valid_595475 != nil:
    section.add "X-Amz-Security-Token", valid_595475
  var valid_595476 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595476 = validateParameter(valid_595476, JString, required = false,
                                 default = nil)
  if valid_595476 != nil:
    section.add "X-Amz-Content-Sha256", valid_595476
  var valid_595477 = header.getOrDefault("X-Amz-Algorithm")
  valid_595477 = validateParameter(valid_595477, JString, required = false,
                                 default = nil)
  if valid_595477 != nil:
    section.add "X-Amz-Algorithm", valid_595477
  var valid_595478 = header.getOrDefault("X-Amz-Signature")
  valid_595478 = validateParameter(valid_595478, JString, required = false,
                                 default = nil)
  if valid_595478 != nil:
    section.add "X-Amz-Signature", valid_595478
  var valid_595479 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595479 = validateParameter(valid_595479, JString, required = false,
                                 default = nil)
  if valid_595479 != nil:
    section.add "X-Amz-SignedHeaders", valid_595479
  var valid_595480 = header.getOrDefault("X-Amz-Credential")
  valid_595480 = validateParameter(valid_595480, JString, required = false,
                                 default = nil)
  if valid_595480 != nil:
    section.add "X-Amz-Credential", valid_595480
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_595481 = formData.getOrDefault("ClusterVersion")
  valid_595481 = validateParameter(valid_595481, JString, required = false,
                                 default = nil)
  if valid_595481 != nil:
    section.add "ClusterVersion", valid_595481
  var valid_595482 = formData.getOrDefault("Marker")
  valid_595482 = validateParameter(valid_595482, JString, required = false,
                                 default = nil)
  if valid_595482 != nil:
    section.add "Marker", valid_595482
  var valid_595483 = formData.getOrDefault("ClusterParameterGroupFamily")
  valid_595483 = validateParameter(valid_595483, JString, required = false,
                                 default = nil)
  if valid_595483 != nil:
    section.add "ClusterParameterGroupFamily", valid_595483
  var valid_595484 = formData.getOrDefault("MaxRecords")
  valid_595484 = validateParameter(valid_595484, JInt, required = false, default = nil)
  if valid_595484 != nil:
    section.add "MaxRecords", valid_595484
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595485: Call_PostDescribeClusterVersions_595469; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_595485.validator(path, query, header, formData, body)
  let scheme = call_595485.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595485.url(scheme.get, call_595485.host, call_595485.base,
                         call_595485.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595485, url, valid)

proc call*(call_595486: Call_PostDescribeClusterVersions_595469;
          ClusterVersion: string = ""; Marker: string = "";
          Action: string = "DescribeClusterVersions";
          ClusterParameterGroupFamily: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_595487 = newJObject()
  var formData_595488 = newJObject()
  add(formData_595488, "ClusterVersion", newJString(ClusterVersion))
  add(formData_595488, "Marker", newJString(Marker))
  add(query_595487, "Action", newJString(Action))
  add(formData_595488, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(formData_595488, "MaxRecords", newJInt(MaxRecords))
  add(query_595487, "Version", newJString(Version))
  result = call_595486.call(nil, query_595487, nil, formData_595488, nil)

var postDescribeClusterVersions* = Call_PostDescribeClusterVersions_595469(
    name: "postDescribeClusterVersions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_PostDescribeClusterVersions_595470, base: "/",
    url: url_PostDescribeClusterVersions_595471,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterVersions_595450 = ref object of OpenApiRestCall_593421
proc url_GetDescribeClusterVersions_595452(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterVersions_595451(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  section = newJObject()
  var valid_595453 = query.getOrDefault("MaxRecords")
  valid_595453 = validateParameter(valid_595453, JInt, required = false, default = nil)
  if valid_595453 != nil:
    section.add "MaxRecords", valid_595453
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595454 = query.getOrDefault("Action")
  valid_595454 = validateParameter(valid_595454, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_595454 != nil:
    section.add "Action", valid_595454
  var valid_595455 = query.getOrDefault("Marker")
  valid_595455 = validateParameter(valid_595455, JString, required = false,
                                 default = nil)
  if valid_595455 != nil:
    section.add "Marker", valid_595455
  var valid_595456 = query.getOrDefault("ClusterVersion")
  valid_595456 = validateParameter(valid_595456, JString, required = false,
                                 default = nil)
  if valid_595456 != nil:
    section.add "ClusterVersion", valid_595456
  var valid_595457 = query.getOrDefault("Version")
  valid_595457 = validateParameter(valid_595457, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595457 != nil:
    section.add "Version", valid_595457
  var valid_595458 = query.getOrDefault("ClusterParameterGroupFamily")
  valid_595458 = validateParameter(valid_595458, JString, required = false,
                                 default = nil)
  if valid_595458 != nil:
    section.add "ClusterParameterGroupFamily", valid_595458
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595459 = header.getOrDefault("X-Amz-Date")
  valid_595459 = validateParameter(valid_595459, JString, required = false,
                                 default = nil)
  if valid_595459 != nil:
    section.add "X-Amz-Date", valid_595459
  var valid_595460 = header.getOrDefault("X-Amz-Security-Token")
  valid_595460 = validateParameter(valid_595460, JString, required = false,
                                 default = nil)
  if valid_595460 != nil:
    section.add "X-Amz-Security-Token", valid_595460
  var valid_595461 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595461 = validateParameter(valid_595461, JString, required = false,
                                 default = nil)
  if valid_595461 != nil:
    section.add "X-Amz-Content-Sha256", valid_595461
  var valid_595462 = header.getOrDefault("X-Amz-Algorithm")
  valid_595462 = validateParameter(valid_595462, JString, required = false,
                                 default = nil)
  if valid_595462 != nil:
    section.add "X-Amz-Algorithm", valid_595462
  var valid_595463 = header.getOrDefault("X-Amz-Signature")
  valid_595463 = validateParameter(valid_595463, JString, required = false,
                                 default = nil)
  if valid_595463 != nil:
    section.add "X-Amz-Signature", valid_595463
  var valid_595464 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595464 = validateParameter(valid_595464, JString, required = false,
                                 default = nil)
  if valid_595464 != nil:
    section.add "X-Amz-SignedHeaders", valid_595464
  var valid_595465 = header.getOrDefault("X-Amz-Credential")
  valid_595465 = validateParameter(valid_595465, JString, required = false,
                                 default = nil)
  if valid_595465 != nil:
    section.add "X-Amz-Credential", valid_595465
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595466: Call_GetDescribeClusterVersions_595450; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_595466.validator(path, query, header, formData, body)
  let scheme = call_595466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595466.url(scheme.get, call_595466.host, call_595466.base,
                         call_595466.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595466, url, valid)

proc call*(call_595467: Call_GetDescribeClusterVersions_595450;
          MaxRecords: int = 0; Action: string = "DescribeClusterVersions";
          Marker: string = ""; ClusterVersion: string = "";
          Version: string = "2012-12-01"; ClusterParameterGroupFamily: string = ""): Recallable =
  ## getDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  var query_595468 = newJObject()
  add(query_595468, "MaxRecords", newJInt(MaxRecords))
  add(query_595468, "Action", newJString(Action))
  add(query_595468, "Marker", newJString(Marker))
  add(query_595468, "ClusterVersion", newJString(ClusterVersion))
  add(query_595468, "Version", newJString(Version))
  add(query_595468, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  result = call_595467.call(nil, query_595468, nil, nil, nil)

var getDescribeClusterVersions* = Call_GetDescribeClusterVersions_595450(
    name: "getDescribeClusterVersions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_GetDescribeClusterVersions_595451, base: "/",
    url: url_GetDescribeClusterVersions_595452,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusters_595509 = ref object of OpenApiRestCall_593421
proc url_PostDescribeClusters_595511(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusters_595510(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595512 = query.getOrDefault("Action")
  valid_595512 = validateParameter(valid_595512, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_595512 != nil:
    section.add "Action", valid_595512
  var valid_595513 = query.getOrDefault("Version")
  valid_595513 = validateParameter(valid_595513, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595513 != nil:
    section.add "Version", valid_595513
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595514 = header.getOrDefault("X-Amz-Date")
  valid_595514 = validateParameter(valid_595514, JString, required = false,
                                 default = nil)
  if valid_595514 != nil:
    section.add "X-Amz-Date", valid_595514
  var valid_595515 = header.getOrDefault("X-Amz-Security-Token")
  valid_595515 = validateParameter(valid_595515, JString, required = false,
                                 default = nil)
  if valid_595515 != nil:
    section.add "X-Amz-Security-Token", valid_595515
  var valid_595516 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595516 = validateParameter(valid_595516, JString, required = false,
                                 default = nil)
  if valid_595516 != nil:
    section.add "X-Amz-Content-Sha256", valid_595516
  var valid_595517 = header.getOrDefault("X-Amz-Algorithm")
  valid_595517 = validateParameter(valid_595517, JString, required = false,
                                 default = nil)
  if valid_595517 != nil:
    section.add "X-Amz-Algorithm", valid_595517
  var valid_595518 = header.getOrDefault("X-Amz-Signature")
  valid_595518 = validateParameter(valid_595518, JString, required = false,
                                 default = nil)
  if valid_595518 != nil:
    section.add "X-Amz-Signature", valid_595518
  var valid_595519 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595519 = validateParameter(valid_595519, JString, required = false,
                                 default = nil)
  if valid_595519 != nil:
    section.add "X-Amz-SignedHeaders", valid_595519
  var valid_595520 = header.getOrDefault("X-Amz-Credential")
  valid_595520 = validateParameter(valid_595520, JString, required = false,
                                 default = nil)
  if valid_595520 != nil:
    section.add "X-Amz-Credential", valid_595520
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_595521 = formData.getOrDefault("Marker")
  valid_595521 = validateParameter(valid_595521, JString, required = false,
                                 default = nil)
  if valid_595521 != nil:
    section.add "Marker", valid_595521
  var valid_595522 = formData.getOrDefault("ClusterIdentifier")
  valid_595522 = validateParameter(valid_595522, JString, required = false,
                                 default = nil)
  if valid_595522 != nil:
    section.add "ClusterIdentifier", valid_595522
  var valid_595523 = formData.getOrDefault("TagKeys")
  valid_595523 = validateParameter(valid_595523, JArray, required = false,
                                 default = nil)
  if valid_595523 != nil:
    section.add "TagKeys", valid_595523
  var valid_595524 = formData.getOrDefault("MaxRecords")
  valid_595524 = validateParameter(valid_595524, JInt, required = false, default = nil)
  if valid_595524 != nil:
    section.add "MaxRecords", valid_595524
  var valid_595525 = formData.getOrDefault("TagValues")
  valid_595525 = validateParameter(valid_595525, JArray, required = false,
                                 default = nil)
  if valid_595525 != nil:
    section.add "TagValues", valid_595525
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595526: Call_PostDescribeClusters_595509; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595526.validator(path, query, header, formData, body)
  let scheme = call_595526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595526.url(scheme.get, call_595526.host, call_595526.base,
                         call_595526.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595526, url, valid)

proc call*(call_595527: Call_PostDescribeClusters_595509; Marker: string = "";
          Action: string = "DescribeClusters"; ClusterIdentifier: string = "";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_595528 = newJObject()
  var formData_595529 = newJObject()
  add(formData_595529, "Marker", newJString(Marker))
  add(query_595528, "Action", newJString(Action))
  add(formData_595529, "ClusterIdentifier", newJString(ClusterIdentifier))
  if TagKeys != nil:
    formData_595529.add "TagKeys", TagKeys
  add(formData_595529, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_595529.add "TagValues", TagValues
  add(query_595528, "Version", newJString(Version))
  result = call_595527.call(nil, query_595528, nil, formData_595529, nil)

var postDescribeClusters* = Call_PostDescribeClusters_595509(
    name: "postDescribeClusters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_PostDescribeClusters_595510, base: "/",
    url: url_PostDescribeClusters_595511, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusters_595489 = ref object of OpenApiRestCall_593421
proc url_GetDescribeClusters_595491(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusters_595490(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595492 = query.getOrDefault("TagValues")
  valid_595492 = validateParameter(valid_595492, JArray, required = false,
                                 default = nil)
  if valid_595492 != nil:
    section.add "TagValues", valid_595492
  var valid_595493 = query.getOrDefault("MaxRecords")
  valid_595493 = validateParameter(valid_595493, JInt, required = false, default = nil)
  if valid_595493 != nil:
    section.add "MaxRecords", valid_595493
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595494 = query.getOrDefault("Action")
  valid_595494 = validateParameter(valid_595494, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_595494 != nil:
    section.add "Action", valid_595494
  var valid_595495 = query.getOrDefault("ClusterIdentifier")
  valid_595495 = validateParameter(valid_595495, JString, required = false,
                                 default = nil)
  if valid_595495 != nil:
    section.add "ClusterIdentifier", valid_595495
  var valid_595496 = query.getOrDefault("Marker")
  valid_595496 = validateParameter(valid_595496, JString, required = false,
                                 default = nil)
  if valid_595496 != nil:
    section.add "Marker", valid_595496
  var valid_595497 = query.getOrDefault("TagKeys")
  valid_595497 = validateParameter(valid_595497, JArray, required = false,
                                 default = nil)
  if valid_595497 != nil:
    section.add "TagKeys", valid_595497
  var valid_595498 = query.getOrDefault("Version")
  valid_595498 = validateParameter(valid_595498, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595498 != nil:
    section.add "Version", valid_595498
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595499 = header.getOrDefault("X-Amz-Date")
  valid_595499 = validateParameter(valid_595499, JString, required = false,
                                 default = nil)
  if valid_595499 != nil:
    section.add "X-Amz-Date", valid_595499
  var valid_595500 = header.getOrDefault("X-Amz-Security-Token")
  valid_595500 = validateParameter(valid_595500, JString, required = false,
                                 default = nil)
  if valid_595500 != nil:
    section.add "X-Amz-Security-Token", valid_595500
  var valid_595501 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595501 = validateParameter(valid_595501, JString, required = false,
                                 default = nil)
  if valid_595501 != nil:
    section.add "X-Amz-Content-Sha256", valid_595501
  var valid_595502 = header.getOrDefault("X-Amz-Algorithm")
  valid_595502 = validateParameter(valid_595502, JString, required = false,
                                 default = nil)
  if valid_595502 != nil:
    section.add "X-Amz-Algorithm", valid_595502
  var valid_595503 = header.getOrDefault("X-Amz-Signature")
  valid_595503 = validateParameter(valid_595503, JString, required = false,
                                 default = nil)
  if valid_595503 != nil:
    section.add "X-Amz-Signature", valid_595503
  var valid_595504 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595504 = validateParameter(valid_595504, JString, required = false,
                                 default = nil)
  if valid_595504 != nil:
    section.add "X-Amz-SignedHeaders", valid_595504
  var valid_595505 = header.getOrDefault("X-Amz-Credential")
  valid_595505 = validateParameter(valid_595505, JString, required = false,
                                 default = nil)
  if valid_595505 != nil:
    section.add "X-Amz-Credential", valid_595505
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595506: Call_GetDescribeClusters_595489; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595506.validator(path, query, header, formData, body)
  let scheme = call_595506.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595506.url(scheme.get, call_595506.host, call_595506.base,
                         call_595506.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595506, url, valid)

proc call*(call_595507: Call_GetDescribeClusters_595489; TagValues: JsonNode = nil;
          MaxRecords: int = 0; Action: string = "DescribeClusters";
          ClusterIdentifier: string = ""; Marker: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_595508 = newJObject()
  if TagValues != nil:
    query_595508.add "TagValues", TagValues
  add(query_595508, "MaxRecords", newJInt(MaxRecords))
  add(query_595508, "Action", newJString(Action))
  add(query_595508, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595508, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_595508.add "TagKeys", TagKeys
  add(query_595508, "Version", newJString(Version))
  result = call_595507.call(nil, query_595508, nil, nil, nil)

var getDescribeClusters* = Call_GetDescribeClusters_595489(
    name: "getDescribeClusters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_GetDescribeClusters_595490, base: "/",
    url: url_GetDescribeClusters_595491, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeDefaultClusterParameters_595548 = ref object of OpenApiRestCall_593421
proc url_PostDescribeDefaultClusterParameters_595550(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeDefaultClusterParameters_595549(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595551 = query.getOrDefault("Action")
  valid_595551 = validateParameter(valid_595551, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_595551 != nil:
    section.add "Action", valid_595551
  var valid_595552 = query.getOrDefault("Version")
  valid_595552 = validateParameter(valid_595552, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595552 != nil:
    section.add "Version", valid_595552
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595553 = header.getOrDefault("X-Amz-Date")
  valid_595553 = validateParameter(valid_595553, JString, required = false,
                                 default = nil)
  if valid_595553 != nil:
    section.add "X-Amz-Date", valid_595553
  var valid_595554 = header.getOrDefault("X-Amz-Security-Token")
  valid_595554 = validateParameter(valid_595554, JString, required = false,
                                 default = nil)
  if valid_595554 != nil:
    section.add "X-Amz-Security-Token", valid_595554
  var valid_595555 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595555 = validateParameter(valid_595555, JString, required = false,
                                 default = nil)
  if valid_595555 != nil:
    section.add "X-Amz-Content-Sha256", valid_595555
  var valid_595556 = header.getOrDefault("X-Amz-Algorithm")
  valid_595556 = validateParameter(valid_595556, JString, required = false,
                                 default = nil)
  if valid_595556 != nil:
    section.add "X-Amz-Algorithm", valid_595556
  var valid_595557 = header.getOrDefault("X-Amz-Signature")
  valid_595557 = validateParameter(valid_595557, JString, required = false,
                                 default = nil)
  if valid_595557 != nil:
    section.add "X-Amz-Signature", valid_595557
  var valid_595558 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595558 = validateParameter(valid_595558, JString, required = false,
                                 default = nil)
  if valid_595558 != nil:
    section.add "X-Amz-SignedHeaders", valid_595558
  var valid_595559 = header.getOrDefault("X-Amz-Credential")
  valid_595559 = validateParameter(valid_595559, JString, required = false,
                                 default = nil)
  if valid_595559 != nil:
    section.add "X-Amz-Credential", valid_595559
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_595560 = formData.getOrDefault("Marker")
  valid_595560 = validateParameter(valid_595560, JString, required = false,
                                 default = nil)
  if valid_595560 != nil:
    section.add "Marker", valid_595560
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupFamily` field"
  var valid_595561 = formData.getOrDefault("ParameterGroupFamily")
  valid_595561 = validateParameter(valid_595561, JString, required = true,
                                 default = nil)
  if valid_595561 != nil:
    section.add "ParameterGroupFamily", valid_595561
  var valid_595562 = formData.getOrDefault("MaxRecords")
  valid_595562 = validateParameter(valid_595562, JInt, required = false, default = nil)
  if valid_595562 != nil:
    section.add "MaxRecords", valid_595562
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595563: Call_PostDescribeDefaultClusterParameters_595548;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_595563.validator(path, query, header, formData, body)
  let scheme = call_595563.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595563.url(scheme.get, call_595563.host, call_595563.base,
                         call_595563.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595563, url, valid)

proc call*(call_595564: Call_PostDescribeDefaultClusterParameters_595548;
          ParameterGroupFamily: string; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_595565 = newJObject()
  var formData_595566 = newJObject()
  add(formData_595566, "Marker", newJString(Marker))
  add(query_595565, "Action", newJString(Action))
  add(formData_595566, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(formData_595566, "MaxRecords", newJInt(MaxRecords))
  add(query_595565, "Version", newJString(Version))
  result = call_595564.call(nil, query_595565, nil, formData_595566, nil)

var postDescribeDefaultClusterParameters* = Call_PostDescribeDefaultClusterParameters_595548(
    name: "postDescribeDefaultClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_PostDescribeDefaultClusterParameters_595549, base: "/",
    url: url_PostDescribeDefaultClusterParameters_595550,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeDefaultClusterParameters_595530 = ref object of OpenApiRestCall_593421
proc url_GetDescribeDefaultClusterParameters_595532(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeDefaultClusterParameters_595531(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595533 = query.getOrDefault("MaxRecords")
  valid_595533 = validateParameter(valid_595533, JInt, required = false, default = nil)
  if valid_595533 != nil:
    section.add "MaxRecords", valid_595533
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595534 = query.getOrDefault("Action")
  valid_595534 = validateParameter(valid_595534, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_595534 != nil:
    section.add "Action", valid_595534
  var valid_595535 = query.getOrDefault("Marker")
  valid_595535 = validateParameter(valid_595535, JString, required = false,
                                 default = nil)
  if valid_595535 != nil:
    section.add "Marker", valid_595535
  var valid_595536 = query.getOrDefault("ParameterGroupFamily")
  valid_595536 = validateParameter(valid_595536, JString, required = true,
                                 default = nil)
  if valid_595536 != nil:
    section.add "ParameterGroupFamily", valid_595536
  var valid_595537 = query.getOrDefault("Version")
  valid_595537 = validateParameter(valid_595537, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595537 != nil:
    section.add "Version", valid_595537
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595538 = header.getOrDefault("X-Amz-Date")
  valid_595538 = validateParameter(valid_595538, JString, required = false,
                                 default = nil)
  if valid_595538 != nil:
    section.add "X-Amz-Date", valid_595538
  var valid_595539 = header.getOrDefault("X-Amz-Security-Token")
  valid_595539 = validateParameter(valid_595539, JString, required = false,
                                 default = nil)
  if valid_595539 != nil:
    section.add "X-Amz-Security-Token", valid_595539
  var valid_595540 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595540 = validateParameter(valid_595540, JString, required = false,
                                 default = nil)
  if valid_595540 != nil:
    section.add "X-Amz-Content-Sha256", valid_595540
  var valid_595541 = header.getOrDefault("X-Amz-Algorithm")
  valid_595541 = validateParameter(valid_595541, JString, required = false,
                                 default = nil)
  if valid_595541 != nil:
    section.add "X-Amz-Algorithm", valid_595541
  var valid_595542 = header.getOrDefault("X-Amz-Signature")
  valid_595542 = validateParameter(valid_595542, JString, required = false,
                                 default = nil)
  if valid_595542 != nil:
    section.add "X-Amz-Signature", valid_595542
  var valid_595543 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595543 = validateParameter(valid_595543, JString, required = false,
                                 default = nil)
  if valid_595543 != nil:
    section.add "X-Amz-SignedHeaders", valid_595543
  var valid_595544 = header.getOrDefault("X-Amz-Credential")
  valid_595544 = validateParameter(valid_595544, JString, required = false,
                                 default = nil)
  if valid_595544 != nil:
    section.add "X-Amz-Credential", valid_595544
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595545: Call_GetDescribeDefaultClusterParameters_595530;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_595545.validator(path, query, header, formData, body)
  let scheme = call_595545.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595545.url(scheme.get, call_595545.host, call_595545.base,
                         call_595545.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595545, url, valid)

proc call*(call_595546: Call_GetDescribeDefaultClusterParameters_595530;
          ParameterGroupFamily: string; MaxRecords: int = 0;
          Action: string = "DescribeDefaultClusterParameters"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Version: string (required)
  var query_595547 = newJObject()
  add(query_595547, "MaxRecords", newJInt(MaxRecords))
  add(query_595547, "Action", newJString(Action))
  add(query_595547, "Marker", newJString(Marker))
  add(query_595547, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_595547, "Version", newJString(Version))
  result = call_595546.call(nil, query_595547, nil, nil, nil)

var getDescribeDefaultClusterParameters* = Call_GetDescribeDefaultClusterParameters_595530(
    name: "getDescribeDefaultClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_GetDescribeDefaultClusterParameters_595531, base: "/",
    url: url_GetDescribeDefaultClusterParameters_595532,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventCategories_595583 = ref object of OpenApiRestCall_593421
proc url_PostDescribeEventCategories_595585(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeEventCategories_595584(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595586 = query.getOrDefault("Action")
  valid_595586 = validateParameter(valid_595586, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_595586 != nil:
    section.add "Action", valid_595586
  var valid_595587 = query.getOrDefault("Version")
  valid_595587 = validateParameter(valid_595587, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595587 != nil:
    section.add "Version", valid_595587
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595588 = header.getOrDefault("X-Amz-Date")
  valid_595588 = validateParameter(valid_595588, JString, required = false,
                                 default = nil)
  if valid_595588 != nil:
    section.add "X-Amz-Date", valid_595588
  var valid_595589 = header.getOrDefault("X-Amz-Security-Token")
  valid_595589 = validateParameter(valid_595589, JString, required = false,
                                 default = nil)
  if valid_595589 != nil:
    section.add "X-Amz-Security-Token", valid_595589
  var valid_595590 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595590 = validateParameter(valid_595590, JString, required = false,
                                 default = nil)
  if valid_595590 != nil:
    section.add "X-Amz-Content-Sha256", valid_595590
  var valid_595591 = header.getOrDefault("X-Amz-Algorithm")
  valid_595591 = validateParameter(valid_595591, JString, required = false,
                                 default = nil)
  if valid_595591 != nil:
    section.add "X-Amz-Algorithm", valid_595591
  var valid_595592 = header.getOrDefault("X-Amz-Signature")
  valid_595592 = validateParameter(valid_595592, JString, required = false,
                                 default = nil)
  if valid_595592 != nil:
    section.add "X-Amz-Signature", valid_595592
  var valid_595593 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595593 = validateParameter(valid_595593, JString, required = false,
                                 default = nil)
  if valid_595593 != nil:
    section.add "X-Amz-SignedHeaders", valid_595593
  var valid_595594 = header.getOrDefault("X-Amz-Credential")
  valid_595594 = validateParameter(valid_595594, JString, required = false,
                                 default = nil)
  if valid_595594 != nil:
    section.add "X-Amz-Credential", valid_595594
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  section = newJObject()
  var valid_595595 = formData.getOrDefault("SourceType")
  valid_595595 = validateParameter(valid_595595, JString, required = false,
                                 default = nil)
  if valid_595595 != nil:
    section.add "SourceType", valid_595595
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595596: Call_PostDescribeEventCategories_595583; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_595596.validator(path, query, header, formData, body)
  let scheme = call_595596.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595596.url(scheme.get, call_595596.host, call_595596.base,
                         call_595596.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595596, url, valid)

proc call*(call_595597: Call_PostDescribeEventCategories_595583;
          Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  var query_595598 = newJObject()
  var formData_595599 = newJObject()
  add(query_595598, "Action", newJString(Action))
  add(query_595598, "Version", newJString(Version))
  add(formData_595599, "SourceType", newJString(SourceType))
  result = call_595597.call(nil, query_595598, nil, formData_595599, nil)

var postDescribeEventCategories* = Call_PostDescribeEventCategories_595583(
    name: "postDescribeEventCategories", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_PostDescribeEventCategories_595584, base: "/",
    url: url_PostDescribeEventCategories_595585,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventCategories_595567 = ref object of OpenApiRestCall_593421
proc url_GetDescribeEventCategories_595569(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeEventCategories_595568(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_595570 = query.getOrDefault("SourceType")
  valid_595570 = validateParameter(valid_595570, JString, required = false,
                                 default = nil)
  if valid_595570 != nil:
    section.add "SourceType", valid_595570
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595571 = query.getOrDefault("Action")
  valid_595571 = validateParameter(valid_595571, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_595571 != nil:
    section.add "Action", valid_595571
  var valid_595572 = query.getOrDefault("Version")
  valid_595572 = validateParameter(valid_595572, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595572 != nil:
    section.add "Version", valid_595572
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595573 = header.getOrDefault("X-Amz-Date")
  valid_595573 = validateParameter(valid_595573, JString, required = false,
                                 default = nil)
  if valid_595573 != nil:
    section.add "X-Amz-Date", valid_595573
  var valid_595574 = header.getOrDefault("X-Amz-Security-Token")
  valid_595574 = validateParameter(valid_595574, JString, required = false,
                                 default = nil)
  if valid_595574 != nil:
    section.add "X-Amz-Security-Token", valid_595574
  var valid_595575 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595575 = validateParameter(valid_595575, JString, required = false,
                                 default = nil)
  if valid_595575 != nil:
    section.add "X-Amz-Content-Sha256", valid_595575
  var valid_595576 = header.getOrDefault("X-Amz-Algorithm")
  valid_595576 = validateParameter(valid_595576, JString, required = false,
                                 default = nil)
  if valid_595576 != nil:
    section.add "X-Amz-Algorithm", valid_595576
  var valid_595577 = header.getOrDefault("X-Amz-Signature")
  valid_595577 = validateParameter(valid_595577, JString, required = false,
                                 default = nil)
  if valid_595577 != nil:
    section.add "X-Amz-Signature", valid_595577
  var valid_595578 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595578 = validateParameter(valid_595578, JString, required = false,
                                 default = nil)
  if valid_595578 != nil:
    section.add "X-Amz-SignedHeaders", valid_595578
  var valid_595579 = header.getOrDefault("X-Amz-Credential")
  valid_595579 = validateParameter(valid_595579, JString, required = false,
                                 default = nil)
  if valid_595579 != nil:
    section.add "X-Amz-Credential", valid_595579
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595580: Call_GetDescribeEventCategories_595567; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_595580.validator(path, query, header, formData, body)
  let scheme = call_595580.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595580.url(scheme.get, call_595580.host, call_595580.base,
                         call_595580.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595580, url, valid)

proc call*(call_595581: Call_GetDescribeEventCategories_595567;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595582 = newJObject()
  add(query_595582, "SourceType", newJString(SourceType))
  add(query_595582, "Action", newJString(Action))
  add(query_595582, "Version", newJString(Version))
  result = call_595581.call(nil, query_595582, nil, nil, nil)

var getDescribeEventCategories* = Call_GetDescribeEventCategories_595567(
    name: "getDescribeEventCategories", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_GetDescribeEventCategories_595568, base: "/",
    url: url_GetDescribeEventCategories_595569,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventSubscriptions_595620 = ref object of OpenApiRestCall_593421
proc url_PostDescribeEventSubscriptions_595622(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeEventSubscriptions_595621(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595623 = query.getOrDefault("Action")
  valid_595623 = validateParameter(valid_595623, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_595623 != nil:
    section.add "Action", valid_595623
  var valid_595624 = query.getOrDefault("Version")
  valid_595624 = validateParameter(valid_595624, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595624 != nil:
    section.add "Version", valid_595624
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595625 = header.getOrDefault("X-Amz-Date")
  valid_595625 = validateParameter(valid_595625, JString, required = false,
                                 default = nil)
  if valid_595625 != nil:
    section.add "X-Amz-Date", valid_595625
  var valid_595626 = header.getOrDefault("X-Amz-Security-Token")
  valid_595626 = validateParameter(valid_595626, JString, required = false,
                                 default = nil)
  if valid_595626 != nil:
    section.add "X-Amz-Security-Token", valid_595626
  var valid_595627 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595627 = validateParameter(valid_595627, JString, required = false,
                                 default = nil)
  if valid_595627 != nil:
    section.add "X-Amz-Content-Sha256", valid_595627
  var valid_595628 = header.getOrDefault("X-Amz-Algorithm")
  valid_595628 = validateParameter(valid_595628, JString, required = false,
                                 default = nil)
  if valid_595628 != nil:
    section.add "X-Amz-Algorithm", valid_595628
  var valid_595629 = header.getOrDefault("X-Amz-Signature")
  valid_595629 = validateParameter(valid_595629, JString, required = false,
                                 default = nil)
  if valid_595629 != nil:
    section.add "X-Amz-Signature", valid_595629
  var valid_595630 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595630 = validateParameter(valid_595630, JString, required = false,
                                 default = nil)
  if valid_595630 != nil:
    section.add "X-Amz-SignedHeaders", valid_595630
  var valid_595631 = header.getOrDefault("X-Amz-Credential")
  valid_595631 = validateParameter(valid_595631, JString, required = false,
                                 default = nil)
  if valid_595631 != nil:
    section.add "X-Amz-Credential", valid_595631
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_595632 = formData.getOrDefault("Marker")
  valid_595632 = validateParameter(valid_595632, JString, required = false,
                                 default = nil)
  if valid_595632 != nil:
    section.add "Marker", valid_595632
  var valid_595633 = formData.getOrDefault("SubscriptionName")
  valid_595633 = validateParameter(valid_595633, JString, required = false,
                                 default = nil)
  if valid_595633 != nil:
    section.add "SubscriptionName", valid_595633
  var valid_595634 = formData.getOrDefault("TagKeys")
  valid_595634 = validateParameter(valid_595634, JArray, required = false,
                                 default = nil)
  if valid_595634 != nil:
    section.add "TagKeys", valid_595634
  var valid_595635 = formData.getOrDefault("MaxRecords")
  valid_595635 = validateParameter(valid_595635, JInt, required = false, default = nil)
  if valid_595635 != nil:
    section.add "MaxRecords", valid_595635
  var valid_595636 = formData.getOrDefault("TagValues")
  valid_595636 = validateParameter(valid_595636, JArray, required = false,
                                 default = nil)
  if valid_595636 != nil:
    section.add "TagValues", valid_595636
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595637: Call_PostDescribeEventSubscriptions_595620; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595637.validator(path, query, header, formData, body)
  let scheme = call_595637.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595637.url(scheme.get, call_595637.host, call_595637.base,
                         call_595637.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595637, url, valid)

proc call*(call_595638: Call_PostDescribeEventSubscriptions_595620;
          Marker: string = ""; SubscriptionName: string = "";
          Action: string = "DescribeEventSubscriptions"; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_595639 = newJObject()
  var formData_595640 = newJObject()
  add(formData_595640, "Marker", newJString(Marker))
  add(formData_595640, "SubscriptionName", newJString(SubscriptionName))
  add(query_595639, "Action", newJString(Action))
  if TagKeys != nil:
    formData_595640.add "TagKeys", TagKeys
  add(formData_595640, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_595640.add "TagValues", TagValues
  add(query_595639, "Version", newJString(Version))
  result = call_595638.call(nil, query_595639, nil, formData_595640, nil)

var postDescribeEventSubscriptions* = Call_PostDescribeEventSubscriptions_595620(
    name: "postDescribeEventSubscriptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_PostDescribeEventSubscriptions_595621, base: "/",
    url: url_PostDescribeEventSubscriptions_595622,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventSubscriptions_595600 = ref object of OpenApiRestCall_593421
proc url_GetDescribeEventSubscriptions_595602(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeEventSubscriptions_595601(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595603 = query.getOrDefault("TagValues")
  valid_595603 = validateParameter(valid_595603, JArray, required = false,
                                 default = nil)
  if valid_595603 != nil:
    section.add "TagValues", valid_595603
  var valid_595604 = query.getOrDefault("MaxRecords")
  valid_595604 = validateParameter(valid_595604, JInt, required = false, default = nil)
  if valid_595604 != nil:
    section.add "MaxRecords", valid_595604
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595605 = query.getOrDefault("Action")
  valid_595605 = validateParameter(valid_595605, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_595605 != nil:
    section.add "Action", valid_595605
  var valid_595606 = query.getOrDefault("Marker")
  valid_595606 = validateParameter(valid_595606, JString, required = false,
                                 default = nil)
  if valid_595606 != nil:
    section.add "Marker", valid_595606
  var valid_595607 = query.getOrDefault("SubscriptionName")
  valid_595607 = validateParameter(valid_595607, JString, required = false,
                                 default = nil)
  if valid_595607 != nil:
    section.add "SubscriptionName", valid_595607
  var valid_595608 = query.getOrDefault("TagKeys")
  valid_595608 = validateParameter(valid_595608, JArray, required = false,
                                 default = nil)
  if valid_595608 != nil:
    section.add "TagKeys", valid_595608
  var valid_595609 = query.getOrDefault("Version")
  valid_595609 = validateParameter(valid_595609, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595609 != nil:
    section.add "Version", valid_595609
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595610 = header.getOrDefault("X-Amz-Date")
  valid_595610 = validateParameter(valid_595610, JString, required = false,
                                 default = nil)
  if valid_595610 != nil:
    section.add "X-Amz-Date", valid_595610
  var valid_595611 = header.getOrDefault("X-Amz-Security-Token")
  valid_595611 = validateParameter(valid_595611, JString, required = false,
                                 default = nil)
  if valid_595611 != nil:
    section.add "X-Amz-Security-Token", valid_595611
  var valid_595612 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595612 = validateParameter(valid_595612, JString, required = false,
                                 default = nil)
  if valid_595612 != nil:
    section.add "X-Amz-Content-Sha256", valid_595612
  var valid_595613 = header.getOrDefault("X-Amz-Algorithm")
  valid_595613 = validateParameter(valid_595613, JString, required = false,
                                 default = nil)
  if valid_595613 != nil:
    section.add "X-Amz-Algorithm", valid_595613
  var valid_595614 = header.getOrDefault("X-Amz-Signature")
  valid_595614 = validateParameter(valid_595614, JString, required = false,
                                 default = nil)
  if valid_595614 != nil:
    section.add "X-Amz-Signature", valid_595614
  var valid_595615 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595615 = validateParameter(valid_595615, JString, required = false,
                                 default = nil)
  if valid_595615 != nil:
    section.add "X-Amz-SignedHeaders", valid_595615
  var valid_595616 = header.getOrDefault("X-Amz-Credential")
  valid_595616 = validateParameter(valid_595616, JString, required = false,
                                 default = nil)
  if valid_595616 != nil:
    section.add "X-Amz-Credential", valid_595616
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595617: Call_GetDescribeEventSubscriptions_595600; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595617.validator(path, query, header, formData, body)
  let scheme = call_595617.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595617.url(scheme.get, call_595617.host, call_595617.base,
                         call_595617.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595617, url, valid)

proc call*(call_595618: Call_GetDescribeEventSubscriptions_595600;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeEventSubscriptions"; Marker: string = "";
          SubscriptionName: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_595619 = newJObject()
  if TagValues != nil:
    query_595619.add "TagValues", TagValues
  add(query_595619, "MaxRecords", newJInt(MaxRecords))
  add(query_595619, "Action", newJString(Action))
  add(query_595619, "Marker", newJString(Marker))
  add(query_595619, "SubscriptionName", newJString(SubscriptionName))
  if TagKeys != nil:
    query_595619.add "TagKeys", TagKeys
  add(query_595619, "Version", newJString(Version))
  result = call_595618.call(nil, query_595619, nil, nil, nil)

var getDescribeEventSubscriptions* = Call_GetDescribeEventSubscriptions_595600(
    name: "getDescribeEventSubscriptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_GetDescribeEventSubscriptions_595601, base: "/",
    url: url_GetDescribeEventSubscriptions_595602,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEvents_595663 = ref object of OpenApiRestCall_593421
proc url_PostDescribeEvents_595665(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeEvents_595664(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595666 = query.getOrDefault("Action")
  valid_595666 = validateParameter(valid_595666, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_595666 != nil:
    section.add "Action", valid_595666
  var valid_595667 = query.getOrDefault("Version")
  valid_595667 = validateParameter(valid_595667, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595667 != nil:
    section.add "Version", valid_595667
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595668 = header.getOrDefault("X-Amz-Date")
  valid_595668 = validateParameter(valid_595668, JString, required = false,
                                 default = nil)
  if valid_595668 != nil:
    section.add "X-Amz-Date", valid_595668
  var valid_595669 = header.getOrDefault("X-Amz-Security-Token")
  valid_595669 = validateParameter(valid_595669, JString, required = false,
                                 default = nil)
  if valid_595669 != nil:
    section.add "X-Amz-Security-Token", valid_595669
  var valid_595670 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595670 = validateParameter(valid_595670, JString, required = false,
                                 default = nil)
  if valid_595670 != nil:
    section.add "X-Amz-Content-Sha256", valid_595670
  var valid_595671 = header.getOrDefault("X-Amz-Algorithm")
  valid_595671 = validateParameter(valid_595671, JString, required = false,
                                 default = nil)
  if valid_595671 != nil:
    section.add "X-Amz-Algorithm", valid_595671
  var valid_595672 = header.getOrDefault("X-Amz-Signature")
  valid_595672 = validateParameter(valid_595672, JString, required = false,
                                 default = nil)
  if valid_595672 != nil:
    section.add "X-Amz-Signature", valid_595672
  var valid_595673 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595673 = validateParameter(valid_595673, JString, required = false,
                                 default = nil)
  if valid_595673 != nil:
    section.add "X-Amz-SignedHeaders", valid_595673
  var valid_595674 = header.getOrDefault("X-Amz-Credential")
  valid_595674 = validateParameter(valid_595674, JString, required = false,
                                 default = nil)
  if valid_595674 != nil:
    section.add "X-Amz-Credential", valid_595674
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  section = newJObject()
  var valid_595675 = formData.getOrDefault("SourceIdentifier")
  valid_595675 = validateParameter(valid_595675, JString, required = false,
                                 default = nil)
  if valid_595675 != nil:
    section.add "SourceIdentifier", valid_595675
  var valid_595676 = formData.getOrDefault("Marker")
  valid_595676 = validateParameter(valid_595676, JString, required = false,
                                 default = nil)
  if valid_595676 != nil:
    section.add "Marker", valid_595676
  var valid_595677 = formData.getOrDefault("StartTime")
  valid_595677 = validateParameter(valid_595677, JString, required = false,
                                 default = nil)
  if valid_595677 != nil:
    section.add "StartTime", valid_595677
  var valid_595678 = formData.getOrDefault("Duration")
  valid_595678 = validateParameter(valid_595678, JInt, required = false, default = nil)
  if valid_595678 != nil:
    section.add "Duration", valid_595678
  var valid_595679 = formData.getOrDefault("EndTime")
  valid_595679 = validateParameter(valid_595679, JString, required = false,
                                 default = nil)
  if valid_595679 != nil:
    section.add "EndTime", valid_595679
  var valid_595680 = formData.getOrDefault("MaxRecords")
  valid_595680 = validateParameter(valid_595680, JInt, required = false, default = nil)
  if valid_595680 != nil:
    section.add "MaxRecords", valid_595680
  var valid_595681 = formData.getOrDefault("SourceType")
  valid_595681 = validateParameter(valid_595681, JString, required = false,
                                 default = newJString("cluster"))
  if valid_595681 != nil:
    section.add "SourceType", valid_595681
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595682: Call_PostDescribeEvents_595663; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_595682.validator(path, query, header, formData, body)
  let scheme = call_595682.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595682.url(scheme.get, call_595682.host, call_595682.base,
                         call_595682.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595682, url, valid)

proc call*(call_595683: Call_PostDescribeEvents_595663;
          SourceIdentifier: string = ""; Marker: string = ""; StartTime: string = "";
          Action: string = "DescribeEvents"; Duration: int = 0; EndTime: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01";
          SourceType: string = "cluster"): Recallable =
  ## postDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  var query_595684 = newJObject()
  var formData_595685 = newJObject()
  add(formData_595685, "SourceIdentifier", newJString(SourceIdentifier))
  add(formData_595685, "Marker", newJString(Marker))
  add(formData_595685, "StartTime", newJString(StartTime))
  add(query_595684, "Action", newJString(Action))
  add(formData_595685, "Duration", newJInt(Duration))
  add(formData_595685, "EndTime", newJString(EndTime))
  add(formData_595685, "MaxRecords", newJInt(MaxRecords))
  add(query_595684, "Version", newJString(Version))
  add(formData_595685, "SourceType", newJString(SourceType))
  result = call_595683.call(nil, query_595684, nil, formData_595685, nil)

var postDescribeEvents* = Call_PostDescribeEvents_595663(
    name: "postDescribeEvents", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEvents",
    validator: validate_PostDescribeEvents_595664, base: "/",
    url: url_PostDescribeEvents_595665, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEvents_595641 = ref object of OpenApiRestCall_593421
proc url_GetDescribeEvents_595643(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeEvents_595642(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: JString (required)
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_595644 = query.getOrDefault("SourceType")
  valid_595644 = validateParameter(valid_595644, JString, required = false,
                                 default = newJString("cluster"))
  if valid_595644 != nil:
    section.add "SourceType", valid_595644
  var valid_595645 = query.getOrDefault("MaxRecords")
  valid_595645 = validateParameter(valid_595645, JInt, required = false, default = nil)
  if valid_595645 != nil:
    section.add "MaxRecords", valid_595645
  var valid_595646 = query.getOrDefault("StartTime")
  valid_595646 = validateParameter(valid_595646, JString, required = false,
                                 default = nil)
  if valid_595646 != nil:
    section.add "StartTime", valid_595646
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595647 = query.getOrDefault("Action")
  valid_595647 = validateParameter(valid_595647, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_595647 != nil:
    section.add "Action", valid_595647
  var valid_595648 = query.getOrDefault("SourceIdentifier")
  valid_595648 = validateParameter(valid_595648, JString, required = false,
                                 default = nil)
  if valid_595648 != nil:
    section.add "SourceIdentifier", valid_595648
  var valid_595649 = query.getOrDefault("Marker")
  valid_595649 = validateParameter(valid_595649, JString, required = false,
                                 default = nil)
  if valid_595649 != nil:
    section.add "Marker", valid_595649
  var valid_595650 = query.getOrDefault("Duration")
  valid_595650 = validateParameter(valid_595650, JInt, required = false, default = nil)
  if valid_595650 != nil:
    section.add "Duration", valid_595650
  var valid_595651 = query.getOrDefault("EndTime")
  valid_595651 = validateParameter(valid_595651, JString, required = false,
                                 default = nil)
  if valid_595651 != nil:
    section.add "EndTime", valid_595651
  var valid_595652 = query.getOrDefault("Version")
  valid_595652 = validateParameter(valid_595652, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595652 != nil:
    section.add "Version", valid_595652
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595653 = header.getOrDefault("X-Amz-Date")
  valid_595653 = validateParameter(valid_595653, JString, required = false,
                                 default = nil)
  if valid_595653 != nil:
    section.add "X-Amz-Date", valid_595653
  var valid_595654 = header.getOrDefault("X-Amz-Security-Token")
  valid_595654 = validateParameter(valid_595654, JString, required = false,
                                 default = nil)
  if valid_595654 != nil:
    section.add "X-Amz-Security-Token", valid_595654
  var valid_595655 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595655 = validateParameter(valid_595655, JString, required = false,
                                 default = nil)
  if valid_595655 != nil:
    section.add "X-Amz-Content-Sha256", valid_595655
  var valid_595656 = header.getOrDefault("X-Amz-Algorithm")
  valid_595656 = validateParameter(valid_595656, JString, required = false,
                                 default = nil)
  if valid_595656 != nil:
    section.add "X-Amz-Algorithm", valid_595656
  var valid_595657 = header.getOrDefault("X-Amz-Signature")
  valid_595657 = validateParameter(valid_595657, JString, required = false,
                                 default = nil)
  if valid_595657 != nil:
    section.add "X-Amz-Signature", valid_595657
  var valid_595658 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595658 = validateParameter(valid_595658, JString, required = false,
                                 default = nil)
  if valid_595658 != nil:
    section.add "X-Amz-SignedHeaders", valid_595658
  var valid_595659 = header.getOrDefault("X-Amz-Credential")
  valid_595659 = validateParameter(valid_595659, JString, required = false,
                                 default = nil)
  if valid_595659 != nil:
    section.add "X-Amz-Credential", valid_595659
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595660: Call_GetDescribeEvents_595641; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_595660.validator(path, query, header, formData, body)
  let scheme = call_595660.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595660.url(scheme.get, call_595660.host, call_595660.base,
                         call_595660.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595660, url, valid)

proc call*(call_595661: Call_GetDescribeEvents_595641;
          SourceType: string = "cluster"; MaxRecords: int = 0; StartTime: string = "";
          Action: string = "DescribeEvents"; SourceIdentifier: string = "";
          Marker: string = ""; Duration: int = 0; EndTime: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: string (required)
  var query_595662 = newJObject()
  add(query_595662, "SourceType", newJString(SourceType))
  add(query_595662, "MaxRecords", newJInt(MaxRecords))
  add(query_595662, "StartTime", newJString(StartTime))
  add(query_595662, "Action", newJString(Action))
  add(query_595662, "SourceIdentifier", newJString(SourceIdentifier))
  add(query_595662, "Marker", newJString(Marker))
  add(query_595662, "Duration", newJInt(Duration))
  add(query_595662, "EndTime", newJString(EndTime))
  add(query_595662, "Version", newJString(Version))
  result = call_595661.call(nil, query_595662, nil, nil, nil)

var getDescribeEvents* = Call_GetDescribeEvents_595641(name: "getDescribeEvents",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeEvents", validator: validate_GetDescribeEvents_595642,
    base: "/", url: url_GetDescribeEvents_595643,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmClientCertificates_595706 = ref object of OpenApiRestCall_593421
proc url_PostDescribeHsmClientCertificates_595708(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeHsmClientCertificates_595707(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595709 = query.getOrDefault("Action")
  valid_595709 = validateParameter(valid_595709, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_595709 != nil:
    section.add "Action", valid_595709
  var valid_595710 = query.getOrDefault("Version")
  valid_595710 = validateParameter(valid_595710, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595710 != nil:
    section.add "Version", valid_595710
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595711 = header.getOrDefault("X-Amz-Date")
  valid_595711 = validateParameter(valid_595711, JString, required = false,
                                 default = nil)
  if valid_595711 != nil:
    section.add "X-Amz-Date", valid_595711
  var valid_595712 = header.getOrDefault("X-Amz-Security-Token")
  valid_595712 = validateParameter(valid_595712, JString, required = false,
                                 default = nil)
  if valid_595712 != nil:
    section.add "X-Amz-Security-Token", valid_595712
  var valid_595713 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595713 = validateParameter(valid_595713, JString, required = false,
                                 default = nil)
  if valid_595713 != nil:
    section.add "X-Amz-Content-Sha256", valid_595713
  var valid_595714 = header.getOrDefault("X-Amz-Algorithm")
  valid_595714 = validateParameter(valid_595714, JString, required = false,
                                 default = nil)
  if valid_595714 != nil:
    section.add "X-Amz-Algorithm", valid_595714
  var valid_595715 = header.getOrDefault("X-Amz-Signature")
  valid_595715 = validateParameter(valid_595715, JString, required = false,
                                 default = nil)
  if valid_595715 != nil:
    section.add "X-Amz-Signature", valid_595715
  var valid_595716 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595716 = validateParameter(valid_595716, JString, required = false,
                                 default = nil)
  if valid_595716 != nil:
    section.add "X-Amz-SignedHeaders", valid_595716
  var valid_595717 = header.getOrDefault("X-Amz-Credential")
  valid_595717 = validateParameter(valid_595717, JString, required = false,
                                 default = nil)
  if valid_595717 != nil:
    section.add "X-Amz-Credential", valid_595717
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_595718 = formData.getOrDefault("Marker")
  valid_595718 = validateParameter(valid_595718, JString, required = false,
                                 default = nil)
  if valid_595718 != nil:
    section.add "Marker", valid_595718
  var valid_595719 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_595719 = validateParameter(valid_595719, JString, required = false,
                                 default = nil)
  if valid_595719 != nil:
    section.add "HsmClientCertificateIdentifier", valid_595719
  var valid_595720 = formData.getOrDefault("TagKeys")
  valid_595720 = validateParameter(valid_595720, JArray, required = false,
                                 default = nil)
  if valid_595720 != nil:
    section.add "TagKeys", valid_595720
  var valid_595721 = formData.getOrDefault("MaxRecords")
  valid_595721 = validateParameter(valid_595721, JInt, required = false, default = nil)
  if valid_595721 != nil:
    section.add "MaxRecords", valid_595721
  var valid_595722 = formData.getOrDefault("TagValues")
  valid_595722 = validateParameter(valid_595722, JArray, required = false,
                                 default = nil)
  if valid_595722 != nil:
    section.add "TagValues", valid_595722
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595723: Call_PostDescribeHsmClientCertificates_595706;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595723.validator(path, query, header, formData, body)
  let scheme = call_595723.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595723.url(scheme.get, call_595723.host, call_595723.base,
                         call_595723.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595723, url, valid)

proc call*(call_595724: Call_PostDescribeHsmClientCertificates_595706;
          Marker: string = ""; Action: string = "DescribeHsmClientCertificates";
          HsmClientCertificateIdentifier: string = ""; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_595725 = newJObject()
  var formData_595726 = newJObject()
  add(formData_595726, "Marker", newJString(Marker))
  add(query_595725, "Action", newJString(Action))
  add(formData_595726, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if TagKeys != nil:
    formData_595726.add "TagKeys", TagKeys
  add(formData_595726, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_595726.add "TagValues", TagValues
  add(query_595725, "Version", newJString(Version))
  result = call_595724.call(nil, query_595725, nil, formData_595726, nil)

var postDescribeHsmClientCertificates* = Call_PostDescribeHsmClientCertificates_595706(
    name: "postDescribeHsmClientCertificates", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_PostDescribeHsmClientCertificates_595707, base: "/",
    url: url_PostDescribeHsmClientCertificates_595708,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmClientCertificates_595686 = ref object of OpenApiRestCall_593421
proc url_GetDescribeHsmClientCertificates_595688(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeHsmClientCertificates_595687(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595689 = query.getOrDefault("TagValues")
  valid_595689 = validateParameter(valid_595689, JArray, required = false,
                                 default = nil)
  if valid_595689 != nil:
    section.add "TagValues", valid_595689
  var valid_595690 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_595690 = validateParameter(valid_595690, JString, required = false,
                                 default = nil)
  if valid_595690 != nil:
    section.add "HsmClientCertificateIdentifier", valid_595690
  var valid_595691 = query.getOrDefault("MaxRecords")
  valid_595691 = validateParameter(valid_595691, JInt, required = false, default = nil)
  if valid_595691 != nil:
    section.add "MaxRecords", valid_595691
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595692 = query.getOrDefault("Action")
  valid_595692 = validateParameter(valid_595692, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_595692 != nil:
    section.add "Action", valid_595692
  var valid_595693 = query.getOrDefault("Marker")
  valid_595693 = validateParameter(valid_595693, JString, required = false,
                                 default = nil)
  if valid_595693 != nil:
    section.add "Marker", valid_595693
  var valid_595694 = query.getOrDefault("TagKeys")
  valid_595694 = validateParameter(valid_595694, JArray, required = false,
                                 default = nil)
  if valid_595694 != nil:
    section.add "TagKeys", valid_595694
  var valid_595695 = query.getOrDefault("Version")
  valid_595695 = validateParameter(valid_595695, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595695 != nil:
    section.add "Version", valid_595695
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595696 = header.getOrDefault("X-Amz-Date")
  valid_595696 = validateParameter(valid_595696, JString, required = false,
                                 default = nil)
  if valid_595696 != nil:
    section.add "X-Amz-Date", valid_595696
  var valid_595697 = header.getOrDefault("X-Amz-Security-Token")
  valid_595697 = validateParameter(valid_595697, JString, required = false,
                                 default = nil)
  if valid_595697 != nil:
    section.add "X-Amz-Security-Token", valid_595697
  var valid_595698 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595698 = validateParameter(valid_595698, JString, required = false,
                                 default = nil)
  if valid_595698 != nil:
    section.add "X-Amz-Content-Sha256", valid_595698
  var valid_595699 = header.getOrDefault("X-Amz-Algorithm")
  valid_595699 = validateParameter(valid_595699, JString, required = false,
                                 default = nil)
  if valid_595699 != nil:
    section.add "X-Amz-Algorithm", valid_595699
  var valid_595700 = header.getOrDefault("X-Amz-Signature")
  valid_595700 = validateParameter(valid_595700, JString, required = false,
                                 default = nil)
  if valid_595700 != nil:
    section.add "X-Amz-Signature", valid_595700
  var valid_595701 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595701 = validateParameter(valid_595701, JString, required = false,
                                 default = nil)
  if valid_595701 != nil:
    section.add "X-Amz-SignedHeaders", valid_595701
  var valid_595702 = header.getOrDefault("X-Amz-Credential")
  valid_595702 = validateParameter(valid_595702, JString, required = false,
                                 default = nil)
  if valid_595702 != nil:
    section.add "X-Amz-Credential", valid_595702
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595703: Call_GetDescribeHsmClientCertificates_595686;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595703.validator(path, query, header, formData, body)
  let scheme = call_595703.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595703.url(scheme.get, call_595703.host, call_595703.base,
                         call_595703.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595703, url, valid)

proc call*(call_595704: Call_GetDescribeHsmClientCertificates_595686;
          TagValues: JsonNode = nil; HsmClientCertificateIdentifier: string = "";
          MaxRecords: int = 0; Action: string = "DescribeHsmClientCertificates";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_595705 = newJObject()
  if TagValues != nil:
    query_595705.add "TagValues", TagValues
  add(query_595705, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_595705, "MaxRecords", newJInt(MaxRecords))
  add(query_595705, "Action", newJString(Action))
  add(query_595705, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_595705.add "TagKeys", TagKeys
  add(query_595705, "Version", newJString(Version))
  result = call_595704.call(nil, query_595705, nil, nil, nil)

var getDescribeHsmClientCertificates* = Call_GetDescribeHsmClientCertificates_595686(
    name: "getDescribeHsmClientCertificates", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_GetDescribeHsmClientCertificates_595687, base: "/",
    url: url_GetDescribeHsmClientCertificates_595688,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmConfigurations_595747 = ref object of OpenApiRestCall_593421
proc url_PostDescribeHsmConfigurations_595749(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeHsmConfigurations_595748(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595750 = query.getOrDefault("Action")
  valid_595750 = validateParameter(valid_595750, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_595750 != nil:
    section.add "Action", valid_595750
  var valid_595751 = query.getOrDefault("Version")
  valid_595751 = validateParameter(valid_595751, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595751 != nil:
    section.add "Version", valid_595751
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595752 = header.getOrDefault("X-Amz-Date")
  valid_595752 = validateParameter(valid_595752, JString, required = false,
                                 default = nil)
  if valid_595752 != nil:
    section.add "X-Amz-Date", valid_595752
  var valid_595753 = header.getOrDefault("X-Amz-Security-Token")
  valid_595753 = validateParameter(valid_595753, JString, required = false,
                                 default = nil)
  if valid_595753 != nil:
    section.add "X-Amz-Security-Token", valid_595753
  var valid_595754 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595754 = validateParameter(valid_595754, JString, required = false,
                                 default = nil)
  if valid_595754 != nil:
    section.add "X-Amz-Content-Sha256", valid_595754
  var valid_595755 = header.getOrDefault("X-Amz-Algorithm")
  valid_595755 = validateParameter(valid_595755, JString, required = false,
                                 default = nil)
  if valid_595755 != nil:
    section.add "X-Amz-Algorithm", valid_595755
  var valid_595756 = header.getOrDefault("X-Amz-Signature")
  valid_595756 = validateParameter(valid_595756, JString, required = false,
                                 default = nil)
  if valid_595756 != nil:
    section.add "X-Amz-Signature", valid_595756
  var valid_595757 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595757 = validateParameter(valid_595757, JString, required = false,
                                 default = nil)
  if valid_595757 != nil:
    section.add "X-Amz-SignedHeaders", valid_595757
  var valid_595758 = header.getOrDefault("X-Amz-Credential")
  valid_595758 = validateParameter(valid_595758, JString, required = false,
                                 default = nil)
  if valid_595758 != nil:
    section.add "X-Amz-Credential", valid_595758
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_595759 = formData.getOrDefault("Marker")
  valid_595759 = validateParameter(valid_595759, JString, required = false,
                                 default = nil)
  if valid_595759 != nil:
    section.add "Marker", valid_595759
  var valid_595760 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_595760 = validateParameter(valid_595760, JString, required = false,
                                 default = nil)
  if valid_595760 != nil:
    section.add "HsmConfigurationIdentifier", valid_595760
  var valid_595761 = formData.getOrDefault("TagKeys")
  valid_595761 = validateParameter(valid_595761, JArray, required = false,
                                 default = nil)
  if valid_595761 != nil:
    section.add "TagKeys", valid_595761
  var valid_595762 = formData.getOrDefault("MaxRecords")
  valid_595762 = validateParameter(valid_595762, JInt, required = false, default = nil)
  if valid_595762 != nil:
    section.add "MaxRecords", valid_595762
  var valid_595763 = formData.getOrDefault("TagValues")
  valid_595763 = validateParameter(valid_595763, JArray, required = false,
                                 default = nil)
  if valid_595763 != nil:
    section.add "TagValues", valid_595763
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595764: Call_PostDescribeHsmConfigurations_595747; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595764.validator(path, query, header, formData, body)
  let scheme = call_595764.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595764.url(scheme.get, call_595764.host, call_595764.base,
                         call_595764.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595764, url, valid)

proc call*(call_595765: Call_PostDescribeHsmConfigurations_595747;
          Marker: string = ""; HsmConfigurationIdentifier: string = "";
          Action: string = "DescribeHsmConfigurations"; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_595766 = newJObject()
  var formData_595767 = newJObject()
  add(formData_595767, "Marker", newJString(Marker))
  add(formData_595767, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_595766, "Action", newJString(Action))
  if TagKeys != nil:
    formData_595767.add "TagKeys", TagKeys
  add(formData_595767, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_595767.add "TagValues", TagValues
  add(query_595766, "Version", newJString(Version))
  result = call_595765.call(nil, query_595766, nil, formData_595767, nil)

var postDescribeHsmConfigurations* = Call_PostDescribeHsmConfigurations_595747(
    name: "postDescribeHsmConfigurations", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_PostDescribeHsmConfigurations_595748, base: "/",
    url: url_PostDescribeHsmConfigurations_595749,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmConfigurations_595727 = ref object of OpenApiRestCall_593421
proc url_GetDescribeHsmConfigurations_595729(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeHsmConfigurations_595728(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595730 = query.getOrDefault("TagValues")
  valid_595730 = validateParameter(valid_595730, JArray, required = false,
                                 default = nil)
  if valid_595730 != nil:
    section.add "TagValues", valid_595730
  var valid_595731 = query.getOrDefault("MaxRecords")
  valid_595731 = validateParameter(valid_595731, JInt, required = false, default = nil)
  if valid_595731 != nil:
    section.add "MaxRecords", valid_595731
  var valid_595732 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_595732 = validateParameter(valid_595732, JString, required = false,
                                 default = nil)
  if valid_595732 != nil:
    section.add "HsmConfigurationIdentifier", valid_595732
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595733 = query.getOrDefault("Action")
  valid_595733 = validateParameter(valid_595733, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_595733 != nil:
    section.add "Action", valid_595733
  var valid_595734 = query.getOrDefault("Marker")
  valid_595734 = validateParameter(valid_595734, JString, required = false,
                                 default = nil)
  if valid_595734 != nil:
    section.add "Marker", valid_595734
  var valid_595735 = query.getOrDefault("TagKeys")
  valid_595735 = validateParameter(valid_595735, JArray, required = false,
                                 default = nil)
  if valid_595735 != nil:
    section.add "TagKeys", valid_595735
  var valid_595736 = query.getOrDefault("Version")
  valid_595736 = validateParameter(valid_595736, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595736 != nil:
    section.add "Version", valid_595736
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595737 = header.getOrDefault("X-Amz-Date")
  valid_595737 = validateParameter(valid_595737, JString, required = false,
                                 default = nil)
  if valid_595737 != nil:
    section.add "X-Amz-Date", valid_595737
  var valid_595738 = header.getOrDefault("X-Amz-Security-Token")
  valid_595738 = validateParameter(valid_595738, JString, required = false,
                                 default = nil)
  if valid_595738 != nil:
    section.add "X-Amz-Security-Token", valid_595738
  var valid_595739 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595739 = validateParameter(valid_595739, JString, required = false,
                                 default = nil)
  if valid_595739 != nil:
    section.add "X-Amz-Content-Sha256", valid_595739
  var valid_595740 = header.getOrDefault("X-Amz-Algorithm")
  valid_595740 = validateParameter(valid_595740, JString, required = false,
                                 default = nil)
  if valid_595740 != nil:
    section.add "X-Amz-Algorithm", valid_595740
  var valid_595741 = header.getOrDefault("X-Amz-Signature")
  valid_595741 = validateParameter(valid_595741, JString, required = false,
                                 default = nil)
  if valid_595741 != nil:
    section.add "X-Amz-Signature", valid_595741
  var valid_595742 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595742 = validateParameter(valid_595742, JString, required = false,
                                 default = nil)
  if valid_595742 != nil:
    section.add "X-Amz-SignedHeaders", valid_595742
  var valid_595743 = header.getOrDefault("X-Amz-Credential")
  valid_595743 = validateParameter(valid_595743, JString, required = false,
                                 default = nil)
  if valid_595743 != nil:
    section.add "X-Amz-Credential", valid_595743
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595744: Call_GetDescribeHsmConfigurations_595727; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595744.validator(path, query, header, formData, body)
  let scheme = call_595744.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595744.url(scheme.get, call_595744.host, call_595744.base,
                         call_595744.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595744, url, valid)

proc call*(call_595745: Call_GetDescribeHsmConfigurations_595727;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          HsmConfigurationIdentifier: string = "";
          Action: string = "DescribeHsmConfigurations"; Marker: string = "";
          TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_595746 = newJObject()
  if TagValues != nil:
    query_595746.add "TagValues", TagValues
  add(query_595746, "MaxRecords", newJInt(MaxRecords))
  add(query_595746, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_595746, "Action", newJString(Action))
  add(query_595746, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_595746.add "TagKeys", TagKeys
  add(query_595746, "Version", newJString(Version))
  result = call_595745.call(nil, query_595746, nil, nil, nil)

var getDescribeHsmConfigurations* = Call_GetDescribeHsmConfigurations_595727(
    name: "getDescribeHsmConfigurations", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_GetDescribeHsmConfigurations_595728, base: "/",
    url: url_GetDescribeHsmConfigurations_595729,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeLoggingStatus_595784 = ref object of OpenApiRestCall_593421
proc url_PostDescribeLoggingStatus_595786(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeLoggingStatus_595785(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595787 = query.getOrDefault("Action")
  valid_595787 = validateParameter(valid_595787, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_595787 != nil:
    section.add "Action", valid_595787
  var valid_595788 = query.getOrDefault("Version")
  valid_595788 = validateParameter(valid_595788, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595788 != nil:
    section.add "Version", valid_595788
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595789 = header.getOrDefault("X-Amz-Date")
  valid_595789 = validateParameter(valid_595789, JString, required = false,
                                 default = nil)
  if valid_595789 != nil:
    section.add "X-Amz-Date", valid_595789
  var valid_595790 = header.getOrDefault("X-Amz-Security-Token")
  valid_595790 = validateParameter(valid_595790, JString, required = false,
                                 default = nil)
  if valid_595790 != nil:
    section.add "X-Amz-Security-Token", valid_595790
  var valid_595791 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595791 = validateParameter(valid_595791, JString, required = false,
                                 default = nil)
  if valid_595791 != nil:
    section.add "X-Amz-Content-Sha256", valid_595791
  var valid_595792 = header.getOrDefault("X-Amz-Algorithm")
  valid_595792 = validateParameter(valid_595792, JString, required = false,
                                 default = nil)
  if valid_595792 != nil:
    section.add "X-Amz-Algorithm", valid_595792
  var valid_595793 = header.getOrDefault("X-Amz-Signature")
  valid_595793 = validateParameter(valid_595793, JString, required = false,
                                 default = nil)
  if valid_595793 != nil:
    section.add "X-Amz-Signature", valid_595793
  var valid_595794 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595794 = validateParameter(valid_595794, JString, required = false,
                                 default = nil)
  if valid_595794 != nil:
    section.add "X-Amz-SignedHeaders", valid_595794
  var valid_595795 = header.getOrDefault("X-Amz-Credential")
  valid_595795 = validateParameter(valid_595795, JString, required = false,
                                 default = nil)
  if valid_595795 != nil:
    section.add "X-Amz-Credential", valid_595795
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595796 = formData.getOrDefault("ClusterIdentifier")
  valid_595796 = validateParameter(valid_595796, JString, required = true,
                                 default = nil)
  if valid_595796 != nil:
    section.add "ClusterIdentifier", valid_595796
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595797: Call_PostDescribeLoggingStatus_595784; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_595797.validator(path, query, header, formData, body)
  let scheme = call_595797.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595797.url(scheme.get, call_595797.host, call_595797.base,
                         call_595797.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595797, url, valid)

proc call*(call_595798: Call_PostDescribeLoggingStatus_595784;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_595799 = newJObject()
  var formData_595800 = newJObject()
  add(query_595799, "Action", newJString(Action))
  add(formData_595800, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595799, "Version", newJString(Version))
  result = call_595798.call(nil, query_595799, nil, formData_595800, nil)

var postDescribeLoggingStatus* = Call_PostDescribeLoggingStatus_595784(
    name: "postDescribeLoggingStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_PostDescribeLoggingStatus_595785, base: "/",
    url: url_PostDescribeLoggingStatus_595786,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeLoggingStatus_595768 = ref object of OpenApiRestCall_593421
proc url_GetDescribeLoggingStatus_595770(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeLoggingStatus_595769(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595771 = query.getOrDefault("Action")
  valid_595771 = validateParameter(valid_595771, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_595771 != nil:
    section.add "Action", valid_595771
  var valid_595772 = query.getOrDefault("ClusterIdentifier")
  valid_595772 = validateParameter(valid_595772, JString, required = true,
                                 default = nil)
  if valid_595772 != nil:
    section.add "ClusterIdentifier", valid_595772
  var valid_595773 = query.getOrDefault("Version")
  valid_595773 = validateParameter(valid_595773, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595773 != nil:
    section.add "Version", valid_595773
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595774 = header.getOrDefault("X-Amz-Date")
  valid_595774 = validateParameter(valid_595774, JString, required = false,
                                 default = nil)
  if valid_595774 != nil:
    section.add "X-Amz-Date", valid_595774
  var valid_595775 = header.getOrDefault("X-Amz-Security-Token")
  valid_595775 = validateParameter(valid_595775, JString, required = false,
                                 default = nil)
  if valid_595775 != nil:
    section.add "X-Amz-Security-Token", valid_595775
  var valid_595776 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595776 = validateParameter(valid_595776, JString, required = false,
                                 default = nil)
  if valid_595776 != nil:
    section.add "X-Amz-Content-Sha256", valid_595776
  var valid_595777 = header.getOrDefault("X-Amz-Algorithm")
  valid_595777 = validateParameter(valid_595777, JString, required = false,
                                 default = nil)
  if valid_595777 != nil:
    section.add "X-Amz-Algorithm", valid_595777
  var valid_595778 = header.getOrDefault("X-Amz-Signature")
  valid_595778 = validateParameter(valid_595778, JString, required = false,
                                 default = nil)
  if valid_595778 != nil:
    section.add "X-Amz-Signature", valid_595778
  var valid_595779 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595779 = validateParameter(valid_595779, JString, required = false,
                                 default = nil)
  if valid_595779 != nil:
    section.add "X-Amz-SignedHeaders", valid_595779
  var valid_595780 = header.getOrDefault("X-Amz-Credential")
  valid_595780 = validateParameter(valid_595780, JString, required = false,
                                 default = nil)
  if valid_595780 != nil:
    section.add "X-Amz-Credential", valid_595780
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595781: Call_GetDescribeLoggingStatus_595768; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_595781.validator(path, query, header, formData, body)
  let scheme = call_595781.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595781.url(scheme.get, call_595781.host, call_595781.base,
                         call_595781.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595781, url, valid)

proc call*(call_595782: Call_GetDescribeLoggingStatus_595768;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_595783 = newJObject()
  add(query_595783, "Action", newJString(Action))
  add(query_595783, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595783, "Version", newJString(Version))
  result = call_595782.call(nil, query_595783, nil, nil, nil)

var getDescribeLoggingStatus* = Call_GetDescribeLoggingStatus_595768(
    name: "getDescribeLoggingStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_GetDescribeLoggingStatus_595769, base: "/",
    url: url_GetDescribeLoggingStatus_595770, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeNodeConfigurationOptions_595822 = ref object of OpenApiRestCall_593421
proc url_PostDescribeNodeConfigurationOptions_595824(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeNodeConfigurationOptions_595823(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595825 = query.getOrDefault("Action")
  valid_595825 = validateParameter(valid_595825, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_595825 != nil:
    section.add "Action", valid_595825
  var valid_595826 = query.getOrDefault("Version")
  valid_595826 = validateParameter(valid_595826, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595826 != nil:
    section.add "Version", valid_595826
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595827 = header.getOrDefault("X-Amz-Date")
  valid_595827 = validateParameter(valid_595827, JString, required = false,
                                 default = nil)
  if valid_595827 != nil:
    section.add "X-Amz-Date", valid_595827
  var valid_595828 = header.getOrDefault("X-Amz-Security-Token")
  valid_595828 = validateParameter(valid_595828, JString, required = false,
                                 default = nil)
  if valid_595828 != nil:
    section.add "X-Amz-Security-Token", valid_595828
  var valid_595829 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595829 = validateParameter(valid_595829, JString, required = false,
                                 default = nil)
  if valid_595829 != nil:
    section.add "X-Amz-Content-Sha256", valid_595829
  var valid_595830 = header.getOrDefault("X-Amz-Algorithm")
  valid_595830 = validateParameter(valid_595830, JString, required = false,
                                 default = nil)
  if valid_595830 != nil:
    section.add "X-Amz-Algorithm", valid_595830
  var valid_595831 = header.getOrDefault("X-Amz-Signature")
  valid_595831 = validateParameter(valid_595831, JString, required = false,
                                 default = nil)
  if valid_595831 != nil:
    section.add "X-Amz-Signature", valid_595831
  var valid_595832 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595832 = validateParameter(valid_595832, JString, required = false,
                                 default = nil)
  if valid_595832 != nil:
    section.add "X-Amz-SignedHeaders", valid_595832
  var valid_595833 = header.getOrDefault("X-Amz-Credential")
  valid_595833 = validateParameter(valid_595833, JString, required = false,
                                 default = nil)
  if valid_595833 != nil:
    section.add "X-Amz-Credential", valid_595833
  result.add "header", section
  ## parameters in `formData` object:
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  section = newJObject()
  var valid_595834 = formData.getOrDefault("Filter")
  valid_595834 = validateParameter(valid_595834, JArray, required = false,
                                 default = nil)
  if valid_595834 != nil:
    section.add "Filter", valid_595834
  var valid_595835 = formData.getOrDefault("Marker")
  valid_595835 = validateParameter(valid_595835, JString, required = false,
                                 default = nil)
  if valid_595835 != nil:
    section.add "Marker", valid_595835
  var valid_595836 = formData.getOrDefault("OwnerAccount")
  valid_595836 = validateParameter(valid_595836, JString, required = false,
                                 default = nil)
  if valid_595836 != nil:
    section.add "OwnerAccount", valid_595836
  assert formData != nil,
        "formData argument is necessary due to required `ActionType` field"
  var valid_595837 = formData.getOrDefault("ActionType")
  valid_595837 = validateParameter(valid_595837, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_595837 != nil:
    section.add "ActionType", valid_595837
  var valid_595838 = formData.getOrDefault("SnapshotIdentifier")
  valid_595838 = validateParameter(valid_595838, JString, required = false,
                                 default = nil)
  if valid_595838 != nil:
    section.add "SnapshotIdentifier", valid_595838
  var valid_595839 = formData.getOrDefault("MaxRecords")
  valid_595839 = validateParameter(valid_595839, JInt, required = false, default = nil)
  if valid_595839 != nil:
    section.add "MaxRecords", valid_595839
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595840: Call_PostDescribeNodeConfigurationOptions_595822;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_595840.validator(path, query, header, formData, body)
  let scheme = call_595840.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595840.url(scheme.get, call_595840.host, call_595840.base,
                         call_595840.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595840, url, valid)

proc call*(call_595841: Call_PostDescribeNodeConfigurationOptions_595822;
          Filter: JsonNode = nil; Marker: string = "";
          Action: string = "DescribeNodeConfigurationOptions";
          OwnerAccount: string = ""; ActionType: string = "restore-cluster";
          SnapshotIdentifier: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Version: string (required)
  var query_595842 = newJObject()
  var formData_595843 = newJObject()
  if Filter != nil:
    formData_595843.add "Filter", Filter
  add(formData_595843, "Marker", newJString(Marker))
  add(query_595842, "Action", newJString(Action))
  add(formData_595843, "OwnerAccount", newJString(OwnerAccount))
  add(formData_595843, "ActionType", newJString(ActionType))
  add(formData_595843, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_595843, "MaxRecords", newJInt(MaxRecords))
  add(query_595842, "Version", newJString(Version))
  result = call_595841.call(nil, query_595842, nil, formData_595843, nil)

var postDescribeNodeConfigurationOptions* = Call_PostDescribeNodeConfigurationOptions_595822(
    name: "postDescribeNodeConfigurationOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_PostDescribeNodeConfigurationOptions_595823, base: "/",
    url: url_PostDescribeNodeConfigurationOptions_595824,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeNodeConfigurationOptions_595801 = ref object of OpenApiRestCall_593421
proc url_GetDescribeNodeConfigurationOptions_595803(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeNodeConfigurationOptions_595802(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   Action: JString (required)
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595804 = query.getOrDefault("MaxRecords")
  valid_595804 = validateParameter(valid_595804, JInt, required = false, default = nil)
  if valid_595804 != nil:
    section.add "MaxRecords", valid_595804
  var valid_595805 = query.getOrDefault("Filter")
  valid_595805 = validateParameter(valid_595805, JArray, required = false,
                                 default = nil)
  if valid_595805 != nil:
    section.add "Filter", valid_595805
  assert query != nil,
        "query argument is necessary due to required `ActionType` field"
  var valid_595806 = query.getOrDefault("ActionType")
  valid_595806 = validateParameter(valid_595806, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_595806 != nil:
    section.add "ActionType", valid_595806
  var valid_595807 = query.getOrDefault("Action")
  valid_595807 = validateParameter(valid_595807, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_595807 != nil:
    section.add "Action", valid_595807
  var valid_595808 = query.getOrDefault("OwnerAccount")
  valid_595808 = validateParameter(valid_595808, JString, required = false,
                                 default = nil)
  if valid_595808 != nil:
    section.add "OwnerAccount", valid_595808
  var valid_595809 = query.getOrDefault("Marker")
  valid_595809 = validateParameter(valid_595809, JString, required = false,
                                 default = nil)
  if valid_595809 != nil:
    section.add "Marker", valid_595809
  var valid_595810 = query.getOrDefault("SnapshotIdentifier")
  valid_595810 = validateParameter(valid_595810, JString, required = false,
                                 default = nil)
  if valid_595810 != nil:
    section.add "SnapshotIdentifier", valid_595810
  var valid_595811 = query.getOrDefault("Version")
  valid_595811 = validateParameter(valid_595811, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595811 != nil:
    section.add "Version", valid_595811
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595812 = header.getOrDefault("X-Amz-Date")
  valid_595812 = validateParameter(valid_595812, JString, required = false,
                                 default = nil)
  if valid_595812 != nil:
    section.add "X-Amz-Date", valid_595812
  var valid_595813 = header.getOrDefault("X-Amz-Security-Token")
  valid_595813 = validateParameter(valid_595813, JString, required = false,
                                 default = nil)
  if valid_595813 != nil:
    section.add "X-Amz-Security-Token", valid_595813
  var valid_595814 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595814 = validateParameter(valid_595814, JString, required = false,
                                 default = nil)
  if valid_595814 != nil:
    section.add "X-Amz-Content-Sha256", valid_595814
  var valid_595815 = header.getOrDefault("X-Amz-Algorithm")
  valid_595815 = validateParameter(valid_595815, JString, required = false,
                                 default = nil)
  if valid_595815 != nil:
    section.add "X-Amz-Algorithm", valid_595815
  var valid_595816 = header.getOrDefault("X-Amz-Signature")
  valid_595816 = validateParameter(valid_595816, JString, required = false,
                                 default = nil)
  if valid_595816 != nil:
    section.add "X-Amz-Signature", valid_595816
  var valid_595817 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595817 = validateParameter(valid_595817, JString, required = false,
                                 default = nil)
  if valid_595817 != nil:
    section.add "X-Amz-SignedHeaders", valid_595817
  var valid_595818 = header.getOrDefault("X-Amz-Credential")
  valid_595818 = validateParameter(valid_595818, JString, required = false,
                                 default = nil)
  if valid_595818 != nil:
    section.add "X-Amz-Credential", valid_595818
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595819: Call_GetDescribeNodeConfigurationOptions_595801;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_595819.validator(path, query, header, formData, body)
  let scheme = call_595819.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595819.url(scheme.get, call_595819.host, call_595819.base,
                         call_595819.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595819, url, valid)

proc call*(call_595820: Call_GetDescribeNodeConfigurationOptions_595801;
          MaxRecords: int = 0; Filter: JsonNode = nil;
          ActionType: string = "restore-cluster";
          Action: string = "DescribeNodeConfigurationOptions";
          OwnerAccount: string = ""; Marker: string = "";
          SnapshotIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Version: string (required)
  var query_595821 = newJObject()
  add(query_595821, "MaxRecords", newJInt(MaxRecords))
  if Filter != nil:
    query_595821.add "Filter", Filter
  add(query_595821, "ActionType", newJString(ActionType))
  add(query_595821, "Action", newJString(Action))
  add(query_595821, "OwnerAccount", newJString(OwnerAccount))
  add(query_595821, "Marker", newJString(Marker))
  add(query_595821, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_595821, "Version", newJString(Version))
  result = call_595820.call(nil, query_595821, nil, nil, nil)

var getDescribeNodeConfigurationOptions* = Call_GetDescribeNodeConfigurationOptions_595801(
    name: "getDescribeNodeConfigurationOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_GetDescribeNodeConfigurationOptions_595802, base: "/",
    url: url_GetDescribeNodeConfigurationOptions_595803,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeOrderableClusterOptions_595863 = ref object of OpenApiRestCall_593421
proc url_PostDescribeOrderableClusterOptions_595865(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeOrderableClusterOptions_595864(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595866 = query.getOrDefault("Action")
  valid_595866 = validateParameter(valid_595866, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_595866 != nil:
    section.add "Action", valid_595866
  var valid_595867 = query.getOrDefault("Version")
  valid_595867 = validateParameter(valid_595867, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595867 != nil:
    section.add "Version", valid_595867
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595868 = header.getOrDefault("X-Amz-Date")
  valid_595868 = validateParameter(valid_595868, JString, required = false,
                                 default = nil)
  if valid_595868 != nil:
    section.add "X-Amz-Date", valid_595868
  var valid_595869 = header.getOrDefault("X-Amz-Security-Token")
  valid_595869 = validateParameter(valid_595869, JString, required = false,
                                 default = nil)
  if valid_595869 != nil:
    section.add "X-Amz-Security-Token", valid_595869
  var valid_595870 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595870 = validateParameter(valid_595870, JString, required = false,
                                 default = nil)
  if valid_595870 != nil:
    section.add "X-Amz-Content-Sha256", valid_595870
  var valid_595871 = header.getOrDefault("X-Amz-Algorithm")
  valid_595871 = validateParameter(valid_595871, JString, required = false,
                                 default = nil)
  if valid_595871 != nil:
    section.add "X-Amz-Algorithm", valid_595871
  var valid_595872 = header.getOrDefault("X-Amz-Signature")
  valid_595872 = validateParameter(valid_595872, JString, required = false,
                                 default = nil)
  if valid_595872 != nil:
    section.add "X-Amz-Signature", valid_595872
  var valid_595873 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595873 = validateParameter(valid_595873, JString, required = false,
                                 default = nil)
  if valid_595873 != nil:
    section.add "X-Amz-SignedHeaders", valid_595873
  var valid_595874 = header.getOrDefault("X-Amz-Credential")
  valid_595874 = validateParameter(valid_595874, JString, required = false,
                                 default = nil)
  if valid_595874 != nil:
    section.add "X-Amz-Credential", valid_595874
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  section = newJObject()
  var valid_595875 = formData.getOrDefault("ClusterVersion")
  valid_595875 = validateParameter(valid_595875, JString, required = false,
                                 default = nil)
  if valid_595875 != nil:
    section.add "ClusterVersion", valid_595875
  var valid_595876 = formData.getOrDefault("Marker")
  valid_595876 = validateParameter(valid_595876, JString, required = false,
                                 default = nil)
  if valid_595876 != nil:
    section.add "Marker", valid_595876
  var valid_595877 = formData.getOrDefault("MaxRecords")
  valid_595877 = validateParameter(valid_595877, JInt, required = false, default = nil)
  if valid_595877 != nil:
    section.add "MaxRecords", valid_595877
  var valid_595878 = formData.getOrDefault("NodeType")
  valid_595878 = validateParameter(valid_595878, JString, required = false,
                                 default = nil)
  if valid_595878 != nil:
    section.add "NodeType", valid_595878
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595879: Call_PostDescribeOrderableClusterOptions_595863;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_595879.validator(path, query, header, formData, body)
  let scheme = call_595879.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595879.url(scheme.get, call_595879.host, call_595879.base,
                         call_595879.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595879, url, valid)

proc call*(call_595880: Call_PostDescribeOrderableClusterOptions_595863;
          ClusterVersion: string = ""; Marker: string = "";
          Action: string = "DescribeOrderableClusterOptions"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; NodeType: string = ""): Recallable =
  ## postDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  var query_595881 = newJObject()
  var formData_595882 = newJObject()
  add(formData_595882, "ClusterVersion", newJString(ClusterVersion))
  add(formData_595882, "Marker", newJString(Marker))
  add(query_595881, "Action", newJString(Action))
  add(formData_595882, "MaxRecords", newJInt(MaxRecords))
  add(query_595881, "Version", newJString(Version))
  add(formData_595882, "NodeType", newJString(NodeType))
  result = call_595880.call(nil, query_595881, nil, formData_595882, nil)

var postDescribeOrderableClusterOptions* = Call_PostDescribeOrderableClusterOptions_595863(
    name: "postDescribeOrderableClusterOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_PostDescribeOrderableClusterOptions_595864, base: "/",
    url: url_PostDescribeOrderableClusterOptions_595865,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeOrderableClusterOptions_595844 = ref object of OpenApiRestCall_593421
proc url_GetDescribeOrderableClusterOptions_595846(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeOrderableClusterOptions_595845(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_595847 = query.getOrDefault("MaxRecords")
  valid_595847 = validateParameter(valid_595847, JInt, required = false, default = nil)
  if valid_595847 != nil:
    section.add "MaxRecords", valid_595847
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595848 = query.getOrDefault("Action")
  valid_595848 = validateParameter(valid_595848, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_595848 != nil:
    section.add "Action", valid_595848
  var valid_595849 = query.getOrDefault("Marker")
  valid_595849 = validateParameter(valid_595849, JString, required = false,
                                 default = nil)
  if valid_595849 != nil:
    section.add "Marker", valid_595849
  var valid_595850 = query.getOrDefault("NodeType")
  valid_595850 = validateParameter(valid_595850, JString, required = false,
                                 default = nil)
  if valid_595850 != nil:
    section.add "NodeType", valid_595850
  var valid_595851 = query.getOrDefault("ClusterVersion")
  valid_595851 = validateParameter(valid_595851, JString, required = false,
                                 default = nil)
  if valid_595851 != nil:
    section.add "ClusterVersion", valid_595851
  var valid_595852 = query.getOrDefault("Version")
  valid_595852 = validateParameter(valid_595852, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595852 != nil:
    section.add "Version", valid_595852
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595853 = header.getOrDefault("X-Amz-Date")
  valid_595853 = validateParameter(valid_595853, JString, required = false,
                                 default = nil)
  if valid_595853 != nil:
    section.add "X-Amz-Date", valid_595853
  var valid_595854 = header.getOrDefault("X-Amz-Security-Token")
  valid_595854 = validateParameter(valid_595854, JString, required = false,
                                 default = nil)
  if valid_595854 != nil:
    section.add "X-Amz-Security-Token", valid_595854
  var valid_595855 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595855 = validateParameter(valid_595855, JString, required = false,
                                 default = nil)
  if valid_595855 != nil:
    section.add "X-Amz-Content-Sha256", valid_595855
  var valid_595856 = header.getOrDefault("X-Amz-Algorithm")
  valid_595856 = validateParameter(valid_595856, JString, required = false,
                                 default = nil)
  if valid_595856 != nil:
    section.add "X-Amz-Algorithm", valid_595856
  var valid_595857 = header.getOrDefault("X-Amz-Signature")
  valid_595857 = validateParameter(valid_595857, JString, required = false,
                                 default = nil)
  if valid_595857 != nil:
    section.add "X-Amz-Signature", valid_595857
  var valid_595858 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595858 = validateParameter(valid_595858, JString, required = false,
                                 default = nil)
  if valid_595858 != nil:
    section.add "X-Amz-SignedHeaders", valid_595858
  var valid_595859 = header.getOrDefault("X-Amz-Credential")
  valid_595859 = validateParameter(valid_595859, JString, required = false,
                                 default = nil)
  if valid_595859 != nil:
    section.add "X-Amz-Credential", valid_595859
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595860: Call_GetDescribeOrderableClusterOptions_595844;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_595860.validator(path, query, header, formData, body)
  let scheme = call_595860.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595860.url(scheme.get, call_595860.host, call_595860.base,
                         call_595860.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595860, url, valid)

proc call*(call_595861: Call_GetDescribeOrderableClusterOptions_595844;
          MaxRecords: int = 0; Action: string = "DescribeOrderableClusterOptions";
          Marker: string = ""; NodeType: string = ""; ClusterVersion: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: string (required)
  var query_595862 = newJObject()
  add(query_595862, "MaxRecords", newJInt(MaxRecords))
  add(query_595862, "Action", newJString(Action))
  add(query_595862, "Marker", newJString(Marker))
  add(query_595862, "NodeType", newJString(NodeType))
  add(query_595862, "ClusterVersion", newJString(ClusterVersion))
  add(query_595862, "Version", newJString(Version))
  result = call_595861.call(nil, query_595862, nil, nil, nil)

var getDescribeOrderableClusterOptions* = Call_GetDescribeOrderableClusterOptions_595844(
    name: "getDescribeOrderableClusterOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_GetDescribeOrderableClusterOptions_595845, base: "/",
    url: url_GetDescribeOrderableClusterOptions_595846,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodeOfferings_595901 = ref object of OpenApiRestCall_593421
proc url_PostDescribeReservedNodeOfferings_595903(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeReservedNodeOfferings_595902(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595904 = query.getOrDefault("Action")
  valid_595904 = validateParameter(valid_595904, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_595904 != nil:
    section.add "Action", valid_595904
  var valid_595905 = query.getOrDefault("Version")
  valid_595905 = validateParameter(valid_595905, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595905 != nil:
    section.add "Version", valid_595905
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595906 = header.getOrDefault("X-Amz-Date")
  valid_595906 = validateParameter(valid_595906, JString, required = false,
                                 default = nil)
  if valid_595906 != nil:
    section.add "X-Amz-Date", valid_595906
  var valid_595907 = header.getOrDefault("X-Amz-Security-Token")
  valid_595907 = validateParameter(valid_595907, JString, required = false,
                                 default = nil)
  if valid_595907 != nil:
    section.add "X-Amz-Security-Token", valid_595907
  var valid_595908 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595908 = validateParameter(valid_595908, JString, required = false,
                                 default = nil)
  if valid_595908 != nil:
    section.add "X-Amz-Content-Sha256", valid_595908
  var valid_595909 = header.getOrDefault("X-Amz-Algorithm")
  valid_595909 = validateParameter(valid_595909, JString, required = false,
                                 default = nil)
  if valid_595909 != nil:
    section.add "X-Amz-Algorithm", valid_595909
  var valid_595910 = header.getOrDefault("X-Amz-Signature")
  valid_595910 = validateParameter(valid_595910, JString, required = false,
                                 default = nil)
  if valid_595910 != nil:
    section.add "X-Amz-Signature", valid_595910
  var valid_595911 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595911 = validateParameter(valid_595911, JString, required = false,
                                 default = nil)
  if valid_595911 != nil:
    section.add "X-Amz-SignedHeaders", valid_595911
  var valid_595912 = header.getOrDefault("X-Amz-Credential")
  valid_595912 = validateParameter(valid_595912, JString, required = false,
                                 default = nil)
  if valid_595912 != nil:
    section.add "X-Amz-Credential", valid_595912
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_595913 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_595913 = validateParameter(valid_595913, JString, required = false,
                                 default = nil)
  if valid_595913 != nil:
    section.add "ReservedNodeOfferingId", valid_595913
  var valid_595914 = formData.getOrDefault("Marker")
  valid_595914 = validateParameter(valid_595914, JString, required = false,
                                 default = nil)
  if valid_595914 != nil:
    section.add "Marker", valid_595914
  var valid_595915 = formData.getOrDefault("MaxRecords")
  valid_595915 = validateParameter(valid_595915, JInt, required = false, default = nil)
  if valid_595915 != nil:
    section.add "MaxRecords", valid_595915
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595916: Call_PostDescribeReservedNodeOfferings_595901;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_595916.validator(path, query, header, formData, body)
  let scheme = call_595916.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595916.url(scheme.get, call_595916.host, call_595916.base,
                         call_595916.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595916, url, valid)

proc call*(call_595917: Call_PostDescribeReservedNodeOfferings_595901;
          ReservedNodeOfferingId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodeOfferings"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_595918 = newJObject()
  var formData_595919 = newJObject()
  add(formData_595919, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_595919, "Marker", newJString(Marker))
  add(query_595918, "Action", newJString(Action))
  add(formData_595919, "MaxRecords", newJInt(MaxRecords))
  add(query_595918, "Version", newJString(Version))
  result = call_595917.call(nil, query_595918, nil, formData_595919, nil)

var postDescribeReservedNodeOfferings* = Call_PostDescribeReservedNodeOfferings_595901(
    name: "postDescribeReservedNodeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_PostDescribeReservedNodeOfferings_595902, base: "/",
    url: url_PostDescribeReservedNodeOfferings_595903,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodeOfferings_595883 = ref object of OpenApiRestCall_593421
proc url_GetDescribeReservedNodeOfferings_595885(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeReservedNodeOfferings_595884(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_595886 = query.getOrDefault("MaxRecords")
  valid_595886 = validateParameter(valid_595886, JInt, required = false, default = nil)
  if valid_595886 != nil:
    section.add "MaxRecords", valid_595886
  var valid_595887 = query.getOrDefault("ReservedNodeOfferingId")
  valid_595887 = validateParameter(valid_595887, JString, required = false,
                                 default = nil)
  if valid_595887 != nil:
    section.add "ReservedNodeOfferingId", valid_595887
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595888 = query.getOrDefault("Action")
  valid_595888 = validateParameter(valid_595888, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_595888 != nil:
    section.add "Action", valid_595888
  var valid_595889 = query.getOrDefault("Marker")
  valid_595889 = validateParameter(valid_595889, JString, required = false,
                                 default = nil)
  if valid_595889 != nil:
    section.add "Marker", valid_595889
  var valid_595890 = query.getOrDefault("Version")
  valid_595890 = validateParameter(valid_595890, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595890 != nil:
    section.add "Version", valid_595890
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595891 = header.getOrDefault("X-Amz-Date")
  valid_595891 = validateParameter(valid_595891, JString, required = false,
                                 default = nil)
  if valid_595891 != nil:
    section.add "X-Amz-Date", valid_595891
  var valid_595892 = header.getOrDefault("X-Amz-Security-Token")
  valid_595892 = validateParameter(valid_595892, JString, required = false,
                                 default = nil)
  if valid_595892 != nil:
    section.add "X-Amz-Security-Token", valid_595892
  var valid_595893 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595893 = validateParameter(valid_595893, JString, required = false,
                                 default = nil)
  if valid_595893 != nil:
    section.add "X-Amz-Content-Sha256", valid_595893
  var valid_595894 = header.getOrDefault("X-Amz-Algorithm")
  valid_595894 = validateParameter(valid_595894, JString, required = false,
                                 default = nil)
  if valid_595894 != nil:
    section.add "X-Amz-Algorithm", valid_595894
  var valid_595895 = header.getOrDefault("X-Amz-Signature")
  valid_595895 = validateParameter(valid_595895, JString, required = false,
                                 default = nil)
  if valid_595895 != nil:
    section.add "X-Amz-Signature", valid_595895
  var valid_595896 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595896 = validateParameter(valid_595896, JString, required = false,
                                 default = nil)
  if valid_595896 != nil:
    section.add "X-Amz-SignedHeaders", valid_595896
  var valid_595897 = header.getOrDefault("X-Amz-Credential")
  valid_595897 = validateParameter(valid_595897, JString, required = false,
                                 default = nil)
  if valid_595897 != nil:
    section.add "X-Amz-Credential", valid_595897
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595898: Call_GetDescribeReservedNodeOfferings_595883;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_595898.validator(path, query, header, formData, body)
  let scheme = call_595898.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595898.url(scheme.get, call_595898.host, call_595898.base,
                         call_595898.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595898, url, valid)

proc call*(call_595899: Call_GetDescribeReservedNodeOfferings_595883;
          MaxRecords: int = 0; ReservedNodeOfferingId: string = "";
          Action: string = "DescribeReservedNodeOfferings"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  var query_595900 = newJObject()
  add(query_595900, "MaxRecords", newJInt(MaxRecords))
  add(query_595900, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_595900, "Action", newJString(Action))
  add(query_595900, "Marker", newJString(Marker))
  add(query_595900, "Version", newJString(Version))
  result = call_595899.call(nil, query_595900, nil, nil, nil)

var getDescribeReservedNodeOfferings* = Call_GetDescribeReservedNodeOfferings_595883(
    name: "getDescribeReservedNodeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_GetDescribeReservedNodeOfferings_595884, base: "/",
    url: url_GetDescribeReservedNodeOfferings_595885,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodes_595938 = ref object of OpenApiRestCall_593421
proc url_PostDescribeReservedNodes_595940(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeReservedNodes_595939(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595941 = query.getOrDefault("Action")
  valid_595941 = validateParameter(valid_595941, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_595941 != nil:
    section.add "Action", valid_595941
  var valid_595942 = query.getOrDefault("Version")
  valid_595942 = validateParameter(valid_595942, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595942 != nil:
    section.add "Version", valid_595942
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595943 = header.getOrDefault("X-Amz-Date")
  valid_595943 = validateParameter(valid_595943, JString, required = false,
                                 default = nil)
  if valid_595943 != nil:
    section.add "X-Amz-Date", valid_595943
  var valid_595944 = header.getOrDefault("X-Amz-Security-Token")
  valid_595944 = validateParameter(valid_595944, JString, required = false,
                                 default = nil)
  if valid_595944 != nil:
    section.add "X-Amz-Security-Token", valid_595944
  var valid_595945 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595945 = validateParameter(valid_595945, JString, required = false,
                                 default = nil)
  if valid_595945 != nil:
    section.add "X-Amz-Content-Sha256", valid_595945
  var valid_595946 = header.getOrDefault("X-Amz-Algorithm")
  valid_595946 = validateParameter(valid_595946, JString, required = false,
                                 default = nil)
  if valid_595946 != nil:
    section.add "X-Amz-Algorithm", valid_595946
  var valid_595947 = header.getOrDefault("X-Amz-Signature")
  valid_595947 = validateParameter(valid_595947, JString, required = false,
                                 default = nil)
  if valid_595947 != nil:
    section.add "X-Amz-Signature", valid_595947
  var valid_595948 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595948 = validateParameter(valid_595948, JString, required = false,
                                 default = nil)
  if valid_595948 != nil:
    section.add "X-Amz-SignedHeaders", valid_595948
  var valid_595949 = header.getOrDefault("X-Amz-Credential")
  valid_595949 = validateParameter(valid_595949, JString, required = false,
                                 default = nil)
  if valid_595949 != nil:
    section.add "X-Amz-Credential", valid_595949
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_595950 = formData.getOrDefault("ReservedNodeId")
  valid_595950 = validateParameter(valid_595950, JString, required = false,
                                 default = nil)
  if valid_595950 != nil:
    section.add "ReservedNodeId", valid_595950
  var valid_595951 = formData.getOrDefault("Marker")
  valid_595951 = validateParameter(valid_595951, JString, required = false,
                                 default = nil)
  if valid_595951 != nil:
    section.add "Marker", valid_595951
  var valid_595952 = formData.getOrDefault("MaxRecords")
  valid_595952 = validateParameter(valid_595952, JInt, required = false, default = nil)
  if valid_595952 != nil:
    section.add "MaxRecords", valid_595952
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595953: Call_PostDescribeReservedNodes_595938; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_595953.validator(path, query, header, formData, body)
  let scheme = call_595953.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595953.url(scheme.get, call_595953.host, call_595953.base,
                         call_595953.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595953, url, valid)

proc call*(call_595954: Call_PostDescribeReservedNodes_595938;
          ReservedNodeId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodes"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_595955 = newJObject()
  var formData_595956 = newJObject()
  add(formData_595956, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_595956, "Marker", newJString(Marker))
  add(query_595955, "Action", newJString(Action))
  add(formData_595956, "MaxRecords", newJInt(MaxRecords))
  add(query_595955, "Version", newJString(Version))
  result = call_595954.call(nil, query_595955, nil, formData_595956, nil)

var postDescribeReservedNodes* = Call_PostDescribeReservedNodes_595938(
    name: "postDescribeReservedNodes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_PostDescribeReservedNodes_595939, base: "/",
    url: url_PostDescribeReservedNodes_595940,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodes_595920 = ref object of OpenApiRestCall_593421
proc url_GetDescribeReservedNodes_595922(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeReservedNodes_595921(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  section = newJObject()
  var valid_595923 = query.getOrDefault("MaxRecords")
  valid_595923 = validateParameter(valid_595923, JInt, required = false, default = nil)
  if valid_595923 != nil:
    section.add "MaxRecords", valid_595923
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595924 = query.getOrDefault("Action")
  valid_595924 = validateParameter(valid_595924, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_595924 != nil:
    section.add "Action", valid_595924
  var valid_595925 = query.getOrDefault("Marker")
  valid_595925 = validateParameter(valid_595925, JString, required = false,
                                 default = nil)
  if valid_595925 != nil:
    section.add "Marker", valid_595925
  var valid_595926 = query.getOrDefault("Version")
  valid_595926 = validateParameter(valid_595926, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595926 != nil:
    section.add "Version", valid_595926
  var valid_595927 = query.getOrDefault("ReservedNodeId")
  valid_595927 = validateParameter(valid_595927, JString, required = false,
                                 default = nil)
  if valid_595927 != nil:
    section.add "ReservedNodeId", valid_595927
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595928 = header.getOrDefault("X-Amz-Date")
  valid_595928 = validateParameter(valid_595928, JString, required = false,
                                 default = nil)
  if valid_595928 != nil:
    section.add "X-Amz-Date", valid_595928
  var valid_595929 = header.getOrDefault("X-Amz-Security-Token")
  valid_595929 = validateParameter(valid_595929, JString, required = false,
                                 default = nil)
  if valid_595929 != nil:
    section.add "X-Amz-Security-Token", valid_595929
  var valid_595930 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595930 = validateParameter(valid_595930, JString, required = false,
                                 default = nil)
  if valid_595930 != nil:
    section.add "X-Amz-Content-Sha256", valid_595930
  var valid_595931 = header.getOrDefault("X-Amz-Algorithm")
  valid_595931 = validateParameter(valid_595931, JString, required = false,
                                 default = nil)
  if valid_595931 != nil:
    section.add "X-Amz-Algorithm", valid_595931
  var valid_595932 = header.getOrDefault("X-Amz-Signature")
  valid_595932 = validateParameter(valid_595932, JString, required = false,
                                 default = nil)
  if valid_595932 != nil:
    section.add "X-Amz-Signature", valid_595932
  var valid_595933 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595933 = validateParameter(valid_595933, JString, required = false,
                                 default = nil)
  if valid_595933 != nil:
    section.add "X-Amz-SignedHeaders", valid_595933
  var valid_595934 = header.getOrDefault("X-Amz-Credential")
  valid_595934 = validateParameter(valid_595934, JString, required = false,
                                 default = nil)
  if valid_595934 != nil:
    section.add "X-Amz-Credential", valid_595934
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595935: Call_GetDescribeReservedNodes_595920; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_595935.validator(path, query, header, formData, body)
  let scheme = call_595935.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595935.url(scheme.get, call_595935.host, call_595935.base,
                         call_595935.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595935, url, valid)

proc call*(call_595936: Call_GetDescribeReservedNodes_595920; MaxRecords: int = 0;
          Action: string = "DescribeReservedNodes"; Marker: string = "";
          Version: string = "2012-12-01"; ReservedNodeId: string = ""): Recallable =
  ## getDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  var query_595937 = newJObject()
  add(query_595937, "MaxRecords", newJInt(MaxRecords))
  add(query_595937, "Action", newJString(Action))
  add(query_595937, "Marker", newJString(Marker))
  add(query_595937, "Version", newJString(Version))
  add(query_595937, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_595936.call(nil, query_595937, nil, nil, nil)

var getDescribeReservedNodes* = Call_GetDescribeReservedNodes_595920(
    name: "getDescribeReservedNodes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_GetDescribeReservedNodes_595921, base: "/",
    url: url_GetDescribeReservedNodes_595922, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeResize_595973 = ref object of OpenApiRestCall_593421
proc url_PostDescribeResize_595975(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeResize_595974(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595976 = query.getOrDefault("Action")
  valid_595976 = validateParameter(valid_595976, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_595976 != nil:
    section.add "Action", valid_595976
  var valid_595977 = query.getOrDefault("Version")
  valid_595977 = validateParameter(valid_595977, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595977 != nil:
    section.add "Version", valid_595977
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595978 = header.getOrDefault("X-Amz-Date")
  valid_595978 = validateParameter(valid_595978, JString, required = false,
                                 default = nil)
  if valid_595978 != nil:
    section.add "X-Amz-Date", valid_595978
  var valid_595979 = header.getOrDefault("X-Amz-Security-Token")
  valid_595979 = validateParameter(valid_595979, JString, required = false,
                                 default = nil)
  if valid_595979 != nil:
    section.add "X-Amz-Security-Token", valid_595979
  var valid_595980 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595980 = validateParameter(valid_595980, JString, required = false,
                                 default = nil)
  if valid_595980 != nil:
    section.add "X-Amz-Content-Sha256", valid_595980
  var valid_595981 = header.getOrDefault("X-Amz-Algorithm")
  valid_595981 = validateParameter(valid_595981, JString, required = false,
                                 default = nil)
  if valid_595981 != nil:
    section.add "X-Amz-Algorithm", valid_595981
  var valid_595982 = header.getOrDefault("X-Amz-Signature")
  valid_595982 = validateParameter(valid_595982, JString, required = false,
                                 default = nil)
  if valid_595982 != nil:
    section.add "X-Amz-Signature", valid_595982
  var valid_595983 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595983 = validateParameter(valid_595983, JString, required = false,
                                 default = nil)
  if valid_595983 != nil:
    section.add "X-Amz-SignedHeaders", valid_595983
  var valid_595984 = header.getOrDefault("X-Amz-Credential")
  valid_595984 = validateParameter(valid_595984, JString, required = false,
                                 default = nil)
  if valid_595984 != nil:
    section.add "X-Amz-Credential", valid_595984
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595985 = formData.getOrDefault("ClusterIdentifier")
  valid_595985 = validateParameter(valid_595985, JString, required = true,
                                 default = nil)
  if valid_595985 != nil:
    section.add "ClusterIdentifier", valid_595985
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595986: Call_PostDescribeResize_595973; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_595986.validator(path, query, header, formData, body)
  let scheme = call_595986.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595986.url(scheme.get, call_595986.host, call_595986.base,
                         call_595986.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595986, url, valid)

proc call*(call_595987: Call_PostDescribeResize_595973; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_595988 = newJObject()
  var formData_595989 = newJObject()
  add(query_595988, "Action", newJString(Action))
  add(formData_595989, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595988, "Version", newJString(Version))
  result = call_595987.call(nil, query_595988, nil, formData_595989, nil)

var postDescribeResize* = Call_PostDescribeResize_595973(
    name: "postDescribeResize", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeResize",
    validator: validate_PostDescribeResize_595974, base: "/",
    url: url_PostDescribeResize_595975, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeResize_595957 = ref object of OpenApiRestCall_593421
proc url_GetDescribeResize_595959(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeResize_595958(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595960 = query.getOrDefault("Action")
  valid_595960 = validateParameter(valid_595960, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_595960 != nil:
    section.add "Action", valid_595960
  var valid_595961 = query.getOrDefault("ClusterIdentifier")
  valid_595961 = validateParameter(valid_595961, JString, required = true,
                                 default = nil)
  if valid_595961 != nil:
    section.add "ClusterIdentifier", valid_595961
  var valid_595962 = query.getOrDefault("Version")
  valid_595962 = validateParameter(valid_595962, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595962 != nil:
    section.add "Version", valid_595962
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_595963 = header.getOrDefault("X-Amz-Date")
  valid_595963 = validateParameter(valid_595963, JString, required = false,
                                 default = nil)
  if valid_595963 != nil:
    section.add "X-Amz-Date", valid_595963
  var valid_595964 = header.getOrDefault("X-Amz-Security-Token")
  valid_595964 = validateParameter(valid_595964, JString, required = false,
                                 default = nil)
  if valid_595964 != nil:
    section.add "X-Amz-Security-Token", valid_595964
  var valid_595965 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595965 = validateParameter(valid_595965, JString, required = false,
                                 default = nil)
  if valid_595965 != nil:
    section.add "X-Amz-Content-Sha256", valid_595965
  var valid_595966 = header.getOrDefault("X-Amz-Algorithm")
  valid_595966 = validateParameter(valid_595966, JString, required = false,
                                 default = nil)
  if valid_595966 != nil:
    section.add "X-Amz-Algorithm", valid_595966
  var valid_595967 = header.getOrDefault("X-Amz-Signature")
  valid_595967 = validateParameter(valid_595967, JString, required = false,
                                 default = nil)
  if valid_595967 != nil:
    section.add "X-Amz-Signature", valid_595967
  var valid_595968 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595968 = validateParameter(valid_595968, JString, required = false,
                                 default = nil)
  if valid_595968 != nil:
    section.add "X-Amz-SignedHeaders", valid_595968
  var valid_595969 = header.getOrDefault("X-Amz-Credential")
  valid_595969 = validateParameter(valid_595969, JString, required = false,
                                 default = nil)
  if valid_595969 != nil:
    section.add "X-Amz-Credential", valid_595969
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595970: Call_GetDescribeResize_595957; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_595970.validator(path, query, header, formData, body)
  let scheme = call_595970.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595970.url(scheme.get, call_595970.host, call_595970.base,
                         call_595970.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595970, url, valid)

proc call*(call_595971: Call_GetDescribeResize_595957; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_595972 = newJObject()
  add(query_595972, "Action", newJString(Action))
  add(query_595972, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595972, "Version", newJString(Version))
  result = call_595971.call(nil, query_595972, nil, nil, nil)

var getDescribeResize* = Call_GetDescribeResize_595957(name: "getDescribeResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeResize", validator: validate_GetDescribeResize_595958,
    base: "/", url: url_GetDescribeResize_595959,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotCopyGrants_596010 = ref object of OpenApiRestCall_593421
proc url_PostDescribeSnapshotCopyGrants_596012(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeSnapshotCopyGrants_596011(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596013 = query.getOrDefault("Action")
  valid_596013 = validateParameter(valid_596013, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_596013 != nil:
    section.add "Action", valid_596013
  var valid_596014 = query.getOrDefault("Version")
  valid_596014 = validateParameter(valid_596014, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596014 != nil:
    section.add "Version", valid_596014
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596015 = header.getOrDefault("X-Amz-Date")
  valid_596015 = validateParameter(valid_596015, JString, required = false,
                                 default = nil)
  if valid_596015 != nil:
    section.add "X-Amz-Date", valid_596015
  var valid_596016 = header.getOrDefault("X-Amz-Security-Token")
  valid_596016 = validateParameter(valid_596016, JString, required = false,
                                 default = nil)
  if valid_596016 != nil:
    section.add "X-Amz-Security-Token", valid_596016
  var valid_596017 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596017 = validateParameter(valid_596017, JString, required = false,
                                 default = nil)
  if valid_596017 != nil:
    section.add "X-Amz-Content-Sha256", valid_596017
  var valid_596018 = header.getOrDefault("X-Amz-Algorithm")
  valid_596018 = validateParameter(valid_596018, JString, required = false,
                                 default = nil)
  if valid_596018 != nil:
    section.add "X-Amz-Algorithm", valid_596018
  var valid_596019 = header.getOrDefault("X-Amz-Signature")
  valid_596019 = validateParameter(valid_596019, JString, required = false,
                                 default = nil)
  if valid_596019 != nil:
    section.add "X-Amz-Signature", valid_596019
  var valid_596020 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596020 = validateParameter(valid_596020, JString, required = false,
                                 default = nil)
  if valid_596020 != nil:
    section.add "X-Amz-SignedHeaders", valid_596020
  var valid_596021 = header.getOrDefault("X-Amz-Credential")
  valid_596021 = validateParameter(valid_596021, JString, required = false,
                                 default = nil)
  if valid_596021 != nil:
    section.add "X-Amz-Credential", valid_596021
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_596022 = formData.getOrDefault("Marker")
  valid_596022 = validateParameter(valid_596022, JString, required = false,
                                 default = nil)
  if valid_596022 != nil:
    section.add "Marker", valid_596022
  var valid_596023 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_596023 = validateParameter(valid_596023, JString, required = false,
                                 default = nil)
  if valid_596023 != nil:
    section.add "SnapshotCopyGrantName", valid_596023
  var valid_596024 = formData.getOrDefault("TagKeys")
  valid_596024 = validateParameter(valid_596024, JArray, required = false,
                                 default = nil)
  if valid_596024 != nil:
    section.add "TagKeys", valid_596024
  var valid_596025 = formData.getOrDefault("MaxRecords")
  valid_596025 = validateParameter(valid_596025, JInt, required = false, default = nil)
  if valid_596025 != nil:
    section.add "MaxRecords", valid_596025
  var valid_596026 = formData.getOrDefault("TagValues")
  valid_596026 = validateParameter(valid_596026, JArray, required = false,
                                 default = nil)
  if valid_596026 != nil:
    section.add "TagValues", valid_596026
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596027: Call_PostDescribeSnapshotCopyGrants_596010; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_596027.validator(path, query, header, formData, body)
  let scheme = call_596027.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596027.url(scheme.get, call_596027.host, call_596027.base,
                         call_596027.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596027, url, valid)

proc call*(call_596028: Call_PostDescribeSnapshotCopyGrants_596010;
          Marker: string = ""; Action: string = "DescribeSnapshotCopyGrants";
          SnapshotCopyGrantName: string = ""; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_596029 = newJObject()
  var formData_596030 = newJObject()
  add(formData_596030, "Marker", newJString(Marker))
  add(query_596029, "Action", newJString(Action))
  add(formData_596030, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  if TagKeys != nil:
    formData_596030.add "TagKeys", TagKeys
  add(formData_596030, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_596030.add "TagValues", TagValues
  add(query_596029, "Version", newJString(Version))
  result = call_596028.call(nil, query_596029, nil, formData_596030, nil)

var postDescribeSnapshotCopyGrants* = Call_PostDescribeSnapshotCopyGrants_596010(
    name: "postDescribeSnapshotCopyGrants", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_PostDescribeSnapshotCopyGrants_596011, base: "/",
    url: url_PostDescribeSnapshotCopyGrants_596012,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotCopyGrants_595990 = ref object of OpenApiRestCall_593421
proc url_GetDescribeSnapshotCopyGrants_595992(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeSnapshotCopyGrants_595991(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595993 = query.getOrDefault("TagValues")
  valid_595993 = validateParameter(valid_595993, JArray, required = false,
                                 default = nil)
  if valid_595993 != nil:
    section.add "TagValues", valid_595993
  var valid_595994 = query.getOrDefault("MaxRecords")
  valid_595994 = validateParameter(valid_595994, JInt, required = false, default = nil)
  if valid_595994 != nil:
    section.add "MaxRecords", valid_595994
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595995 = query.getOrDefault("Action")
  valid_595995 = validateParameter(valid_595995, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_595995 != nil:
    section.add "Action", valid_595995
  var valid_595996 = query.getOrDefault("Marker")
  valid_595996 = validateParameter(valid_595996, JString, required = false,
                                 default = nil)
  if valid_595996 != nil:
    section.add "Marker", valid_595996
  var valid_595997 = query.getOrDefault("SnapshotCopyGrantName")
  valid_595997 = validateParameter(valid_595997, JString, required = false,
                                 default = nil)
  if valid_595997 != nil:
    section.add "SnapshotCopyGrantName", valid_595997
  var valid_595998 = query.getOrDefault("TagKeys")
  valid_595998 = validateParameter(valid_595998, JArray, required = false,
                                 default = nil)
  if valid_595998 != nil:
    section.add "TagKeys", valid_595998
  var valid_595999 = query.getOrDefault("Version")
  valid_595999 = validateParameter(valid_595999, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595999 != nil:
    section.add "Version", valid_595999
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596000 = header.getOrDefault("X-Amz-Date")
  valid_596000 = validateParameter(valid_596000, JString, required = false,
                                 default = nil)
  if valid_596000 != nil:
    section.add "X-Amz-Date", valid_596000
  var valid_596001 = header.getOrDefault("X-Amz-Security-Token")
  valid_596001 = validateParameter(valid_596001, JString, required = false,
                                 default = nil)
  if valid_596001 != nil:
    section.add "X-Amz-Security-Token", valid_596001
  var valid_596002 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596002 = validateParameter(valid_596002, JString, required = false,
                                 default = nil)
  if valid_596002 != nil:
    section.add "X-Amz-Content-Sha256", valid_596002
  var valid_596003 = header.getOrDefault("X-Amz-Algorithm")
  valid_596003 = validateParameter(valid_596003, JString, required = false,
                                 default = nil)
  if valid_596003 != nil:
    section.add "X-Amz-Algorithm", valid_596003
  var valid_596004 = header.getOrDefault("X-Amz-Signature")
  valid_596004 = validateParameter(valid_596004, JString, required = false,
                                 default = nil)
  if valid_596004 != nil:
    section.add "X-Amz-Signature", valid_596004
  var valid_596005 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596005 = validateParameter(valid_596005, JString, required = false,
                                 default = nil)
  if valid_596005 != nil:
    section.add "X-Amz-SignedHeaders", valid_596005
  var valid_596006 = header.getOrDefault("X-Amz-Credential")
  valid_596006 = validateParameter(valid_596006, JString, required = false,
                                 default = nil)
  if valid_596006 != nil:
    section.add "X-Amz-Credential", valid_596006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596007: Call_GetDescribeSnapshotCopyGrants_595990; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_596007.validator(path, query, header, formData, body)
  let scheme = call_596007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596007.url(scheme.get, call_596007.host, call_596007.base,
                         call_596007.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596007, url, valid)

proc call*(call_596008: Call_GetDescribeSnapshotCopyGrants_595990;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeSnapshotCopyGrants"; Marker: string = "";
          SnapshotCopyGrantName: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_596009 = newJObject()
  if TagValues != nil:
    query_596009.add "TagValues", TagValues
  add(query_596009, "MaxRecords", newJInt(MaxRecords))
  add(query_596009, "Action", newJString(Action))
  add(query_596009, "Marker", newJString(Marker))
  add(query_596009, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  if TagKeys != nil:
    query_596009.add "TagKeys", TagKeys
  add(query_596009, "Version", newJString(Version))
  result = call_596008.call(nil, query_596009, nil, nil, nil)

var getDescribeSnapshotCopyGrants* = Call_GetDescribeSnapshotCopyGrants_595990(
    name: "getDescribeSnapshotCopyGrants", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_GetDescribeSnapshotCopyGrants_595991, base: "/",
    url: url_GetDescribeSnapshotCopyGrants_595992,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotSchedules_596052 = ref object of OpenApiRestCall_593421
proc url_PostDescribeSnapshotSchedules_596054(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeSnapshotSchedules_596053(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596055 = query.getOrDefault("Action")
  valid_596055 = validateParameter(valid_596055, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_596055 != nil:
    section.add "Action", valid_596055
  var valid_596056 = query.getOrDefault("Version")
  valid_596056 = validateParameter(valid_596056, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596056 != nil:
    section.add "Version", valid_596056
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596057 = header.getOrDefault("X-Amz-Date")
  valid_596057 = validateParameter(valid_596057, JString, required = false,
                                 default = nil)
  if valid_596057 != nil:
    section.add "X-Amz-Date", valid_596057
  var valid_596058 = header.getOrDefault("X-Amz-Security-Token")
  valid_596058 = validateParameter(valid_596058, JString, required = false,
                                 default = nil)
  if valid_596058 != nil:
    section.add "X-Amz-Security-Token", valid_596058
  var valid_596059 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596059 = validateParameter(valid_596059, JString, required = false,
                                 default = nil)
  if valid_596059 != nil:
    section.add "X-Amz-Content-Sha256", valid_596059
  var valid_596060 = header.getOrDefault("X-Amz-Algorithm")
  valid_596060 = validateParameter(valid_596060, JString, required = false,
                                 default = nil)
  if valid_596060 != nil:
    section.add "X-Amz-Algorithm", valid_596060
  var valid_596061 = header.getOrDefault("X-Amz-Signature")
  valid_596061 = validateParameter(valid_596061, JString, required = false,
                                 default = nil)
  if valid_596061 != nil:
    section.add "X-Amz-Signature", valid_596061
  var valid_596062 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596062 = validateParameter(valid_596062, JString, required = false,
                                 default = nil)
  if valid_596062 != nil:
    section.add "X-Amz-SignedHeaders", valid_596062
  var valid_596063 = header.getOrDefault("X-Amz-Credential")
  valid_596063 = validateParameter(valid_596063, JString, required = false,
                                 default = nil)
  if valid_596063 != nil:
    section.add "X-Amz-Credential", valid_596063
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  section = newJObject()
  var valid_596064 = formData.getOrDefault("Marker")
  valid_596064 = validateParameter(valid_596064, JString, required = false,
                                 default = nil)
  if valid_596064 != nil:
    section.add "Marker", valid_596064
  var valid_596065 = formData.getOrDefault("ClusterIdentifier")
  valid_596065 = validateParameter(valid_596065, JString, required = false,
                                 default = nil)
  if valid_596065 != nil:
    section.add "ClusterIdentifier", valid_596065
  var valid_596066 = formData.getOrDefault("ScheduleIdentifier")
  valid_596066 = validateParameter(valid_596066, JString, required = false,
                                 default = nil)
  if valid_596066 != nil:
    section.add "ScheduleIdentifier", valid_596066
  var valid_596067 = formData.getOrDefault("TagKeys")
  valid_596067 = validateParameter(valid_596067, JArray, required = false,
                                 default = nil)
  if valid_596067 != nil:
    section.add "TagKeys", valid_596067
  var valid_596068 = formData.getOrDefault("MaxRecords")
  valid_596068 = validateParameter(valid_596068, JInt, required = false, default = nil)
  if valid_596068 != nil:
    section.add "MaxRecords", valid_596068
  var valid_596069 = formData.getOrDefault("TagValues")
  valid_596069 = validateParameter(valid_596069, JArray, required = false,
                                 default = nil)
  if valid_596069 != nil:
    section.add "TagValues", valid_596069
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596070: Call_PostDescribeSnapshotSchedules_596052; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_596070.validator(path, query, header, formData, body)
  let scheme = call_596070.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596070.url(scheme.get, call_596070.host, call_596070.base,
                         call_596070.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596070, url, valid)

proc call*(call_596071: Call_PostDescribeSnapshotSchedules_596052;
          Marker: string = ""; Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; ScheduleIdentifier: string = "";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   Version: string (required)
  var query_596072 = newJObject()
  var formData_596073 = newJObject()
  add(formData_596073, "Marker", newJString(Marker))
  add(query_596072, "Action", newJString(Action))
  add(formData_596073, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_596073, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if TagKeys != nil:
    formData_596073.add "TagKeys", TagKeys
  add(formData_596073, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_596073.add "TagValues", TagValues
  add(query_596072, "Version", newJString(Version))
  result = call_596071.call(nil, query_596072, nil, formData_596073, nil)

var postDescribeSnapshotSchedules* = Call_PostDescribeSnapshotSchedules_596052(
    name: "postDescribeSnapshotSchedules", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_PostDescribeSnapshotSchedules_596053, base: "/",
    url: url_PostDescribeSnapshotSchedules_596054,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotSchedules_596031 = ref object of OpenApiRestCall_593421
proc url_GetDescribeSnapshotSchedules_596033(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeSnapshotSchedules_596032(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Version: JString (required)
  section = newJObject()
  var valid_596034 = query.getOrDefault("TagValues")
  valid_596034 = validateParameter(valid_596034, JArray, required = false,
                                 default = nil)
  if valid_596034 != nil:
    section.add "TagValues", valid_596034
  var valid_596035 = query.getOrDefault("MaxRecords")
  valid_596035 = validateParameter(valid_596035, JInt, required = false, default = nil)
  if valid_596035 != nil:
    section.add "MaxRecords", valid_596035
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596036 = query.getOrDefault("Action")
  valid_596036 = validateParameter(valid_596036, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_596036 != nil:
    section.add "Action", valid_596036
  var valid_596037 = query.getOrDefault("ClusterIdentifier")
  valid_596037 = validateParameter(valid_596037, JString, required = false,
                                 default = nil)
  if valid_596037 != nil:
    section.add "ClusterIdentifier", valid_596037
  var valid_596038 = query.getOrDefault("ScheduleIdentifier")
  valid_596038 = validateParameter(valid_596038, JString, required = false,
                                 default = nil)
  if valid_596038 != nil:
    section.add "ScheduleIdentifier", valid_596038
  var valid_596039 = query.getOrDefault("Marker")
  valid_596039 = validateParameter(valid_596039, JString, required = false,
                                 default = nil)
  if valid_596039 != nil:
    section.add "Marker", valid_596039
  var valid_596040 = query.getOrDefault("TagKeys")
  valid_596040 = validateParameter(valid_596040, JArray, required = false,
                                 default = nil)
  if valid_596040 != nil:
    section.add "TagKeys", valid_596040
  var valid_596041 = query.getOrDefault("Version")
  valid_596041 = validateParameter(valid_596041, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596041 != nil:
    section.add "Version", valid_596041
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596042 = header.getOrDefault("X-Amz-Date")
  valid_596042 = validateParameter(valid_596042, JString, required = false,
                                 default = nil)
  if valid_596042 != nil:
    section.add "X-Amz-Date", valid_596042
  var valid_596043 = header.getOrDefault("X-Amz-Security-Token")
  valid_596043 = validateParameter(valid_596043, JString, required = false,
                                 default = nil)
  if valid_596043 != nil:
    section.add "X-Amz-Security-Token", valid_596043
  var valid_596044 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596044 = validateParameter(valid_596044, JString, required = false,
                                 default = nil)
  if valid_596044 != nil:
    section.add "X-Amz-Content-Sha256", valid_596044
  var valid_596045 = header.getOrDefault("X-Amz-Algorithm")
  valid_596045 = validateParameter(valid_596045, JString, required = false,
                                 default = nil)
  if valid_596045 != nil:
    section.add "X-Amz-Algorithm", valid_596045
  var valid_596046 = header.getOrDefault("X-Amz-Signature")
  valid_596046 = validateParameter(valid_596046, JString, required = false,
                                 default = nil)
  if valid_596046 != nil:
    section.add "X-Amz-Signature", valid_596046
  var valid_596047 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596047 = validateParameter(valid_596047, JString, required = false,
                                 default = nil)
  if valid_596047 != nil:
    section.add "X-Amz-SignedHeaders", valid_596047
  var valid_596048 = header.getOrDefault("X-Amz-Credential")
  valid_596048 = validateParameter(valid_596048, JString, required = false,
                                 default = nil)
  if valid_596048 != nil:
    section.add "X-Amz-Credential", valid_596048
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596049: Call_GetDescribeSnapshotSchedules_596031; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_596049.validator(path, query, header, formData, body)
  let scheme = call_596049.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596049.url(scheme.get, call_596049.host, call_596049.base,
                         call_596049.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596049, url, valid)

proc call*(call_596050: Call_GetDescribeSnapshotSchedules_596031;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; ScheduleIdentifier: string = "";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Version: string (required)
  var query_596051 = newJObject()
  if TagValues != nil:
    query_596051.add "TagValues", TagValues
  add(query_596051, "MaxRecords", newJInt(MaxRecords))
  add(query_596051, "Action", newJString(Action))
  add(query_596051, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596051, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_596051, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_596051.add "TagKeys", TagKeys
  add(query_596051, "Version", newJString(Version))
  result = call_596050.call(nil, query_596051, nil, nil, nil)

var getDescribeSnapshotSchedules* = Call_GetDescribeSnapshotSchedules_596031(
    name: "getDescribeSnapshotSchedules", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_GetDescribeSnapshotSchedules_596032, base: "/",
    url: url_GetDescribeSnapshotSchedules_596033,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeStorage_596089 = ref object of OpenApiRestCall_593421
proc url_PostDescribeStorage_596091(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeStorage_596090(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596092 = query.getOrDefault("Action")
  valid_596092 = validateParameter(valid_596092, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_596092 != nil:
    section.add "Action", valid_596092
  var valid_596093 = query.getOrDefault("Version")
  valid_596093 = validateParameter(valid_596093, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596093 != nil:
    section.add "Version", valid_596093
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596094 = header.getOrDefault("X-Amz-Date")
  valid_596094 = validateParameter(valid_596094, JString, required = false,
                                 default = nil)
  if valid_596094 != nil:
    section.add "X-Amz-Date", valid_596094
  var valid_596095 = header.getOrDefault("X-Amz-Security-Token")
  valid_596095 = validateParameter(valid_596095, JString, required = false,
                                 default = nil)
  if valid_596095 != nil:
    section.add "X-Amz-Security-Token", valid_596095
  var valid_596096 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596096 = validateParameter(valid_596096, JString, required = false,
                                 default = nil)
  if valid_596096 != nil:
    section.add "X-Amz-Content-Sha256", valid_596096
  var valid_596097 = header.getOrDefault("X-Amz-Algorithm")
  valid_596097 = validateParameter(valid_596097, JString, required = false,
                                 default = nil)
  if valid_596097 != nil:
    section.add "X-Amz-Algorithm", valid_596097
  var valid_596098 = header.getOrDefault("X-Amz-Signature")
  valid_596098 = validateParameter(valid_596098, JString, required = false,
                                 default = nil)
  if valid_596098 != nil:
    section.add "X-Amz-Signature", valid_596098
  var valid_596099 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596099 = validateParameter(valid_596099, JString, required = false,
                                 default = nil)
  if valid_596099 != nil:
    section.add "X-Amz-SignedHeaders", valid_596099
  var valid_596100 = header.getOrDefault("X-Amz-Credential")
  valid_596100 = validateParameter(valid_596100, JString, required = false,
                                 default = nil)
  if valid_596100 != nil:
    section.add "X-Amz-Credential", valid_596100
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596101: Call_PostDescribeStorage_596089; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_596101.validator(path, query, header, formData, body)
  let scheme = call_596101.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596101.url(scheme.get, call_596101.host, call_596101.base,
                         call_596101.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596101, url, valid)

proc call*(call_596102: Call_PostDescribeStorage_596089;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_596103 = newJObject()
  add(query_596103, "Action", newJString(Action))
  add(query_596103, "Version", newJString(Version))
  result = call_596102.call(nil, query_596103, nil, nil, nil)

var postDescribeStorage* = Call_PostDescribeStorage_596089(
    name: "postDescribeStorage", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_PostDescribeStorage_596090, base: "/",
    url: url_PostDescribeStorage_596091, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeStorage_596074 = ref object of OpenApiRestCall_593421
proc url_GetDescribeStorage_596076(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeStorage_596075(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596077 = query.getOrDefault("Action")
  valid_596077 = validateParameter(valid_596077, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_596077 != nil:
    section.add "Action", valid_596077
  var valid_596078 = query.getOrDefault("Version")
  valid_596078 = validateParameter(valid_596078, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596078 != nil:
    section.add "Version", valid_596078
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596079 = header.getOrDefault("X-Amz-Date")
  valid_596079 = validateParameter(valid_596079, JString, required = false,
                                 default = nil)
  if valid_596079 != nil:
    section.add "X-Amz-Date", valid_596079
  var valid_596080 = header.getOrDefault("X-Amz-Security-Token")
  valid_596080 = validateParameter(valid_596080, JString, required = false,
                                 default = nil)
  if valid_596080 != nil:
    section.add "X-Amz-Security-Token", valid_596080
  var valid_596081 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596081 = validateParameter(valid_596081, JString, required = false,
                                 default = nil)
  if valid_596081 != nil:
    section.add "X-Amz-Content-Sha256", valid_596081
  var valid_596082 = header.getOrDefault("X-Amz-Algorithm")
  valid_596082 = validateParameter(valid_596082, JString, required = false,
                                 default = nil)
  if valid_596082 != nil:
    section.add "X-Amz-Algorithm", valid_596082
  var valid_596083 = header.getOrDefault("X-Amz-Signature")
  valid_596083 = validateParameter(valid_596083, JString, required = false,
                                 default = nil)
  if valid_596083 != nil:
    section.add "X-Amz-Signature", valid_596083
  var valid_596084 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596084 = validateParameter(valid_596084, JString, required = false,
                                 default = nil)
  if valid_596084 != nil:
    section.add "X-Amz-SignedHeaders", valid_596084
  var valid_596085 = header.getOrDefault("X-Amz-Credential")
  valid_596085 = validateParameter(valid_596085, JString, required = false,
                                 default = nil)
  if valid_596085 != nil:
    section.add "X-Amz-Credential", valid_596085
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596086: Call_GetDescribeStorage_596074; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_596086.validator(path, query, header, formData, body)
  let scheme = call_596086.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596086.url(scheme.get, call_596086.host, call_596086.base,
                         call_596086.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596086, url, valid)

proc call*(call_596087: Call_GetDescribeStorage_596074;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_596088 = newJObject()
  add(query_596088, "Action", newJString(Action))
  add(query_596088, "Version", newJString(Version))
  result = call_596087.call(nil, query_596088, nil, nil, nil)

var getDescribeStorage* = Call_GetDescribeStorage_596074(
    name: "getDescribeStorage", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_GetDescribeStorage_596075, base: "/",
    url: url_GetDescribeStorage_596076, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTableRestoreStatus_596123 = ref object of OpenApiRestCall_593421
proc url_PostDescribeTableRestoreStatus_596125(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeTableRestoreStatus_596124(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596126 = query.getOrDefault("Action")
  valid_596126 = validateParameter(valid_596126, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_596126 != nil:
    section.add "Action", valid_596126
  var valid_596127 = query.getOrDefault("Version")
  valid_596127 = validateParameter(valid_596127, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596127 != nil:
    section.add "Version", valid_596127
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596128 = header.getOrDefault("X-Amz-Date")
  valid_596128 = validateParameter(valid_596128, JString, required = false,
                                 default = nil)
  if valid_596128 != nil:
    section.add "X-Amz-Date", valid_596128
  var valid_596129 = header.getOrDefault("X-Amz-Security-Token")
  valid_596129 = validateParameter(valid_596129, JString, required = false,
                                 default = nil)
  if valid_596129 != nil:
    section.add "X-Amz-Security-Token", valid_596129
  var valid_596130 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596130 = validateParameter(valid_596130, JString, required = false,
                                 default = nil)
  if valid_596130 != nil:
    section.add "X-Amz-Content-Sha256", valid_596130
  var valid_596131 = header.getOrDefault("X-Amz-Algorithm")
  valid_596131 = validateParameter(valid_596131, JString, required = false,
                                 default = nil)
  if valid_596131 != nil:
    section.add "X-Amz-Algorithm", valid_596131
  var valid_596132 = header.getOrDefault("X-Amz-Signature")
  valid_596132 = validateParameter(valid_596132, JString, required = false,
                                 default = nil)
  if valid_596132 != nil:
    section.add "X-Amz-Signature", valid_596132
  var valid_596133 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596133 = validateParameter(valid_596133, JString, required = false,
                                 default = nil)
  if valid_596133 != nil:
    section.add "X-Amz-SignedHeaders", valid_596133
  var valid_596134 = header.getOrDefault("X-Amz-Credential")
  valid_596134 = validateParameter(valid_596134, JString, required = false,
                                 default = nil)
  if valid_596134 != nil:
    section.add "X-Amz-Credential", valid_596134
  result.add "header", section
  ## parameters in `formData` object:
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  section = newJObject()
  var valid_596135 = formData.getOrDefault("TableRestoreRequestId")
  valid_596135 = validateParameter(valid_596135, JString, required = false,
                                 default = nil)
  if valid_596135 != nil:
    section.add "TableRestoreRequestId", valid_596135
  var valid_596136 = formData.getOrDefault("Marker")
  valid_596136 = validateParameter(valid_596136, JString, required = false,
                                 default = nil)
  if valid_596136 != nil:
    section.add "Marker", valid_596136
  var valid_596137 = formData.getOrDefault("ClusterIdentifier")
  valid_596137 = validateParameter(valid_596137, JString, required = false,
                                 default = nil)
  if valid_596137 != nil:
    section.add "ClusterIdentifier", valid_596137
  var valid_596138 = formData.getOrDefault("MaxRecords")
  valid_596138 = validateParameter(valid_596138, JInt, required = false, default = nil)
  if valid_596138 != nil:
    section.add "MaxRecords", valid_596138
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596139: Call_PostDescribeTableRestoreStatus_596123; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_596139.validator(path, query, header, formData, body)
  let scheme = call_596139.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596139.url(scheme.get, call_596139.host, call_596139.base,
                         call_596139.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596139, url, valid)

proc call*(call_596140: Call_PostDescribeTableRestoreStatus_596123;
          TableRestoreRequestId: string = ""; Marker: string = "";
          Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Version: string (required)
  var query_596141 = newJObject()
  var formData_596142 = newJObject()
  add(formData_596142, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(formData_596142, "Marker", newJString(Marker))
  add(query_596141, "Action", newJString(Action))
  add(formData_596142, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_596142, "MaxRecords", newJInt(MaxRecords))
  add(query_596141, "Version", newJString(Version))
  result = call_596140.call(nil, query_596141, nil, formData_596142, nil)

var postDescribeTableRestoreStatus* = Call_PostDescribeTableRestoreStatus_596123(
    name: "postDescribeTableRestoreStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_PostDescribeTableRestoreStatus_596124, base: "/",
    url: url_PostDescribeTableRestoreStatus_596125,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTableRestoreStatus_596104 = ref object of OpenApiRestCall_593421
proc url_GetDescribeTableRestoreStatus_596106(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeTableRestoreStatus_596105(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Version: JString (required)
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  section = newJObject()
  var valid_596107 = query.getOrDefault("MaxRecords")
  valid_596107 = validateParameter(valid_596107, JInt, required = false, default = nil)
  if valid_596107 != nil:
    section.add "MaxRecords", valid_596107
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596108 = query.getOrDefault("Action")
  valid_596108 = validateParameter(valid_596108, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_596108 != nil:
    section.add "Action", valid_596108
  var valid_596109 = query.getOrDefault("ClusterIdentifier")
  valid_596109 = validateParameter(valid_596109, JString, required = false,
                                 default = nil)
  if valid_596109 != nil:
    section.add "ClusterIdentifier", valid_596109
  var valid_596110 = query.getOrDefault("Marker")
  valid_596110 = validateParameter(valid_596110, JString, required = false,
                                 default = nil)
  if valid_596110 != nil:
    section.add "Marker", valid_596110
  var valid_596111 = query.getOrDefault("Version")
  valid_596111 = validateParameter(valid_596111, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596111 != nil:
    section.add "Version", valid_596111
  var valid_596112 = query.getOrDefault("TableRestoreRequestId")
  valid_596112 = validateParameter(valid_596112, JString, required = false,
                                 default = nil)
  if valid_596112 != nil:
    section.add "TableRestoreRequestId", valid_596112
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596113 = header.getOrDefault("X-Amz-Date")
  valid_596113 = validateParameter(valid_596113, JString, required = false,
                                 default = nil)
  if valid_596113 != nil:
    section.add "X-Amz-Date", valid_596113
  var valid_596114 = header.getOrDefault("X-Amz-Security-Token")
  valid_596114 = validateParameter(valid_596114, JString, required = false,
                                 default = nil)
  if valid_596114 != nil:
    section.add "X-Amz-Security-Token", valid_596114
  var valid_596115 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596115 = validateParameter(valid_596115, JString, required = false,
                                 default = nil)
  if valid_596115 != nil:
    section.add "X-Amz-Content-Sha256", valid_596115
  var valid_596116 = header.getOrDefault("X-Amz-Algorithm")
  valid_596116 = validateParameter(valid_596116, JString, required = false,
                                 default = nil)
  if valid_596116 != nil:
    section.add "X-Amz-Algorithm", valid_596116
  var valid_596117 = header.getOrDefault("X-Amz-Signature")
  valid_596117 = validateParameter(valid_596117, JString, required = false,
                                 default = nil)
  if valid_596117 != nil:
    section.add "X-Amz-Signature", valid_596117
  var valid_596118 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596118 = validateParameter(valid_596118, JString, required = false,
                                 default = nil)
  if valid_596118 != nil:
    section.add "X-Amz-SignedHeaders", valid_596118
  var valid_596119 = header.getOrDefault("X-Amz-Credential")
  valid_596119 = validateParameter(valid_596119, JString, required = false,
                                 default = nil)
  if valid_596119 != nil:
    section.add "X-Amz-Credential", valid_596119
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596120: Call_GetDescribeTableRestoreStatus_596104; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_596120.validator(path, query, header, formData, body)
  let scheme = call_596120.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596120.url(scheme.get, call_596120.host, call_596120.base,
                         call_596120.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596120, url, valid)

proc call*(call_596121: Call_GetDescribeTableRestoreStatus_596104;
          MaxRecords: int = 0; Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; Marker: string = "";
          Version: string = "2012-12-01"; TableRestoreRequestId: string = ""): Recallable =
  ## getDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Version: string (required)
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  var query_596122 = newJObject()
  add(query_596122, "MaxRecords", newJInt(MaxRecords))
  add(query_596122, "Action", newJString(Action))
  add(query_596122, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596122, "Marker", newJString(Marker))
  add(query_596122, "Version", newJString(Version))
  add(query_596122, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  result = call_596121.call(nil, query_596122, nil, nil, nil)

var getDescribeTableRestoreStatus* = Call_GetDescribeTableRestoreStatus_596104(
    name: "getDescribeTableRestoreStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_GetDescribeTableRestoreStatus_596105, base: "/",
    url: url_GetDescribeTableRestoreStatus_596106,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTags_596164 = ref object of OpenApiRestCall_593421
proc url_PostDescribeTags_596166(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeTags_596165(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596167 = query.getOrDefault("Action")
  valid_596167 = validateParameter(valid_596167, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_596167 != nil:
    section.add "Action", valid_596167
  var valid_596168 = query.getOrDefault("Version")
  valid_596168 = validateParameter(valid_596168, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596168 != nil:
    section.add "Version", valid_596168
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596169 = header.getOrDefault("X-Amz-Date")
  valid_596169 = validateParameter(valid_596169, JString, required = false,
                                 default = nil)
  if valid_596169 != nil:
    section.add "X-Amz-Date", valid_596169
  var valid_596170 = header.getOrDefault("X-Amz-Security-Token")
  valid_596170 = validateParameter(valid_596170, JString, required = false,
                                 default = nil)
  if valid_596170 != nil:
    section.add "X-Amz-Security-Token", valid_596170
  var valid_596171 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596171 = validateParameter(valid_596171, JString, required = false,
                                 default = nil)
  if valid_596171 != nil:
    section.add "X-Amz-Content-Sha256", valid_596171
  var valid_596172 = header.getOrDefault("X-Amz-Algorithm")
  valid_596172 = validateParameter(valid_596172, JString, required = false,
                                 default = nil)
  if valid_596172 != nil:
    section.add "X-Amz-Algorithm", valid_596172
  var valid_596173 = header.getOrDefault("X-Amz-Signature")
  valid_596173 = validateParameter(valid_596173, JString, required = false,
                                 default = nil)
  if valid_596173 != nil:
    section.add "X-Amz-Signature", valid_596173
  var valid_596174 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596174 = validateParameter(valid_596174, JString, required = false,
                                 default = nil)
  if valid_596174 != nil:
    section.add "X-Amz-SignedHeaders", valid_596174
  var valid_596175 = header.getOrDefault("X-Amz-Credential")
  valid_596175 = validateParameter(valid_596175, JString, required = false,
                                 default = nil)
  if valid_596175 != nil:
    section.add "X-Amz-Credential", valid_596175
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_596176 = formData.getOrDefault("Marker")
  valid_596176 = validateParameter(valid_596176, JString, required = false,
                                 default = nil)
  if valid_596176 != nil:
    section.add "Marker", valid_596176
  var valid_596177 = formData.getOrDefault("ResourceType")
  valid_596177 = validateParameter(valid_596177, JString, required = false,
                                 default = nil)
  if valid_596177 != nil:
    section.add "ResourceType", valid_596177
  var valid_596178 = formData.getOrDefault("TagKeys")
  valid_596178 = validateParameter(valid_596178, JArray, required = false,
                                 default = nil)
  if valid_596178 != nil:
    section.add "TagKeys", valid_596178
  var valid_596179 = formData.getOrDefault("ResourceName")
  valid_596179 = validateParameter(valid_596179, JString, required = false,
                                 default = nil)
  if valid_596179 != nil:
    section.add "ResourceName", valid_596179
  var valid_596180 = formData.getOrDefault("MaxRecords")
  valid_596180 = validateParameter(valid_596180, JInt, required = false, default = nil)
  if valid_596180 != nil:
    section.add "MaxRecords", valid_596180
  var valid_596181 = formData.getOrDefault("TagValues")
  valid_596181 = validateParameter(valid_596181, JArray, required = false,
                                 default = nil)
  if valid_596181 != nil:
    section.add "TagValues", valid_596181
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596182: Call_PostDescribeTags_596164; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_596182.validator(path, query, header, formData, body)
  let scheme = call_596182.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596182.url(scheme.get, call_596182.host, call_596182.base,
                         call_596182.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596182, url, valid)

proc call*(call_596183: Call_PostDescribeTags_596164; Marker: string = "";
          Action: string = "DescribeTags"; ResourceType: string = "";
          TagKeys: JsonNode = nil; ResourceName: string = ""; MaxRecords: int = 0;
          TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   Action: string (required)
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_596184 = newJObject()
  var formData_596185 = newJObject()
  add(formData_596185, "Marker", newJString(Marker))
  add(query_596184, "Action", newJString(Action))
  add(formData_596185, "ResourceType", newJString(ResourceType))
  if TagKeys != nil:
    formData_596185.add "TagKeys", TagKeys
  add(formData_596185, "ResourceName", newJString(ResourceName))
  add(formData_596185, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_596185.add "TagValues", TagValues
  add(query_596184, "Version", newJString(Version))
  result = call_596183.call(nil, query_596184, nil, formData_596185, nil)

var postDescribeTags* = Call_PostDescribeTags_596164(name: "postDescribeTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_PostDescribeTags_596165,
    base: "/", url: url_PostDescribeTags_596166,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTags_596143 = ref object of OpenApiRestCall_593421
proc url_GetDescribeTags_596145(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeTags_596144(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_596146 = query.getOrDefault("TagValues")
  valid_596146 = validateParameter(valid_596146, JArray, required = false,
                                 default = nil)
  if valid_596146 != nil:
    section.add "TagValues", valid_596146
  var valid_596147 = query.getOrDefault("MaxRecords")
  valid_596147 = validateParameter(valid_596147, JInt, required = false, default = nil)
  if valid_596147 != nil:
    section.add "MaxRecords", valid_596147
  var valid_596148 = query.getOrDefault("ResourceName")
  valid_596148 = validateParameter(valid_596148, JString, required = false,
                                 default = nil)
  if valid_596148 != nil:
    section.add "ResourceName", valid_596148
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596149 = query.getOrDefault("Action")
  valid_596149 = validateParameter(valid_596149, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_596149 != nil:
    section.add "Action", valid_596149
  var valid_596150 = query.getOrDefault("Marker")
  valid_596150 = validateParameter(valid_596150, JString, required = false,
                                 default = nil)
  if valid_596150 != nil:
    section.add "Marker", valid_596150
  var valid_596151 = query.getOrDefault("TagKeys")
  valid_596151 = validateParameter(valid_596151, JArray, required = false,
                                 default = nil)
  if valid_596151 != nil:
    section.add "TagKeys", valid_596151
  var valid_596152 = query.getOrDefault("ResourceType")
  valid_596152 = validateParameter(valid_596152, JString, required = false,
                                 default = nil)
  if valid_596152 != nil:
    section.add "ResourceType", valid_596152
  var valid_596153 = query.getOrDefault("Version")
  valid_596153 = validateParameter(valid_596153, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596153 != nil:
    section.add "Version", valid_596153
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596154 = header.getOrDefault("X-Amz-Date")
  valid_596154 = validateParameter(valid_596154, JString, required = false,
                                 default = nil)
  if valid_596154 != nil:
    section.add "X-Amz-Date", valid_596154
  var valid_596155 = header.getOrDefault("X-Amz-Security-Token")
  valid_596155 = validateParameter(valid_596155, JString, required = false,
                                 default = nil)
  if valid_596155 != nil:
    section.add "X-Amz-Security-Token", valid_596155
  var valid_596156 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596156 = validateParameter(valid_596156, JString, required = false,
                                 default = nil)
  if valid_596156 != nil:
    section.add "X-Amz-Content-Sha256", valid_596156
  var valid_596157 = header.getOrDefault("X-Amz-Algorithm")
  valid_596157 = validateParameter(valid_596157, JString, required = false,
                                 default = nil)
  if valid_596157 != nil:
    section.add "X-Amz-Algorithm", valid_596157
  var valid_596158 = header.getOrDefault("X-Amz-Signature")
  valid_596158 = validateParameter(valid_596158, JString, required = false,
                                 default = nil)
  if valid_596158 != nil:
    section.add "X-Amz-Signature", valid_596158
  var valid_596159 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596159 = validateParameter(valid_596159, JString, required = false,
                                 default = nil)
  if valid_596159 != nil:
    section.add "X-Amz-SignedHeaders", valid_596159
  var valid_596160 = header.getOrDefault("X-Amz-Credential")
  valid_596160 = validateParameter(valid_596160, JString, required = false,
                                 default = nil)
  if valid_596160 != nil:
    section.add "X-Amz-Credential", valid_596160
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596161: Call_GetDescribeTags_596143; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_596161.validator(path, query, header, formData, body)
  let scheme = call_596161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596161.url(scheme.get, call_596161.host, call_596161.base,
                         call_596161.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596161, url, valid)

proc call*(call_596162: Call_GetDescribeTags_596143; TagValues: JsonNode = nil;
          MaxRecords: int = 0; ResourceName: string = "";
          Action: string = "DescribeTags"; Marker: string = ""; TagKeys: JsonNode = nil;
          ResourceType: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Version: string (required)
  var query_596163 = newJObject()
  if TagValues != nil:
    query_596163.add "TagValues", TagValues
  add(query_596163, "MaxRecords", newJInt(MaxRecords))
  add(query_596163, "ResourceName", newJString(ResourceName))
  add(query_596163, "Action", newJString(Action))
  add(query_596163, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_596163.add "TagKeys", TagKeys
  add(query_596163, "ResourceType", newJString(ResourceType))
  add(query_596163, "Version", newJString(Version))
  result = call_596162.call(nil, query_596163, nil, nil, nil)

var getDescribeTags* = Call_GetDescribeTags_596143(name: "getDescribeTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_GetDescribeTags_596144,
    base: "/", url: url_GetDescribeTags_596145, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableLogging_596202 = ref object of OpenApiRestCall_593421
proc url_PostDisableLogging_596204(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDisableLogging_596203(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596205 = query.getOrDefault("Action")
  valid_596205 = validateParameter(valid_596205, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_596205 != nil:
    section.add "Action", valid_596205
  var valid_596206 = query.getOrDefault("Version")
  valid_596206 = validateParameter(valid_596206, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596206 != nil:
    section.add "Version", valid_596206
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596207 = header.getOrDefault("X-Amz-Date")
  valid_596207 = validateParameter(valid_596207, JString, required = false,
                                 default = nil)
  if valid_596207 != nil:
    section.add "X-Amz-Date", valid_596207
  var valid_596208 = header.getOrDefault("X-Amz-Security-Token")
  valid_596208 = validateParameter(valid_596208, JString, required = false,
                                 default = nil)
  if valid_596208 != nil:
    section.add "X-Amz-Security-Token", valid_596208
  var valid_596209 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596209 = validateParameter(valid_596209, JString, required = false,
                                 default = nil)
  if valid_596209 != nil:
    section.add "X-Amz-Content-Sha256", valid_596209
  var valid_596210 = header.getOrDefault("X-Amz-Algorithm")
  valid_596210 = validateParameter(valid_596210, JString, required = false,
                                 default = nil)
  if valid_596210 != nil:
    section.add "X-Amz-Algorithm", valid_596210
  var valid_596211 = header.getOrDefault("X-Amz-Signature")
  valid_596211 = validateParameter(valid_596211, JString, required = false,
                                 default = nil)
  if valid_596211 != nil:
    section.add "X-Amz-Signature", valid_596211
  var valid_596212 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596212 = validateParameter(valid_596212, JString, required = false,
                                 default = nil)
  if valid_596212 != nil:
    section.add "X-Amz-SignedHeaders", valid_596212
  var valid_596213 = header.getOrDefault("X-Amz-Credential")
  valid_596213 = validateParameter(valid_596213, JString, required = false,
                                 default = nil)
  if valid_596213 != nil:
    section.add "X-Amz-Credential", valid_596213
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_596214 = formData.getOrDefault("ClusterIdentifier")
  valid_596214 = validateParameter(valid_596214, JString, required = true,
                                 default = nil)
  if valid_596214 != nil:
    section.add "ClusterIdentifier", valid_596214
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596215: Call_PostDisableLogging_596202; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_596215.validator(path, query, header, formData, body)
  let scheme = call_596215.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596215.url(scheme.get, call_596215.host, call_596215.base,
                         call_596215.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596215, url, valid)

proc call*(call_596216: Call_PostDisableLogging_596202; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_596217 = newJObject()
  var formData_596218 = newJObject()
  add(query_596217, "Action", newJString(Action))
  add(formData_596218, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596217, "Version", newJString(Version))
  result = call_596216.call(nil, query_596217, nil, formData_596218, nil)

var postDisableLogging* = Call_PostDisableLogging_596202(
    name: "postDisableLogging", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableLogging",
    validator: validate_PostDisableLogging_596203, base: "/",
    url: url_PostDisableLogging_596204, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableLogging_596186 = ref object of OpenApiRestCall_593421
proc url_GetDisableLogging_596188(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDisableLogging_596187(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596189 = query.getOrDefault("Action")
  valid_596189 = validateParameter(valid_596189, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_596189 != nil:
    section.add "Action", valid_596189
  var valid_596190 = query.getOrDefault("ClusterIdentifier")
  valid_596190 = validateParameter(valid_596190, JString, required = true,
                                 default = nil)
  if valid_596190 != nil:
    section.add "ClusterIdentifier", valid_596190
  var valid_596191 = query.getOrDefault("Version")
  valid_596191 = validateParameter(valid_596191, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596191 != nil:
    section.add "Version", valid_596191
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596192 = header.getOrDefault("X-Amz-Date")
  valid_596192 = validateParameter(valid_596192, JString, required = false,
                                 default = nil)
  if valid_596192 != nil:
    section.add "X-Amz-Date", valid_596192
  var valid_596193 = header.getOrDefault("X-Amz-Security-Token")
  valid_596193 = validateParameter(valid_596193, JString, required = false,
                                 default = nil)
  if valid_596193 != nil:
    section.add "X-Amz-Security-Token", valid_596193
  var valid_596194 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596194 = validateParameter(valid_596194, JString, required = false,
                                 default = nil)
  if valid_596194 != nil:
    section.add "X-Amz-Content-Sha256", valid_596194
  var valid_596195 = header.getOrDefault("X-Amz-Algorithm")
  valid_596195 = validateParameter(valid_596195, JString, required = false,
                                 default = nil)
  if valid_596195 != nil:
    section.add "X-Amz-Algorithm", valid_596195
  var valid_596196 = header.getOrDefault("X-Amz-Signature")
  valid_596196 = validateParameter(valid_596196, JString, required = false,
                                 default = nil)
  if valid_596196 != nil:
    section.add "X-Amz-Signature", valid_596196
  var valid_596197 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596197 = validateParameter(valid_596197, JString, required = false,
                                 default = nil)
  if valid_596197 != nil:
    section.add "X-Amz-SignedHeaders", valid_596197
  var valid_596198 = header.getOrDefault("X-Amz-Credential")
  valid_596198 = validateParameter(valid_596198, JString, required = false,
                                 default = nil)
  if valid_596198 != nil:
    section.add "X-Amz-Credential", valid_596198
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596199: Call_GetDisableLogging_596186; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_596199.validator(path, query, header, formData, body)
  let scheme = call_596199.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596199.url(scheme.get, call_596199.host, call_596199.base,
                         call_596199.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596199, url, valid)

proc call*(call_596200: Call_GetDisableLogging_596186; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_596201 = newJObject()
  add(query_596201, "Action", newJString(Action))
  add(query_596201, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596201, "Version", newJString(Version))
  result = call_596200.call(nil, query_596201, nil, nil, nil)

var getDisableLogging* = Call_GetDisableLogging_596186(name: "getDisableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DisableLogging", validator: validate_GetDisableLogging_596187,
    base: "/", url: url_GetDisableLogging_596188,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableSnapshotCopy_596235 = ref object of OpenApiRestCall_593421
proc url_PostDisableSnapshotCopy_596237(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDisableSnapshotCopy_596236(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596238 = query.getOrDefault("Action")
  valid_596238 = validateParameter(valid_596238, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_596238 != nil:
    section.add "Action", valid_596238
  var valid_596239 = query.getOrDefault("Version")
  valid_596239 = validateParameter(valid_596239, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596239 != nil:
    section.add "Version", valid_596239
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596240 = header.getOrDefault("X-Amz-Date")
  valid_596240 = validateParameter(valid_596240, JString, required = false,
                                 default = nil)
  if valid_596240 != nil:
    section.add "X-Amz-Date", valid_596240
  var valid_596241 = header.getOrDefault("X-Amz-Security-Token")
  valid_596241 = validateParameter(valid_596241, JString, required = false,
                                 default = nil)
  if valid_596241 != nil:
    section.add "X-Amz-Security-Token", valid_596241
  var valid_596242 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596242 = validateParameter(valid_596242, JString, required = false,
                                 default = nil)
  if valid_596242 != nil:
    section.add "X-Amz-Content-Sha256", valid_596242
  var valid_596243 = header.getOrDefault("X-Amz-Algorithm")
  valid_596243 = validateParameter(valid_596243, JString, required = false,
                                 default = nil)
  if valid_596243 != nil:
    section.add "X-Amz-Algorithm", valid_596243
  var valid_596244 = header.getOrDefault("X-Amz-Signature")
  valid_596244 = validateParameter(valid_596244, JString, required = false,
                                 default = nil)
  if valid_596244 != nil:
    section.add "X-Amz-Signature", valid_596244
  var valid_596245 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596245 = validateParameter(valid_596245, JString, required = false,
                                 default = nil)
  if valid_596245 != nil:
    section.add "X-Amz-SignedHeaders", valid_596245
  var valid_596246 = header.getOrDefault("X-Amz-Credential")
  valid_596246 = validateParameter(valid_596246, JString, required = false,
                                 default = nil)
  if valid_596246 != nil:
    section.add "X-Amz-Credential", valid_596246
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_596247 = formData.getOrDefault("ClusterIdentifier")
  valid_596247 = validateParameter(valid_596247, JString, required = true,
                                 default = nil)
  if valid_596247 != nil:
    section.add "ClusterIdentifier", valid_596247
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596248: Call_PostDisableSnapshotCopy_596235; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_596248.validator(path, query, header, formData, body)
  let scheme = call_596248.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596248.url(scheme.get, call_596248.host, call_596248.base,
                         call_596248.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596248, url, valid)

proc call*(call_596249: Call_PostDisableSnapshotCopy_596235;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## postDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_596250 = newJObject()
  var formData_596251 = newJObject()
  add(query_596250, "Action", newJString(Action))
  add(formData_596251, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596250, "Version", newJString(Version))
  result = call_596249.call(nil, query_596250, nil, formData_596251, nil)

var postDisableSnapshotCopy* = Call_PostDisableSnapshotCopy_596235(
    name: "postDisableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_PostDisableSnapshotCopy_596236, base: "/",
    url: url_PostDisableSnapshotCopy_596237, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableSnapshotCopy_596219 = ref object of OpenApiRestCall_593421
proc url_GetDisableSnapshotCopy_596221(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDisableSnapshotCopy_596220(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596222 = query.getOrDefault("Action")
  valid_596222 = validateParameter(valid_596222, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_596222 != nil:
    section.add "Action", valid_596222
  var valid_596223 = query.getOrDefault("ClusterIdentifier")
  valid_596223 = validateParameter(valid_596223, JString, required = true,
                                 default = nil)
  if valid_596223 != nil:
    section.add "ClusterIdentifier", valid_596223
  var valid_596224 = query.getOrDefault("Version")
  valid_596224 = validateParameter(valid_596224, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596224 != nil:
    section.add "Version", valid_596224
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596225 = header.getOrDefault("X-Amz-Date")
  valid_596225 = validateParameter(valid_596225, JString, required = false,
                                 default = nil)
  if valid_596225 != nil:
    section.add "X-Amz-Date", valid_596225
  var valid_596226 = header.getOrDefault("X-Amz-Security-Token")
  valid_596226 = validateParameter(valid_596226, JString, required = false,
                                 default = nil)
  if valid_596226 != nil:
    section.add "X-Amz-Security-Token", valid_596226
  var valid_596227 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596227 = validateParameter(valid_596227, JString, required = false,
                                 default = nil)
  if valid_596227 != nil:
    section.add "X-Amz-Content-Sha256", valid_596227
  var valid_596228 = header.getOrDefault("X-Amz-Algorithm")
  valid_596228 = validateParameter(valid_596228, JString, required = false,
                                 default = nil)
  if valid_596228 != nil:
    section.add "X-Amz-Algorithm", valid_596228
  var valid_596229 = header.getOrDefault("X-Amz-Signature")
  valid_596229 = validateParameter(valid_596229, JString, required = false,
                                 default = nil)
  if valid_596229 != nil:
    section.add "X-Amz-Signature", valid_596229
  var valid_596230 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596230 = validateParameter(valid_596230, JString, required = false,
                                 default = nil)
  if valid_596230 != nil:
    section.add "X-Amz-SignedHeaders", valid_596230
  var valid_596231 = header.getOrDefault("X-Amz-Credential")
  valid_596231 = validateParameter(valid_596231, JString, required = false,
                                 default = nil)
  if valid_596231 != nil:
    section.add "X-Amz-Credential", valid_596231
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596232: Call_GetDisableSnapshotCopy_596219; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_596232.validator(path, query, header, formData, body)
  let scheme = call_596232.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596232.url(scheme.get, call_596232.host, call_596232.base,
                         call_596232.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596232, url, valid)

proc call*(call_596233: Call_GetDisableSnapshotCopy_596219;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## getDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_596234 = newJObject()
  add(query_596234, "Action", newJString(Action))
  add(query_596234, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596234, "Version", newJString(Version))
  result = call_596233.call(nil, query_596234, nil, nil, nil)

var getDisableSnapshotCopy* = Call_GetDisableSnapshotCopy_596219(
    name: "getDisableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_GetDisableSnapshotCopy_596220, base: "/",
    url: url_GetDisableSnapshotCopy_596221, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableLogging_596270 = ref object of OpenApiRestCall_593421
proc url_PostEnableLogging_596272(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostEnableLogging_596271(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596273 = query.getOrDefault("Action")
  valid_596273 = validateParameter(valid_596273, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_596273 != nil:
    section.add "Action", valid_596273
  var valid_596274 = query.getOrDefault("Version")
  valid_596274 = validateParameter(valid_596274, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596274 != nil:
    section.add "Version", valid_596274
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596275 = header.getOrDefault("X-Amz-Date")
  valid_596275 = validateParameter(valid_596275, JString, required = false,
                                 default = nil)
  if valid_596275 != nil:
    section.add "X-Amz-Date", valid_596275
  var valid_596276 = header.getOrDefault("X-Amz-Security-Token")
  valid_596276 = validateParameter(valid_596276, JString, required = false,
                                 default = nil)
  if valid_596276 != nil:
    section.add "X-Amz-Security-Token", valid_596276
  var valid_596277 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596277 = validateParameter(valid_596277, JString, required = false,
                                 default = nil)
  if valid_596277 != nil:
    section.add "X-Amz-Content-Sha256", valid_596277
  var valid_596278 = header.getOrDefault("X-Amz-Algorithm")
  valid_596278 = validateParameter(valid_596278, JString, required = false,
                                 default = nil)
  if valid_596278 != nil:
    section.add "X-Amz-Algorithm", valid_596278
  var valid_596279 = header.getOrDefault("X-Amz-Signature")
  valid_596279 = validateParameter(valid_596279, JString, required = false,
                                 default = nil)
  if valid_596279 != nil:
    section.add "X-Amz-Signature", valid_596279
  var valid_596280 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596280 = validateParameter(valid_596280, JString, required = false,
                                 default = nil)
  if valid_596280 != nil:
    section.add "X-Amz-SignedHeaders", valid_596280
  var valid_596281 = header.getOrDefault("X-Amz-Credential")
  valid_596281 = validateParameter(valid_596281, JString, required = false,
                                 default = nil)
  if valid_596281 != nil:
    section.add "X-Amz-Credential", valid_596281
  result.add "header", section
  ## parameters in `formData` object:
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  var valid_596282 = formData.getOrDefault("S3KeyPrefix")
  valid_596282 = validateParameter(valid_596282, JString, required = false,
                                 default = nil)
  if valid_596282 != nil:
    section.add "S3KeyPrefix", valid_596282
  assert formData != nil,
        "formData argument is necessary due to required `BucketName` field"
  var valid_596283 = formData.getOrDefault("BucketName")
  valid_596283 = validateParameter(valid_596283, JString, required = true,
                                 default = nil)
  if valid_596283 != nil:
    section.add "BucketName", valid_596283
  var valid_596284 = formData.getOrDefault("ClusterIdentifier")
  valid_596284 = validateParameter(valid_596284, JString, required = true,
                                 default = nil)
  if valid_596284 != nil:
    section.add "ClusterIdentifier", valid_596284
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596285: Call_PostEnableLogging_596270; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_596285.validator(path, query, header, formData, body)
  let scheme = call_596285.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596285.url(scheme.get, call_596285.host, call_596285.base,
                         call_596285.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596285, url, valid)

proc call*(call_596286: Call_PostEnableLogging_596270; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_596287 = newJObject()
  var formData_596288 = newJObject()
  add(formData_596288, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(formData_596288, "BucketName", newJString(BucketName))
  add(query_596287, "Action", newJString(Action))
  add(formData_596288, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596287, "Version", newJString(Version))
  result = call_596286.call(nil, query_596287, nil, formData_596288, nil)

var postEnableLogging* = Call_PostEnableLogging_596270(name: "postEnableLogging",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_PostEnableLogging_596271,
    base: "/", url: url_PostEnableLogging_596272,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableLogging_596252 = ref object of OpenApiRestCall_593421
proc url_GetEnableLogging_596254(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetEnableLogging_596253(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_596255 = query.getOrDefault("S3KeyPrefix")
  valid_596255 = validateParameter(valid_596255, JString, required = false,
                                 default = nil)
  if valid_596255 != nil:
    section.add "S3KeyPrefix", valid_596255
  assert query != nil,
        "query argument is necessary due to required `BucketName` field"
  var valid_596256 = query.getOrDefault("BucketName")
  valid_596256 = validateParameter(valid_596256, JString, required = true,
                                 default = nil)
  if valid_596256 != nil:
    section.add "BucketName", valid_596256
  var valid_596257 = query.getOrDefault("Action")
  valid_596257 = validateParameter(valid_596257, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_596257 != nil:
    section.add "Action", valid_596257
  var valid_596258 = query.getOrDefault("ClusterIdentifier")
  valid_596258 = validateParameter(valid_596258, JString, required = true,
                                 default = nil)
  if valid_596258 != nil:
    section.add "ClusterIdentifier", valid_596258
  var valid_596259 = query.getOrDefault("Version")
  valid_596259 = validateParameter(valid_596259, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596259 != nil:
    section.add "Version", valid_596259
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596260 = header.getOrDefault("X-Amz-Date")
  valid_596260 = validateParameter(valid_596260, JString, required = false,
                                 default = nil)
  if valid_596260 != nil:
    section.add "X-Amz-Date", valid_596260
  var valid_596261 = header.getOrDefault("X-Amz-Security-Token")
  valid_596261 = validateParameter(valid_596261, JString, required = false,
                                 default = nil)
  if valid_596261 != nil:
    section.add "X-Amz-Security-Token", valid_596261
  var valid_596262 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596262 = validateParameter(valid_596262, JString, required = false,
                                 default = nil)
  if valid_596262 != nil:
    section.add "X-Amz-Content-Sha256", valid_596262
  var valid_596263 = header.getOrDefault("X-Amz-Algorithm")
  valid_596263 = validateParameter(valid_596263, JString, required = false,
                                 default = nil)
  if valid_596263 != nil:
    section.add "X-Amz-Algorithm", valid_596263
  var valid_596264 = header.getOrDefault("X-Amz-Signature")
  valid_596264 = validateParameter(valid_596264, JString, required = false,
                                 default = nil)
  if valid_596264 != nil:
    section.add "X-Amz-Signature", valid_596264
  var valid_596265 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596265 = validateParameter(valid_596265, JString, required = false,
                                 default = nil)
  if valid_596265 != nil:
    section.add "X-Amz-SignedHeaders", valid_596265
  var valid_596266 = header.getOrDefault("X-Amz-Credential")
  valid_596266 = validateParameter(valid_596266, JString, required = false,
                                 default = nil)
  if valid_596266 != nil:
    section.add "X-Amz-Credential", valid_596266
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596267: Call_GetEnableLogging_596252; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_596267.validator(path, query, header, formData, body)
  let scheme = call_596267.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596267.url(scheme.get, call_596267.host, call_596267.base,
                         call_596267.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596267, url, valid)

proc call*(call_596268: Call_GetEnableLogging_596252; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_596269 = newJObject()
  add(query_596269, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(query_596269, "BucketName", newJString(BucketName))
  add(query_596269, "Action", newJString(Action))
  add(query_596269, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596269, "Version", newJString(Version))
  result = call_596268.call(nil, query_596269, nil, nil, nil)

var getEnableLogging* = Call_GetEnableLogging_596252(name: "getEnableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_GetEnableLogging_596253,
    base: "/", url: url_GetEnableLogging_596254,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableSnapshotCopy_596309 = ref object of OpenApiRestCall_593421
proc url_PostEnableSnapshotCopy_596311(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostEnableSnapshotCopy_596310(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596312 = query.getOrDefault("Action")
  valid_596312 = validateParameter(valid_596312, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_596312 != nil:
    section.add "Action", valid_596312
  var valid_596313 = query.getOrDefault("Version")
  valid_596313 = validateParameter(valid_596313, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596313 != nil:
    section.add "Version", valid_596313
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596314 = header.getOrDefault("X-Amz-Date")
  valid_596314 = validateParameter(valid_596314, JString, required = false,
                                 default = nil)
  if valid_596314 != nil:
    section.add "X-Amz-Date", valid_596314
  var valid_596315 = header.getOrDefault("X-Amz-Security-Token")
  valid_596315 = validateParameter(valid_596315, JString, required = false,
                                 default = nil)
  if valid_596315 != nil:
    section.add "X-Amz-Security-Token", valid_596315
  var valid_596316 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596316 = validateParameter(valid_596316, JString, required = false,
                                 default = nil)
  if valid_596316 != nil:
    section.add "X-Amz-Content-Sha256", valid_596316
  var valid_596317 = header.getOrDefault("X-Amz-Algorithm")
  valid_596317 = validateParameter(valid_596317, JString, required = false,
                                 default = nil)
  if valid_596317 != nil:
    section.add "X-Amz-Algorithm", valid_596317
  var valid_596318 = header.getOrDefault("X-Amz-Signature")
  valid_596318 = validateParameter(valid_596318, JString, required = false,
                                 default = nil)
  if valid_596318 != nil:
    section.add "X-Amz-Signature", valid_596318
  var valid_596319 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596319 = validateParameter(valid_596319, JString, required = false,
                                 default = nil)
  if valid_596319 != nil:
    section.add "X-Amz-SignedHeaders", valid_596319
  var valid_596320 = header.getOrDefault("X-Amz-Credential")
  valid_596320 = validateParameter(valid_596320, JString, required = false,
                                 default = nil)
  if valid_596320 != nil:
    section.add "X-Amz-Credential", valid_596320
  result.add "header", section
  ## parameters in `formData` object:
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_596321 = formData.getOrDefault("RetentionPeriod")
  valid_596321 = validateParameter(valid_596321, JInt, required = false, default = nil)
  if valid_596321 != nil:
    section.add "RetentionPeriod", valid_596321
  var valid_596322 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_596322 = validateParameter(valid_596322, JString, required = false,
                                 default = nil)
  if valid_596322 != nil:
    section.add "SnapshotCopyGrantName", valid_596322
  assert formData != nil, "formData argument is necessary due to required `DestinationRegion` field"
  var valid_596323 = formData.getOrDefault("DestinationRegion")
  valid_596323 = validateParameter(valid_596323, JString, required = true,
                                 default = nil)
  if valid_596323 != nil:
    section.add "DestinationRegion", valid_596323
  var valid_596324 = formData.getOrDefault("ClusterIdentifier")
  valid_596324 = validateParameter(valid_596324, JString, required = true,
                                 default = nil)
  if valid_596324 != nil:
    section.add "ClusterIdentifier", valid_596324
  var valid_596325 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_596325 = validateParameter(valid_596325, JInt, required = false, default = nil)
  if valid_596325 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_596325
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596326: Call_PostEnableSnapshotCopy_596309; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_596326.validator(path, query, header, formData, body)
  let scheme = call_596326.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596326.url(scheme.get, call_596326.host, call_596326.base,
                         call_596326.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596326, url, valid)

proc call*(call_596327: Call_PostEnableSnapshotCopy_596309;
          DestinationRegion: string; ClusterIdentifier: string;
          RetentionPeriod: int = 0; Action: string = "EnableSnapshotCopy";
          SnapshotCopyGrantName: string = "";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Version: string (required)
  var query_596328 = newJObject()
  var formData_596329 = newJObject()
  add(formData_596329, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_596328, "Action", newJString(Action))
  add(formData_596329, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(formData_596329, "DestinationRegion", newJString(DestinationRegion))
  add(formData_596329, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_596329, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_596328, "Version", newJString(Version))
  result = call_596327.call(nil, query_596328, nil, formData_596329, nil)

var postEnableSnapshotCopy* = Call_PostEnableSnapshotCopy_596309(
    name: "postEnableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_PostEnableSnapshotCopy_596310, base: "/",
    url: url_PostEnableSnapshotCopy_596311, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableSnapshotCopy_596289 = ref object of OpenApiRestCall_593421
proc url_GetEnableSnapshotCopy_596291(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetEnableSnapshotCopy_596290(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `DestinationRegion` field"
  var valid_596292 = query.getOrDefault("DestinationRegion")
  valid_596292 = validateParameter(valid_596292, JString, required = true,
                                 default = nil)
  if valid_596292 != nil:
    section.add "DestinationRegion", valid_596292
  var valid_596293 = query.getOrDefault("Action")
  valid_596293 = validateParameter(valid_596293, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_596293 != nil:
    section.add "Action", valid_596293
  var valid_596294 = query.getOrDefault("ClusterIdentifier")
  valid_596294 = validateParameter(valid_596294, JString, required = true,
                                 default = nil)
  if valid_596294 != nil:
    section.add "ClusterIdentifier", valid_596294
  var valid_596295 = query.getOrDefault("SnapshotCopyGrantName")
  valid_596295 = validateParameter(valid_596295, JString, required = false,
                                 default = nil)
  if valid_596295 != nil:
    section.add "SnapshotCopyGrantName", valid_596295
  var valid_596296 = query.getOrDefault("RetentionPeriod")
  valid_596296 = validateParameter(valid_596296, JInt, required = false, default = nil)
  if valid_596296 != nil:
    section.add "RetentionPeriod", valid_596296
  var valid_596297 = query.getOrDefault("Version")
  valid_596297 = validateParameter(valid_596297, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596297 != nil:
    section.add "Version", valid_596297
  var valid_596298 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_596298 = validateParameter(valid_596298, JInt, required = false, default = nil)
  if valid_596298 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_596298
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596299 = header.getOrDefault("X-Amz-Date")
  valid_596299 = validateParameter(valid_596299, JString, required = false,
                                 default = nil)
  if valid_596299 != nil:
    section.add "X-Amz-Date", valid_596299
  var valid_596300 = header.getOrDefault("X-Amz-Security-Token")
  valid_596300 = validateParameter(valid_596300, JString, required = false,
                                 default = nil)
  if valid_596300 != nil:
    section.add "X-Amz-Security-Token", valid_596300
  var valid_596301 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596301 = validateParameter(valid_596301, JString, required = false,
                                 default = nil)
  if valid_596301 != nil:
    section.add "X-Amz-Content-Sha256", valid_596301
  var valid_596302 = header.getOrDefault("X-Amz-Algorithm")
  valid_596302 = validateParameter(valid_596302, JString, required = false,
                                 default = nil)
  if valid_596302 != nil:
    section.add "X-Amz-Algorithm", valid_596302
  var valid_596303 = header.getOrDefault("X-Amz-Signature")
  valid_596303 = validateParameter(valid_596303, JString, required = false,
                                 default = nil)
  if valid_596303 != nil:
    section.add "X-Amz-Signature", valid_596303
  var valid_596304 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596304 = validateParameter(valid_596304, JString, required = false,
                                 default = nil)
  if valid_596304 != nil:
    section.add "X-Amz-SignedHeaders", valid_596304
  var valid_596305 = header.getOrDefault("X-Amz-Credential")
  valid_596305 = validateParameter(valid_596305, JString, required = false,
                                 default = nil)
  if valid_596305 != nil:
    section.add "X-Amz-Credential", valid_596305
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596306: Call_GetEnableSnapshotCopy_596289; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_596306.validator(path, query, header, formData, body)
  let scheme = call_596306.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596306.url(scheme.get, call_596306.host, call_596306.base,
                         call_596306.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596306, url, valid)

proc call*(call_596307: Call_GetEnableSnapshotCopy_596289;
          DestinationRegion: string; ClusterIdentifier: string;
          Action: string = "EnableSnapshotCopy"; SnapshotCopyGrantName: string = "";
          RetentionPeriod: int = 0; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_596308 = newJObject()
  add(query_596308, "DestinationRegion", newJString(DestinationRegion))
  add(query_596308, "Action", newJString(Action))
  add(query_596308, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596308, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_596308, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_596308, "Version", newJString(Version))
  add(query_596308, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_596307.call(nil, query_596308, nil, nil, nil)

var getEnableSnapshotCopy* = Call_GetEnableSnapshotCopy_596289(
    name: "getEnableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_GetEnableSnapshotCopy_596290, base: "/",
    url: url_GetEnableSnapshotCopy_596291, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetClusterCredentials_596351 = ref object of OpenApiRestCall_593421
proc url_PostGetClusterCredentials_596353(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostGetClusterCredentials_596352(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596354 = query.getOrDefault("Action")
  valid_596354 = validateParameter(valid_596354, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_596354 != nil:
    section.add "Action", valid_596354
  var valid_596355 = query.getOrDefault("Version")
  valid_596355 = validateParameter(valid_596355, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596355 != nil:
    section.add "Version", valid_596355
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596356 = header.getOrDefault("X-Amz-Date")
  valid_596356 = validateParameter(valid_596356, JString, required = false,
                                 default = nil)
  if valid_596356 != nil:
    section.add "X-Amz-Date", valid_596356
  var valid_596357 = header.getOrDefault("X-Amz-Security-Token")
  valid_596357 = validateParameter(valid_596357, JString, required = false,
                                 default = nil)
  if valid_596357 != nil:
    section.add "X-Amz-Security-Token", valid_596357
  var valid_596358 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596358 = validateParameter(valid_596358, JString, required = false,
                                 default = nil)
  if valid_596358 != nil:
    section.add "X-Amz-Content-Sha256", valid_596358
  var valid_596359 = header.getOrDefault("X-Amz-Algorithm")
  valid_596359 = validateParameter(valid_596359, JString, required = false,
                                 default = nil)
  if valid_596359 != nil:
    section.add "X-Amz-Algorithm", valid_596359
  var valid_596360 = header.getOrDefault("X-Amz-Signature")
  valid_596360 = validateParameter(valid_596360, JString, required = false,
                                 default = nil)
  if valid_596360 != nil:
    section.add "X-Amz-Signature", valid_596360
  var valid_596361 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596361 = validateParameter(valid_596361, JString, required = false,
                                 default = nil)
  if valid_596361 != nil:
    section.add "X-Amz-SignedHeaders", valid_596361
  var valid_596362 = header.getOrDefault("X-Amz-Credential")
  valid_596362 = validateParameter(valid_596362, JString, required = false,
                                 default = nil)
  if valid_596362 != nil:
    section.add "X-Amz-Credential", valid_596362
  result.add "header", section
  ## parameters in `formData` object:
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `DbUser` field"
  var valid_596363 = formData.getOrDefault("DbUser")
  valid_596363 = validateParameter(valid_596363, JString, required = true,
                                 default = nil)
  if valid_596363 != nil:
    section.add "DbUser", valid_596363
  var valid_596364 = formData.getOrDefault("AutoCreate")
  valid_596364 = validateParameter(valid_596364, JBool, required = false, default = nil)
  if valid_596364 != nil:
    section.add "AutoCreate", valid_596364
  var valid_596365 = formData.getOrDefault("ClusterIdentifier")
  valid_596365 = validateParameter(valid_596365, JString, required = true,
                                 default = nil)
  if valid_596365 != nil:
    section.add "ClusterIdentifier", valid_596365
  var valid_596366 = formData.getOrDefault("DbName")
  valid_596366 = validateParameter(valid_596366, JString, required = false,
                                 default = nil)
  if valid_596366 != nil:
    section.add "DbName", valid_596366
  var valid_596367 = formData.getOrDefault("DbGroups")
  valid_596367 = validateParameter(valid_596367, JArray, required = false,
                                 default = nil)
  if valid_596367 != nil:
    section.add "DbGroups", valid_596367
  var valid_596368 = formData.getOrDefault("DurationSeconds")
  valid_596368 = validateParameter(valid_596368, JInt, required = false, default = nil)
  if valid_596368 != nil:
    section.add "DurationSeconds", valid_596368
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596369: Call_PostGetClusterCredentials_596351; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_596369.validator(path, query, header, formData, body)
  let scheme = call_596369.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596369.url(scheme.get, call_596369.host, call_596369.base,
                         call_596369.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596369, url, valid)

proc call*(call_596370: Call_PostGetClusterCredentials_596351; DbUser: string;
          ClusterIdentifier: string; Action: string = "GetClusterCredentials";
          AutoCreate: bool = false; DbName: string = ""; DbGroups: JsonNode = nil;
          Version: string = "2012-12-01"; DurationSeconds: int = 0): Recallable =
  ## postGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: string (required)
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  var query_596371 = newJObject()
  var formData_596372 = newJObject()
  add(formData_596372, "DbUser", newJString(DbUser))
  add(query_596371, "Action", newJString(Action))
  add(formData_596372, "AutoCreate", newJBool(AutoCreate))
  add(formData_596372, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_596372, "DbName", newJString(DbName))
  if DbGroups != nil:
    formData_596372.add "DbGroups", DbGroups
  add(query_596371, "Version", newJString(Version))
  add(formData_596372, "DurationSeconds", newJInt(DurationSeconds))
  result = call_596370.call(nil, query_596371, nil, formData_596372, nil)

var postGetClusterCredentials* = Call_PostGetClusterCredentials_596351(
    name: "postGetClusterCredentials", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_PostGetClusterCredentials_596352, base: "/",
    url: url_PostGetClusterCredentials_596353,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetClusterCredentials_596330 = ref object of OpenApiRestCall_593421
proc url_GetGetClusterCredentials_596332(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetGetClusterCredentials_596331(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_596333 = query.getOrDefault("DbGroups")
  valid_596333 = validateParameter(valid_596333, JArray, required = false,
                                 default = nil)
  if valid_596333 != nil:
    section.add "DbGroups", valid_596333
  var valid_596334 = query.getOrDefault("DurationSeconds")
  valid_596334 = validateParameter(valid_596334, JInt, required = false, default = nil)
  if valid_596334 != nil:
    section.add "DurationSeconds", valid_596334
  var valid_596335 = query.getOrDefault("DbName")
  valid_596335 = validateParameter(valid_596335, JString, required = false,
                                 default = nil)
  if valid_596335 != nil:
    section.add "DbName", valid_596335
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596336 = query.getOrDefault("Action")
  valid_596336 = validateParameter(valid_596336, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_596336 != nil:
    section.add "Action", valid_596336
  var valid_596337 = query.getOrDefault("ClusterIdentifier")
  valid_596337 = validateParameter(valid_596337, JString, required = true,
                                 default = nil)
  if valid_596337 != nil:
    section.add "ClusterIdentifier", valid_596337
  var valid_596338 = query.getOrDefault("AutoCreate")
  valid_596338 = validateParameter(valid_596338, JBool, required = false, default = nil)
  if valid_596338 != nil:
    section.add "AutoCreate", valid_596338
  var valid_596339 = query.getOrDefault("DbUser")
  valid_596339 = validateParameter(valid_596339, JString, required = true,
                                 default = nil)
  if valid_596339 != nil:
    section.add "DbUser", valid_596339
  var valid_596340 = query.getOrDefault("Version")
  valid_596340 = validateParameter(valid_596340, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596340 != nil:
    section.add "Version", valid_596340
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596341 = header.getOrDefault("X-Amz-Date")
  valid_596341 = validateParameter(valid_596341, JString, required = false,
                                 default = nil)
  if valid_596341 != nil:
    section.add "X-Amz-Date", valid_596341
  var valid_596342 = header.getOrDefault("X-Amz-Security-Token")
  valid_596342 = validateParameter(valid_596342, JString, required = false,
                                 default = nil)
  if valid_596342 != nil:
    section.add "X-Amz-Security-Token", valid_596342
  var valid_596343 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596343 = validateParameter(valid_596343, JString, required = false,
                                 default = nil)
  if valid_596343 != nil:
    section.add "X-Amz-Content-Sha256", valid_596343
  var valid_596344 = header.getOrDefault("X-Amz-Algorithm")
  valid_596344 = validateParameter(valid_596344, JString, required = false,
                                 default = nil)
  if valid_596344 != nil:
    section.add "X-Amz-Algorithm", valid_596344
  var valid_596345 = header.getOrDefault("X-Amz-Signature")
  valid_596345 = validateParameter(valid_596345, JString, required = false,
                                 default = nil)
  if valid_596345 != nil:
    section.add "X-Amz-Signature", valid_596345
  var valid_596346 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596346 = validateParameter(valid_596346, JString, required = false,
                                 default = nil)
  if valid_596346 != nil:
    section.add "X-Amz-SignedHeaders", valid_596346
  var valid_596347 = header.getOrDefault("X-Amz-Credential")
  valid_596347 = validateParameter(valid_596347, JString, required = false,
                                 default = nil)
  if valid_596347 != nil:
    section.add "X-Amz-Credential", valid_596347
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596348: Call_GetGetClusterCredentials_596330; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_596348.validator(path, query, header, formData, body)
  let scheme = call_596348.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596348.url(scheme.get, call_596348.host, call_596348.base,
                         call_596348.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596348, url, valid)

proc call*(call_596349: Call_GetGetClusterCredentials_596330;
          ClusterIdentifier: string; DbUser: string; DbGroups: JsonNode = nil;
          DurationSeconds: int = 0; DbName: string = "";
          Action: string = "GetClusterCredentials"; AutoCreate: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## getGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: string (required)
  var query_596350 = newJObject()
  if DbGroups != nil:
    query_596350.add "DbGroups", DbGroups
  add(query_596350, "DurationSeconds", newJInt(DurationSeconds))
  add(query_596350, "DbName", newJString(DbName))
  add(query_596350, "Action", newJString(Action))
  add(query_596350, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596350, "AutoCreate", newJBool(AutoCreate))
  add(query_596350, "DbUser", newJString(DbUser))
  add(query_596350, "Version", newJString(Version))
  result = call_596349.call(nil, query_596350, nil, nil, nil)

var getGetClusterCredentials* = Call_GetGetClusterCredentials_596330(
    name: "getGetClusterCredentials", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_GetGetClusterCredentials_596331, base: "/",
    url: url_GetGetClusterCredentials_596332, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetReservedNodeExchangeOfferings_596391 = ref object of OpenApiRestCall_593421
proc url_PostGetReservedNodeExchangeOfferings_596393(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostGetReservedNodeExchangeOfferings_596392(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596394 = query.getOrDefault("Action")
  valid_596394 = validateParameter(valid_596394, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_596394 != nil:
    section.add "Action", valid_596394
  var valid_596395 = query.getOrDefault("Version")
  valid_596395 = validateParameter(valid_596395, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596395 != nil:
    section.add "Version", valid_596395
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596396 = header.getOrDefault("X-Amz-Date")
  valid_596396 = validateParameter(valid_596396, JString, required = false,
                                 default = nil)
  if valid_596396 != nil:
    section.add "X-Amz-Date", valid_596396
  var valid_596397 = header.getOrDefault("X-Amz-Security-Token")
  valid_596397 = validateParameter(valid_596397, JString, required = false,
                                 default = nil)
  if valid_596397 != nil:
    section.add "X-Amz-Security-Token", valid_596397
  var valid_596398 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596398 = validateParameter(valid_596398, JString, required = false,
                                 default = nil)
  if valid_596398 != nil:
    section.add "X-Amz-Content-Sha256", valid_596398
  var valid_596399 = header.getOrDefault("X-Amz-Algorithm")
  valid_596399 = validateParameter(valid_596399, JString, required = false,
                                 default = nil)
  if valid_596399 != nil:
    section.add "X-Amz-Algorithm", valid_596399
  var valid_596400 = header.getOrDefault("X-Amz-Signature")
  valid_596400 = validateParameter(valid_596400, JString, required = false,
                                 default = nil)
  if valid_596400 != nil:
    section.add "X-Amz-Signature", valid_596400
  var valid_596401 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596401 = validateParameter(valid_596401, JString, required = false,
                                 default = nil)
  if valid_596401 != nil:
    section.add "X-Amz-SignedHeaders", valid_596401
  var valid_596402 = header.getOrDefault("X-Amz-Credential")
  valid_596402 = validateParameter(valid_596402, JString, required = false,
                                 default = nil)
  if valid_596402 != nil:
    section.add "X-Amz-Credential", valid_596402
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_596403 = formData.getOrDefault("ReservedNodeId")
  valid_596403 = validateParameter(valid_596403, JString, required = true,
                                 default = nil)
  if valid_596403 != nil:
    section.add "ReservedNodeId", valid_596403
  var valid_596404 = formData.getOrDefault("Marker")
  valid_596404 = validateParameter(valid_596404, JString, required = false,
                                 default = nil)
  if valid_596404 != nil:
    section.add "Marker", valid_596404
  var valid_596405 = formData.getOrDefault("MaxRecords")
  valid_596405 = validateParameter(valid_596405, JInt, required = false, default = nil)
  if valid_596405 != nil:
    section.add "MaxRecords", valid_596405
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596406: Call_PostGetReservedNodeExchangeOfferings_596391;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_596406.validator(path, query, header, formData, body)
  let scheme = call_596406.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596406.url(scheme.get, call_596406.host, call_596406.base,
                         call_596406.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596406, url, valid)

proc call*(call_596407: Call_PostGetReservedNodeExchangeOfferings_596391;
          ReservedNodeId: string; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Version: string (required)
  var query_596408 = newJObject()
  var formData_596409 = newJObject()
  add(formData_596409, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_596409, "Marker", newJString(Marker))
  add(query_596408, "Action", newJString(Action))
  add(formData_596409, "MaxRecords", newJInt(MaxRecords))
  add(query_596408, "Version", newJString(Version))
  result = call_596407.call(nil, query_596408, nil, formData_596409, nil)

var postGetReservedNodeExchangeOfferings* = Call_PostGetReservedNodeExchangeOfferings_596391(
    name: "postGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_PostGetReservedNodeExchangeOfferings_596392, base: "/",
    url: url_PostGetReservedNodeExchangeOfferings_596393,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetReservedNodeExchangeOfferings_596373 = ref object of OpenApiRestCall_593421
proc url_GetGetReservedNodeExchangeOfferings_596375(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetGetReservedNodeExchangeOfferings_596374(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Version: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  section = newJObject()
  var valid_596376 = query.getOrDefault("MaxRecords")
  valid_596376 = validateParameter(valid_596376, JInt, required = false, default = nil)
  if valid_596376 != nil:
    section.add "MaxRecords", valid_596376
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596377 = query.getOrDefault("Action")
  valid_596377 = validateParameter(valid_596377, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_596377 != nil:
    section.add "Action", valid_596377
  var valid_596378 = query.getOrDefault("Marker")
  valid_596378 = validateParameter(valid_596378, JString, required = false,
                                 default = nil)
  if valid_596378 != nil:
    section.add "Marker", valid_596378
  var valid_596379 = query.getOrDefault("Version")
  valid_596379 = validateParameter(valid_596379, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596379 != nil:
    section.add "Version", valid_596379
  var valid_596380 = query.getOrDefault("ReservedNodeId")
  valid_596380 = validateParameter(valid_596380, JString, required = true,
                                 default = nil)
  if valid_596380 != nil:
    section.add "ReservedNodeId", valid_596380
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596381 = header.getOrDefault("X-Amz-Date")
  valid_596381 = validateParameter(valid_596381, JString, required = false,
                                 default = nil)
  if valid_596381 != nil:
    section.add "X-Amz-Date", valid_596381
  var valid_596382 = header.getOrDefault("X-Amz-Security-Token")
  valid_596382 = validateParameter(valid_596382, JString, required = false,
                                 default = nil)
  if valid_596382 != nil:
    section.add "X-Amz-Security-Token", valid_596382
  var valid_596383 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596383 = validateParameter(valid_596383, JString, required = false,
                                 default = nil)
  if valid_596383 != nil:
    section.add "X-Amz-Content-Sha256", valid_596383
  var valid_596384 = header.getOrDefault("X-Amz-Algorithm")
  valid_596384 = validateParameter(valid_596384, JString, required = false,
                                 default = nil)
  if valid_596384 != nil:
    section.add "X-Amz-Algorithm", valid_596384
  var valid_596385 = header.getOrDefault("X-Amz-Signature")
  valid_596385 = validateParameter(valid_596385, JString, required = false,
                                 default = nil)
  if valid_596385 != nil:
    section.add "X-Amz-Signature", valid_596385
  var valid_596386 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596386 = validateParameter(valid_596386, JString, required = false,
                                 default = nil)
  if valid_596386 != nil:
    section.add "X-Amz-SignedHeaders", valid_596386
  var valid_596387 = header.getOrDefault("X-Amz-Credential")
  valid_596387 = validateParameter(valid_596387, JString, required = false,
                                 default = nil)
  if valid_596387 != nil:
    section.add "X-Amz-Credential", valid_596387
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596388: Call_GetGetReservedNodeExchangeOfferings_596373;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_596388.validator(path, query, header, formData, body)
  let scheme = call_596388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596388.url(scheme.get, call_596388.host, call_596388.base,
                         call_596388.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596388, url, valid)

proc call*(call_596389: Call_GetGetReservedNodeExchangeOfferings_596373;
          ReservedNodeId: string; MaxRecords: int = 0;
          Action: string = "GetReservedNodeExchangeOfferings"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Action: string (required)
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Version: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  var query_596390 = newJObject()
  add(query_596390, "MaxRecords", newJInt(MaxRecords))
  add(query_596390, "Action", newJString(Action))
  add(query_596390, "Marker", newJString(Marker))
  add(query_596390, "Version", newJString(Version))
  add(query_596390, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_596389.call(nil, query_596390, nil, nil, nil)

var getGetReservedNodeExchangeOfferings* = Call_GetGetReservedNodeExchangeOfferings_596373(
    name: "getGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_GetGetReservedNodeExchangeOfferings_596374, base: "/",
    url: url_GetGetReservedNodeExchangeOfferings_596375,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyCluster_596447 = ref object of OpenApiRestCall_593421
proc url_PostModifyCluster_596449(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyCluster_596448(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596450 = query.getOrDefault("Action")
  valid_596450 = validateParameter(valid_596450, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_596450 != nil:
    section.add "Action", valid_596450
  var valid_596451 = query.getOrDefault("Version")
  valid_596451 = validateParameter(valid_596451, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596451 != nil:
    section.add "Version", valid_596451
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596452 = header.getOrDefault("X-Amz-Date")
  valid_596452 = validateParameter(valid_596452, JString, required = false,
                                 default = nil)
  if valid_596452 != nil:
    section.add "X-Amz-Date", valid_596452
  var valid_596453 = header.getOrDefault("X-Amz-Security-Token")
  valid_596453 = validateParameter(valid_596453, JString, required = false,
                                 default = nil)
  if valid_596453 != nil:
    section.add "X-Amz-Security-Token", valid_596453
  var valid_596454 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596454 = validateParameter(valid_596454, JString, required = false,
                                 default = nil)
  if valid_596454 != nil:
    section.add "X-Amz-Content-Sha256", valid_596454
  var valid_596455 = header.getOrDefault("X-Amz-Algorithm")
  valid_596455 = validateParameter(valid_596455, JString, required = false,
                                 default = nil)
  if valid_596455 != nil:
    section.add "X-Amz-Algorithm", valid_596455
  var valid_596456 = header.getOrDefault("X-Amz-Signature")
  valid_596456 = validateParameter(valid_596456, JString, required = false,
                                 default = nil)
  if valid_596456 != nil:
    section.add "X-Amz-Signature", valid_596456
  var valid_596457 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596457 = validateParameter(valid_596457, JString, required = false,
                                 default = nil)
  if valid_596457 != nil:
    section.add "X-Amz-SignedHeaders", valid_596457
  var valid_596458 = header.getOrDefault("X-Amz-Credential")
  valid_596458 = validateParameter(valid_596458, JString, required = false,
                                 default = nil)
  if valid_596458 != nil:
    section.add "X-Amz-Credential", valid_596458
  result.add "header", section
  ## parameters in `formData` object:
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  section = newJObject()
  var valid_596459 = formData.getOrDefault("EnhancedVpcRouting")
  valid_596459 = validateParameter(valid_596459, JBool, required = false, default = nil)
  if valid_596459 != nil:
    section.add "EnhancedVpcRouting", valid_596459
  var valid_596460 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_596460 = validateParameter(valid_596460, JArray, required = false,
                                 default = nil)
  if valid_596460 != nil:
    section.add "VpcSecurityGroupIds", valid_596460
  var valid_596461 = formData.getOrDefault("ClusterVersion")
  valid_596461 = validateParameter(valid_596461, JString, required = false,
                                 default = nil)
  if valid_596461 != nil:
    section.add "ClusterVersion", valid_596461
  var valid_596462 = formData.getOrDefault("ClusterType")
  valid_596462 = validateParameter(valid_596462, JString, required = false,
                                 default = nil)
  if valid_596462 != nil:
    section.add "ClusterType", valid_596462
  var valid_596463 = formData.getOrDefault("MasterUserPassword")
  valid_596463 = validateParameter(valid_596463, JString, required = false,
                                 default = nil)
  if valid_596463 != nil:
    section.add "MasterUserPassword", valid_596463
  var valid_596464 = formData.getOrDefault("ClusterSecurityGroups")
  valid_596464 = validateParameter(valid_596464, JArray, required = false,
                                 default = nil)
  if valid_596464 != nil:
    section.add "ClusterSecurityGroups", valid_596464
  var valid_596465 = formData.getOrDefault("Encrypted")
  valid_596465 = validateParameter(valid_596465, JBool, required = false, default = nil)
  if valid_596465 != nil:
    section.add "Encrypted", valid_596465
  var valid_596466 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_596466 = validateParameter(valid_596466, JString, required = false,
                                 default = nil)
  if valid_596466 != nil:
    section.add "HsmConfigurationIdentifier", valid_596466
  var valid_596467 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_596467 = validateParameter(valid_596467, JString, required = false,
                                 default = nil)
  if valid_596467 != nil:
    section.add "HsmClientCertificateIdentifier", valid_596467
  var valid_596468 = formData.getOrDefault("PubliclyAccessible")
  valid_596468 = validateParameter(valid_596468, JBool, required = false, default = nil)
  if valid_596468 != nil:
    section.add "PubliclyAccessible", valid_596468
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_596469 = formData.getOrDefault("ClusterIdentifier")
  valid_596469 = validateParameter(valid_596469, JString, required = true,
                                 default = nil)
  if valid_596469 != nil:
    section.add "ClusterIdentifier", valid_596469
  var valid_596470 = formData.getOrDefault("NumberOfNodes")
  valid_596470 = validateParameter(valid_596470, JInt, required = false, default = nil)
  if valid_596470 != nil:
    section.add "NumberOfNodes", valid_596470
  var valid_596471 = formData.getOrDefault("ClusterParameterGroupName")
  valid_596471 = validateParameter(valid_596471, JString, required = false,
                                 default = nil)
  if valid_596471 != nil:
    section.add "ClusterParameterGroupName", valid_596471
  var valid_596472 = formData.getOrDefault("KmsKeyId")
  valid_596472 = validateParameter(valid_596472, JString, required = false,
                                 default = nil)
  if valid_596472 != nil:
    section.add "KmsKeyId", valid_596472
  var valid_596473 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_596473 = validateParameter(valid_596473, JInt, required = false, default = nil)
  if valid_596473 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_596473
  var valid_596474 = formData.getOrDefault("ElasticIp")
  valid_596474 = validateParameter(valid_596474, JString, required = false,
                                 default = nil)
  if valid_596474 != nil:
    section.add "ElasticIp", valid_596474
  var valid_596475 = formData.getOrDefault("NewClusterIdentifier")
  valid_596475 = validateParameter(valid_596475, JString, required = false,
                                 default = nil)
  if valid_596475 != nil:
    section.add "NewClusterIdentifier", valid_596475
  var valid_596476 = formData.getOrDefault("AllowVersionUpgrade")
  valid_596476 = validateParameter(valid_596476, JBool, required = false, default = nil)
  if valid_596476 != nil:
    section.add "AllowVersionUpgrade", valid_596476
  var valid_596477 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_596477 = validateParameter(valid_596477, JInt, required = false, default = nil)
  if valid_596477 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_596477
  var valid_596478 = formData.getOrDefault("NodeType")
  valid_596478 = validateParameter(valid_596478, JString, required = false,
                                 default = nil)
  if valid_596478 != nil:
    section.add "NodeType", valid_596478
  var valid_596479 = formData.getOrDefault("MaintenanceTrackName")
  valid_596479 = validateParameter(valid_596479, JString, required = false,
                                 default = nil)
  if valid_596479 != nil:
    section.add "MaintenanceTrackName", valid_596479
  var valid_596480 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_596480 = validateParameter(valid_596480, JString, required = false,
                                 default = nil)
  if valid_596480 != nil:
    section.add "PreferredMaintenanceWindow", valid_596480
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596481: Call_PostModifyCluster_596447; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_596481.validator(path, query, header, formData, body)
  let scheme = call_596481.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596481.url(scheme.get, call_596481.host, call_596481.base,
                         call_596481.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596481, url, valid)

proc call*(call_596482: Call_PostModifyCluster_596447; ClusterIdentifier: string;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterVersion: string = ""; ClusterType: string = "";
          MasterUserPassword: string = ""; ClusterSecurityGroups: JsonNode = nil;
          Encrypted: bool = false; HsmConfigurationIdentifier: string = "";
          Action: string = "ModifyCluster";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          ClusterParameterGroupName: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          NewClusterIdentifier: string = ""; AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          NodeType: string = ""; MaintenanceTrackName: string = "";
          PreferredMaintenanceWindow: string = ""): Recallable =
  ## postModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  var query_596483 = newJObject()
  var formData_596484 = newJObject()
  add(formData_596484, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    formData_596484.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_596484, "ClusterVersion", newJString(ClusterVersion))
  add(formData_596484, "ClusterType", newJString(ClusterType))
  add(formData_596484, "MasterUserPassword", newJString(MasterUserPassword))
  if ClusterSecurityGroups != nil:
    formData_596484.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_596484, "Encrypted", newJBool(Encrypted))
  add(formData_596484, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_596483, "Action", newJString(Action))
  add(formData_596484, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_596484, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_596484, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_596484, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_596484, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_596484, "KmsKeyId", newJString(KmsKeyId))
  add(formData_596484, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_596484, "ElasticIp", newJString(ElasticIp))
  add(formData_596484, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(formData_596484, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_596484, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_596483, "Version", newJString(Version))
  add(formData_596484, "NodeType", newJString(NodeType))
  add(formData_596484, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_596484, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  result = call_596482.call(nil, query_596483, nil, formData_596484, nil)

var postModifyCluster* = Call_PostModifyCluster_596447(name: "postModifyCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_PostModifyCluster_596448,
    base: "/", url: url_PostModifyCluster_596449,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyCluster_596410 = ref object of OpenApiRestCall_593421
proc url_GetModifyCluster_596412(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyCluster_596411(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_596413 = query.getOrDefault("ClusterSecurityGroups")
  valid_596413 = validateParameter(valid_596413, JArray, required = false,
                                 default = nil)
  if valid_596413 != nil:
    section.add "ClusterSecurityGroups", valid_596413
  var valid_596414 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_596414 = validateParameter(valid_596414, JString, required = false,
                                 default = nil)
  if valid_596414 != nil:
    section.add "HsmClientCertificateIdentifier", valid_596414
  var valid_596415 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_596415 = validateParameter(valid_596415, JString, required = false,
                                 default = nil)
  if valid_596415 != nil:
    section.add "PreferredMaintenanceWindow", valid_596415
  var valid_596416 = query.getOrDefault("Encrypted")
  valid_596416 = validateParameter(valid_596416, JBool, required = false, default = nil)
  if valid_596416 != nil:
    section.add "Encrypted", valid_596416
  var valid_596417 = query.getOrDefault("MaintenanceTrackName")
  valid_596417 = validateParameter(valid_596417, JString, required = false,
                                 default = nil)
  if valid_596417 != nil:
    section.add "MaintenanceTrackName", valid_596417
  var valid_596418 = query.getOrDefault("MasterUserPassword")
  valid_596418 = validateParameter(valid_596418, JString, required = false,
                                 default = nil)
  if valid_596418 != nil:
    section.add "MasterUserPassword", valid_596418
  var valid_596419 = query.getOrDefault("AllowVersionUpgrade")
  valid_596419 = validateParameter(valid_596419, JBool, required = false, default = nil)
  if valid_596419 != nil:
    section.add "AllowVersionUpgrade", valid_596419
  var valid_596420 = query.getOrDefault("EnhancedVpcRouting")
  valid_596420 = validateParameter(valid_596420, JBool, required = false, default = nil)
  if valid_596420 != nil:
    section.add "EnhancedVpcRouting", valid_596420
  var valid_596421 = query.getOrDefault("VpcSecurityGroupIds")
  valid_596421 = validateParameter(valid_596421, JArray, required = false,
                                 default = nil)
  if valid_596421 != nil:
    section.add "VpcSecurityGroupIds", valid_596421
  var valid_596422 = query.getOrDefault("ClusterParameterGroupName")
  valid_596422 = validateParameter(valid_596422, JString, required = false,
                                 default = nil)
  if valid_596422 != nil:
    section.add "ClusterParameterGroupName", valid_596422
  var valid_596423 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_596423 = validateParameter(valid_596423, JString, required = false,
                                 default = nil)
  if valid_596423 != nil:
    section.add "HsmConfigurationIdentifier", valid_596423
  var valid_596424 = query.getOrDefault("NewClusterIdentifier")
  valid_596424 = validateParameter(valid_596424, JString, required = false,
                                 default = nil)
  if valid_596424 != nil:
    section.add "NewClusterIdentifier", valid_596424
  var valid_596425 = query.getOrDefault("ElasticIp")
  valid_596425 = validateParameter(valid_596425, JString, required = false,
                                 default = nil)
  if valid_596425 != nil:
    section.add "ElasticIp", valid_596425
  assert query != nil,
        "query argument is necessary due to required `ClusterIdentifier` field"
  var valid_596426 = query.getOrDefault("ClusterIdentifier")
  valid_596426 = validateParameter(valid_596426, JString, required = true,
                                 default = nil)
  if valid_596426 != nil:
    section.add "ClusterIdentifier", valid_596426
  var valid_596427 = query.getOrDefault("Action")
  valid_596427 = validateParameter(valid_596427, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_596427 != nil:
    section.add "Action", valid_596427
  var valid_596428 = query.getOrDefault("KmsKeyId")
  valid_596428 = validateParameter(valid_596428, JString, required = false,
                                 default = nil)
  if valid_596428 != nil:
    section.add "KmsKeyId", valid_596428
  var valid_596429 = query.getOrDefault("PubliclyAccessible")
  valid_596429 = validateParameter(valid_596429, JBool, required = false, default = nil)
  if valid_596429 != nil:
    section.add "PubliclyAccessible", valid_596429
  var valid_596430 = query.getOrDefault("NumberOfNodes")
  valid_596430 = validateParameter(valid_596430, JInt, required = false, default = nil)
  if valid_596430 != nil:
    section.add "NumberOfNodes", valid_596430
  var valid_596431 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_596431 = validateParameter(valid_596431, JInt, required = false, default = nil)
  if valid_596431 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_596431
  var valid_596432 = query.getOrDefault("NodeType")
  valid_596432 = validateParameter(valid_596432, JString, required = false,
                                 default = nil)
  if valid_596432 != nil:
    section.add "NodeType", valid_596432
  var valid_596433 = query.getOrDefault("ClusterVersion")
  valid_596433 = validateParameter(valid_596433, JString, required = false,
                                 default = nil)
  if valid_596433 != nil:
    section.add "ClusterVersion", valid_596433
  var valid_596434 = query.getOrDefault("Version")
  valid_596434 = validateParameter(valid_596434, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596434 != nil:
    section.add "Version", valid_596434
  var valid_596435 = query.getOrDefault("ClusterType")
  valid_596435 = validateParameter(valid_596435, JString, required = false,
                                 default = nil)
  if valid_596435 != nil:
    section.add "ClusterType", valid_596435
  var valid_596436 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_596436 = validateParameter(valid_596436, JInt, required = false, default = nil)
  if valid_596436 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_596436
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596437 = header.getOrDefault("X-Amz-Date")
  valid_596437 = validateParameter(valid_596437, JString, required = false,
                                 default = nil)
  if valid_596437 != nil:
    section.add "X-Amz-Date", valid_596437
  var valid_596438 = header.getOrDefault("X-Amz-Security-Token")
  valid_596438 = validateParameter(valid_596438, JString, required = false,
                                 default = nil)
  if valid_596438 != nil:
    section.add "X-Amz-Security-Token", valid_596438
  var valid_596439 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596439 = validateParameter(valid_596439, JString, required = false,
                                 default = nil)
  if valid_596439 != nil:
    section.add "X-Amz-Content-Sha256", valid_596439
  var valid_596440 = header.getOrDefault("X-Amz-Algorithm")
  valid_596440 = validateParameter(valid_596440, JString, required = false,
                                 default = nil)
  if valid_596440 != nil:
    section.add "X-Amz-Algorithm", valid_596440
  var valid_596441 = header.getOrDefault("X-Amz-Signature")
  valid_596441 = validateParameter(valid_596441, JString, required = false,
                                 default = nil)
  if valid_596441 != nil:
    section.add "X-Amz-Signature", valid_596441
  var valid_596442 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596442 = validateParameter(valid_596442, JString, required = false,
                                 default = nil)
  if valid_596442 != nil:
    section.add "X-Amz-SignedHeaders", valid_596442
  var valid_596443 = header.getOrDefault("X-Amz-Credential")
  valid_596443 = validateParameter(valid_596443, JString, required = false,
                                 default = nil)
  if valid_596443 != nil:
    section.add "X-Amz-Credential", valid_596443
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596444: Call_GetModifyCluster_596410; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_596444.validator(path, query, header, formData, body)
  let scheme = call_596444.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596444.url(scheme.get, call_596444.host, call_596444.base,
                         call_596444.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596444, url, valid)

proc call*(call_596445: Call_GetModifyCluster_596410; ClusterIdentifier: string;
          ClusterSecurityGroups: JsonNode = nil;
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = ""; Encrypted: bool = false;
          MaintenanceTrackName: string = ""; MasterUserPassword: string = "";
          AllowVersionUpgrade: bool = false; EnhancedVpcRouting: bool = false;
          VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = "";
          NewClusterIdentifier: string = ""; ElasticIp: string = "";
          Action: string = "ModifyCluster"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; NodeType: string = "";
          ClusterVersion: string = ""; Version: string = "2012-12-01";
          ClusterType: string = ""; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_596446 = newJObject()
  if ClusterSecurityGroups != nil:
    query_596446.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_596446, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_596446, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_596446, "Encrypted", newJBool(Encrypted))
  add(query_596446, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_596446, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_596446, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_596446, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_596446.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_596446, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_596446, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_596446, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(query_596446, "ElasticIp", newJString(ElasticIp))
  add(query_596446, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596446, "Action", newJString(Action))
  add(query_596446, "KmsKeyId", newJString(KmsKeyId))
  add(query_596446, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_596446, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_596446, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_596446, "NodeType", newJString(NodeType))
  add(query_596446, "ClusterVersion", newJString(ClusterVersion))
  add(query_596446, "Version", newJString(Version))
  add(query_596446, "ClusterType", newJString(ClusterType))
  add(query_596446, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_596445.call(nil, query_596446, nil, nil, nil)

var getModifyCluster* = Call_GetModifyCluster_596410(name: "getModifyCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_GetModifyCluster_596411,
    base: "/", url: url_GetModifyCluster_596412,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterDbRevision_596502 = ref object of OpenApiRestCall_593421
proc url_PostModifyClusterDbRevision_596504(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterDbRevision_596503(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596505 = query.getOrDefault("Action")
  valid_596505 = validateParameter(valid_596505, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_596505 != nil:
    section.add "Action", valid_596505
  var valid_596506 = query.getOrDefault("Version")
  valid_596506 = validateParameter(valid_596506, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596506 != nil:
    section.add "Version", valid_596506
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596507 = header.getOrDefault("X-Amz-Date")
  valid_596507 = validateParameter(valid_596507, JString, required = false,
                                 default = nil)
  if valid_596507 != nil:
    section.add "X-Amz-Date", valid_596507
  var valid_596508 = header.getOrDefault("X-Amz-Security-Token")
  valid_596508 = validateParameter(valid_596508, JString, required = false,
                                 default = nil)
  if valid_596508 != nil:
    section.add "X-Amz-Security-Token", valid_596508
  var valid_596509 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596509 = validateParameter(valid_596509, JString, required = false,
                                 default = nil)
  if valid_596509 != nil:
    section.add "X-Amz-Content-Sha256", valid_596509
  var valid_596510 = header.getOrDefault("X-Amz-Algorithm")
  valid_596510 = validateParameter(valid_596510, JString, required = false,
                                 default = nil)
  if valid_596510 != nil:
    section.add "X-Amz-Algorithm", valid_596510
  var valid_596511 = header.getOrDefault("X-Amz-Signature")
  valid_596511 = validateParameter(valid_596511, JString, required = false,
                                 default = nil)
  if valid_596511 != nil:
    section.add "X-Amz-Signature", valid_596511
  var valid_596512 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596512 = validateParameter(valid_596512, JString, required = false,
                                 default = nil)
  if valid_596512 != nil:
    section.add "X-Amz-SignedHeaders", valid_596512
  var valid_596513 = header.getOrDefault("X-Amz-Credential")
  valid_596513 = validateParameter(valid_596513, JString, required = false,
                                 default = nil)
  if valid_596513 != nil:
    section.add "X-Amz-Credential", valid_596513
  result.add "header", section
  ## parameters in `formData` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `RevisionTarget` field"
  var valid_596514 = formData.getOrDefault("RevisionTarget")
  valid_596514 = validateParameter(valid_596514, JString, required = true,
                                 default = nil)
  if valid_596514 != nil:
    section.add "RevisionTarget", valid_596514
  var valid_596515 = formData.getOrDefault("ClusterIdentifier")
  valid_596515 = validateParameter(valid_596515, JString, required = true,
                                 default = nil)
  if valid_596515 != nil:
    section.add "ClusterIdentifier", valid_596515
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596516: Call_PostModifyClusterDbRevision_596502; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_596516.validator(path, query, header, formData, body)
  let scheme = call_596516.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596516.url(scheme.get, call_596516.host, call_596516.base,
                         call_596516.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596516, url, valid)

proc call*(call_596517: Call_PostModifyClusterDbRevision_596502;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_596518 = newJObject()
  var formData_596519 = newJObject()
  add(formData_596519, "RevisionTarget", newJString(RevisionTarget))
  add(query_596518, "Action", newJString(Action))
  add(formData_596519, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596518, "Version", newJString(Version))
  result = call_596517.call(nil, query_596518, nil, formData_596519, nil)

var postModifyClusterDbRevision* = Call_PostModifyClusterDbRevision_596502(
    name: "postModifyClusterDbRevision", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_PostModifyClusterDbRevision_596503, base: "/",
    url: url_PostModifyClusterDbRevision_596504,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterDbRevision_596485 = ref object of OpenApiRestCall_593421
proc url_GetModifyClusterDbRevision_596487(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterDbRevision_596486(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `RevisionTarget` field"
  var valid_596488 = query.getOrDefault("RevisionTarget")
  valid_596488 = validateParameter(valid_596488, JString, required = true,
                                 default = nil)
  if valid_596488 != nil:
    section.add "RevisionTarget", valid_596488
  var valid_596489 = query.getOrDefault("Action")
  valid_596489 = validateParameter(valid_596489, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_596489 != nil:
    section.add "Action", valid_596489
  var valid_596490 = query.getOrDefault("ClusterIdentifier")
  valid_596490 = validateParameter(valid_596490, JString, required = true,
                                 default = nil)
  if valid_596490 != nil:
    section.add "ClusterIdentifier", valid_596490
  var valid_596491 = query.getOrDefault("Version")
  valid_596491 = validateParameter(valid_596491, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596491 != nil:
    section.add "Version", valid_596491
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596492 = header.getOrDefault("X-Amz-Date")
  valid_596492 = validateParameter(valid_596492, JString, required = false,
                                 default = nil)
  if valid_596492 != nil:
    section.add "X-Amz-Date", valid_596492
  var valid_596493 = header.getOrDefault("X-Amz-Security-Token")
  valid_596493 = validateParameter(valid_596493, JString, required = false,
                                 default = nil)
  if valid_596493 != nil:
    section.add "X-Amz-Security-Token", valid_596493
  var valid_596494 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596494 = validateParameter(valid_596494, JString, required = false,
                                 default = nil)
  if valid_596494 != nil:
    section.add "X-Amz-Content-Sha256", valid_596494
  var valid_596495 = header.getOrDefault("X-Amz-Algorithm")
  valid_596495 = validateParameter(valid_596495, JString, required = false,
                                 default = nil)
  if valid_596495 != nil:
    section.add "X-Amz-Algorithm", valid_596495
  var valid_596496 = header.getOrDefault("X-Amz-Signature")
  valid_596496 = validateParameter(valid_596496, JString, required = false,
                                 default = nil)
  if valid_596496 != nil:
    section.add "X-Amz-Signature", valid_596496
  var valid_596497 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596497 = validateParameter(valid_596497, JString, required = false,
                                 default = nil)
  if valid_596497 != nil:
    section.add "X-Amz-SignedHeaders", valid_596497
  var valid_596498 = header.getOrDefault("X-Amz-Credential")
  valid_596498 = validateParameter(valid_596498, JString, required = false,
                                 default = nil)
  if valid_596498 != nil:
    section.add "X-Amz-Credential", valid_596498
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596499: Call_GetModifyClusterDbRevision_596485; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_596499.validator(path, query, header, formData, body)
  let scheme = call_596499.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596499.url(scheme.get, call_596499.host, call_596499.base,
                         call_596499.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596499, url, valid)

proc call*(call_596500: Call_GetModifyClusterDbRevision_596485;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_596501 = newJObject()
  add(query_596501, "RevisionTarget", newJString(RevisionTarget))
  add(query_596501, "Action", newJString(Action))
  add(query_596501, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596501, "Version", newJString(Version))
  result = call_596500.call(nil, query_596501, nil, nil, nil)

var getModifyClusterDbRevision* = Call_GetModifyClusterDbRevision_596485(
    name: "getModifyClusterDbRevision", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_GetModifyClusterDbRevision_596486, base: "/",
    url: url_GetModifyClusterDbRevision_596487,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterIamRoles_596538 = ref object of OpenApiRestCall_593421
proc url_PostModifyClusterIamRoles_596540(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterIamRoles_596539(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596541 = query.getOrDefault("Action")
  valid_596541 = validateParameter(valid_596541, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_596541 != nil:
    section.add "Action", valid_596541
  var valid_596542 = query.getOrDefault("Version")
  valid_596542 = validateParameter(valid_596542, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596542 != nil:
    section.add "Version", valid_596542
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596543 = header.getOrDefault("X-Amz-Date")
  valid_596543 = validateParameter(valid_596543, JString, required = false,
                                 default = nil)
  if valid_596543 != nil:
    section.add "X-Amz-Date", valid_596543
  var valid_596544 = header.getOrDefault("X-Amz-Security-Token")
  valid_596544 = validateParameter(valid_596544, JString, required = false,
                                 default = nil)
  if valid_596544 != nil:
    section.add "X-Amz-Security-Token", valid_596544
  var valid_596545 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596545 = validateParameter(valid_596545, JString, required = false,
                                 default = nil)
  if valid_596545 != nil:
    section.add "X-Amz-Content-Sha256", valid_596545
  var valid_596546 = header.getOrDefault("X-Amz-Algorithm")
  valid_596546 = validateParameter(valid_596546, JString, required = false,
                                 default = nil)
  if valid_596546 != nil:
    section.add "X-Amz-Algorithm", valid_596546
  var valid_596547 = header.getOrDefault("X-Amz-Signature")
  valid_596547 = validateParameter(valid_596547, JString, required = false,
                                 default = nil)
  if valid_596547 != nil:
    section.add "X-Amz-Signature", valid_596547
  var valid_596548 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596548 = validateParameter(valid_596548, JString, required = false,
                                 default = nil)
  if valid_596548 != nil:
    section.add "X-Amz-SignedHeaders", valid_596548
  var valid_596549 = header.getOrDefault("X-Amz-Credential")
  valid_596549 = validateParameter(valid_596549, JString, required = false,
                                 default = nil)
  if valid_596549 != nil:
    section.add "X-Amz-Credential", valid_596549
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_596550 = formData.getOrDefault("ClusterIdentifier")
  valid_596550 = validateParameter(valid_596550, JString, required = true,
                                 default = nil)
  if valid_596550 != nil:
    section.add "ClusterIdentifier", valid_596550
  var valid_596551 = formData.getOrDefault("AddIamRoles")
  valid_596551 = validateParameter(valid_596551, JArray, required = false,
                                 default = nil)
  if valid_596551 != nil:
    section.add "AddIamRoles", valid_596551
  var valid_596552 = formData.getOrDefault("RemoveIamRoles")
  valid_596552 = validateParameter(valid_596552, JArray, required = false,
                                 default = nil)
  if valid_596552 != nil:
    section.add "RemoveIamRoles", valid_596552
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596553: Call_PostModifyClusterIamRoles_596538; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_596553.validator(path, query, header, formData, body)
  let scheme = call_596553.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596553.url(scheme.get, call_596553.host, call_596553.base,
                         call_596553.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596553, url, valid)

proc call*(call_596554: Call_PostModifyClusterIamRoles_596538;
          ClusterIdentifier: string; Action: string = "ModifyClusterIamRoles";
          AddIamRoles: JsonNode = nil; RemoveIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: string (required)
  var query_596555 = newJObject()
  var formData_596556 = newJObject()
  add(query_596555, "Action", newJString(Action))
  add(formData_596556, "ClusterIdentifier", newJString(ClusterIdentifier))
  if AddIamRoles != nil:
    formData_596556.add "AddIamRoles", AddIamRoles
  if RemoveIamRoles != nil:
    formData_596556.add "RemoveIamRoles", RemoveIamRoles
  add(query_596555, "Version", newJString(Version))
  result = call_596554.call(nil, query_596555, nil, formData_596556, nil)

var postModifyClusterIamRoles* = Call_PostModifyClusterIamRoles_596538(
    name: "postModifyClusterIamRoles", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_PostModifyClusterIamRoles_596539, base: "/",
    url: url_PostModifyClusterIamRoles_596540,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterIamRoles_596520 = ref object of OpenApiRestCall_593421
proc url_GetModifyClusterIamRoles_596522(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterIamRoles_596521(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   Version: JString (required)
  section = newJObject()
  var valid_596523 = query.getOrDefault("AddIamRoles")
  valid_596523 = validateParameter(valid_596523, JArray, required = false,
                                 default = nil)
  if valid_596523 != nil:
    section.add "AddIamRoles", valid_596523
  var valid_596524 = query.getOrDefault("RemoveIamRoles")
  valid_596524 = validateParameter(valid_596524, JArray, required = false,
                                 default = nil)
  if valid_596524 != nil:
    section.add "RemoveIamRoles", valid_596524
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596525 = query.getOrDefault("Action")
  valid_596525 = validateParameter(valid_596525, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_596525 != nil:
    section.add "Action", valid_596525
  var valid_596526 = query.getOrDefault("ClusterIdentifier")
  valid_596526 = validateParameter(valid_596526, JString, required = true,
                                 default = nil)
  if valid_596526 != nil:
    section.add "ClusterIdentifier", valid_596526
  var valid_596527 = query.getOrDefault("Version")
  valid_596527 = validateParameter(valid_596527, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596527 != nil:
    section.add "Version", valid_596527
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596528 = header.getOrDefault("X-Amz-Date")
  valid_596528 = validateParameter(valid_596528, JString, required = false,
                                 default = nil)
  if valid_596528 != nil:
    section.add "X-Amz-Date", valid_596528
  var valid_596529 = header.getOrDefault("X-Amz-Security-Token")
  valid_596529 = validateParameter(valid_596529, JString, required = false,
                                 default = nil)
  if valid_596529 != nil:
    section.add "X-Amz-Security-Token", valid_596529
  var valid_596530 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596530 = validateParameter(valid_596530, JString, required = false,
                                 default = nil)
  if valid_596530 != nil:
    section.add "X-Amz-Content-Sha256", valid_596530
  var valid_596531 = header.getOrDefault("X-Amz-Algorithm")
  valid_596531 = validateParameter(valid_596531, JString, required = false,
                                 default = nil)
  if valid_596531 != nil:
    section.add "X-Amz-Algorithm", valid_596531
  var valid_596532 = header.getOrDefault("X-Amz-Signature")
  valid_596532 = validateParameter(valid_596532, JString, required = false,
                                 default = nil)
  if valid_596532 != nil:
    section.add "X-Amz-Signature", valid_596532
  var valid_596533 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596533 = validateParameter(valid_596533, JString, required = false,
                                 default = nil)
  if valid_596533 != nil:
    section.add "X-Amz-SignedHeaders", valid_596533
  var valid_596534 = header.getOrDefault("X-Amz-Credential")
  valid_596534 = validateParameter(valid_596534, JString, required = false,
                                 default = nil)
  if valid_596534 != nil:
    section.add "X-Amz-Credential", valid_596534
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596535: Call_GetModifyClusterIamRoles_596520; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_596535.validator(path, query, header, formData, body)
  let scheme = call_596535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596535.url(scheme.get, call_596535.host, call_596535.base,
                         call_596535.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596535, url, valid)

proc call*(call_596536: Call_GetModifyClusterIamRoles_596520;
          ClusterIdentifier: string; AddIamRoles: JsonNode = nil;
          RemoveIamRoles: JsonNode = nil; Action: string = "ModifyClusterIamRoles";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   Version: string (required)
  var query_596537 = newJObject()
  if AddIamRoles != nil:
    query_596537.add "AddIamRoles", AddIamRoles
  if RemoveIamRoles != nil:
    query_596537.add "RemoveIamRoles", RemoveIamRoles
  add(query_596537, "Action", newJString(Action))
  add(query_596537, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596537, "Version", newJString(Version))
  result = call_596536.call(nil, query_596537, nil, nil, nil)

var getModifyClusterIamRoles* = Call_GetModifyClusterIamRoles_596520(
    name: "getModifyClusterIamRoles", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_GetModifyClusterIamRoles_596521, base: "/",
    url: url_GetModifyClusterIamRoles_596522, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterMaintenance_596578 = ref object of OpenApiRestCall_593421
proc url_PostModifyClusterMaintenance_596580(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterMaintenance_596579(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596581 = query.getOrDefault("Action")
  valid_596581 = validateParameter(valid_596581, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_596581 != nil:
    section.add "Action", valid_596581
  var valid_596582 = query.getOrDefault("Version")
  valid_596582 = validateParameter(valid_596582, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596582 != nil:
    section.add "Version", valid_596582
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596583 = header.getOrDefault("X-Amz-Date")
  valid_596583 = validateParameter(valid_596583, JString, required = false,
                                 default = nil)
  if valid_596583 != nil:
    section.add "X-Amz-Date", valid_596583
  var valid_596584 = header.getOrDefault("X-Amz-Security-Token")
  valid_596584 = validateParameter(valid_596584, JString, required = false,
                                 default = nil)
  if valid_596584 != nil:
    section.add "X-Amz-Security-Token", valid_596584
  var valid_596585 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596585 = validateParameter(valid_596585, JString, required = false,
                                 default = nil)
  if valid_596585 != nil:
    section.add "X-Amz-Content-Sha256", valid_596585
  var valid_596586 = header.getOrDefault("X-Amz-Algorithm")
  valid_596586 = validateParameter(valid_596586, JString, required = false,
                                 default = nil)
  if valid_596586 != nil:
    section.add "X-Amz-Algorithm", valid_596586
  var valid_596587 = header.getOrDefault("X-Amz-Signature")
  valid_596587 = validateParameter(valid_596587, JString, required = false,
                                 default = nil)
  if valid_596587 != nil:
    section.add "X-Amz-Signature", valid_596587
  var valid_596588 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596588 = validateParameter(valid_596588, JString, required = false,
                                 default = nil)
  if valid_596588 != nil:
    section.add "X-Amz-SignedHeaders", valid_596588
  var valid_596589 = header.getOrDefault("X-Amz-Credential")
  valid_596589 = validateParameter(valid_596589, JString, required = false,
                                 default = nil)
  if valid_596589 != nil:
    section.add "X-Amz-Credential", valid_596589
  result.add "header", section
  ## parameters in `formData` object:
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  section = newJObject()
  var valid_596590 = formData.getOrDefault("DeferMaintenanceDuration")
  valid_596590 = validateParameter(valid_596590, JInt, required = false, default = nil)
  if valid_596590 != nil:
    section.add "DeferMaintenanceDuration", valid_596590
  var valid_596591 = formData.getOrDefault("DeferMaintenanceIdentifier")
  valid_596591 = validateParameter(valid_596591, JString, required = false,
                                 default = nil)
  if valid_596591 != nil:
    section.add "DeferMaintenanceIdentifier", valid_596591
  var valid_596592 = formData.getOrDefault("DeferMaintenanceStartTime")
  valid_596592 = validateParameter(valid_596592, JString, required = false,
                                 default = nil)
  if valid_596592 != nil:
    section.add "DeferMaintenanceStartTime", valid_596592
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_596593 = formData.getOrDefault("ClusterIdentifier")
  valid_596593 = validateParameter(valid_596593, JString, required = true,
                                 default = nil)
  if valid_596593 != nil:
    section.add "ClusterIdentifier", valid_596593
  var valid_596594 = formData.getOrDefault("DeferMaintenanceEndTime")
  valid_596594 = validateParameter(valid_596594, JString, required = false,
                                 default = nil)
  if valid_596594 != nil:
    section.add "DeferMaintenanceEndTime", valid_596594
  var valid_596595 = formData.getOrDefault("DeferMaintenance")
  valid_596595 = validateParameter(valid_596595, JBool, required = false, default = nil)
  if valid_596595 != nil:
    section.add "DeferMaintenance", valid_596595
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596596: Call_PostModifyClusterMaintenance_596578; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_596596.validator(path, query, header, formData, body)
  let scheme = call_596596.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596596.url(scheme.get, call_596596.host, call_596596.base,
                         call_596596.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596596, url, valid)

proc call*(call_596597: Call_PostModifyClusterMaintenance_596578;
          ClusterIdentifier: string; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceIdentifier: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenanceStartTime: string = "";
          DeferMaintenanceEndTime: string = ""; DeferMaintenance: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   Action: string (required)
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Version: string (required)
  var query_596598 = newJObject()
  var formData_596599 = newJObject()
  add(formData_596599, "DeferMaintenanceDuration",
      newJInt(DeferMaintenanceDuration))
  add(formData_596599, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_596598, "Action", newJString(Action))
  add(formData_596599, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(formData_596599, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_596599, "DeferMaintenanceEndTime",
      newJString(DeferMaintenanceEndTime))
  add(formData_596599, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_596598, "Version", newJString(Version))
  result = call_596597.call(nil, query_596598, nil, formData_596599, nil)

var postModifyClusterMaintenance* = Call_PostModifyClusterMaintenance_596578(
    name: "postModifyClusterMaintenance", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_PostModifyClusterMaintenance_596579, base: "/",
    url: url_PostModifyClusterMaintenance_596580,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterMaintenance_596557 = ref object of OpenApiRestCall_593421
proc url_GetModifyClusterMaintenance_596559(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterMaintenance_596558(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: JString (required)
  section = newJObject()
  var valid_596560 = query.getOrDefault("DeferMaintenanceStartTime")
  valid_596560 = validateParameter(valid_596560, JString, required = false,
                                 default = nil)
  if valid_596560 != nil:
    section.add "DeferMaintenanceStartTime", valid_596560
  var valid_596561 = query.getOrDefault("DeferMaintenanceDuration")
  valid_596561 = validateParameter(valid_596561, JInt, required = false, default = nil)
  if valid_596561 != nil:
    section.add "DeferMaintenanceDuration", valid_596561
  var valid_596562 = query.getOrDefault("DeferMaintenanceEndTime")
  valid_596562 = validateParameter(valid_596562, JString, required = false,
                                 default = nil)
  if valid_596562 != nil:
    section.add "DeferMaintenanceEndTime", valid_596562
  var valid_596563 = query.getOrDefault("DeferMaintenanceIdentifier")
  valid_596563 = validateParameter(valid_596563, JString, required = false,
                                 default = nil)
  if valid_596563 != nil:
    section.add "DeferMaintenanceIdentifier", valid_596563
  var valid_596564 = query.getOrDefault("DeferMaintenance")
  valid_596564 = validateParameter(valid_596564, JBool, required = false, default = nil)
  if valid_596564 != nil:
    section.add "DeferMaintenance", valid_596564
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596565 = query.getOrDefault("Action")
  valid_596565 = validateParameter(valid_596565, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_596565 != nil:
    section.add "Action", valid_596565
  var valid_596566 = query.getOrDefault("ClusterIdentifier")
  valid_596566 = validateParameter(valid_596566, JString, required = true,
                                 default = nil)
  if valid_596566 != nil:
    section.add "ClusterIdentifier", valid_596566
  var valid_596567 = query.getOrDefault("Version")
  valid_596567 = validateParameter(valid_596567, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596567 != nil:
    section.add "Version", valid_596567
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596568 = header.getOrDefault("X-Amz-Date")
  valid_596568 = validateParameter(valid_596568, JString, required = false,
                                 default = nil)
  if valid_596568 != nil:
    section.add "X-Amz-Date", valid_596568
  var valid_596569 = header.getOrDefault("X-Amz-Security-Token")
  valid_596569 = validateParameter(valid_596569, JString, required = false,
                                 default = nil)
  if valid_596569 != nil:
    section.add "X-Amz-Security-Token", valid_596569
  var valid_596570 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596570 = validateParameter(valid_596570, JString, required = false,
                                 default = nil)
  if valid_596570 != nil:
    section.add "X-Amz-Content-Sha256", valid_596570
  var valid_596571 = header.getOrDefault("X-Amz-Algorithm")
  valid_596571 = validateParameter(valid_596571, JString, required = false,
                                 default = nil)
  if valid_596571 != nil:
    section.add "X-Amz-Algorithm", valid_596571
  var valid_596572 = header.getOrDefault("X-Amz-Signature")
  valid_596572 = validateParameter(valid_596572, JString, required = false,
                                 default = nil)
  if valid_596572 != nil:
    section.add "X-Amz-Signature", valid_596572
  var valid_596573 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596573 = validateParameter(valid_596573, JString, required = false,
                                 default = nil)
  if valid_596573 != nil:
    section.add "X-Amz-SignedHeaders", valid_596573
  var valid_596574 = header.getOrDefault("X-Amz-Credential")
  valid_596574 = validateParameter(valid_596574, JString, required = false,
                                 default = nil)
  if valid_596574 != nil:
    section.add "X-Amz-Credential", valid_596574
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596575: Call_GetModifyClusterMaintenance_596557; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_596575.validator(path, query, header, formData, body)
  let scheme = call_596575.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596575.url(scheme.get, call_596575.host, call_596575.base,
                         call_596575.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596575, url, valid)

proc call*(call_596576: Call_GetModifyClusterMaintenance_596557;
          ClusterIdentifier: string; DeferMaintenanceStartTime: string = "";
          DeferMaintenanceDuration: int = 0; DeferMaintenanceEndTime: string = "";
          DeferMaintenanceIdentifier: string = ""; DeferMaintenance: bool = false;
          Action: string = "ModifyClusterMaintenance";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: string (required)
  var query_596577 = newJObject()
  add(query_596577, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(query_596577, "DeferMaintenanceDuration", newJInt(DeferMaintenanceDuration))
  add(query_596577, "DeferMaintenanceEndTime", newJString(DeferMaintenanceEndTime))
  add(query_596577, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_596577, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_596577, "Action", newJString(Action))
  add(query_596577, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596577, "Version", newJString(Version))
  result = call_596576.call(nil, query_596577, nil, nil, nil)

var getModifyClusterMaintenance* = Call_GetModifyClusterMaintenance_596557(
    name: "getModifyClusterMaintenance", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_GetModifyClusterMaintenance_596558, base: "/",
    url: url_GetModifyClusterMaintenance_596559,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterParameterGroup_596617 = ref object of OpenApiRestCall_593421
proc url_PostModifyClusterParameterGroup_596619(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterParameterGroup_596618(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596620 = query.getOrDefault("Action")
  valid_596620 = validateParameter(valid_596620, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_596620 != nil:
    section.add "Action", valid_596620
  var valid_596621 = query.getOrDefault("Version")
  valid_596621 = validateParameter(valid_596621, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596621 != nil:
    section.add "Version", valid_596621
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596622 = header.getOrDefault("X-Amz-Date")
  valid_596622 = validateParameter(valid_596622, JString, required = false,
                                 default = nil)
  if valid_596622 != nil:
    section.add "X-Amz-Date", valid_596622
  var valid_596623 = header.getOrDefault("X-Amz-Security-Token")
  valid_596623 = validateParameter(valid_596623, JString, required = false,
                                 default = nil)
  if valid_596623 != nil:
    section.add "X-Amz-Security-Token", valid_596623
  var valid_596624 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596624 = validateParameter(valid_596624, JString, required = false,
                                 default = nil)
  if valid_596624 != nil:
    section.add "X-Amz-Content-Sha256", valid_596624
  var valid_596625 = header.getOrDefault("X-Amz-Algorithm")
  valid_596625 = validateParameter(valid_596625, JString, required = false,
                                 default = nil)
  if valid_596625 != nil:
    section.add "X-Amz-Algorithm", valid_596625
  var valid_596626 = header.getOrDefault("X-Amz-Signature")
  valid_596626 = validateParameter(valid_596626, JString, required = false,
                                 default = nil)
  if valid_596626 != nil:
    section.add "X-Amz-Signature", valid_596626
  var valid_596627 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596627 = validateParameter(valid_596627, JString, required = false,
                                 default = nil)
  if valid_596627 != nil:
    section.add "X-Amz-SignedHeaders", valid_596627
  var valid_596628 = header.getOrDefault("X-Amz-Credential")
  valid_596628 = validateParameter(valid_596628, JString, required = false,
                                 default = nil)
  if valid_596628 != nil:
    section.add "X-Amz-Credential", valid_596628
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_596629 = formData.getOrDefault("ParameterGroupName")
  valid_596629 = validateParameter(valid_596629, JString, required = true,
                                 default = nil)
  if valid_596629 != nil:
    section.add "ParameterGroupName", valid_596629
  var valid_596630 = formData.getOrDefault("Parameters")
  valid_596630 = validateParameter(valid_596630, JArray, required = true, default = nil)
  if valid_596630 != nil:
    section.add "Parameters", valid_596630
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596631: Call_PostModifyClusterParameterGroup_596617;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_596631.validator(path, query, header, formData, body)
  let scheme = call_596631.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596631.url(scheme.get, call_596631.host, call_596631.base,
                         call_596631.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596631, url, valid)

proc call*(call_596632: Call_PostModifyClusterParameterGroup_596617;
          ParameterGroupName: string; Parameters: JsonNode;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_596633 = newJObject()
  var formData_596634 = newJObject()
  add(formData_596634, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    formData_596634.add "Parameters", Parameters
  add(query_596633, "Action", newJString(Action))
  add(query_596633, "Version", newJString(Version))
  result = call_596632.call(nil, query_596633, nil, formData_596634, nil)

var postModifyClusterParameterGroup* = Call_PostModifyClusterParameterGroup_596617(
    name: "postModifyClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_PostModifyClusterParameterGroup_596618, base: "/",
    url: url_PostModifyClusterParameterGroup_596619,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterParameterGroup_596600 = ref object of OpenApiRestCall_593421
proc url_GetModifyClusterParameterGroup_596602(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterParameterGroup_596601(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_596603 = query.getOrDefault("ParameterGroupName")
  valid_596603 = validateParameter(valid_596603, JString, required = true,
                                 default = nil)
  if valid_596603 != nil:
    section.add "ParameterGroupName", valid_596603
  var valid_596604 = query.getOrDefault("Parameters")
  valid_596604 = validateParameter(valid_596604, JArray, required = true, default = nil)
  if valid_596604 != nil:
    section.add "Parameters", valid_596604
  var valid_596605 = query.getOrDefault("Action")
  valid_596605 = validateParameter(valid_596605, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_596605 != nil:
    section.add "Action", valid_596605
  var valid_596606 = query.getOrDefault("Version")
  valid_596606 = validateParameter(valid_596606, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596606 != nil:
    section.add "Version", valid_596606
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596607 = header.getOrDefault("X-Amz-Date")
  valid_596607 = validateParameter(valid_596607, JString, required = false,
                                 default = nil)
  if valid_596607 != nil:
    section.add "X-Amz-Date", valid_596607
  var valid_596608 = header.getOrDefault("X-Amz-Security-Token")
  valid_596608 = validateParameter(valid_596608, JString, required = false,
                                 default = nil)
  if valid_596608 != nil:
    section.add "X-Amz-Security-Token", valid_596608
  var valid_596609 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596609 = validateParameter(valid_596609, JString, required = false,
                                 default = nil)
  if valid_596609 != nil:
    section.add "X-Amz-Content-Sha256", valid_596609
  var valid_596610 = header.getOrDefault("X-Amz-Algorithm")
  valid_596610 = validateParameter(valid_596610, JString, required = false,
                                 default = nil)
  if valid_596610 != nil:
    section.add "X-Amz-Algorithm", valid_596610
  var valid_596611 = header.getOrDefault("X-Amz-Signature")
  valid_596611 = validateParameter(valid_596611, JString, required = false,
                                 default = nil)
  if valid_596611 != nil:
    section.add "X-Amz-Signature", valid_596611
  var valid_596612 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596612 = validateParameter(valid_596612, JString, required = false,
                                 default = nil)
  if valid_596612 != nil:
    section.add "X-Amz-SignedHeaders", valid_596612
  var valid_596613 = header.getOrDefault("X-Amz-Credential")
  valid_596613 = validateParameter(valid_596613, JString, required = false,
                                 default = nil)
  if valid_596613 != nil:
    section.add "X-Amz-Credential", valid_596613
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596614: Call_GetModifyClusterParameterGroup_596600; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_596614.validator(path, query, header, formData, body)
  let scheme = call_596614.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596614.url(scheme.get, call_596614.host, call_596614.base,
                         call_596614.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596614, url, valid)

proc call*(call_596615: Call_GetModifyClusterParameterGroup_596600;
          ParameterGroupName: string; Parameters: JsonNode;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_596616 = newJObject()
  add(query_596616, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    query_596616.add "Parameters", Parameters
  add(query_596616, "Action", newJString(Action))
  add(query_596616, "Version", newJString(Version))
  result = call_596615.call(nil, query_596616, nil, nil, nil)

var getModifyClusterParameterGroup* = Call_GetModifyClusterParameterGroup_596600(
    name: "getModifyClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_GetModifyClusterParameterGroup_596601, base: "/",
    url: url_GetModifyClusterParameterGroup_596602,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshot_596653 = ref object of OpenApiRestCall_593421
proc url_PostModifyClusterSnapshot_596655(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterSnapshot_596654(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596656 = query.getOrDefault("Action")
  valid_596656 = validateParameter(valid_596656, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_596656 != nil:
    section.add "Action", valid_596656
  var valid_596657 = query.getOrDefault("Version")
  valid_596657 = validateParameter(valid_596657, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596657 != nil:
    section.add "Version", valid_596657
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596658 = header.getOrDefault("X-Amz-Date")
  valid_596658 = validateParameter(valid_596658, JString, required = false,
                                 default = nil)
  if valid_596658 != nil:
    section.add "X-Amz-Date", valid_596658
  var valid_596659 = header.getOrDefault("X-Amz-Security-Token")
  valid_596659 = validateParameter(valid_596659, JString, required = false,
                                 default = nil)
  if valid_596659 != nil:
    section.add "X-Amz-Security-Token", valid_596659
  var valid_596660 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596660 = validateParameter(valid_596660, JString, required = false,
                                 default = nil)
  if valid_596660 != nil:
    section.add "X-Amz-Content-Sha256", valid_596660
  var valid_596661 = header.getOrDefault("X-Amz-Algorithm")
  valid_596661 = validateParameter(valid_596661, JString, required = false,
                                 default = nil)
  if valid_596661 != nil:
    section.add "X-Amz-Algorithm", valid_596661
  var valid_596662 = header.getOrDefault("X-Amz-Signature")
  valid_596662 = validateParameter(valid_596662, JString, required = false,
                                 default = nil)
  if valid_596662 != nil:
    section.add "X-Amz-Signature", valid_596662
  var valid_596663 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596663 = validateParameter(valid_596663, JString, required = false,
                                 default = nil)
  if valid_596663 != nil:
    section.add "X-Amz-SignedHeaders", valid_596663
  var valid_596664 = header.getOrDefault("X-Amz-Credential")
  valid_596664 = validateParameter(valid_596664, JString, required = false,
                                 default = nil)
  if valid_596664 != nil:
    section.add "X-Amz-Credential", valid_596664
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_596665 = formData.getOrDefault("Force")
  valid_596665 = validateParameter(valid_596665, JBool, required = false, default = nil)
  if valid_596665 != nil:
    section.add "Force", valid_596665
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_596666 = formData.getOrDefault("SnapshotIdentifier")
  valid_596666 = validateParameter(valid_596666, JString, required = true,
                                 default = nil)
  if valid_596666 != nil:
    section.add "SnapshotIdentifier", valid_596666
  var valid_596667 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_596667 = validateParameter(valid_596667, JInt, required = false, default = nil)
  if valid_596667 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_596667
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596668: Call_PostModifyClusterSnapshot_596653; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_596668.validator(path, query, header, formData, body)
  let scheme = call_596668.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596668.url(scheme.get, call_596668.host, call_596668.base,
                         call_596668.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596668, url, valid)

proc call*(call_596669: Call_PostModifyClusterSnapshot_596653;
          SnapshotIdentifier: string; Force: bool = false;
          Action: string = "ModifyClusterSnapshot";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Version: string (required)
  var query_596670 = newJObject()
  var formData_596671 = newJObject()
  add(formData_596671, "Force", newJBool(Force))
  add(query_596670, "Action", newJString(Action))
  add(formData_596671, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_596671, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_596670, "Version", newJString(Version))
  result = call_596669.call(nil, query_596670, nil, formData_596671, nil)

var postModifyClusterSnapshot* = Call_PostModifyClusterSnapshot_596653(
    name: "postModifyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_PostModifyClusterSnapshot_596654, base: "/",
    url: url_PostModifyClusterSnapshot_596655,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshot_596635 = ref object of OpenApiRestCall_593421
proc url_GetModifyClusterSnapshot_596637(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterSnapshot_596636(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Version: JString (required)
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596638 = query.getOrDefault("Action")
  valid_596638 = validateParameter(valid_596638, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_596638 != nil:
    section.add "Action", valid_596638
  var valid_596639 = query.getOrDefault("SnapshotIdentifier")
  valid_596639 = validateParameter(valid_596639, JString, required = true,
                                 default = nil)
  if valid_596639 != nil:
    section.add "SnapshotIdentifier", valid_596639
  var valid_596640 = query.getOrDefault("Version")
  valid_596640 = validateParameter(valid_596640, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596640 != nil:
    section.add "Version", valid_596640
  var valid_596641 = query.getOrDefault("Force")
  valid_596641 = validateParameter(valid_596641, JBool, required = false, default = nil)
  if valid_596641 != nil:
    section.add "Force", valid_596641
  var valid_596642 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_596642 = validateParameter(valid_596642, JInt, required = false, default = nil)
  if valid_596642 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_596642
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596643 = header.getOrDefault("X-Amz-Date")
  valid_596643 = validateParameter(valid_596643, JString, required = false,
                                 default = nil)
  if valid_596643 != nil:
    section.add "X-Amz-Date", valid_596643
  var valid_596644 = header.getOrDefault("X-Amz-Security-Token")
  valid_596644 = validateParameter(valid_596644, JString, required = false,
                                 default = nil)
  if valid_596644 != nil:
    section.add "X-Amz-Security-Token", valid_596644
  var valid_596645 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596645 = validateParameter(valid_596645, JString, required = false,
                                 default = nil)
  if valid_596645 != nil:
    section.add "X-Amz-Content-Sha256", valid_596645
  var valid_596646 = header.getOrDefault("X-Amz-Algorithm")
  valid_596646 = validateParameter(valid_596646, JString, required = false,
                                 default = nil)
  if valid_596646 != nil:
    section.add "X-Amz-Algorithm", valid_596646
  var valid_596647 = header.getOrDefault("X-Amz-Signature")
  valid_596647 = validateParameter(valid_596647, JString, required = false,
                                 default = nil)
  if valid_596647 != nil:
    section.add "X-Amz-Signature", valid_596647
  var valid_596648 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596648 = validateParameter(valid_596648, JString, required = false,
                                 default = nil)
  if valid_596648 != nil:
    section.add "X-Amz-SignedHeaders", valid_596648
  var valid_596649 = header.getOrDefault("X-Amz-Credential")
  valid_596649 = validateParameter(valid_596649, JString, required = false,
                                 default = nil)
  if valid_596649 != nil:
    section.add "X-Amz-Credential", valid_596649
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596650: Call_GetModifyClusterSnapshot_596635; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_596650.validator(path, query, header, formData, body)
  let scheme = call_596650.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596650.url(scheme.get, call_596650.host, call_596650.base,
                         call_596650.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596650, url, valid)

proc call*(call_596651: Call_GetModifyClusterSnapshot_596635;
          SnapshotIdentifier: string; Action: string = "ModifyClusterSnapshot";
          Version: string = "2012-12-01"; Force: bool = false;
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Version: string (required)
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_596652 = newJObject()
  add(query_596652, "Action", newJString(Action))
  add(query_596652, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_596652, "Version", newJString(Version))
  add(query_596652, "Force", newJBool(Force))
  add(query_596652, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_596651.call(nil, query_596652, nil, nil, nil)

var getModifyClusterSnapshot* = Call_GetModifyClusterSnapshot_596635(
    name: "getModifyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_GetModifyClusterSnapshot_596636, base: "/",
    url: url_GetModifyClusterSnapshot_596637, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshotSchedule_596690 = ref object of OpenApiRestCall_593421
proc url_PostModifyClusterSnapshotSchedule_596692(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterSnapshotSchedule_596691(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596693 = query.getOrDefault("Action")
  valid_596693 = validateParameter(valid_596693, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_596693 != nil:
    section.add "Action", valid_596693
  var valid_596694 = query.getOrDefault("Version")
  valid_596694 = validateParameter(valid_596694, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596694 != nil:
    section.add "Version", valid_596694
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596695 = header.getOrDefault("X-Amz-Date")
  valid_596695 = validateParameter(valid_596695, JString, required = false,
                                 default = nil)
  if valid_596695 != nil:
    section.add "X-Amz-Date", valid_596695
  var valid_596696 = header.getOrDefault("X-Amz-Security-Token")
  valid_596696 = validateParameter(valid_596696, JString, required = false,
                                 default = nil)
  if valid_596696 != nil:
    section.add "X-Amz-Security-Token", valid_596696
  var valid_596697 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596697 = validateParameter(valid_596697, JString, required = false,
                                 default = nil)
  if valid_596697 != nil:
    section.add "X-Amz-Content-Sha256", valid_596697
  var valid_596698 = header.getOrDefault("X-Amz-Algorithm")
  valid_596698 = validateParameter(valid_596698, JString, required = false,
                                 default = nil)
  if valid_596698 != nil:
    section.add "X-Amz-Algorithm", valid_596698
  var valid_596699 = header.getOrDefault("X-Amz-Signature")
  valid_596699 = validateParameter(valid_596699, JString, required = false,
                                 default = nil)
  if valid_596699 != nil:
    section.add "X-Amz-Signature", valid_596699
  var valid_596700 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596700 = validateParameter(valid_596700, JString, required = false,
                                 default = nil)
  if valid_596700 != nil:
    section.add "X-Amz-SignedHeaders", valid_596700
  var valid_596701 = header.getOrDefault("X-Amz-Credential")
  valid_596701 = validateParameter(valid_596701, JString, required = false,
                                 default = nil)
  if valid_596701 != nil:
    section.add "X-Amz-Credential", valid_596701
  result.add "header", section
  ## parameters in `formData` object:
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  section = newJObject()
  var valid_596702 = formData.getOrDefault("DisassociateSchedule")
  valid_596702 = validateParameter(valid_596702, JBool, required = false, default = nil)
  if valid_596702 != nil:
    section.add "DisassociateSchedule", valid_596702
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_596703 = formData.getOrDefault("ClusterIdentifier")
  valid_596703 = validateParameter(valid_596703, JString, required = true,
                                 default = nil)
  if valid_596703 != nil:
    section.add "ClusterIdentifier", valid_596703
  var valid_596704 = formData.getOrDefault("ScheduleIdentifier")
  valid_596704 = validateParameter(valid_596704, JString, required = false,
                                 default = nil)
  if valid_596704 != nil:
    section.add "ScheduleIdentifier", valid_596704
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596705: Call_PostModifyClusterSnapshotSchedule_596690;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_596705.validator(path, query, header, formData, body)
  let scheme = call_596705.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596705.url(scheme.get, call_596705.host, call_596705.base,
                         call_596705.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596705, url, valid)

proc call*(call_596706: Call_PostModifyClusterSnapshotSchedule_596690;
          ClusterIdentifier: string; DisassociateSchedule: bool = false;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Version: string (required)
  var query_596707 = newJObject()
  var formData_596708 = newJObject()
  add(formData_596708, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_596707, "Action", newJString(Action))
  add(formData_596708, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_596708, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_596707, "Version", newJString(Version))
  result = call_596706.call(nil, query_596707, nil, formData_596708, nil)

var postModifyClusterSnapshotSchedule* = Call_PostModifyClusterSnapshotSchedule_596690(
    name: "postModifyClusterSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_PostModifyClusterSnapshotSchedule_596691, base: "/",
    url: url_PostModifyClusterSnapshotSchedule_596692,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshotSchedule_596672 = ref object of OpenApiRestCall_593421
proc url_GetModifyClusterSnapshotSchedule_596674(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterSnapshotSchedule_596673(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596675 = query.getOrDefault("Action")
  valid_596675 = validateParameter(valid_596675, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_596675 != nil:
    section.add "Action", valid_596675
  var valid_596676 = query.getOrDefault("ClusterIdentifier")
  valid_596676 = validateParameter(valid_596676, JString, required = true,
                                 default = nil)
  if valid_596676 != nil:
    section.add "ClusterIdentifier", valid_596676
  var valid_596677 = query.getOrDefault("ScheduleIdentifier")
  valid_596677 = validateParameter(valid_596677, JString, required = false,
                                 default = nil)
  if valid_596677 != nil:
    section.add "ScheduleIdentifier", valid_596677
  var valid_596678 = query.getOrDefault("DisassociateSchedule")
  valid_596678 = validateParameter(valid_596678, JBool, required = false, default = nil)
  if valid_596678 != nil:
    section.add "DisassociateSchedule", valid_596678
  var valid_596679 = query.getOrDefault("Version")
  valid_596679 = validateParameter(valid_596679, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596679 != nil:
    section.add "Version", valid_596679
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596680 = header.getOrDefault("X-Amz-Date")
  valid_596680 = validateParameter(valid_596680, JString, required = false,
                                 default = nil)
  if valid_596680 != nil:
    section.add "X-Amz-Date", valid_596680
  var valid_596681 = header.getOrDefault("X-Amz-Security-Token")
  valid_596681 = validateParameter(valid_596681, JString, required = false,
                                 default = nil)
  if valid_596681 != nil:
    section.add "X-Amz-Security-Token", valid_596681
  var valid_596682 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596682 = validateParameter(valid_596682, JString, required = false,
                                 default = nil)
  if valid_596682 != nil:
    section.add "X-Amz-Content-Sha256", valid_596682
  var valid_596683 = header.getOrDefault("X-Amz-Algorithm")
  valid_596683 = validateParameter(valid_596683, JString, required = false,
                                 default = nil)
  if valid_596683 != nil:
    section.add "X-Amz-Algorithm", valid_596683
  var valid_596684 = header.getOrDefault("X-Amz-Signature")
  valid_596684 = validateParameter(valid_596684, JString, required = false,
                                 default = nil)
  if valid_596684 != nil:
    section.add "X-Amz-Signature", valid_596684
  var valid_596685 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596685 = validateParameter(valid_596685, JString, required = false,
                                 default = nil)
  if valid_596685 != nil:
    section.add "X-Amz-SignedHeaders", valid_596685
  var valid_596686 = header.getOrDefault("X-Amz-Credential")
  valid_596686 = validateParameter(valid_596686, JString, required = false,
                                 default = nil)
  if valid_596686 != nil:
    section.add "X-Amz-Credential", valid_596686
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596687: Call_GetModifyClusterSnapshotSchedule_596672;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_596687.validator(path, query, header, formData, body)
  let scheme = call_596687.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596687.url(scheme.get, call_596687.host, call_596687.base,
                         call_596687.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596687, url, valid)

proc call*(call_596688: Call_GetModifyClusterSnapshotSchedule_596672;
          ClusterIdentifier: string;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; DisassociateSchedule: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: string (required)
  var query_596689 = newJObject()
  add(query_596689, "Action", newJString(Action))
  add(query_596689, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596689, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_596689, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_596689, "Version", newJString(Version))
  result = call_596688.call(nil, query_596689, nil, nil, nil)

var getModifyClusterSnapshotSchedule* = Call_GetModifyClusterSnapshotSchedule_596672(
    name: "getModifyClusterSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_GetModifyClusterSnapshotSchedule_596673, base: "/",
    url: url_GetModifyClusterSnapshotSchedule_596674,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSubnetGroup_596727 = ref object of OpenApiRestCall_593421
proc url_PostModifyClusterSubnetGroup_596729(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterSubnetGroup_596728(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596730 = query.getOrDefault("Action")
  valid_596730 = validateParameter(valid_596730, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_596730 != nil:
    section.add "Action", valid_596730
  var valid_596731 = query.getOrDefault("Version")
  valid_596731 = validateParameter(valid_596731, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596731 != nil:
    section.add "Version", valid_596731
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596732 = header.getOrDefault("X-Amz-Date")
  valid_596732 = validateParameter(valid_596732, JString, required = false,
                                 default = nil)
  if valid_596732 != nil:
    section.add "X-Amz-Date", valid_596732
  var valid_596733 = header.getOrDefault("X-Amz-Security-Token")
  valid_596733 = validateParameter(valid_596733, JString, required = false,
                                 default = nil)
  if valid_596733 != nil:
    section.add "X-Amz-Security-Token", valid_596733
  var valid_596734 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596734 = validateParameter(valid_596734, JString, required = false,
                                 default = nil)
  if valid_596734 != nil:
    section.add "X-Amz-Content-Sha256", valid_596734
  var valid_596735 = header.getOrDefault("X-Amz-Algorithm")
  valid_596735 = validateParameter(valid_596735, JString, required = false,
                                 default = nil)
  if valid_596735 != nil:
    section.add "X-Amz-Algorithm", valid_596735
  var valid_596736 = header.getOrDefault("X-Amz-Signature")
  valid_596736 = validateParameter(valid_596736, JString, required = false,
                                 default = nil)
  if valid_596736 != nil:
    section.add "X-Amz-Signature", valid_596736
  var valid_596737 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596737 = validateParameter(valid_596737, JString, required = false,
                                 default = nil)
  if valid_596737 != nil:
    section.add "X-Amz-SignedHeaders", valid_596737
  var valid_596738 = header.getOrDefault("X-Amz-Credential")
  valid_596738 = validateParameter(valid_596738, JString, required = false,
                                 default = nil)
  if valid_596738 != nil:
    section.add "X-Amz-Credential", valid_596738
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `SubnetIds` field"
  var valid_596739 = formData.getOrDefault("SubnetIds")
  valid_596739 = validateParameter(valid_596739, JArray, required = true, default = nil)
  if valid_596739 != nil:
    section.add "SubnetIds", valid_596739
  var valid_596740 = formData.getOrDefault("Description")
  valid_596740 = validateParameter(valid_596740, JString, required = false,
                                 default = nil)
  if valid_596740 != nil:
    section.add "Description", valid_596740
  var valid_596741 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_596741 = validateParameter(valid_596741, JString, required = true,
                                 default = nil)
  if valid_596741 != nil:
    section.add "ClusterSubnetGroupName", valid_596741
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596742: Call_PostModifyClusterSubnetGroup_596727; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_596742.validator(path, query, header, formData, body)
  let scheme = call_596742.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596742.url(scheme.get, call_596742.host, call_596742.base,
                         call_596742.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596742, url, valid)

proc call*(call_596743: Call_PostModifyClusterSubnetGroup_596727;
          SubnetIds: JsonNode; ClusterSubnetGroupName: string;
          Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"; Description: string = ""): Recallable =
  ## postModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  var query_596744 = newJObject()
  var formData_596745 = newJObject()
  if SubnetIds != nil:
    formData_596745.add "SubnetIds", SubnetIds
  add(query_596744, "Action", newJString(Action))
  add(query_596744, "Version", newJString(Version))
  add(formData_596745, "Description", newJString(Description))
  add(formData_596745, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_596743.call(nil, query_596744, nil, formData_596745, nil)

var postModifyClusterSubnetGroup* = Call_PostModifyClusterSubnetGroup_596727(
    name: "postModifyClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_PostModifyClusterSubnetGroup_596728, base: "/",
    url: url_PostModifyClusterSubnetGroup_596729,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSubnetGroup_596709 = ref object of OpenApiRestCall_593421
proc url_GetModifyClusterSubnetGroup_596711(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterSubnetGroup_596710(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   Action: JString (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_596712 = query.getOrDefault("ClusterSubnetGroupName")
  valid_596712 = validateParameter(valid_596712, JString, required = true,
                                 default = nil)
  if valid_596712 != nil:
    section.add "ClusterSubnetGroupName", valid_596712
  var valid_596713 = query.getOrDefault("Description")
  valid_596713 = validateParameter(valid_596713, JString, required = false,
                                 default = nil)
  if valid_596713 != nil:
    section.add "Description", valid_596713
  var valid_596714 = query.getOrDefault("Action")
  valid_596714 = validateParameter(valid_596714, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_596714 != nil:
    section.add "Action", valid_596714
  var valid_596715 = query.getOrDefault("SubnetIds")
  valid_596715 = validateParameter(valid_596715, JArray, required = true, default = nil)
  if valid_596715 != nil:
    section.add "SubnetIds", valid_596715
  var valid_596716 = query.getOrDefault("Version")
  valid_596716 = validateParameter(valid_596716, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596716 != nil:
    section.add "Version", valid_596716
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596717 = header.getOrDefault("X-Amz-Date")
  valid_596717 = validateParameter(valid_596717, JString, required = false,
                                 default = nil)
  if valid_596717 != nil:
    section.add "X-Amz-Date", valid_596717
  var valid_596718 = header.getOrDefault("X-Amz-Security-Token")
  valid_596718 = validateParameter(valid_596718, JString, required = false,
                                 default = nil)
  if valid_596718 != nil:
    section.add "X-Amz-Security-Token", valid_596718
  var valid_596719 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596719 = validateParameter(valid_596719, JString, required = false,
                                 default = nil)
  if valid_596719 != nil:
    section.add "X-Amz-Content-Sha256", valid_596719
  var valid_596720 = header.getOrDefault("X-Amz-Algorithm")
  valid_596720 = validateParameter(valid_596720, JString, required = false,
                                 default = nil)
  if valid_596720 != nil:
    section.add "X-Amz-Algorithm", valid_596720
  var valid_596721 = header.getOrDefault("X-Amz-Signature")
  valid_596721 = validateParameter(valid_596721, JString, required = false,
                                 default = nil)
  if valid_596721 != nil:
    section.add "X-Amz-Signature", valid_596721
  var valid_596722 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596722 = validateParameter(valid_596722, JString, required = false,
                                 default = nil)
  if valid_596722 != nil:
    section.add "X-Amz-SignedHeaders", valid_596722
  var valid_596723 = header.getOrDefault("X-Amz-Credential")
  valid_596723 = validateParameter(valid_596723, JString, required = false,
                                 default = nil)
  if valid_596723 != nil:
    section.add "X-Amz-Credential", valid_596723
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596724: Call_GetModifyClusterSubnetGroup_596709; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_596724.validator(path, query, header, formData, body)
  let scheme = call_596724.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596724.url(scheme.get, call_596724.host, call_596724.base,
                         call_596724.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596724, url, valid)

proc call*(call_596725: Call_GetModifyClusterSubnetGroup_596709;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Description: string = ""; Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   Action: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: string (required)
  var query_596726 = newJObject()
  add(query_596726, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_596726, "Description", newJString(Description))
  add(query_596726, "Action", newJString(Action))
  if SubnetIds != nil:
    query_596726.add "SubnetIds", SubnetIds
  add(query_596726, "Version", newJString(Version))
  result = call_596725.call(nil, query_596726, nil, nil, nil)

var getModifyClusterSubnetGroup* = Call_GetModifyClusterSubnetGroup_596709(
    name: "getModifyClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_GetModifyClusterSubnetGroup_596710, base: "/",
    url: url_GetModifyClusterSubnetGroup_596711,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyEventSubscription_596768 = ref object of OpenApiRestCall_593421
proc url_PostModifyEventSubscription_596770(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyEventSubscription_596769(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596771 = query.getOrDefault("Action")
  valid_596771 = validateParameter(valid_596771, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_596771 != nil:
    section.add "Action", valid_596771
  var valid_596772 = query.getOrDefault("Version")
  valid_596772 = validateParameter(valid_596772, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596772 != nil:
    section.add "Version", valid_596772
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596773 = header.getOrDefault("X-Amz-Date")
  valid_596773 = validateParameter(valid_596773, JString, required = false,
                                 default = nil)
  if valid_596773 != nil:
    section.add "X-Amz-Date", valid_596773
  var valid_596774 = header.getOrDefault("X-Amz-Security-Token")
  valid_596774 = validateParameter(valid_596774, JString, required = false,
                                 default = nil)
  if valid_596774 != nil:
    section.add "X-Amz-Security-Token", valid_596774
  var valid_596775 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596775 = validateParameter(valid_596775, JString, required = false,
                                 default = nil)
  if valid_596775 != nil:
    section.add "X-Amz-Content-Sha256", valid_596775
  var valid_596776 = header.getOrDefault("X-Amz-Algorithm")
  valid_596776 = validateParameter(valid_596776, JString, required = false,
                                 default = nil)
  if valid_596776 != nil:
    section.add "X-Amz-Algorithm", valid_596776
  var valid_596777 = header.getOrDefault("X-Amz-Signature")
  valid_596777 = validateParameter(valid_596777, JString, required = false,
                                 default = nil)
  if valid_596777 != nil:
    section.add "X-Amz-Signature", valid_596777
  var valid_596778 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596778 = validateParameter(valid_596778, JString, required = false,
                                 default = nil)
  if valid_596778 != nil:
    section.add "X-Amz-SignedHeaders", valid_596778
  var valid_596779 = header.getOrDefault("X-Amz-Credential")
  valid_596779 = validateParameter(valid_596779, JString, required = false,
                                 default = nil)
  if valid_596779 != nil:
    section.add "X-Amz-Credential", valid_596779
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  section = newJObject()
  var valid_596780 = formData.getOrDefault("Enabled")
  valid_596780 = validateParameter(valid_596780, JBool, required = false, default = nil)
  if valid_596780 != nil:
    section.add "Enabled", valid_596780
  var valid_596781 = formData.getOrDefault("EventCategories")
  valid_596781 = validateParameter(valid_596781, JArray, required = false,
                                 default = nil)
  if valid_596781 != nil:
    section.add "EventCategories", valid_596781
  var valid_596782 = formData.getOrDefault("SnsTopicArn")
  valid_596782 = validateParameter(valid_596782, JString, required = false,
                                 default = nil)
  if valid_596782 != nil:
    section.add "SnsTopicArn", valid_596782
  var valid_596783 = formData.getOrDefault("Severity")
  valid_596783 = validateParameter(valid_596783, JString, required = false,
                                 default = nil)
  if valid_596783 != nil:
    section.add "Severity", valid_596783
  var valid_596784 = formData.getOrDefault("SourceIds")
  valid_596784 = validateParameter(valid_596784, JArray, required = false,
                                 default = nil)
  if valid_596784 != nil:
    section.add "SourceIds", valid_596784
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_596785 = formData.getOrDefault("SubscriptionName")
  valid_596785 = validateParameter(valid_596785, JString, required = true,
                                 default = nil)
  if valid_596785 != nil:
    section.add "SubscriptionName", valid_596785
  var valid_596786 = formData.getOrDefault("SourceType")
  valid_596786 = validateParameter(valid_596786, JString, required = false,
                                 default = nil)
  if valid_596786 != nil:
    section.add "SourceType", valid_596786
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596787: Call_PostModifyEventSubscription_596768; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_596787.validator(path, query, header, formData, body)
  let scheme = call_596787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596787.url(scheme.get, call_596787.host, call_596787.base,
                         call_596787.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596787, url, valid)

proc call*(call_596788: Call_PostModifyEventSubscription_596768;
          SubscriptionName: string; Enabled: bool = false;
          EventCategories: JsonNode = nil; SnsTopicArn: string = "";
          Severity: string = ""; SourceIds: JsonNode = nil;
          Action: string = "ModifyEventSubscription";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  var query_596789 = newJObject()
  var formData_596790 = newJObject()
  add(formData_596790, "Enabled", newJBool(Enabled))
  if EventCategories != nil:
    formData_596790.add "EventCategories", EventCategories
  add(formData_596790, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_596790, "Severity", newJString(Severity))
  if SourceIds != nil:
    formData_596790.add "SourceIds", SourceIds
  add(formData_596790, "SubscriptionName", newJString(SubscriptionName))
  add(query_596789, "Action", newJString(Action))
  add(query_596789, "Version", newJString(Version))
  add(formData_596790, "SourceType", newJString(SourceType))
  result = call_596788.call(nil, query_596789, nil, formData_596790, nil)

var postModifyEventSubscription* = Call_PostModifyEventSubscription_596768(
    name: "postModifyEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_PostModifyEventSubscription_596769, base: "/",
    url: url_PostModifyEventSubscription_596770,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyEventSubscription_596746 = ref object of OpenApiRestCall_593421
proc url_GetModifyEventSubscription_596748(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyEventSubscription_596747(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Action: JString (required)
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_596749 = query.getOrDefault("SourceType")
  valid_596749 = validateParameter(valid_596749, JString, required = false,
                                 default = nil)
  if valid_596749 != nil:
    section.add "SourceType", valid_596749
  var valid_596750 = query.getOrDefault("SourceIds")
  valid_596750 = validateParameter(valid_596750, JArray, required = false,
                                 default = nil)
  if valid_596750 != nil:
    section.add "SourceIds", valid_596750
  var valid_596751 = query.getOrDefault("Enabled")
  valid_596751 = validateParameter(valid_596751, JBool, required = false, default = nil)
  if valid_596751 != nil:
    section.add "Enabled", valid_596751
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596752 = query.getOrDefault("Action")
  valid_596752 = validateParameter(valid_596752, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_596752 != nil:
    section.add "Action", valid_596752
  var valid_596753 = query.getOrDefault("SnsTopicArn")
  valid_596753 = validateParameter(valid_596753, JString, required = false,
                                 default = nil)
  if valid_596753 != nil:
    section.add "SnsTopicArn", valid_596753
  var valid_596754 = query.getOrDefault("EventCategories")
  valid_596754 = validateParameter(valid_596754, JArray, required = false,
                                 default = nil)
  if valid_596754 != nil:
    section.add "EventCategories", valid_596754
  var valid_596755 = query.getOrDefault("SubscriptionName")
  valid_596755 = validateParameter(valid_596755, JString, required = true,
                                 default = nil)
  if valid_596755 != nil:
    section.add "SubscriptionName", valid_596755
  var valid_596756 = query.getOrDefault("Severity")
  valid_596756 = validateParameter(valid_596756, JString, required = false,
                                 default = nil)
  if valid_596756 != nil:
    section.add "Severity", valid_596756
  var valid_596757 = query.getOrDefault("Version")
  valid_596757 = validateParameter(valid_596757, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596757 != nil:
    section.add "Version", valid_596757
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596758 = header.getOrDefault("X-Amz-Date")
  valid_596758 = validateParameter(valid_596758, JString, required = false,
                                 default = nil)
  if valid_596758 != nil:
    section.add "X-Amz-Date", valid_596758
  var valid_596759 = header.getOrDefault("X-Amz-Security-Token")
  valid_596759 = validateParameter(valid_596759, JString, required = false,
                                 default = nil)
  if valid_596759 != nil:
    section.add "X-Amz-Security-Token", valid_596759
  var valid_596760 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596760 = validateParameter(valid_596760, JString, required = false,
                                 default = nil)
  if valid_596760 != nil:
    section.add "X-Amz-Content-Sha256", valid_596760
  var valid_596761 = header.getOrDefault("X-Amz-Algorithm")
  valid_596761 = validateParameter(valid_596761, JString, required = false,
                                 default = nil)
  if valid_596761 != nil:
    section.add "X-Amz-Algorithm", valid_596761
  var valid_596762 = header.getOrDefault("X-Amz-Signature")
  valid_596762 = validateParameter(valid_596762, JString, required = false,
                                 default = nil)
  if valid_596762 != nil:
    section.add "X-Amz-Signature", valid_596762
  var valid_596763 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596763 = validateParameter(valid_596763, JString, required = false,
                                 default = nil)
  if valid_596763 != nil:
    section.add "X-Amz-SignedHeaders", valid_596763
  var valid_596764 = header.getOrDefault("X-Amz-Credential")
  valid_596764 = validateParameter(valid_596764, JString, required = false,
                                 default = nil)
  if valid_596764 != nil:
    section.add "X-Amz-Credential", valid_596764
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596765: Call_GetModifyEventSubscription_596746; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_596765.validator(path, query, header, formData, body)
  let scheme = call_596765.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596765.url(scheme.get, call_596765.host, call_596765.base,
                         call_596765.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596765, url, valid)

proc call*(call_596766: Call_GetModifyEventSubscription_596746;
          SubscriptionName: string; SourceType: string = "";
          SourceIds: JsonNode = nil; Enabled: bool = false;
          Action: string = "ModifyEventSubscription"; SnsTopicArn: string = "";
          EventCategories: JsonNode = nil; Severity: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Action: string (required)
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: string (required)
  var query_596767 = newJObject()
  add(query_596767, "SourceType", newJString(SourceType))
  if SourceIds != nil:
    query_596767.add "SourceIds", SourceIds
  add(query_596767, "Enabled", newJBool(Enabled))
  add(query_596767, "Action", newJString(Action))
  add(query_596767, "SnsTopicArn", newJString(SnsTopicArn))
  if EventCategories != nil:
    query_596767.add "EventCategories", EventCategories
  add(query_596767, "SubscriptionName", newJString(SubscriptionName))
  add(query_596767, "Severity", newJString(Severity))
  add(query_596767, "Version", newJString(Version))
  result = call_596766.call(nil, query_596767, nil, nil, nil)

var getModifyEventSubscription* = Call_GetModifyEventSubscription_596746(
    name: "getModifyEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_GetModifyEventSubscription_596747, base: "/",
    url: url_GetModifyEventSubscription_596748,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotCopyRetentionPeriod_596809 = ref object of OpenApiRestCall_593421
proc url_PostModifySnapshotCopyRetentionPeriod_596811(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifySnapshotCopyRetentionPeriod_596810(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596812 = query.getOrDefault("Action")
  valid_596812 = validateParameter(valid_596812, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_596812 != nil:
    section.add "Action", valid_596812
  var valid_596813 = query.getOrDefault("Version")
  valid_596813 = validateParameter(valid_596813, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596813 != nil:
    section.add "Version", valid_596813
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596814 = header.getOrDefault("X-Amz-Date")
  valid_596814 = validateParameter(valid_596814, JString, required = false,
                                 default = nil)
  if valid_596814 != nil:
    section.add "X-Amz-Date", valid_596814
  var valid_596815 = header.getOrDefault("X-Amz-Security-Token")
  valid_596815 = validateParameter(valid_596815, JString, required = false,
                                 default = nil)
  if valid_596815 != nil:
    section.add "X-Amz-Security-Token", valid_596815
  var valid_596816 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596816 = validateParameter(valid_596816, JString, required = false,
                                 default = nil)
  if valid_596816 != nil:
    section.add "X-Amz-Content-Sha256", valid_596816
  var valid_596817 = header.getOrDefault("X-Amz-Algorithm")
  valid_596817 = validateParameter(valid_596817, JString, required = false,
                                 default = nil)
  if valid_596817 != nil:
    section.add "X-Amz-Algorithm", valid_596817
  var valid_596818 = header.getOrDefault("X-Amz-Signature")
  valid_596818 = validateParameter(valid_596818, JString, required = false,
                                 default = nil)
  if valid_596818 != nil:
    section.add "X-Amz-Signature", valid_596818
  var valid_596819 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596819 = validateParameter(valid_596819, JString, required = false,
                                 default = nil)
  if valid_596819 != nil:
    section.add "X-Amz-SignedHeaders", valid_596819
  var valid_596820 = header.getOrDefault("X-Amz-Credential")
  valid_596820 = validateParameter(valid_596820, JString, required = false,
                                 default = nil)
  if valid_596820 != nil:
    section.add "X-Amz-Credential", valid_596820
  result.add "header", section
  ## parameters in `formData` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  var valid_596821 = formData.getOrDefault("Manual")
  valid_596821 = validateParameter(valid_596821, JBool, required = false, default = nil)
  if valid_596821 != nil:
    section.add "Manual", valid_596821
  assert formData != nil, "formData argument is necessary due to required `RetentionPeriod` field"
  var valid_596822 = formData.getOrDefault("RetentionPeriod")
  valid_596822 = validateParameter(valid_596822, JInt, required = true, default = nil)
  if valid_596822 != nil:
    section.add "RetentionPeriod", valid_596822
  var valid_596823 = formData.getOrDefault("ClusterIdentifier")
  valid_596823 = validateParameter(valid_596823, JString, required = true,
                                 default = nil)
  if valid_596823 != nil:
    section.add "ClusterIdentifier", valid_596823
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596824: Call_PostModifySnapshotCopyRetentionPeriod_596809;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_596824.validator(path, query, header, formData, body)
  let scheme = call_596824.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596824.url(scheme.get, call_596824.host, call_596824.base,
                         call_596824.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596824, url, valid)

proc call*(call_596825: Call_PostModifySnapshotCopyRetentionPeriod_596809;
          RetentionPeriod: int; ClusterIdentifier: string; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_596826 = newJObject()
  var formData_596827 = newJObject()
  add(formData_596827, "Manual", newJBool(Manual))
  add(formData_596827, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_596826, "Action", newJString(Action))
  add(formData_596827, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596826, "Version", newJString(Version))
  result = call_596825.call(nil, query_596826, nil, formData_596827, nil)

var postModifySnapshotCopyRetentionPeriod* = Call_PostModifySnapshotCopyRetentionPeriod_596809(
    name: "postModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_PostModifySnapshotCopyRetentionPeriod_596810, base: "/",
    url: url_PostModifySnapshotCopyRetentionPeriod_596811,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotCopyRetentionPeriod_596791 = ref object of OpenApiRestCall_593421
proc url_GetModifySnapshotCopyRetentionPeriod_596793(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifySnapshotCopyRetentionPeriod_596792(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_596794 = query.getOrDefault("Manual")
  valid_596794 = validateParameter(valid_596794, JBool, required = false, default = nil)
  if valid_596794 != nil:
    section.add "Manual", valid_596794
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596795 = query.getOrDefault("Action")
  valid_596795 = validateParameter(valid_596795, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_596795 != nil:
    section.add "Action", valid_596795
  var valid_596796 = query.getOrDefault("ClusterIdentifier")
  valid_596796 = validateParameter(valid_596796, JString, required = true,
                                 default = nil)
  if valid_596796 != nil:
    section.add "ClusterIdentifier", valid_596796
  var valid_596797 = query.getOrDefault("RetentionPeriod")
  valid_596797 = validateParameter(valid_596797, JInt, required = true, default = nil)
  if valid_596797 != nil:
    section.add "RetentionPeriod", valid_596797
  var valid_596798 = query.getOrDefault("Version")
  valid_596798 = validateParameter(valid_596798, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596798 != nil:
    section.add "Version", valid_596798
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596799 = header.getOrDefault("X-Amz-Date")
  valid_596799 = validateParameter(valid_596799, JString, required = false,
                                 default = nil)
  if valid_596799 != nil:
    section.add "X-Amz-Date", valid_596799
  var valid_596800 = header.getOrDefault("X-Amz-Security-Token")
  valid_596800 = validateParameter(valid_596800, JString, required = false,
                                 default = nil)
  if valid_596800 != nil:
    section.add "X-Amz-Security-Token", valid_596800
  var valid_596801 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596801 = validateParameter(valid_596801, JString, required = false,
                                 default = nil)
  if valid_596801 != nil:
    section.add "X-Amz-Content-Sha256", valid_596801
  var valid_596802 = header.getOrDefault("X-Amz-Algorithm")
  valid_596802 = validateParameter(valid_596802, JString, required = false,
                                 default = nil)
  if valid_596802 != nil:
    section.add "X-Amz-Algorithm", valid_596802
  var valid_596803 = header.getOrDefault("X-Amz-Signature")
  valid_596803 = validateParameter(valid_596803, JString, required = false,
                                 default = nil)
  if valid_596803 != nil:
    section.add "X-Amz-Signature", valid_596803
  var valid_596804 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596804 = validateParameter(valid_596804, JString, required = false,
                                 default = nil)
  if valid_596804 != nil:
    section.add "X-Amz-SignedHeaders", valid_596804
  var valid_596805 = header.getOrDefault("X-Amz-Credential")
  valid_596805 = validateParameter(valid_596805, JString, required = false,
                                 default = nil)
  if valid_596805 != nil:
    section.add "X-Amz-Credential", valid_596805
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596806: Call_GetModifySnapshotCopyRetentionPeriod_596791;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_596806.validator(path, query, header, formData, body)
  let scheme = call_596806.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596806.url(scheme.get, call_596806.host, call_596806.base,
                         call_596806.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596806, url, valid)

proc call*(call_596807: Call_GetModifySnapshotCopyRetentionPeriod_596791;
          ClusterIdentifier: string; RetentionPeriod: int; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Version: string (required)
  var query_596808 = newJObject()
  add(query_596808, "Manual", newJBool(Manual))
  add(query_596808, "Action", newJString(Action))
  add(query_596808, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596808, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_596808, "Version", newJString(Version))
  result = call_596807.call(nil, query_596808, nil, nil, nil)

var getModifySnapshotCopyRetentionPeriod* = Call_GetModifySnapshotCopyRetentionPeriod_596791(
    name: "getModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_GetModifySnapshotCopyRetentionPeriod_596792, base: "/",
    url: url_GetModifySnapshotCopyRetentionPeriod_596793,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotSchedule_596845 = ref object of OpenApiRestCall_593421
proc url_PostModifySnapshotSchedule_596847(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifySnapshotSchedule_596846(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596848 = query.getOrDefault("Action")
  valid_596848 = validateParameter(valid_596848, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_596848 != nil:
    section.add "Action", valid_596848
  var valid_596849 = query.getOrDefault("Version")
  valid_596849 = validateParameter(valid_596849, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596849 != nil:
    section.add "Version", valid_596849
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596850 = header.getOrDefault("X-Amz-Date")
  valid_596850 = validateParameter(valid_596850, JString, required = false,
                                 default = nil)
  if valid_596850 != nil:
    section.add "X-Amz-Date", valid_596850
  var valid_596851 = header.getOrDefault("X-Amz-Security-Token")
  valid_596851 = validateParameter(valid_596851, JString, required = false,
                                 default = nil)
  if valid_596851 != nil:
    section.add "X-Amz-Security-Token", valid_596851
  var valid_596852 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596852 = validateParameter(valid_596852, JString, required = false,
                                 default = nil)
  if valid_596852 != nil:
    section.add "X-Amz-Content-Sha256", valid_596852
  var valid_596853 = header.getOrDefault("X-Amz-Algorithm")
  valid_596853 = validateParameter(valid_596853, JString, required = false,
                                 default = nil)
  if valid_596853 != nil:
    section.add "X-Amz-Algorithm", valid_596853
  var valid_596854 = header.getOrDefault("X-Amz-Signature")
  valid_596854 = validateParameter(valid_596854, JString, required = false,
                                 default = nil)
  if valid_596854 != nil:
    section.add "X-Amz-Signature", valid_596854
  var valid_596855 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596855 = validateParameter(valid_596855, JString, required = false,
                                 default = nil)
  if valid_596855 != nil:
    section.add "X-Amz-SignedHeaders", valid_596855
  var valid_596856 = header.getOrDefault("X-Amz-Credential")
  valid_596856 = validateParameter(valid_596856, JString, required = false,
                                 default = nil)
  if valid_596856 != nil:
    section.add "X-Amz-Credential", valid_596856
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleDefinitions` field"
  var valid_596857 = formData.getOrDefault("ScheduleDefinitions")
  valid_596857 = validateParameter(valid_596857, JArray, required = true, default = nil)
  if valid_596857 != nil:
    section.add "ScheduleDefinitions", valid_596857
  var valid_596858 = formData.getOrDefault("ScheduleIdentifier")
  valid_596858 = validateParameter(valid_596858, JString, required = true,
                                 default = nil)
  if valid_596858 != nil:
    section.add "ScheduleIdentifier", valid_596858
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596859: Call_PostModifySnapshotSchedule_596845; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_596859.validator(path, query, header, formData, body)
  let scheme = call_596859.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596859.url(scheme.get, call_596859.host, call_596859.base,
                         call_596859.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596859, url, valid)

proc call*(call_596860: Call_PostModifySnapshotSchedule_596845;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_596861 = newJObject()
  var formData_596862 = newJObject()
  if ScheduleDefinitions != nil:
    formData_596862.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_596861, "Action", newJString(Action))
  add(formData_596862, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_596861, "Version", newJString(Version))
  result = call_596860.call(nil, query_596861, nil, formData_596862, nil)

var postModifySnapshotSchedule* = Call_PostModifySnapshotSchedule_596845(
    name: "postModifySnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_PostModifySnapshotSchedule_596846, base: "/",
    url: url_PostModifySnapshotSchedule_596847,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotSchedule_596828 = ref object of OpenApiRestCall_593421
proc url_GetModifySnapshotSchedule_596830(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifySnapshotSchedule_596829(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleDefinitions` field"
  var valid_596831 = query.getOrDefault("ScheduleDefinitions")
  valid_596831 = validateParameter(valid_596831, JArray, required = true, default = nil)
  if valid_596831 != nil:
    section.add "ScheduleDefinitions", valid_596831
  var valid_596832 = query.getOrDefault("Action")
  valid_596832 = validateParameter(valid_596832, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_596832 != nil:
    section.add "Action", valid_596832
  var valid_596833 = query.getOrDefault("ScheduleIdentifier")
  valid_596833 = validateParameter(valid_596833, JString, required = true,
                                 default = nil)
  if valid_596833 != nil:
    section.add "ScheduleIdentifier", valid_596833
  var valid_596834 = query.getOrDefault("Version")
  valid_596834 = validateParameter(valid_596834, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596834 != nil:
    section.add "Version", valid_596834
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596835 = header.getOrDefault("X-Amz-Date")
  valid_596835 = validateParameter(valid_596835, JString, required = false,
                                 default = nil)
  if valid_596835 != nil:
    section.add "X-Amz-Date", valid_596835
  var valid_596836 = header.getOrDefault("X-Amz-Security-Token")
  valid_596836 = validateParameter(valid_596836, JString, required = false,
                                 default = nil)
  if valid_596836 != nil:
    section.add "X-Amz-Security-Token", valid_596836
  var valid_596837 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596837 = validateParameter(valid_596837, JString, required = false,
                                 default = nil)
  if valid_596837 != nil:
    section.add "X-Amz-Content-Sha256", valid_596837
  var valid_596838 = header.getOrDefault("X-Amz-Algorithm")
  valid_596838 = validateParameter(valid_596838, JString, required = false,
                                 default = nil)
  if valid_596838 != nil:
    section.add "X-Amz-Algorithm", valid_596838
  var valid_596839 = header.getOrDefault("X-Amz-Signature")
  valid_596839 = validateParameter(valid_596839, JString, required = false,
                                 default = nil)
  if valid_596839 != nil:
    section.add "X-Amz-Signature", valid_596839
  var valid_596840 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596840 = validateParameter(valid_596840, JString, required = false,
                                 default = nil)
  if valid_596840 != nil:
    section.add "X-Amz-SignedHeaders", valid_596840
  var valid_596841 = header.getOrDefault("X-Amz-Credential")
  valid_596841 = validateParameter(valid_596841, JString, required = false,
                                 default = nil)
  if valid_596841 != nil:
    section.add "X-Amz-Credential", valid_596841
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596842: Call_GetModifySnapshotSchedule_596828; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_596842.validator(path, query, header, formData, body)
  let scheme = call_596842.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596842.url(scheme.get, call_596842.host, call_596842.base,
                         call_596842.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596842, url, valid)

proc call*(call_596843: Call_GetModifySnapshotSchedule_596828;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_596844 = newJObject()
  if ScheduleDefinitions != nil:
    query_596844.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_596844, "Action", newJString(Action))
  add(query_596844, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_596844, "Version", newJString(Version))
  result = call_596843.call(nil, query_596844, nil, nil, nil)

var getModifySnapshotSchedule* = Call_GetModifySnapshotSchedule_596828(
    name: "getModifySnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_GetModifySnapshotSchedule_596829, base: "/",
    url: url_GetModifySnapshotSchedule_596830,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostPurchaseReservedNodeOffering_596880 = ref object of OpenApiRestCall_593421
proc url_PostPurchaseReservedNodeOffering_596882(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostPurchaseReservedNodeOffering_596881(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596883 = query.getOrDefault("Action")
  valid_596883 = validateParameter(valid_596883, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_596883 != nil:
    section.add "Action", valid_596883
  var valid_596884 = query.getOrDefault("Version")
  valid_596884 = validateParameter(valid_596884, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596884 != nil:
    section.add "Version", valid_596884
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596885 = header.getOrDefault("X-Amz-Date")
  valid_596885 = validateParameter(valid_596885, JString, required = false,
                                 default = nil)
  if valid_596885 != nil:
    section.add "X-Amz-Date", valid_596885
  var valid_596886 = header.getOrDefault("X-Amz-Security-Token")
  valid_596886 = validateParameter(valid_596886, JString, required = false,
                                 default = nil)
  if valid_596886 != nil:
    section.add "X-Amz-Security-Token", valid_596886
  var valid_596887 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596887 = validateParameter(valid_596887, JString, required = false,
                                 default = nil)
  if valid_596887 != nil:
    section.add "X-Amz-Content-Sha256", valid_596887
  var valid_596888 = header.getOrDefault("X-Amz-Algorithm")
  valid_596888 = validateParameter(valid_596888, JString, required = false,
                                 default = nil)
  if valid_596888 != nil:
    section.add "X-Amz-Algorithm", valid_596888
  var valid_596889 = header.getOrDefault("X-Amz-Signature")
  valid_596889 = validateParameter(valid_596889, JString, required = false,
                                 default = nil)
  if valid_596889 != nil:
    section.add "X-Amz-Signature", valid_596889
  var valid_596890 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596890 = validateParameter(valid_596890, JString, required = false,
                                 default = nil)
  if valid_596890 != nil:
    section.add "X-Amz-SignedHeaders", valid_596890
  var valid_596891 = header.getOrDefault("X-Amz-Credential")
  valid_596891 = validateParameter(valid_596891, JString, required = false,
                                 default = nil)
  if valid_596891 != nil:
    section.add "X-Amz-Credential", valid_596891
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_596892 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_596892 = validateParameter(valid_596892, JString, required = true,
                                 default = nil)
  if valid_596892 != nil:
    section.add "ReservedNodeOfferingId", valid_596892
  var valid_596893 = formData.getOrDefault("NodeCount")
  valid_596893 = validateParameter(valid_596893, JInt, required = false, default = nil)
  if valid_596893 != nil:
    section.add "NodeCount", valid_596893
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596894: Call_PostPurchaseReservedNodeOffering_596880;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_596894.validator(path, query, header, formData, body)
  let scheme = call_596894.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596894.url(scheme.get, call_596894.host, call_596894.base,
                         call_596894.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596894, url, valid)

proc call*(call_596895: Call_PostPurchaseReservedNodeOffering_596880;
          ReservedNodeOfferingId: string; NodeCount: int = 0;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"): Recallable =
  ## postPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_596896 = newJObject()
  var formData_596897 = newJObject()
  add(formData_596897, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_596897, "NodeCount", newJInt(NodeCount))
  add(query_596896, "Action", newJString(Action))
  add(query_596896, "Version", newJString(Version))
  result = call_596895.call(nil, query_596896, nil, formData_596897, nil)

var postPurchaseReservedNodeOffering* = Call_PostPurchaseReservedNodeOffering_596880(
    name: "postPurchaseReservedNodeOffering", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_PostPurchaseReservedNodeOffering_596881, base: "/",
    url: url_PostPurchaseReservedNodeOffering_596882,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPurchaseReservedNodeOffering_596863 = ref object of OpenApiRestCall_593421
proc url_GetPurchaseReservedNodeOffering_596865(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetPurchaseReservedNodeOffering_596864(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: JString (required)
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_596866 = query.getOrDefault("ReservedNodeOfferingId")
  valid_596866 = validateParameter(valid_596866, JString, required = true,
                                 default = nil)
  if valid_596866 != nil:
    section.add "ReservedNodeOfferingId", valid_596866
  var valid_596867 = query.getOrDefault("Action")
  valid_596867 = validateParameter(valid_596867, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_596867 != nil:
    section.add "Action", valid_596867
  var valid_596868 = query.getOrDefault("NodeCount")
  valid_596868 = validateParameter(valid_596868, JInt, required = false, default = nil)
  if valid_596868 != nil:
    section.add "NodeCount", valid_596868
  var valid_596869 = query.getOrDefault("Version")
  valid_596869 = validateParameter(valid_596869, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596869 != nil:
    section.add "Version", valid_596869
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596870 = header.getOrDefault("X-Amz-Date")
  valid_596870 = validateParameter(valid_596870, JString, required = false,
                                 default = nil)
  if valid_596870 != nil:
    section.add "X-Amz-Date", valid_596870
  var valid_596871 = header.getOrDefault("X-Amz-Security-Token")
  valid_596871 = validateParameter(valid_596871, JString, required = false,
                                 default = nil)
  if valid_596871 != nil:
    section.add "X-Amz-Security-Token", valid_596871
  var valid_596872 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596872 = validateParameter(valid_596872, JString, required = false,
                                 default = nil)
  if valid_596872 != nil:
    section.add "X-Amz-Content-Sha256", valid_596872
  var valid_596873 = header.getOrDefault("X-Amz-Algorithm")
  valid_596873 = validateParameter(valid_596873, JString, required = false,
                                 default = nil)
  if valid_596873 != nil:
    section.add "X-Amz-Algorithm", valid_596873
  var valid_596874 = header.getOrDefault("X-Amz-Signature")
  valid_596874 = validateParameter(valid_596874, JString, required = false,
                                 default = nil)
  if valid_596874 != nil:
    section.add "X-Amz-Signature", valid_596874
  var valid_596875 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596875 = validateParameter(valid_596875, JString, required = false,
                                 default = nil)
  if valid_596875 != nil:
    section.add "X-Amz-SignedHeaders", valid_596875
  var valid_596876 = header.getOrDefault("X-Amz-Credential")
  valid_596876 = validateParameter(valid_596876, JString, required = false,
                                 default = nil)
  if valid_596876 != nil:
    section.add "X-Amz-Credential", valid_596876
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596877: Call_GetPurchaseReservedNodeOffering_596863;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_596877.validator(path, query, header, formData, body)
  let scheme = call_596877.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596877.url(scheme.get, call_596877.host, call_596877.base,
                         call_596877.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596877, url, valid)

proc call*(call_596878: Call_GetPurchaseReservedNodeOffering_596863;
          ReservedNodeOfferingId: string;
          Action: string = "PurchaseReservedNodeOffering"; NodeCount: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## getPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Version: string (required)
  var query_596879 = newJObject()
  add(query_596879, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_596879, "Action", newJString(Action))
  add(query_596879, "NodeCount", newJInt(NodeCount))
  add(query_596879, "Version", newJString(Version))
  result = call_596878.call(nil, query_596879, nil, nil, nil)

var getPurchaseReservedNodeOffering* = Call_GetPurchaseReservedNodeOffering_596863(
    name: "getPurchaseReservedNodeOffering", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_GetPurchaseReservedNodeOffering_596864, base: "/",
    url: url_GetPurchaseReservedNodeOffering_596865,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRebootCluster_596914 = ref object of OpenApiRestCall_593421
proc url_PostRebootCluster_596916(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRebootCluster_596915(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596917 = query.getOrDefault("Action")
  valid_596917 = validateParameter(valid_596917, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_596917 != nil:
    section.add "Action", valid_596917
  var valid_596918 = query.getOrDefault("Version")
  valid_596918 = validateParameter(valid_596918, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596918 != nil:
    section.add "Version", valid_596918
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596919 = header.getOrDefault("X-Amz-Date")
  valid_596919 = validateParameter(valid_596919, JString, required = false,
                                 default = nil)
  if valid_596919 != nil:
    section.add "X-Amz-Date", valid_596919
  var valid_596920 = header.getOrDefault("X-Amz-Security-Token")
  valid_596920 = validateParameter(valid_596920, JString, required = false,
                                 default = nil)
  if valid_596920 != nil:
    section.add "X-Amz-Security-Token", valid_596920
  var valid_596921 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596921 = validateParameter(valid_596921, JString, required = false,
                                 default = nil)
  if valid_596921 != nil:
    section.add "X-Amz-Content-Sha256", valid_596921
  var valid_596922 = header.getOrDefault("X-Amz-Algorithm")
  valid_596922 = validateParameter(valid_596922, JString, required = false,
                                 default = nil)
  if valid_596922 != nil:
    section.add "X-Amz-Algorithm", valid_596922
  var valid_596923 = header.getOrDefault("X-Amz-Signature")
  valid_596923 = validateParameter(valid_596923, JString, required = false,
                                 default = nil)
  if valid_596923 != nil:
    section.add "X-Amz-Signature", valid_596923
  var valid_596924 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596924 = validateParameter(valid_596924, JString, required = false,
                                 default = nil)
  if valid_596924 != nil:
    section.add "X-Amz-SignedHeaders", valid_596924
  var valid_596925 = header.getOrDefault("X-Amz-Credential")
  valid_596925 = validateParameter(valid_596925, JString, required = false,
                                 default = nil)
  if valid_596925 != nil:
    section.add "X-Amz-Credential", valid_596925
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_596926 = formData.getOrDefault("ClusterIdentifier")
  valid_596926 = validateParameter(valid_596926, JString, required = true,
                                 default = nil)
  if valid_596926 != nil:
    section.add "ClusterIdentifier", valid_596926
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596927: Call_PostRebootCluster_596914; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_596927.validator(path, query, header, formData, body)
  let scheme = call_596927.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596927.url(scheme.get, call_596927.host, call_596927.base,
                         call_596927.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596927, url, valid)

proc call*(call_596928: Call_PostRebootCluster_596914; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## postRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_596929 = newJObject()
  var formData_596930 = newJObject()
  add(query_596929, "Action", newJString(Action))
  add(formData_596930, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596929, "Version", newJString(Version))
  result = call_596928.call(nil, query_596929, nil, formData_596930, nil)

var postRebootCluster* = Call_PostRebootCluster_596914(name: "postRebootCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_PostRebootCluster_596915,
    base: "/", url: url_PostRebootCluster_596916,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRebootCluster_596898 = ref object of OpenApiRestCall_593421
proc url_GetRebootCluster_596900(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRebootCluster_596899(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596901 = query.getOrDefault("Action")
  valid_596901 = validateParameter(valid_596901, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_596901 != nil:
    section.add "Action", valid_596901
  var valid_596902 = query.getOrDefault("ClusterIdentifier")
  valid_596902 = validateParameter(valid_596902, JString, required = true,
                                 default = nil)
  if valid_596902 != nil:
    section.add "ClusterIdentifier", valid_596902
  var valid_596903 = query.getOrDefault("Version")
  valid_596903 = validateParameter(valid_596903, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596903 != nil:
    section.add "Version", valid_596903
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596904 = header.getOrDefault("X-Amz-Date")
  valid_596904 = validateParameter(valid_596904, JString, required = false,
                                 default = nil)
  if valid_596904 != nil:
    section.add "X-Amz-Date", valid_596904
  var valid_596905 = header.getOrDefault("X-Amz-Security-Token")
  valid_596905 = validateParameter(valid_596905, JString, required = false,
                                 default = nil)
  if valid_596905 != nil:
    section.add "X-Amz-Security-Token", valid_596905
  var valid_596906 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596906 = validateParameter(valid_596906, JString, required = false,
                                 default = nil)
  if valid_596906 != nil:
    section.add "X-Amz-Content-Sha256", valid_596906
  var valid_596907 = header.getOrDefault("X-Amz-Algorithm")
  valid_596907 = validateParameter(valid_596907, JString, required = false,
                                 default = nil)
  if valid_596907 != nil:
    section.add "X-Amz-Algorithm", valid_596907
  var valid_596908 = header.getOrDefault("X-Amz-Signature")
  valid_596908 = validateParameter(valid_596908, JString, required = false,
                                 default = nil)
  if valid_596908 != nil:
    section.add "X-Amz-Signature", valid_596908
  var valid_596909 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596909 = validateParameter(valid_596909, JString, required = false,
                                 default = nil)
  if valid_596909 != nil:
    section.add "X-Amz-SignedHeaders", valid_596909
  var valid_596910 = header.getOrDefault("X-Amz-Credential")
  valid_596910 = validateParameter(valid_596910, JString, required = false,
                                 default = nil)
  if valid_596910 != nil:
    section.add "X-Amz-Credential", valid_596910
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596911: Call_GetRebootCluster_596898; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_596911.validator(path, query, header, formData, body)
  let scheme = call_596911.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596911.url(scheme.get, call_596911.host, call_596911.base,
                         call_596911.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596911, url, valid)

proc call*(call_596912: Call_GetRebootCluster_596898; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## getRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_596913 = newJObject()
  add(query_596913, "Action", newJString(Action))
  add(query_596913, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596913, "Version", newJString(Version))
  result = call_596912.call(nil, query_596913, nil, nil, nil)

var getRebootCluster* = Call_GetRebootCluster_596898(name: "getRebootCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_GetRebootCluster_596899,
    base: "/", url: url_GetRebootCluster_596900,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResetClusterParameterGroup_596949 = ref object of OpenApiRestCall_593421
proc url_PostResetClusterParameterGroup_596951(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostResetClusterParameterGroup_596950(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596952 = query.getOrDefault("Action")
  valid_596952 = validateParameter(valid_596952, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_596952 != nil:
    section.add "Action", valid_596952
  var valid_596953 = query.getOrDefault("Version")
  valid_596953 = validateParameter(valid_596953, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596953 != nil:
    section.add "Version", valid_596953
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596954 = header.getOrDefault("X-Amz-Date")
  valid_596954 = validateParameter(valid_596954, JString, required = false,
                                 default = nil)
  if valid_596954 != nil:
    section.add "X-Amz-Date", valid_596954
  var valid_596955 = header.getOrDefault("X-Amz-Security-Token")
  valid_596955 = validateParameter(valid_596955, JString, required = false,
                                 default = nil)
  if valid_596955 != nil:
    section.add "X-Amz-Security-Token", valid_596955
  var valid_596956 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596956 = validateParameter(valid_596956, JString, required = false,
                                 default = nil)
  if valid_596956 != nil:
    section.add "X-Amz-Content-Sha256", valid_596956
  var valid_596957 = header.getOrDefault("X-Amz-Algorithm")
  valid_596957 = validateParameter(valid_596957, JString, required = false,
                                 default = nil)
  if valid_596957 != nil:
    section.add "X-Amz-Algorithm", valid_596957
  var valid_596958 = header.getOrDefault("X-Amz-Signature")
  valid_596958 = validateParameter(valid_596958, JString, required = false,
                                 default = nil)
  if valid_596958 != nil:
    section.add "X-Amz-Signature", valid_596958
  var valid_596959 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596959 = validateParameter(valid_596959, JString, required = false,
                                 default = nil)
  if valid_596959 != nil:
    section.add "X-Amz-SignedHeaders", valid_596959
  var valid_596960 = header.getOrDefault("X-Amz-Credential")
  valid_596960 = validateParameter(valid_596960, JString, required = false,
                                 default = nil)
  if valid_596960 != nil:
    section.add "X-Amz-Credential", valid_596960
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_596961 = formData.getOrDefault("ParameterGroupName")
  valid_596961 = validateParameter(valid_596961, JString, required = true,
                                 default = nil)
  if valid_596961 != nil:
    section.add "ParameterGroupName", valid_596961
  var valid_596962 = formData.getOrDefault("Parameters")
  valid_596962 = validateParameter(valid_596962, JArray, required = false,
                                 default = nil)
  if valid_596962 != nil:
    section.add "Parameters", valid_596962
  var valid_596963 = formData.getOrDefault("ResetAllParameters")
  valid_596963 = validateParameter(valid_596963, JBool, required = false, default = nil)
  if valid_596963 != nil:
    section.add "ResetAllParameters", valid_596963
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596964: Call_PostResetClusterParameterGroup_596949; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_596964.validator(path, query, header, formData, body)
  let scheme = call_596964.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596964.url(scheme.get, call_596964.host, call_596964.base,
                         call_596964.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596964, url, valid)

proc call*(call_596965: Call_PostResetClusterParameterGroup_596949;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          Action: string = "ResetClusterParameterGroup";
          ResetAllParameters: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: string (required)
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: string (required)
  var query_596966 = newJObject()
  var formData_596967 = newJObject()
  add(formData_596967, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    formData_596967.add "Parameters", Parameters
  add(query_596966, "Action", newJString(Action))
  add(formData_596967, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_596966, "Version", newJString(Version))
  result = call_596965.call(nil, query_596966, nil, formData_596967, nil)

var postResetClusterParameterGroup* = Call_PostResetClusterParameterGroup_596949(
    name: "postResetClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_PostResetClusterParameterGroup_596950, base: "/",
    url: url_PostResetClusterParameterGroup_596951,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResetClusterParameterGroup_596931 = ref object of OpenApiRestCall_593421
proc url_GetResetClusterParameterGroup_596933(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetResetClusterParameterGroup_596932(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: JString (required)
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_596934 = query.getOrDefault("ParameterGroupName")
  valid_596934 = validateParameter(valid_596934, JString, required = true,
                                 default = nil)
  if valid_596934 != nil:
    section.add "ParameterGroupName", valid_596934
  var valid_596935 = query.getOrDefault("Parameters")
  valid_596935 = validateParameter(valid_596935, JArray, required = false,
                                 default = nil)
  if valid_596935 != nil:
    section.add "Parameters", valid_596935
  var valid_596936 = query.getOrDefault("Action")
  valid_596936 = validateParameter(valid_596936, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_596936 != nil:
    section.add "Action", valid_596936
  var valid_596937 = query.getOrDefault("ResetAllParameters")
  valid_596937 = validateParameter(valid_596937, JBool, required = false, default = nil)
  if valid_596937 != nil:
    section.add "ResetAllParameters", valid_596937
  var valid_596938 = query.getOrDefault("Version")
  valid_596938 = validateParameter(valid_596938, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596938 != nil:
    section.add "Version", valid_596938
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596939 = header.getOrDefault("X-Amz-Date")
  valid_596939 = validateParameter(valid_596939, JString, required = false,
                                 default = nil)
  if valid_596939 != nil:
    section.add "X-Amz-Date", valid_596939
  var valid_596940 = header.getOrDefault("X-Amz-Security-Token")
  valid_596940 = validateParameter(valid_596940, JString, required = false,
                                 default = nil)
  if valid_596940 != nil:
    section.add "X-Amz-Security-Token", valid_596940
  var valid_596941 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596941 = validateParameter(valid_596941, JString, required = false,
                                 default = nil)
  if valid_596941 != nil:
    section.add "X-Amz-Content-Sha256", valid_596941
  var valid_596942 = header.getOrDefault("X-Amz-Algorithm")
  valid_596942 = validateParameter(valid_596942, JString, required = false,
                                 default = nil)
  if valid_596942 != nil:
    section.add "X-Amz-Algorithm", valid_596942
  var valid_596943 = header.getOrDefault("X-Amz-Signature")
  valid_596943 = validateParameter(valid_596943, JString, required = false,
                                 default = nil)
  if valid_596943 != nil:
    section.add "X-Amz-Signature", valid_596943
  var valid_596944 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596944 = validateParameter(valid_596944, JString, required = false,
                                 default = nil)
  if valid_596944 != nil:
    section.add "X-Amz-SignedHeaders", valid_596944
  var valid_596945 = header.getOrDefault("X-Amz-Credential")
  valid_596945 = validateParameter(valid_596945, JString, required = false,
                                 default = nil)
  if valid_596945 != nil:
    section.add "X-Amz-Credential", valid_596945
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596946: Call_GetResetClusterParameterGroup_596931; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_596946.validator(path, query, header, formData, body)
  let scheme = call_596946.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596946.url(scheme.get, call_596946.host, call_596946.base,
                         call_596946.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596946, url, valid)

proc call*(call_596947: Call_GetResetClusterParameterGroup_596931;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          Action: string = "ResetClusterParameterGroup";
          ResetAllParameters: bool = false; Version: string = "2012-12-01"): Recallable =
  ## getResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: string (required)
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: string (required)
  var query_596948 = newJObject()
  add(query_596948, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    query_596948.add "Parameters", Parameters
  add(query_596948, "Action", newJString(Action))
  add(query_596948, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_596948, "Version", newJString(Version))
  result = call_596947.call(nil, query_596948, nil, nil, nil)

var getResetClusterParameterGroup* = Call_GetResetClusterParameterGroup_596931(
    name: "getResetClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_GetResetClusterParameterGroup_596932, base: "/",
    url: url_GetResetClusterParameterGroup_596933,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResizeCluster_596988 = ref object of OpenApiRestCall_593421
proc url_PostResizeCluster_596990(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostResizeCluster_596989(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596991 = query.getOrDefault("Action")
  valid_596991 = validateParameter(valid_596991, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_596991 != nil:
    section.add "Action", valid_596991
  var valid_596992 = query.getOrDefault("Version")
  valid_596992 = validateParameter(valid_596992, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596992 != nil:
    section.add "Version", valid_596992
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596993 = header.getOrDefault("X-Amz-Date")
  valid_596993 = validateParameter(valid_596993, JString, required = false,
                                 default = nil)
  if valid_596993 != nil:
    section.add "X-Amz-Date", valid_596993
  var valid_596994 = header.getOrDefault("X-Amz-Security-Token")
  valid_596994 = validateParameter(valid_596994, JString, required = false,
                                 default = nil)
  if valid_596994 != nil:
    section.add "X-Amz-Security-Token", valid_596994
  var valid_596995 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596995 = validateParameter(valid_596995, JString, required = false,
                                 default = nil)
  if valid_596995 != nil:
    section.add "X-Amz-Content-Sha256", valid_596995
  var valid_596996 = header.getOrDefault("X-Amz-Algorithm")
  valid_596996 = validateParameter(valid_596996, JString, required = false,
                                 default = nil)
  if valid_596996 != nil:
    section.add "X-Amz-Algorithm", valid_596996
  var valid_596997 = header.getOrDefault("X-Amz-Signature")
  valid_596997 = validateParameter(valid_596997, JString, required = false,
                                 default = nil)
  if valid_596997 != nil:
    section.add "X-Amz-Signature", valid_596997
  var valid_596998 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596998 = validateParameter(valid_596998, JString, required = false,
                                 default = nil)
  if valid_596998 != nil:
    section.add "X-Amz-SignedHeaders", valid_596998
  var valid_596999 = header.getOrDefault("X-Amz-Credential")
  valid_596999 = validateParameter(valid_596999, JString, required = false,
                                 default = nil)
  if valid_596999 != nil:
    section.add "X-Amz-Credential", valid_596999
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  section = newJObject()
  var valid_597000 = formData.getOrDefault("ClusterType")
  valid_597000 = validateParameter(valid_597000, JString, required = false,
                                 default = nil)
  if valid_597000 != nil:
    section.add "ClusterType", valid_597000
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_597001 = formData.getOrDefault("ClusterIdentifier")
  valid_597001 = validateParameter(valid_597001, JString, required = true,
                                 default = nil)
  if valid_597001 != nil:
    section.add "ClusterIdentifier", valid_597001
  var valid_597002 = formData.getOrDefault("NumberOfNodes")
  valid_597002 = validateParameter(valid_597002, JInt, required = true, default = nil)
  if valid_597002 != nil:
    section.add "NumberOfNodes", valid_597002
  var valid_597003 = formData.getOrDefault("Classic")
  valid_597003 = validateParameter(valid_597003, JBool, required = false, default = nil)
  if valid_597003 != nil:
    section.add "Classic", valid_597003
  var valid_597004 = formData.getOrDefault("NodeType")
  valid_597004 = validateParameter(valid_597004, JString, required = false,
                                 default = nil)
  if valid_597004 != nil:
    section.add "NodeType", valid_597004
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597005: Call_PostResizeCluster_596988; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_597005.validator(path, query, header, formData, body)
  let scheme = call_597005.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597005.url(scheme.get, call_597005.host, call_597005.base,
                         call_597005.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597005, url, valid)

proc call*(call_597006: Call_PostResizeCluster_596988; ClusterIdentifier: string;
          NumberOfNodes: int; ClusterType: string = "";
          Action: string = "ResizeCluster"; Classic: bool = false;
          Version: string = "2012-12-01"; NodeType: string = ""): Recallable =
  ## postResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Version: string (required)
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  var query_597007 = newJObject()
  var formData_597008 = newJObject()
  add(formData_597008, "ClusterType", newJString(ClusterType))
  add(query_597007, "Action", newJString(Action))
  add(formData_597008, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_597008, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_597008, "Classic", newJBool(Classic))
  add(query_597007, "Version", newJString(Version))
  add(formData_597008, "NodeType", newJString(NodeType))
  result = call_597006.call(nil, query_597007, nil, formData_597008, nil)

var postResizeCluster* = Call_PostResizeCluster_596988(name: "postResizeCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_PostResizeCluster_596989,
    base: "/", url: url_PostResizeCluster_596990,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResizeCluster_596968 = ref object of OpenApiRestCall_593421
proc url_GetResizeCluster_596970(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetResizeCluster_596969(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596971 = query.getOrDefault("Action")
  valid_596971 = validateParameter(valid_596971, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_596971 != nil:
    section.add "Action", valid_596971
  var valid_596972 = query.getOrDefault("ClusterIdentifier")
  valid_596972 = validateParameter(valid_596972, JString, required = true,
                                 default = nil)
  if valid_596972 != nil:
    section.add "ClusterIdentifier", valid_596972
  var valid_596973 = query.getOrDefault("Classic")
  valid_596973 = validateParameter(valid_596973, JBool, required = false, default = nil)
  if valid_596973 != nil:
    section.add "Classic", valid_596973
  var valid_596974 = query.getOrDefault("NumberOfNodes")
  valid_596974 = validateParameter(valid_596974, JInt, required = true, default = nil)
  if valid_596974 != nil:
    section.add "NumberOfNodes", valid_596974
  var valid_596975 = query.getOrDefault("NodeType")
  valid_596975 = validateParameter(valid_596975, JString, required = false,
                                 default = nil)
  if valid_596975 != nil:
    section.add "NodeType", valid_596975
  var valid_596976 = query.getOrDefault("Version")
  valid_596976 = validateParameter(valid_596976, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596976 != nil:
    section.add "Version", valid_596976
  var valid_596977 = query.getOrDefault("ClusterType")
  valid_596977 = validateParameter(valid_596977, JString, required = false,
                                 default = nil)
  if valid_596977 != nil:
    section.add "ClusterType", valid_596977
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_596978 = header.getOrDefault("X-Amz-Date")
  valid_596978 = validateParameter(valid_596978, JString, required = false,
                                 default = nil)
  if valid_596978 != nil:
    section.add "X-Amz-Date", valid_596978
  var valid_596979 = header.getOrDefault("X-Amz-Security-Token")
  valid_596979 = validateParameter(valid_596979, JString, required = false,
                                 default = nil)
  if valid_596979 != nil:
    section.add "X-Amz-Security-Token", valid_596979
  var valid_596980 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596980 = validateParameter(valid_596980, JString, required = false,
                                 default = nil)
  if valid_596980 != nil:
    section.add "X-Amz-Content-Sha256", valid_596980
  var valid_596981 = header.getOrDefault("X-Amz-Algorithm")
  valid_596981 = validateParameter(valid_596981, JString, required = false,
                                 default = nil)
  if valid_596981 != nil:
    section.add "X-Amz-Algorithm", valid_596981
  var valid_596982 = header.getOrDefault("X-Amz-Signature")
  valid_596982 = validateParameter(valid_596982, JString, required = false,
                                 default = nil)
  if valid_596982 != nil:
    section.add "X-Amz-Signature", valid_596982
  var valid_596983 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596983 = validateParameter(valid_596983, JString, required = false,
                                 default = nil)
  if valid_596983 != nil:
    section.add "X-Amz-SignedHeaders", valid_596983
  var valid_596984 = header.getOrDefault("X-Amz-Credential")
  valid_596984 = validateParameter(valid_596984, JString, required = false,
                                 default = nil)
  if valid_596984 != nil:
    section.add "X-Amz-Credential", valid_596984
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596985: Call_GetResizeCluster_596968; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_596985.validator(path, query, header, formData, body)
  let scheme = call_596985.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596985.url(scheme.get, call_596985.host, call_596985.base,
                         call_596985.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596985, url, valid)

proc call*(call_596986: Call_GetResizeCluster_596968; ClusterIdentifier: string;
          NumberOfNodes: int; Action: string = "ResizeCluster"; Classic: bool = false;
          NodeType: string = ""; Version: string = "2012-12-01";
          ClusterType: string = ""): Recallable =
  ## getResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  var query_596987 = newJObject()
  add(query_596987, "Action", newJString(Action))
  add(query_596987, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596987, "Classic", newJBool(Classic))
  add(query_596987, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_596987, "NodeType", newJString(NodeType))
  add(query_596987, "Version", newJString(Version))
  add(query_596987, "ClusterType", newJString(ClusterType))
  result = call_596986.call(nil, query_596987, nil, nil, nil)

var getResizeCluster* = Call_GetResizeCluster_596968(name: "getResizeCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_GetResizeCluster_596969,
    base: "/", url: url_GetResizeCluster_596970,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreFromClusterSnapshot_597050 = ref object of OpenApiRestCall_593421
proc url_PostRestoreFromClusterSnapshot_597052(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRestoreFromClusterSnapshot_597051(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_597053 = query.getOrDefault("Action")
  valid_597053 = validateParameter(valid_597053, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_597053 != nil:
    section.add "Action", valid_597053
  var valid_597054 = query.getOrDefault("Version")
  valid_597054 = validateParameter(valid_597054, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_597054 != nil:
    section.add "Version", valid_597054
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_597055 = header.getOrDefault("X-Amz-Date")
  valid_597055 = validateParameter(valid_597055, JString, required = false,
                                 default = nil)
  if valid_597055 != nil:
    section.add "X-Amz-Date", valid_597055
  var valid_597056 = header.getOrDefault("X-Amz-Security-Token")
  valid_597056 = validateParameter(valid_597056, JString, required = false,
                                 default = nil)
  if valid_597056 != nil:
    section.add "X-Amz-Security-Token", valid_597056
  var valid_597057 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_597057 = validateParameter(valid_597057, JString, required = false,
                                 default = nil)
  if valid_597057 != nil:
    section.add "X-Amz-Content-Sha256", valid_597057
  var valid_597058 = header.getOrDefault("X-Amz-Algorithm")
  valid_597058 = validateParameter(valid_597058, JString, required = false,
                                 default = nil)
  if valid_597058 != nil:
    section.add "X-Amz-Algorithm", valid_597058
  var valid_597059 = header.getOrDefault("X-Amz-Signature")
  valid_597059 = validateParameter(valid_597059, JString, required = false,
                                 default = nil)
  if valid_597059 != nil:
    section.add "X-Amz-Signature", valid_597059
  var valid_597060 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_597060 = validateParameter(valid_597060, JString, required = false,
                                 default = nil)
  if valid_597060 != nil:
    section.add "X-Amz-SignedHeaders", valid_597060
  var valid_597061 = header.getOrDefault("X-Amz-Credential")
  valid_597061 = validateParameter(valid_597061, JString, required = false,
                                 default = nil)
  if valid_597061 != nil:
    section.add "X-Amz-Credential", valid_597061
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  section = newJObject()
  var valid_597062 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_597062 = validateParameter(valid_597062, JString, required = false,
                                 default = nil)
  if valid_597062 != nil:
    section.add "PreferredMaintenanceWindow", valid_597062
  var valid_597063 = formData.getOrDefault("EnhancedVpcRouting")
  valid_597063 = validateParameter(valid_597063, JBool, required = false, default = nil)
  if valid_597063 != nil:
    section.add "EnhancedVpcRouting", valid_597063
  var valid_597064 = formData.getOrDefault("Port")
  valid_597064 = validateParameter(valid_597064, JInt, required = false, default = nil)
  if valid_597064 != nil:
    section.add "Port", valid_597064
  var valid_597065 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_597065 = validateParameter(valid_597065, JArray, required = false,
                                 default = nil)
  if valid_597065 != nil:
    section.add "VpcSecurityGroupIds", valid_597065
  var valid_597066 = formData.getOrDefault("AdditionalInfo")
  valid_597066 = validateParameter(valid_597066, JString, required = false,
                                 default = nil)
  if valid_597066 != nil:
    section.add "AdditionalInfo", valid_597066
  var valid_597067 = formData.getOrDefault("AvailabilityZone")
  valid_597067 = validateParameter(valid_597067, JString, required = false,
                                 default = nil)
  if valid_597067 != nil:
    section.add "AvailabilityZone", valid_597067
  var valid_597068 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_597068 = validateParameter(valid_597068, JString, required = false,
                                 default = nil)
  if valid_597068 != nil:
    section.add "SnapshotClusterIdentifier", valid_597068
  var valid_597069 = formData.getOrDefault("ClusterSecurityGroups")
  valid_597069 = validateParameter(valid_597069, JArray, required = false,
                                 default = nil)
  if valid_597069 != nil:
    section.add "ClusterSecurityGroups", valid_597069
  var valid_597070 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_597070 = validateParameter(valid_597070, JString, required = false,
                                 default = nil)
  if valid_597070 != nil:
    section.add "HsmConfigurationIdentifier", valid_597070
  var valid_597071 = formData.getOrDefault("OwnerAccount")
  valid_597071 = validateParameter(valid_597071, JString, required = false,
                                 default = nil)
  if valid_597071 != nil:
    section.add "OwnerAccount", valid_597071
  var valid_597072 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_597072 = validateParameter(valid_597072, JString, required = false,
                                 default = nil)
  if valid_597072 != nil:
    section.add "HsmClientCertificateIdentifier", valid_597072
  var valid_597073 = formData.getOrDefault("PubliclyAccessible")
  valid_597073 = validateParameter(valid_597073, JBool, required = false, default = nil)
  if valid_597073 != nil:
    section.add "PubliclyAccessible", valid_597073
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_597074 = formData.getOrDefault("ClusterIdentifier")
  valid_597074 = validateParameter(valid_597074, JString, required = true,
                                 default = nil)
  if valid_597074 != nil:
    section.add "ClusterIdentifier", valid_597074
  var valid_597075 = formData.getOrDefault("IamRoles")
  valid_597075 = validateParameter(valid_597075, JArray, required = false,
                                 default = nil)
  if valid_597075 != nil:
    section.add "IamRoles", valid_597075
  var valid_597076 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_597076 = validateParameter(valid_597076, JString, required = false,
                                 default = nil)
  if valid_597076 != nil:
    section.add "SnapshotScheduleIdentifier", valid_597076
  var valid_597077 = formData.getOrDefault("NumberOfNodes")
  valid_597077 = validateParameter(valid_597077, JInt, required = false, default = nil)
  if valid_597077 != nil:
    section.add "NumberOfNodes", valid_597077
  var valid_597078 = formData.getOrDefault("ClusterParameterGroupName")
  valid_597078 = validateParameter(valid_597078, JString, required = false,
                                 default = nil)
  if valid_597078 != nil:
    section.add "ClusterParameterGroupName", valid_597078
  var valid_597079 = formData.getOrDefault("KmsKeyId")
  valid_597079 = validateParameter(valid_597079, JString, required = false,
                                 default = nil)
  if valid_597079 != nil:
    section.add "KmsKeyId", valid_597079
  var valid_597080 = formData.getOrDefault("SnapshotIdentifier")
  valid_597080 = validateParameter(valid_597080, JString, required = true,
                                 default = nil)
  if valid_597080 != nil:
    section.add "SnapshotIdentifier", valid_597080
  var valid_597081 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_597081 = validateParameter(valid_597081, JInt, required = false, default = nil)
  if valid_597081 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_597081
  var valid_597082 = formData.getOrDefault("ElasticIp")
  valid_597082 = validateParameter(valid_597082, JString, required = false,
                                 default = nil)
  if valid_597082 != nil:
    section.add "ElasticIp", valid_597082
  var valid_597083 = formData.getOrDefault("AllowVersionUpgrade")
  valid_597083 = validateParameter(valid_597083, JBool, required = false, default = nil)
  if valid_597083 != nil:
    section.add "AllowVersionUpgrade", valid_597083
  var valid_597084 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_597084 = validateParameter(valid_597084, JInt, required = false, default = nil)
  if valid_597084 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_597084
  var valid_597085 = formData.getOrDefault("NodeType")
  valid_597085 = validateParameter(valid_597085, JString, required = false,
                                 default = nil)
  if valid_597085 != nil:
    section.add "NodeType", valid_597085
  var valid_597086 = formData.getOrDefault("MaintenanceTrackName")
  valid_597086 = validateParameter(valid_597086, JString, required = false,
                                 default = nil)
  if valid_597086 != nil:
    section.add "MaintenanceTrackName", valid_597086
  var valid_597087 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_597087 = validateParameter(valid_597087, JString, required = false,
                                 default = nil)
  if valid_597087 != nil:
    section.add "ClusterSubnetGroupName", valid_597087
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597088: Call_PostRestoreFromClusterSnapshot_597050; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_597088.validator(path, query, header, formData, body)
  let scheme = call_597088.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597088.url(scheme.get, call_597088.host, call_597088.base,
                         call_597088.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597088, url, valid)

proc call*(call_597089: Call_PostRestoreFromClusterSnapshot_597050;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          PreferredMaintenanceWindow: string = ""; EnhancedVpcRouting: bool = false;
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil;
          AdditionalInfo: string = ""; AvailabilityZone: string = "";
          SnapshotClusterIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil;
          HsmConfigurationIdentifier: string = "";
          Action: string = "RestoreFromClusterSnapshot"; OwnerAccount: string = "";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; IamRoles: JsonNode = nil;
          SnapshotScheduleIdentifier: string = ""; NumberOfNodes: int = 0;
          ClusterParameterGroupName: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          NodeType: string = ""; MaintenanceTrackName: string = "";
          ClusterSubnetGroupName: string = ""): Recallable =
  ## postRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  var query_597090 = newJObject()
  var formData_597091 = newJObject()
  add(formData_597091, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_597091, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_597091, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    formData_597091.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_597091, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_597091, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_597091, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  if ClusterSecurityGroups != nil:
    formData_597091.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_597091, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_597090, "Action", newJString(Action))
  add(formData_597091, "OwnerAccount", newJString(OwnerAccount))
  add(formData_597091, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_597091, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_597091, "ClusterIdentifier", newJString(ClusterIdentifier))
  if IamRoles != nil:
    formData_597091.add "IamRoles", IamRoles
  add(formData_597091, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(formData_597091, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_597091, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_597091, "KmsKeyId", newJString(KmsKeyId))
  add(formData_597091, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_597091, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_597091, "ElasticIp", newJString(ElasticIp))
  add(formData_597091, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_597091, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_597090, "Version", newJString(Version))
  add(formData_597091, "NodeType", newJString(NodeType))
  add(formData_597091, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_597091, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_597089.call(nil, query_597090, nil, formData_597091, nil)

var postRestoreFromClusterSnapshot* = Call_PostRestoreFromClusterSnapshot_597050(
    name: "postRestoreFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_PostRestoreFromClusterSnapshot_597051, base: "/",
    url: url_PostRestoreFromClusterSnapshot_597052,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreFromClusterSnapshot_597009 = ref object of OpenApiRestCall_593421
proc url_GetRestoreFromClusterSnapshot_597011(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRestoreFromClusterSnapshot_597010(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_597012 = query.getOrDefault("ClusterSecurityGroups")
  valid_597012 = validateParameter(valid_597012, JArray, required = false,
                                 default = nil)
  if valid_597012 != nil:
    section.add "ClusterSecurityGroups", valid_597012
  var valid_597013 = query.getOrDefault("ClusterSubnetGroupName")
  valid_597013 = validateParameter(valid_597013, JString, required = false,
                                 default = nil)
  if valid_597013 != nil:
    section.add "ClusterSubnetGroupName", valid_597013
  var valid_597014 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_597014 = validateParameter(valid_597014, JString, required = false,
                                 default = nil)
  if valid_597014 != nil:
    section.add "HsmClientCertificateIdentifier", valid_597014
  var valid_597015 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_597015 = validateParameter(valid_597015, JString, required = false,
                                 default = nil)
  if valid_597015 != nil:
    section.add "PreferredMaintenanceWindow", valid_597015
  var valid_597016 = query.getOrDefault("MaintenanceTrackName")
  valid_597016 = validateParameter(valid_597016, JString, required = false,
                                 default = nil)
  if valid_597016 != nil:
    section.add "MaintenanceTrackName", valid_597016
  var valid_597017 = query.getOrDefault("IamRoles")
  valid_597017 = validateParameter(valid_597017, JArray, required = false,
                                 default = nil)
  if valid_597017 != nil:
    section.add "IamRoles", valid_597017
  var valid_597018 = query.getOrDefault("AvailabilityZone")
  valid_597018 = validateParameter(valid_597018, JString, required = false,
                                 default = nil)
  if valid_597018 != nil:
    section.add "AvailabilityZone", valid_597018
  var valid_597019 = query.getOrDefault("AllowVersionUpgrade")
  valid_597019 = validateParameter(valid_597019, JBool, required = false, default = nil)
  if valid_597019 != nil:
    section.add "AllowVersionUpgrade", valid_597019
  var valid_597020 = query.getOrDefault("EnhancedVpcRouting")
  valid_597020 = validateParameter(valid_597020, JBool, required = false, default = nil)
  if valid_597020 != nil:
    section.add "EnhancedVpcRouting", valid_597020
  var valid_597021 = query.getOrDefault("VpcSecurityGroupIds")
  valid_597021 = validateParameter(valid_597021, JArray, required = false,
                                 default = nil)
  if valid_597021 != nil:
    section.add "VpcSecurityGroupIds", valid_597021
  var valid_597022 = query.getOrDefault("ClusterParameterGroupName")
  valid_597022 = validateParameter(valid_597022, JString, required = false,
                                 default = nil)
  if valid_597022 != nil:
    section.add "ClusterParameterGroupName", valid_597022
  var valid_597023 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_597023 = validateParameter(valid_597023, JString, required = false,
                                 default = nil)
  if valid_597023 != nil:
    section.add "HsmConfigurationIdentifier", valid_597023
  var valid_597024 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_597024 = validateParameter(valid_597024, JString, required = false,
                                 default = nil)
  if valid_597024 != nil:
    section.add "SnapshotScheduleIdentifier", valid_597024
  var valid_597025 = query.getOrDefault("AdditionalInfo")
  valid_597025 = validateParameter(valid_597025, JString, required = false,
                                 default = nil)
  if valid_597025 != nil:
    section.add "AdditionalInfo", valid_597025
  var valid_597026 = query.getOrDefault("ElasticIp")
  valid_597026 = validateParameter(valid_597026, JString, required = false,
                                 default = nil)
  if valid_597026 != nil:
    section.add "ElasticIp", valid_597026
  assert query != nil,
        "query argument is necessary due to required `ClusterIdentifier` field"
  var valid_597027 = query.getOrDefault("ClusterIdentifier")
  valid_597027 = validateParameter(valid_597027, JString, required = true,
                                 default = nil)
  if valid_597027 != nil:
    section.add "ClusterIdentifier", valid_597027
  var valid_597028 = query.getOrDefault("OwnerAccount")
  valid_597028 = validateParameter(valid_597028, JString, required = false,
                                 default = nil)
  if valid_597028 != nil:
    section.add "OwnerAccount", valid_597028
  var valid_597029 = query.getOrDefault("Action")
  valid_597029 = validateParameter(valid_597029, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_597029 != nil:
    section.add "Action", valid_597029
  var valid_597030 = query.getOrDefault("KmsKeyId")
  valid_597030 = validateParameter(valid_597030, JString, required = false,
                                 default = nil)
  if valid_597030 != nil:
    section.add "KmsKeyId", valid_597030
  var valid_597031 = query.getOrDefault("PubliclyAccessible")
  valid_597031 = validateParameter(valid_597031, JBool, required = false, default = nil)
  if valid_597031 != nil:
    section.add "PubliclyAccessible", valid_597031
  var valid_597032 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_597032 = validateParameter(valid_597032, JString, required = false,
                                 default = nil)
  if valid_597032 != nil:
    section.add "SnapshotClusterIdentifier", valid_597032
  var valid_597033 = query.getOrDefault("Port")
  valid_597033 = validateParameter(valid_597033, JInt, required = false, default = nil)
  if valid_597033 != nil:
    section.add "Port", valid_597033
  var valid_597034 = query.getOrDefault("NumberOfNodes")
  valid_597034 = validateParameter(valid_597034, JInt, required = false, default = nil)
  if valid_597034 != nil:
    section.add "NumberOfNodes", valid_597034
  var valid_597035 = query.getOrDefault("SnapshotIdentifier")
  valid_597035 = validateParameter(valid_597035, JString, required = true,
                                 default = nil)
  if valid_597035 != nil:
    section.add "SnapshotIdentifier", valid_597035
  var valid_597036 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_597036 = validateParameter(valid_597036, JInt, required = false, default = nil)
  if valid_597036 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_597036
  var valid_597037 = query.getOrDefault("NodeType")
  valid_597037 = validateParameter(valid_597037, JString, required = false,
                                 default = nil)
  if valid_597037 != nil:
    section.add "NodeType", valid_597037
  var valid_597038 = query.getOrDefault("Version")
  valid_597038 = validateParameter(valid_597038, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_597038 != nil:
    section.add "Version", valid_597038
  var valid_597039 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_597039 = validateParameter(valid_597039, JInt, required = false, default = nil)
  if valid_597039 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_597039
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_597040 = header.getOrDefault("X-Amz-Date")
  valid_597040 = validateParameter(valid_597040, JString, required = false,
                                 default = nil)
  if valid_597040 != nil:
    section.add "X-Amz-Date", valid_597040
  var valid_597041 = header.getOrDefault("X-Amz-Security-Token")
  valid_597041 = validateParameter(valid_597041, JString, required = false,
                                 default = nil)
  if valid_597041 != nil:
    section.add "X-Amz-Security-Token", valid_597041
  var valid_597042 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_597042 = validateParameter(valid_597042, JString, required = false,
                                 default = nil)
  if valid_597042 != nil:
    section.add "X-Amz-Content-Sha256", valid_597042
  var valid_597043 = header.getOrDefault("X-Amz-Algorithm")
  valid_597043 = validateParameter(valid_597043, JString, required = false,
                                 default = nil)
  if valid_597043 != nil:
    section.add "X-Amz-Algorithm", valid_597043
  var valid_597044 = header.getOrDefault("X-Amz-Signature")
  valid_597044 = validateParameter(valid_597044, JString, required = false,
                                 default = nil)
  if valid_597044 != nil:
    section.add "X-Amz-Signature", valid_597044
  var valid_597045 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_597045 = validateParameter(valid_597045, JString, required = false,
                                 default = nil)
  if valid_597045 != nil:
    section.add "X-Amz-SignedHeaders", valid_597045
  var valid_597046 = header.getOrDefault("X-Amz-Credential")
  valid_597046 = validateParameter(valid_597046, JString, required = false,
                                 default = nil)
  if valid_597046 != nil:
    section.add "X-Amz-Credential", valid_597046
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597047: Call_GetRestoreFromClusterSnapshot_597009; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_597047.validator(path, query, header, formData, body)
  let scheme = call_597047.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597047.url(scheme.get, call_597047.host, call_597047.base,
                         call_597047.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597047, url, valid)

proc call*(call_597048: Call_GetRestoreFromClusterSnapshot_597009;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          ClusterSecurityGroups: JsonNode = nil;
          ClusterSubnetGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = "";
          MaintenanceTrackName: string = ""; IamRoles: JsonNode = nil;
          AvailabilityZone: string = ""; AllowVersionUpgrade: bool = false;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = "";
          SnapshotScheduleIdentifier: string = ""; AdditionalInfo: string = "";
          ElasticIp: string = ""; OwnerAccount: string = "";
          Action: string = "RestoreFromClusterSnapshot"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; SnapshotClusterIdentifier: string = "";
          Port: int = 0; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; NodeType: string = "";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_597049 = newJObject()
  if ClusterSecurityGroups != nil:
    query_597049.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_597049, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_597049, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_597049, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_597049, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if IamRoles != nil:
    query_597049.add "IamRoles", IamRoles
  add(query_597049, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_597049, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_597049, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_597049.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_597049, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_597049, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_597049, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_597049, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_597049, "ElasticIp", newJString(ElasticIp))
  add(query_597049, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_597049, "OwnerAccount", newJString(OwnerAccount))
  add(query_597049, "Action", newJString(Action))
  add(query_597049, "KmsKeyId", newJString(KmsKeyId))
  add(query_597049, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_597049, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_597049, "Port", newJInt(Port))
  add(query_597049, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_597049, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_597049, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_597049, "NodeType", newJString(NodeType))
  add(query_597049, "Version", newJString(Version))
  add(query_597049, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_597048.call(nil, query_597049, nil, nil, nil)

var getRestoreFromClusterSnapshot* = Call_GetRestoreFromClusterSnapshot_597009(
    name: "getRestoreFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_GetRestoreFromClusterSnapshot_597010, base: "/",
    url: url_GetRestoreFromClusterSnapshot_597011,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreTableFromClusterSnapshot_597115 = ref object of OpenApiRestCall_593421
proc url_PostRestoreTableFromClusterSnapshot_597117(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRestoreTableFromClusterSnapshot_597116(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_597118 = query.getOrDefault("Action")
  valid_597118 = validateParameter(valid_597118, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_597118 != nil:
    section.add "Action", valid_597118
  var valid_597119 = query.getOrDefault("Version")
  valid_597119 = validateParameter(valid_597119, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_597119 != nil:
    section.add "Version", valid_597119
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_597120 = header.getOrDefault("X-Amz-Date")
  valid_597120 = validateParameter(valid_597120, JString, required = false,
                                 default = nil)
  if valid_597120 != nil:
    section.add "X-Amz-Date", valid_597120
  var valid_597121 = header.getOrDefault("X-Amz-Security-Token")
  valid_597121 = validateParameter(valid_597121, JString, required = false,
                                 default = nil)
  if valid_597121 != nil:
    section.add "X-Amz-Security-Token", valid_597121
  var valid_597122 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_597122 = validateParameter(valid_597122, JString, required = false,
                                 default = nil)
  if valid_597122 != nil:
    section.add "X-Amz-Content-Sha256", valid_597122
  var valid_597123 = header.getOrDefault("X-Amz-Algorithm")
  valid_597123 = validateParameter(valid_597123, JString, required = false,
                                 default = nil)
  if valid_597123 != nil:
    section.add "X-Amz-Algorithm", valid_597123
  var valid_597124 = header.getOrDefault("X-Amz-Signature")
  valid_597124 = validateParameter(valid_597124, JString, required = false,
                                 default = nil)
  if valid_597124 != nil:
    section.add "X-Amz-Signature", valid_597124
  var valid_597125 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_597125 = validateParameter(valid_597125, JString, required = false,
                                 default = nil)
  if valid_597125 != nil:
    section.add "X-Amz-SignedHeaders", valid_597125
  var valid_597126 = header.getOrDefault("X-Amz-Credential")
  valid_597126 = validateParameter(valid_597126, JString, required = false,
                                 default = nil)
  if valid_597126 != nil:
    section.add "X-Amz-Credential", valid_597126
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  section = newJObject()
  var valid_597127 = formData.getOrDefault("SourceSchemaName")
  valid_597127 = validateParameter(valid_597127, JString, required = false,
                                 default = nil)
  if valid_597127 != nil:
    section.add "SourceSchemaName", valid_597127
  assert formData != nil, "formData argument is necessary due to required `SourceDatabaseName` field"
  var valid_597128 = formData.getOrDefault("SourceDatabaseName")
  valid_597128 = validateParameter(valid_597128, JString, required = true,
                                 default = nil)
  if valid_597128 != nil:
    section.add "SourceDatabaseName", valid_597128
  var valid_597129 = formData.getOrDefault("SourceTableName")
  valid_597129 = validateParameter(valid_597129, JString, required = true,
                                 default = nil)
  if valid_597129 != nil:
    section.add "SourceTableName", valid_597129
  var valid_597130 = formData.getOrDefault("ClusterIdentifier")
  valid_597130 = validateParameter(valid_597130, JString, required = true,
                                 default = nil)
  if valid_597130 != nil:
    section.add "ClusterIdentifier", valid_597130
  var valid_597131 = formData.getOrDefault("TargetDatabaseName")
  valid_597131 = validateParameter(valid_597131, JString, required = false,
                                 default = nil)
  if valid_597131 != nil:
    section.add "TargetDatabaseName", valid_597131
  var valid_597132 = formData.getOrDefault("SnapshotIdentifier")
  valid_597132 = validateParameter(valid_597132, JString, required = true,
                                 default = nil)
  if valid_597132 != nil:
    section.add "SnapshotIdentifier", valid_597132
  var valid_597133 = formData.getOrDefault("TargetSchemaName")
  valid_597133 = validateParameter(valid_597133, JString, required = false,
                                 default = nil)
  if valid_597133 != nil:
    section.add "TargetSchemaName", valid_597133
  var valid_597134 = formData.getOrDefault("NewTableName")
  valid_597134 = validateParameter(valid_597134, JString, required = true,
                                 default = nil)
  if valid_597134 != nil:
    section.add "NewTableName", valid_597134
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597135: Call_PostRestoreTableFromClusterSnapshot_597115;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_597135.validator(path, query, header, formData, body)
  let scheme = call_597135.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597135.url(scheme.get, call_597135.host, call_597135.base,
                         call_597135.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597135, url, valid)

proc call*(call_597136: Call_PostRestoreTableFromClusterSnapshot_597115;
          SourceDatabaseName: string; SourceTableName: string;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          NewTableName: string; SourceSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          TargetDatabaseName: string = ""; TargetSchemaName: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   Version: string (required)
  var query_597137 = newJObject()
  var formData_597138 = newJObject()
  add(formData_597138, "SourceSchemaName", newJString(SourceSchemaName))
  add(formData_597138, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(formData_597138, "SourceTableName", newJString(SourceTableName))
  add(query_597137, "Action", newJString(Action))
  add(formData_597138, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_597138, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(formData_597138, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_597138, "TargetSchemaName", newJString(TargetSchemaName))
  add(formData_597138, "NewTableName", newJString(NewTableName))
  add(query_597137, "Version", newJString(Version))
  result = call_597136.call(nil, query_597137, nil, formData_597138, nil)

var postRestoreTableFromClusterSnapshot* = Call_PostRestoreTableFromClusterSnapshot_597115(
    name: "postRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_PostRestoreTableFromClusterSnapshot_597116, base: "/",
    url: url_PostRestoreTableFromClusterSnapshot_597117,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreTableFromClusterSnapshot_597092 = ref object of OpenApiRestCall_593421
proc url_GetRestoreTableFromClusterSnapshot_597094(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRestoreTableFromClusterSnapshot_597093(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   Action: JString (required)
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   Version: JString (required)
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SourceDatabaseName` field"
  var valid_597095 = query.getOrDefault("SourceDatabaseName")
  valid_597095 = validateParameter(valid_597095, JString, required = true,
                                 default = nil)
  if valid_597095 != nil:
    section.add "SourceDatabaseName", valid_597095
  var valid_597096 = query.getOrDefault("SourceTableName")
  valid_597096 = validateParameter(valid_597096, JString, required = true,
                                 default = nil)
  if valid_597096 != nil:
    section.add "SourceTableName", valid_597096
  var valid_597097 = query.getOrDefault("SourceSchemaName")
  valid_597097 = validateParameter(valid_597097, JString, required = false,
                                 default = nil)
  if valid_597097 != nil:
    section.add "SourceSchemaName", valid_597097
  var valid_597098 = query.getOrDefault("ClusterIdentifier")
  valid_597098 = validateParameter(valid_597098, JString, required = true,
                                 default = nil)
  if valid_597098 != nil:
    section.add "ClusterIdentifier", valid_597098
  var valid_597099 = query.getOrDefault("Action")
  valid_597099 = validateParameter(valid_597099, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_597099 != nil:
    section.add "Action", valid_597099
  var valid_597100 = query.getOrDefault("TargetDatabaseName")
  valid_597100 = validateParameter(valid_597100, JString, required = false,
                                 default = nil)
  if valid_597100 != nil:
    section.add "TargetDatabaseName", valid_597100
  var valid_597101 = query.getOrDefault("NewTableName")
  valid_597101 = validateParameter(valid_597101, JString, required = true,
                                 default = nil)
  if valid_597101 != nil:
    section.add "NewTableName", valid_597101
  var valid_597102 = query.getOrDefault("SnapshotIdentifier")
  valid_597102 = validateParameter(valid_597102, JString, required = true,
                                 default = nil)
  if valid_597102 != nil:
    section.add "SnapshotIdentifier", valid_597102
  var valid_597103 = query.getOrDefault("Version")
  valid_597103 = validateParameter(valid_597103, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_597103 != nil:
    section.add "Version", valid_597103
  var valid_597104 = query.getOrDefault("TargetSchemaName")
  valid_597104 = validateParameter(valid_597104, JString, required = false,
                                 default = nil)
  if valid_597104 != nil:
    section.add "TargetSchemaName", valid_597104
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_597105 = header.getOrDefault("X-Amz-Date")
  valid_597105 = validateParameter(valid_597105, JString, required = false,
                                 default = nil)
  if valid_597105 != nil:
    section.add "X-Amz-Date", valid_597105
  var valid_597106 = header.getOrDefault("X-Amz-Security-Token")
  valid_597106 = validateParameter(valid_597106, JString, required = false,
                                 default = nil)
  if valid_597106 != nil:
    section.add "X-Amz-Security-Token", valid_597106
  var valid_597107 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_597107 = validateParameter(valid_597107, JString, required = false,
                                 default = nil)
  if valid_597107 != nil:
    section.add "X-Amz-Content-Sha256", valid_597107
  var valid_597108 = header.getOrDefault("X-Amz-Algorithm")
  valid_597108 = validateParameter(valid_597108, JString, required = false,
                                 default = nil)
  if valid_597108 != nil:
    section.add "X-Amz-Algorithm", valid_597108
  var valid_597109 = header.getOrDefault("X-Amz-Signature")
  valid_597109 = validateParameter(valid_597109, JString, required = false,
                                 default = nil)
  if valid_597109 != nil:
    section.add "X-Amz-Signature", valid_597109
  var valid_597110 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_597110 = validateParameter(valid_597110, JString, required = false,
                                 default = nil)
  if valid_597110 != nil:
    section.add "X-Amz-SignedHeaders", valid_597110
  var valid_597111 = header.getOrDefault("X-Amz-Credential")
  valid_597111 = validateParameter(valid_597111, JString, required = false,
                                 default = nil)
  if valid_597111 != nil:
    section.add "X-Amz-Credential", valid_597111
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597112: Call_GetRestoreTableFromClusterSnapshot_597092;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_597112.validator(path, query, header, formData, body)
  let scheme = call_597112.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597112.url(scheme.get, call_597112.host, call_597112.base,
                         call_597112.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597112, url, valid)

proc call*(call_597113: Call_GetRestoreTableFromClusterSnapshot_597092;
          SourceDatabaseName: string; SourceTableName: string;
          ClusterIdentifier: string; NewTableName: string;
          SnapshotIdentifier: string; SourceSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          TargetDatabaseName: string = ""; Version: string = "2012-12-01";
          TargetSchemaName: string = ""): Recallable =
  ## getRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   Action: string (required)
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   Version: string (required)
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  var query_597114 = newJObject()
  add(query_597114, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_597114, "SourceTableName", newJString(SourceTableName))
  add(query_597114, "SourceSchemaName", newJString(SourceSchemaName))
  add(query_597114, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_597114, "Action", newJString(Action))
  add(query_597114, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(query_597114, "NewTableName", newJString(NewTableName))
  add(query_597114, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_597114, "Version", newJString(Version))
  add(query_597114, "TargetSchemaName", newJString(TargetSchemaName))
  result = call_597113.call(nil, query_597114, nil, nil, nil)

var getRestoreTableFromClusterSnapshot* = Call_GetRestoreTableFromClusterSnapshot_597092(
    name: "getRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_GetRestoreTableFromClusterSnapshot_597093, base: "/",
    url: url_GetRestoreTableFromClusterSnapshot_597094,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeClusterSecurityGroupIngress_597158 = ref object of OpenApiRestCall_593421
proc url_PostRevokeClusterSecurityGroupIngress_597160(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRevokeClusterSecurityGroupIngress_597159(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_597161 = query.getOrDefault("Action")
  valid_597161 = validateParameter(valid_597161, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_597161 != nil:
    section.add "Action", valid_597161
  var valid_597162 = query.getOrDefault("Version")
  valid_597162 = validateParameter(valid_597162, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_597162 != nil:
    section.add "Version", valid_597162
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_597163 = header.getOrDefault("X-Amz-Date")
  valid_597163 = validateParameter(valid_597163, JString, required = false,
                                 default = nil)
  if valid_597163 != nil:
    section.add "X-Amz-Date", valid_597163
  var valid_597164 = header.getOrDefault("X-Amz-Security-Token")
  valid_597164 = validateParameter(valid_597164, JString, required = false,
                                 default = nil)
  if valid_597164 != nil:
    section.add "X-Amz-Security-Token", valid_597164
  var valid_597165 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_597165 = validateParameter(valid_597165, JString, required = false,
                                 default = nil)
  if valid_597165 != nil:
    section.add "X-Amz-Content-Sha256", valid_597165
  var valid_597166 = header.getOrDefault("X-Amz-Algorithm")
  valid_597166 = validateParameter(valid_597166, JString, required = false,
                                 default = nil)
  if valid_597166 != nil:
    section.add "X-Amz-Algorithm", valid_597166
  var valid_597167 = header.getOrDefault("X-Amz-Signature")
  valid_597167 = validateParameter(valid_597167, JString, required = false,
                                 default = nil)
  if valid_597167 != nil:
    section.add "X-Amz-Signature", valid_597167
  var valid_597168 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_597168 = validateParameter(valid_597168, JString, required = false,
                                 default = nil)
  if valid_597168 != nil:
    section.add "X-Amz-SignedHeaders", valid_597168
  var valid_597169 = header.getOrDefault("X-Amz-Credential")
  valid_597169 = validateParameter(valid_597169, JString, required = false,
                                 default = nil)
  if valid_597169 != nil:
    section.add "X-Amz-Credential", valid_597169
  result.add "header", section
  ## parameters in `formData` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  section = newJObject()
  var valid_597170 = formData.getOrDefault("EC2SecurityGroupName")
  valid_597170 = validateParameter(valid_597170, JString, required = false,
                                 default = nil)
  if valid_597170 != nil:
    section.add "EC2SecurityGroupName", valid_597170
  var valid_597171 = formData.getOrDefault("CIDRIP")
  valid_597171 = validateParameter(valid_597171, JString, required = false,
                                 default = nil)
  if valid_597171 != nil:
    section.add "CIDRIP", valid_597171
  var valid_597172 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_597172 = validateParameter(valid_597172, JString, required = false,
                                 default = nil)
  if valid_597172 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_597172
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_597173 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_597173 = validateParameter(valid_597173, JString, required = true,
                                 default = nil)
  if valid_597173 != nil:
    section.add "ClusterSecurityGroupName", valid_597173
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597174: Call_PostRevokeClusterSecurityGroupIngress_597158;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_597174.validator(path, query, header, formData, body)
  let scheme = call_597174.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597174.url(scheme.get, call_597174.host, call_597174.base,
                         call_597174.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597174, url, valid)

proc call*(call_597175: Call_PostRevokeClusterSecurityGroupIngress_597158;
          ClusterSecurityGroupName: string;
          Action: string = "RevokeClusterSecurityGroupIngress";
          EC2SecurityGroupName: string = ""; CIDRIP: string = "";
          Version: string = "2012-12-01"; EC2SecurityGroupOwnerId: string = ""): Recallable =
  ## postRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   Version: string (required)
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  var query_597176 = newJObject()
  var formData_597177 = newJObject()
  add(query_597176, "Action", newJString(Action))
  add(formData_597177, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_597177, "CIDRIP", newJString(CIDRIP))
  add(query_597176, "Version", newJString(Version))
  add(formData_597177, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_597177, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_597175.call(nil, query_597176, nil, formData_597177, nil)

var postRevokeClusterSecurityGroupIngress* = Call_PostRevokeClusterSecurityGroupIngress_597158(
    name: "postRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_PostRevokeClusterSecurityGroupIngress_597159, base: "/",
    url: url_PostRevokeClusterSecurityGroupIngress_597160,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeClusterSecurityGroupIngress_597139 = ref object of OpenApiRestCall_593421
proc url_GetRevokeClusterSecurityGroupIngress_597141(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRevokeClusterSecurityGroupIngress_597140(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_597142 = query.getOrDefault("ClusterSecurityGroupName")
  valid_597142 = validateParameter(valid_597142, JString, required = true,
                                 default = nil)
  if valid_597142 != nil:
    section.add "ClusterSecurityGroupName", valid_597142
  var valid_597143 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_597143 = validateParameter(valid_597143, JString, required = false,
                                 default = nil)
  if valid_597143 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_597143
  var valid_597144 = query.getOrDefault("Action")
  valid_597144 = validateParameter(valid_597144, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_597144 != nil:
    section.add "Action", valid_597144
  var valid_597145 = query.getOrDefault("CIDRIP")
  valid_597145 = validateParameter(valid_597145, JString, required = false,
                                 default = nil)
  if valid_597145 != nil:
    section.add "CIDRIP", valid_597145
  var valid_597146 = query.getOrDefault("EC2SecurityGroupName")
  valid_597146 = validateParameter(valid_597146, JString, required = false,
                                 default = nil)
  if valid_597146 != nil:
    section.add "EC2SecurityGroupName", valid_597146
  var valid_597147 = query.getOrDefault("Version")
  valid_597147 = validateParameter(valid_597147, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_597147 != nil:
    section.add "Version", valid_597147
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_597148 = header.getOrDefault("X-Amz-Date")
  valid_597148 = validateParameter(valid_597148, JString, required = false,
                                 default = nil)
  if valid_597148 != nil:
    section.add "X-Amz-Date", valid_597148
  var valid_597149 = header.getOrDefault("X-Amz-Security-Token")
  valid_597149 = validateParameter(valid_597149, JString, required = false,
                                 default = nil)
  if valid_597149 != nil:
    section.add "X-Amz-Security-Token", valid_597149
  var valid_597150 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_597150 = validateParameter(valid_597150, JString, required = false,
                                 default = nil)
  if valid_597150 != nil:
    section.add "X-Amz-Content-Sha256", valid_597150
  var valid_597151 = header.getOrDefault("X-Amz-Algorithm")
  valid_597151 = validateParameter(valid_597151, JString, required = false,
                                 default = nil)
  if valid_597151 != nil:
    section.add "X-Amz-Algorithm", valid_597151
  var valid_597152 = header.getOrDefault("X-Amz-Signature")
  valid_597152 = validateParameter(valid_597152, JString, required = false,
                                 default = nil)
  if valid_597152 != nil:
    section.add "X-Amz-Signature", valid_597152
  var valid_597153 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_597153 = validateParameter(valid_597153, JString, required = false,
                                 default = nil)
  if valid_597153 != nil:
    section.add "X-Amz-SignedHeaders", valid_597153
  var valid_597154 = header.getOrDefault("X-Amz-Credential")
  valid_597154 = validateParameter(valid_597154, JString, required = false,
                                 default = nil)
  if valid_597154 != nil:
    section.add "X-Amz-Credential", valid_597154
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597155: Call_GetRevokeClusterSecurityGroupIngress_597139;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_597155.validator(path, query, header, formData, body)
  let scheme = call_597155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597155.url(scheme.get, call_597155.host, call_597155.base,
                         call_597155.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597155, url, valid)

proc call*(call_597156: Call_GetRevokeClusterSecurityGroupIngress_597139;
          ClusterSecurityGroupName: string; EC2SecurityGroupOwnerId: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress"; CIDRIP: string = "";
          EC2SecurityGroupName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: string (required)
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   Version: string (required)
  var query_597157 = newJObject()
  add(query_597157, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_597157, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_597157, "Action", newJString(Action))
  add(query_597157, "CIDRIP", newJString(CIDRIP))
  add(query_597157, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_597157, "Version", newJString(Version))
  result = call_597156.call(nil, query_597157, nil, nil, nil)

var getRevokeClusterSecurityGroupIngress* = Call_GetRevokeClusterSecurityGroupIngress_597139(
    name: "getRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_GetRevokeClusterSecurityGroupIngress_597140, base: "/",
    url: url_GetRevokeClusterSecurityGroupIngress_597141,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeSnapshotAccess_597196 = ref object of OpenApiRestCall_593421
proc url_PostRevokeSnapshotAccess_597198(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRevokeSnapshotAccess_597197(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_597199 = query.getOrDefault("Action")
  valid_597199 = validateParameter(valid_597199, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_597199 != nil:
    section.add "Action", valid_597199
  var valid_597200 = query.getOrDefault("Version")
  valid_597200 = validateParameter(valid_597200, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_597200 != nil:
    section.add "Version", valid_597200
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_597201 = header.getOrDefault("X-Amz-Date")
  valid_597201 = validateParameter(valid_597201, JString, required = false,
                                 default = nil)
  if valid_597201 != nil:
    section.add "X-Amz-Date", valid_597201
  var valid_597202 = header.getOrDefault("X-Amz-Security-Token")
  valid_597202 = validateParameter(valid_597202, JString, required = false,
                                 default = nil)
  if valid_597202 != nil:
    section.add "X-Amz-Security-Token", valid_597202
  var valid_597203 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_597203 = validateParameter(valid_597203, JString, required = false,
                                 default = nil)
  if valid_597203 != nil:
    section.add "X-Amz-Content-Sha256", valid_597203
  var valid_597204 = header.getOrDefault("X-Amz-Algorithm")
  valid_597204 = validateParameter(valid_597204, JString, required = false,
                                 default = nil)
  if valid_597204 != nil:
    section.add "X-Amz-Algorithm", valid_597204
  var valid_597205 = header.getOrDefault("X-Amz-Signature")
  valid_597205 = validateParameter(valid_597205, JString, required = false,
                                 default = nil)
  if valid_597205 != nil:
    section.add "X-Amz-Signature", valid_597205
  var valid_597206 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_597206 = validateParameter(valid_597206, JString, required = false,
                                 default = nil)
  if valid_597206 != nil:
    section.add "X-Amz-SignedHeaders", valid_597206
  var valid_597207 = header.getOrDefault("X-Amz-Credential")
  valid_597207 = validateParameter(valid_597207, JString, required = false,
                                 default = nil)
  if valid_597207 != nil:
    section.add "X-Amz-Credential", valid_597207
  result.add "header", section
  ## parameters in `formData` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_597208 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_597208 = validateParameter(valid_597208, JString, required = true,
                                 default = nil)
  if valid_597208 != nil:
    section.add "AccountWithRestoreAccess", valid_597208
  var valid_597209 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_597209 = validateParameter(valid_597209, JString, required = false,
                                 default = nil)
  if valid_597209 != nil:
    section.add "SnapshotClusterIdentifier", valid_597209
  var valid_597210 = formData.getOrDefault("SnapshotIdentifier")
  valid_597210 = validateParameter(valid_597210, JString, required = true,
                                 default = nil)
  if valid_597210 != nil:
    section.add "SnapshotIdentifier", valid_597210
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597211: Call_PostRevokeSnapshotAccess_597196; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_597211.validator(path, query, header, formData, body)
  let scheme = call_597211.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597211.url(scheme.get, call_597211.host, call_597211.base,
                         call_597211.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597211, url, valid)

proc call*(call_597212: Call_PostRevokeSnapshotAccess_597196;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "RevokeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## postRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: string (required)
  var query_597213 = newJObject()
  var formData_597214 = newJObject()
  add(formData_597214, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_597214, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_597213, "Action", newJString(Action))
  add(formData_597214, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_597213, "Version", newJString(Version))
  result = call_597212.call(nil, query_597213, nil, formData_597214, nil)

var postRevokeSnapshotAccess* = Call_PostRevokeSnapshotAccess_597196(
    name: "postRevokeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_PostRevokeSnapshotAccess_597197, base: "/",
    url: url_PostRevokeSnapshotAccess_597198, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeSnapshotAccess_597178 = ref object of OpenApiRestCall_593421
proc url_GetRevokeSnapshotAccess_597180(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRevokeSnapshotAccess_597179(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_597181 = query.getOrDefault("AccountWithRestoreAccess")
  valid_597181 = validateParameter(valid_597181, JString, required = true,
                                 default = nil)
  if valid_597181 != nil:
    section.add "AccountWithRestoreAccess", valid_597181
  var valid_597182 = query.getOrDefault("Action")
  valid_597182 = validateParameter(valid_597182, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_597182 != nil:
    section.add "Action", valid_597182
  var valid_597183 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_597183 = validateParameter(valid_597183, JString, required = false,
                                 default = nil)
  if valid_597183 != nil:
    section.add "SnapshotClusterIdentifier", valid_597183
  var valid_597184 = query.getOrDefault("SnapshotIdentifier")
  valid_597184 = validateParameter(valid_597184, JString, required = true,
                                 default = nil)
  if valid_597184 != nil:
    section.add "SnapshotIdentifier", valid_597184
  var valid_597185 = query.getOrDefault("Version")
  valid_597185 = validateParameter(valid_597185, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_597185 != nil:
    section.add "Version", valid_597185
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_597186 = header.getOrDefault("X-Amz-Date")
  valid_597186 = validateParameter(valid_597186, JString, required = false,
                                 default = nil)
  if valid_597186 != nil:
    section.add "X-Amz-Date", valid_597186
  var valid_597187 = header.getOrDefault("X-Amz-Security-Token")
  valid_597187 = validateParameter(valid_597187, JString, required = false,
                                 default = nil)
  if valid_597187 != nil:
    section.add "X-Amz-Security-Token", valid_597187
  var valid_597188 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_597188 = validateParameter(valid_597188, JString, required = false,
                                 default = nil)
  if valid_597188 != nil:
    section.add "X-Amz-Content-Sha256", valid_597188
  var valid_597189 = header.getOrDefault("X-Amz-Algorithm")
  valid_597189 = validateParameter(valid_597189, JString, required = false,
                                 default = nil)
  if valid_597189 != nil:
    section.add "X-Amz-Algorithm", valid_597189
  var valid_597190 = header.getOrDefault("X-Amz-Signature")
  valid_597190 = validateParameter(valid_597190, JString, required = false,
                                 default = nil)
  if valid_597190 != nil:
    section.add "X-Amz-Signature", valid_597190
  var valid_597191 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_597191 = validateParameter(valid_597191, JString, required = false,
                                 default = nil)
  if valid_597191 != nil:
    section.add "X-Amz-SignedHeaders", valid_597191
  var valid_597192 = header.getOrDefault("X-Amz-Credential")
  valid_597192 = validateParameter(valid_597192, JString, required = false,
                                 default = nil)
  if valid_597192 != nil:
    section.add "X-Amz-Credential", valid_597192
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597193: Call_GetRevokeSnapshotAccess_597178; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_597193.validator(path, query, header, formData, body)
  let scheme = call_597193.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597193.url(scheme.get, call_597193.host, call_597193.base,
                         call_597193.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597193, url, valid)

proc call*(call_597194: Call_GetRevokeSnapshotAccess_597178;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          Action: string = "RevokeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: string (required)
  var query_597195 = newJObject()
  add(query_597195, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_597195, "Action", newJString(Action))
  add(query_597195, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_597195, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_597195, "Version", newJString(Version))
  result = call_597194.call(nil, query_597195, nil, nil, nil)

var getRevokeSnapshotAccess* = Call_GetRevokeSnapshotAccess_597178(
    name: "getRevokeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_GetRevokeSnapshotAccess_597179, base: "/",
    url: url_GetRevokeSnapshotAccess_597180, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRotateEncryptionKey_597231 = ref object of OpenApiRestCall_593421
proc url_PostRotateEncryptionKey_597233(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRotateEncryptionKey_597232(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_597234 = query.getOrDefault("Action")
  valid_597234 = validateParameter(valid_597234, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_597234 != nil:
    section.add "Action", valid_597234
  var valid_597235 = query.getOrDefault("Version")
  valid_597235 = validateParameter(valid_597235, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_597235 != nil:
    section.add "Version", valid_597235
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_597236 = header.getOrDefault("X-Amz-Date")
  valid_597236 = validateParameter(valid_597236, JString, required = false,
                                 default = nil)
  if valid_597236 != nil:
    section.add "X-Amz-Date", valid_597236
  var valid_597237 = header.getOrDefault("X-Amz-Security-Token")
  valid_597237 = validateParameter(valid_597237, JString, required = false,
                                 default = nil)
  if valid_597237 != nil:
    section.add "X-Amz-Security-Token", valid_597237
  var valid_597238 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_597238 = validateParameter(valid_597238, JString, required = false,
                                 default = nil)
  if valid_597238 != nil:
    section.add "X-Amz-Content-Sha256", valid_597238
  var valid_597239 = header.getOrDefault("X-Amz-Algorithm")
  valid_597239 = validateParameter(valid_597239, JString, required = false,
                                 default = nil)
  if valid_597239 != nil:
    section.add "X-Amz-Algorithm", valid_597239
  var valid_597240 = header.getOrDefault("X-Amz-Signature")
  valid_597240 = validateParameter(valid_597240, JString, required = false,
                                 default = nil)
  if valid_597240 != nil:
    section.add "X-Amz-Signature", valid_597240
  var valid_597241 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_597241 = validateParameter(valid_597241, JString, required = false,
                                 default = nil)
  if valid_597241 != nil:
    section.add "X-Amz-SignedHeaders", valid_597241
  var valid_597242 = header.getOrDefault("X-Amz-Credential")
  valid_597242 = validateParameter(valid_597242, JString, required = false,
                                 default = nil)
  if valid_597242 != nil:
    section.add "X-Amz-Credential", valid_597242
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_597243 = formData.getOrDefault("ClusterIdentifier")
  valid_597243 = validateParameter(valid_597243, JString, required = true,
                                 default = nil)
  if valid_597243 != nil:
    section.add "ClusterIdentifier", valid_597243
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597244: Call_PostRotateEncryptionKey_597231; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_597244.validator(path, query, header, formData, body)
  let scheme = call_597244.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597244.url(scheme.get, call_597244.host, call_597244.base,
                         call_597244.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597244, url, valid)

proc call*(call_597245: Call_PostRotateEncryptionKey_597231;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## postRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_597246 = newJObject()
  var formData_597247 = newJObject()
  add(query_597246, "Action", newJString(Action))
  add(formData_597247, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_597246, "Version", newJString(Version))
  result = call_597245.call(nil, query_597246, nil, formData_597247, nil)

var postRotateEncryptionKey* = Call_PostRotateEncryptionKey_597231(
    name: "postRotateEncryptionKey", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_PostRotateEncryptionKey_597232, base: "/",
    url: url_PostRotateEncryptionKey_597233, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRotateEncryptionKey_597215 = ref object of OpenApiRestCall_593421
proc url_GetRotateEncryptionKey_597217(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRotateEncryptionKey_597216(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_597218 = query.getOrDefault("Action")
  valid_597218 = validateParameter(valid_597218, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_597218 != nil:
    section.add "Action", valid_597218
  var valid_597219 = query.getOrDefault("ClusterIdentifier")
  valid_597219 = validateParameter(valid_597219, JString, required = true,
                                 default = nil)
  if valid_597219 != nil:
    section.add "ClusterIdentifier", valid_597219
  var valid_597220 = query.getOrDefault("Version")
  valid_597220 = validateParameter(valid_597220, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_597220 != nil:
    section.add "Version", valid_597220
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_597221 = header.getOrDefault("X-Amz-Date")
  valid_597221 = validateParameter(valid_597221, JString, required = false,
                                 default = nil)
  if valid_597221 != nil:
    section.add "X-Amz-Date", valid_597221
  var valid_597222 = header.getOrDefault("X-Amz-Security-Token")
  valid_597222 = validateParameter(valid_597222, JString, required = false,
                                 default = nil)
  if valid_597222 != nil:
    section.add "X-Amz-Security-Token", valid_597222
  var valid_597223 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_597223 = validateParameter(valid_597223, JString, required = false,
                                 default = nil)
  if valid_597223 != nil:
    section.add "X-Amz-Content-Sha256", valid_597223
  var valid_597224 = header.getOrDefault("X-Amz-Algorithm")
  valid_597224 = validateParameter(valid_597224, JString, required = false,
                                 default = nil)
  if valid_597224 != nil:
    section.add "X-Amz-Algorithm", valid_597224
  var valid_597225 = header.getOrDefault("X-Amz-Signature")
  valid_597225 = validateParameter(valid_597225, JString, required = false,
                                 default = nil)
  if valid_597225 != nil:
    section.add "X-Amz-Signature", valid_597225
  var valid_597226 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_597226 = validateParameter(valid_597226, JString, required = false,
                                 default = nil)
  if valid_597226 != nil:
    section.add "X-Amz-SignedHeaders", valid_597226
  var valid_597227 = header.getOrDefault("X-Amz-Credential")
  valid_597227 = validateParameter(valid_597227, JString, required = false,
                                 default = nil)
  if valid_597227 != nil:
    section.add "X-Amz-Credential", valid_597227
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_597228: Call_GetRotateEncryptionKey_597215; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_597228.validator(path, query, header, formData, body)
  let scheme = call_597228.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_597228.url(scheme.get, call_597228.host, call_597228.base,
                         call_597228.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_597228, url, valid)

proc call*(call_597229: Call_GetRotateEncryptionKey_597215;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## getRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_597230 = newJObject()
  add(query_597230, "Action", newJString(Action))
  add(query_597230, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_597230, "Version", newJString(Version))
  result = call_597229.call(nil, query_597230, nil, nil, nil)

var getRotateEncryptionKey* = Call_GetRotateEncryptionKey_597215(
    name: "getRotateEncryptionKey", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_GetRotateEncryptionKey_597216, base: "/",
    url: url_GetRotateEncryptionKey_597217, schemes: {Scheme.Https, Scheme.Http})
export
  rest

proc sign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", "")
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", "")
    region = os.getEnv("AWS_REGION", "")
  assert secret != "", "need secret key in env"
  assert access != "", "need access key in env"
  assert region != "", "need region in env"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
  result.sign(input.getOrDefault("query"), SHA256)
