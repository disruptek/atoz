
import
  json, options, hashes, uri, strutils, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: Amazon Redshift
## version: 2012-12-01
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>Amazon Redshift</fullname> <p> <b>Overview</b> </p> <p>This is an interface reference for Amazon Redshift. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Redshift clusters. Note that Amazon Redshift is asynchronous, which means that some interfaces may require techniques, such as polling or asynchronous callback handlers, to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a change is applied immediately, on the next instance reboot, or during the next maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the Amazon Redshift Management Interfaces</a>.</p> <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data warehouse: provisioning capacity, monitoring and backing up the cluster, and applying patches and upgrades to the Amazon Redshift engine. You can focus on using your data to acquire new insights for your business and customers.</p> <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p> <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design, build, query, and maintain the databases that make up your data warehouse. </p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/redshift/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_601373 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_601373](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_601373): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com", "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
                           "us-west-2": "redshift.us-west-2.amazonaws.com",
                           "eu-west-2": "redshift.eu-west-2.amazonaws.com", "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com", "eu-central-1": "redshift.eu-central-1.amazonaws.com",
                           "us-east-2": "redshift.us-east-2.amazonaws.com",
                           "us-east-1": "redshift.us-east-1.amazonaws.com", "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "redshift.ap-south-1.amazonaws.com",
                           "eu-north-1": "redshift.eu-north-1.amazonaws.com", "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
                           "us-west-1": "redshift.us-west-1.amazonaws.com", "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "redshift.eu-west-3.amazonaws.com", "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "redshift.sa-east-1.amazonaws.com",
                           "eu-west-1": "redshift.eu-west-1.amazonaws.com", "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com", "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com", "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
      "us-west-2": "redshift.us-west-2.amazonaws.com",
      "eu-west-2": "redshift.eu-west-2.amazonaws.com",
      "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com",
      "eu-central-1": "redshift.eu-central-1.amazonaws.com",
      "us-east-2": "redshift.us-east-2.amazonaws.com",
      "us-east-1": "redshift.us-east-1.amazonaws.com",
      "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "redshift.ap-south-1.amazonaws.com",
      "eu-north-1": "redshift.eu-north-1.amazonaws.com",
      "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
      "us-west-1": "redshift.us-west-1.amazonaws.com",
      "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
      "eu-west-3": "redshift.eu-west-3.amazonaws.com",
      "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "redshift.sa-east-1.amazonaws.com",
      "eu-west-1": "redshift.eu-west-1.amazonaws.com",
      "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com",
      "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "redshift"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_PostAcceptReservedNodeExchange_601983 = ref object of OpenApiRestCall_601373
proc url_PostAcceptReservedNodeExchange_601985(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAcceptReservedNodeExchange_601984(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601986 = query.getOrDefault("Action")
  valid_601986 = validateParameter(valid_601986, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_601986 != nil:
    section.add "Action", valid_601986
  var valid_601987 = query.getOrDefault("Version")
  valid_601987 = validateParameter(valid_601987, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601987 != nil:
    section.add "Version", valid_601987
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_601988 = header.getOrDefault("X-Amz-Signature")
  valid_601988 = validateParameter(valid_601988, JString, required = false,
                                 default = nil)
  if valid_601988 != nil:
    section.add "X-Amz-Signature", valid_601988
  var valid_601989 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601989 = validateParameter(valid_601989, JString, required = false,
                                 default = nil)
  if valid_601989 != nil:
    section.add "X-Amz-Content-Sha256", valid_601989
  var valid_601990 = header.getOrDefault("X-Amz-Date")
  valid_601990 = validateParameter(valid_601990, JString, required = false,
                                 default = nil)
  if valid_601990 != nil:
    section.add "X-Amz-Date", valid_601990
  var valid_601991 = header.getOrDefault("X-Amz-Credential")
  valid_601991 = validateParameter(valid_601991, JString, required = false,
                                 default = nil)
  if valid_601991 != nil:
    section.add "X-Amz-Credential", valid_601991
  var valid_601992 = header.getOrDefault("X-Amz-Security-Token")
  valid_601992 = validateParameter(valid_601992, JString, required = false,
                                 default = nil)
  if valid_601992 != nil:
    section.add "X-Amz-Security-Token", valid_601992
  var valid_601993 = header.getOrDefault("X-Amz-Algorithm")
  valid_601993 = validateParameter(valid_601993, JString, required = false,
                                 default = nil)
  if valid_601993 != nil:
    section.add "X-Amz-Algorithm", valid_601993
  var valid_601994 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601994 = validateParameter(valid_601994, JString, required = false,
                                 default = nil)
  if valid_601994 != nil:
    section.add "X-Amz-SignedHeaders", valid_601994
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_601995 = formData.getOrDefault("ReservedNodeId")
  valid_601995 = validateParameter(valid_601995, JString, required = true,
                                 default = nil)
  if valid_601995 != nil:
    section.add "ReservedNodeId", valid_601995
  var valid_601996 = formData.getOrDefault("TargetReservedNodeOfferingId")
  valid_601996 = validateParameter(valid_601996, JString, required = true,
                                 default = nil)
  if valid_601996 != nil:
    section.add "TargetReservedNodeOfferingId", valid_601996
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601997: Call_PostAcceptReservedNodeExchange_601983; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_601997.validator(path, query, header, formData, body)
  let scheme = call_601997.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601997.url(scheme.get, call_601997.host, call_601997.base,
                         call_601997.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601997, url, valid)

proc call*(call_601998: Call_PostAcceptReservedNodeExchange_601983;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## postAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_601999 = newJObject()
  var formData_602000 = newJObject()
  add(formData_602000, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_602000, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_601999, "Action", newJString(Action))
  add(query_601999, "Version", newJString(Version))
  result = call_601998.call(nil, query_601999, nil, formData_602000, nil)

var postAcceptReservedNodeExchange* = Call_PostAcceptReservedNodeExchange_601983(
    name: "postAcceptReservedNodeExchange", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_PostAcceptReservedNodeExchange_601984, base: "/",
    url: url_PostAcceptReservedNodeExchange_601985,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAcceptReservedNodeExchange_601711 = ref object of OpenApiRestCall_601373
proc url_GetAcceptReservedNodeExchange_601713(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAcceptReservedNodeExchange_601712(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   Version: JString (required)
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601838 = query.getOrDefault("Action")
  valid_601838 = validateParameter(valid_601838, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_601838 != nil:
    section.add "Action", valid_601838
  var valid_601839 = query.getOrDefault("ReservedNodeId")
  valid_601839 = validateParameter(valid_601839, JString, required = true,
                                 default = nil)
  if valid_601839 != nil:
    section.add "ReservedNodeId", valid_601839
  var valid_601840 = query.getOrDefault("Version")
  valid_601840 = validateParameter(valid_601840, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601840 != nil:
    section.add "Version", valid_601840
  var valid_601841 = query.getOrDefault("TargetReservedNodeOfferingId")
  valid_601841 = validateParameter(valid_601841, JString, required = true,
                                 default = nil)
  if valid_601841 != nil:
    section.add "TargetReservedNodeOfferingId", valid_601841
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_601842 = header.getOrDefault("X-Amz-Signature")
  valid_601842 = validateParameter(valid_601842, JString, required = false,
                                 default = nil)
  if valid_601842 != nil:
    section.add "X-Amz-Signature", valid_601842
  var valid_601843 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601843 = validateParameter(valid_601843, JString, required = false,
                                 default = nil)
  if valid_601843 != nil:
    section.add "X-Amz-Content-Sha256", valid_601843
  var valid_601844 = header.getOrDefault("X-Amz-Date")
  valid_601844 = validateParameter(valid_601844, JString, required = false,
                                 default = nil)
  if valid_601844 != nil:
    section.add "X-Amz-Date", valid_601844
  var valid_601845 = header.getOrDefault("X-Amz-Credential")
  valid_601845 = validateParameter(valid_601845, JString, required = false,
                                 default = nil)
  if valid_601845 != nil:
    section.add "X-Amz-Credential", valid_601845
  var valid_601846 = header.getOrDefault("X-Amz-Security-Token")
  valid_601846 = validateParameter(valid_601846, JString, required = false,
                                 default = nil)
  if valid_601846 != nil:
    section.add "X-Amz-Security-Token", valid_601846
  var valid_601847 = header.getOrDefault("X-Amz-Algorithm")
  valid_601847 = validateParameter(valid_601847, JString, required = false,
                                 default = nil)
  if valid_601847 != nil:
    section.add "X-Amz-Algorithm", valid_601847
  var valid_601848 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601848 = validateParameter(valid_601848, JString, required = false,
                                 default = nil)
  if valid_601848 != nil:
    section.add "X-Amz-SignedHeaders", valid_601848
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601871: Call_GetAcceptReservedNodeExchange_601711; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_601871.validator(path, query, header, formData, body)
  let scheme = call_601871.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601871.url(scheme.get, call_601871.host, call_601871.base,
                         call_601871.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601871, url, valid)

proc call*(call_601942: Call_GetAcceptReservedNodeExchange_601711;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## getAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   Action: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   Version: string (required)
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  var query_601943 = newJObject()
  add(query_601943, "Action", newJString(Action))
  add(query_601943, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_601943, "Version", newJString(Version))
  add(query_601943, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  result = call_601942.call(nil, query_601943, nil, nil, nil)

var getAcceptReservedNodeExchange* = Call_GetAcceptReservedNodeExchange_601711(
    name: "getAcceptReservedNodeExchange", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_GetAcceptReservedNodeExchange_601712, base: "/",
    url: url_GetAcceptReservedNodeExchange_601713,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeClusterSecurityGroupIngress_602020 = ref object of OpenApiRestCall_601373
proc url_PostAuthorizeClusterSecurityGroupIngress_602022(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeClusterSecurityGroupIngress_602021(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602023 = query.getOrDefault("Action")
  valid_602023 = validateParameter(valid_602023, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_602023 != nil:
    section.add "Action", valid_602023
  var valid_602024 = query.getOrDefault("Version")
  valid_602024 = validateParameter(valid_602024, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602024 != nil:
    section.add "Version", valid_602024
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602025 = header.getOrDefault("X-Amz-Signature")
  valid_602025 = validateParameter(valid_602025, JString, required = false,
                                 default = nil)
  if valid_602025 != nil:
    section.add "X-Amz-Signature", valid_602025
  var valid_602026 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602026 = validateParameter(valid_602026, JString, required = false,
                                 default = nil)
  if valid_602026 != nil:
    section.add "X-Amz-Content-Sha256", valid_602026
  var valid_602027 = header.getOrDefault("X-Amz-Date")
  valid_602027 = validateParameter(valid_602027, JString, required = false,
                                 default = nil)
  if valid_602027 != nil:
    section.add "X-Amz-Date", valid_602027
  var valid_602028 = header.getOrDefault("X-Amz-Credential")
  valid_602028 = validateParameter(valid_602028, JString, required = false,
                                 default = nil)
  if valid_602028 != nil:
    section.add "X-Amz-Credential", valid_602028
  var valid_602029 = header.getOrDefault("X-Amz-Security-Token")
  valid_602029 = validateParameter(valid_602029, JString, required = false,
                                 default = nil)
  if valid_602029 != nil:
    section.add "X-Amz-Security-Token", valid_602029
  var valid_602030 = header.getOrDefault("X-Amz-Algorithm")
  valid_602030 = validateParameter(valid_602030, JString, required = false,
                                 default = nil)
  if valid_602030 != nil:
    section.add "X-Amz-Algorithm", valid_602030
  var valid_602031 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602031 = validateParameter(valid_602031, JString, required = false,
                                 default = nil)
  if valid_602031 != nil:
    section.add "X-Amz-SignedHeaders", valid_602031
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_602032 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_602032 = validateParameter(valid_602032, JString, required = true,
                                 default = nil)
  if valid_602032 != nil:
    section.add "ClusterSecurityGroupName", valid_602032
  var valid_602033 = formData.getOrDefault("EC2SecurityGroupName")
  valid_602033 = validateParameter(valid_602033, JString, required = false,
                                 default = nil)
  if valid_602033 != nil:
    section.add "EC2SecurityGroupName", valid_602033
  var valid_602034 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_602034 = validateParameter(valid_602034, JString, required = false,
                                 default = nil)
  if valid_602034 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_602034
  var valid_602035 = formData.getOrDefault("CIDRIP")
  valid_602035 = validateParameter(valid_602035, JString, required = false,
                                 default = nil)
  if valid_602035 != nil:
    section.add "CIDRIP", valid_602035
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602036: Call_PostAuthorizeClusterSecurityGroupIngress_602020;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602036.validator(path, query, header, formData, body)
  let scheme = call_602036.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602036.url(scheme.get, call_602036.host, call_602036.base,
                         call_602036.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602036, url, valid)

proc call*(call_602037: Call_PostAuthorizeClusterSecurityGroupIngress_602020;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = ""; CIDRIP: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602038 = newJObject()
  var formData_602039 = newJObject()
  add(formData_602039, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_602039, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_602039, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_602039, "CIDRIP", newJString(CIDRIP))
  add(query_602038, "Action", newJString(Action))
  add(query_602038, "Version", newJString(Version))
  result = call_602037.call(nil, query_602038, nil, formData_602039, nil)

var postAuthorizeClusterSecurityGroupIngress* = Call_PostAuthorizeClusterSecurityGroupIngress_602020(
    name: "postAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_PostAuthorizeClusterSecurityGroupIngress_602021,
    base: "/", url: url_PostAuthorizeClusterSecurityGroupIngress_602022,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeClusterSecurityGroupIngress_602001 = ref object of OpenApiRestCall_601373
proc url_GetAuthorizeClusterSecurityGroupIngress_602003(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeClusterSecurityGroupIngress_602002(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  section = newJObject()
  var valid_602004 = query.getOrDefault("EC2SecurityGroupName")
  valid_602004 = validateParameter(valid_602004, JString, required = false,
                                 default = nil)
  if valid_602004 != nil:
    section.add "EC2SecurityGroupName", valid_602004
  var valid_602005 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_602005 = validateParameter(valid_602005, JString, required = false,
                                 default = nil)
  if valid_602005 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_602005
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_602006 = query.getOrDefault("ClusterSecurityGroupName")
  valid_602006 = validateParameter(valid_602006, JString, required = true,
                                 default = nil)
  if valid_602006 != nil:
    section.add "ClusterSecurityGroupName", valid_602006
  var valid_602007 = query.getOrDefault("Action")
  valid_602007 = validateParameter(valid_602007, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_602007 != nil:
    section.add "Action", valid_602007
  var valid_602008 = query.getOrDefault("Version")
  valid_602008 = validateParameter(valid_602008, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602008 != nil:
    section.add "Version", valid_602008
  var valid_602009 = query.getOrDefault("CIDRIP")
  valid_602009 = validateParameter(valid_602009, JString, required = false,
                                 default = nil)
  if valid_602009 != nil:
    section.add "CIDRIP", valid_602009
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602010 = header.getOrDefault("X-Amz-Signature")
  valid_602010 = validateParameter(valid_602010, JString, required = false,
                                 default = nil)
  if valid_602010 != nil:
    section.add "X-Amz-Signature", valid_602010
  var valid_602011 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602011 = validateParameter(valid_602011, JString, required = false,
                                 default = nil)
  if valid_602011 != nil:
    section.add "X-Amz-Content-Sha256", valid_602011
  var valid_602012 = header.getOrDefault("X-Amz-Date")
  valid_602012 = validateParameter(valid_602012, JString, required = false,
                                 default = nil)
  if valid_602012 != nil:
    section.add "X-Amz-Date", valid_602012
  var valid_602013 = header.getOrDefault("X-Amz-Credential")
  valid_602013 = validateParameter(valid_602013, JString, required = false,
                                 default = nil)
  if valid_602013 != nil:
    section.add "X-Amz-Credential", valid_602013
  var valid_602014 = header.getOrDefault("X-Amz-Security-Token")
  valid_602014 = validateParameter(valid_602014, JString, required = false,
                                 default = nil)
  if valid_602014 != nil:
    section.add "X-Amz-Security-Token", valid_602014
  var valid_602015 = header.getOrDefault("X-Amz-Algorithm")
  valid_602015 = validateParameter(valid_602015, JString, required = false,
                                 default = nil)
  if valid_602015 != nil:
    section.add "X-Amz-Algorithm", valid_602015
  var valid_602016 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602016 = validateParameter(valid_602016, JString, required = false,
                                 default = nil)
  if valid_602016 != nil:
    section.add "X-Amz-SignedHeaders", valid_602016
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602017: Call_GetAuthorizeClusterSecurityGroupIngress_602001;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602017.validator(path, query, header, formData, body)
  let scheme = call_602017.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602017.url(scheme.get, call_602017.host, call_602017.base,
                         call_602017.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602017, url, valid)

proc call*(call_602018: Call_GetAuthorizeClusterSecurityGroupIngress_602001;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"; CIDRIP: string = ""): Recallable =
  ## getAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  var query_602019 = newJObject()
  add(query_602019, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_602019, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_602019, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_602019, "Action", newJString(Action))
  add(query_602019, "Version", newJString(Version))
  add(query_602019, "CIDRIP", newJString(CIDRIP))
  result = call_602018.call(nil, query_602019, nil, nil, nil)

var getAuthorizeClusterSecurityGroupIngress* = Call_GetAuthorizeClusterSecurityGroupIngress_602001(
    name: "getAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_GetAuthorizeClusterSecurityGroupIngress_602002, base: "/",
    url: url_GetAuthorizeClusterSecurityGroupIngress_602003,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeSnapshotAccess_602058 = ref object of OpenApiRestCall_601373
proc url_PostAuthorizeSnapshotAccess_602060(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeSnapshotAccess_602059(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602061 = query.getOrDefault("Action")
  valid_602061 = validateParameter(valid_602061, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_602061 != nil:
    section.add "Action", valid_602061
  var valid_602062 = query.getOrDefault("Version")
  valid_602062 = validateParameter(valid_602062, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602062 != nil:
    section.add "Version", valid_602062
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602063 = header.getOrDefault("X-Amz-Signature")
  valid_602063 = validateParameter(valid_602063, JString, required = false,
                                 default = nil)
  if valid_602063 != nil:
    section.add "X-Amz-Signature", valid_602063
  var valid_602064 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602064 = validateParameter(valid_602064, JString, required = false,
                                 default = nil)
  if valid_602064 != nil:
    section.add "X-Amz-Content-Sha256", valid_602064
  var valid_602065 = header.getOrDefault("X-Amz-Date")
  valid_602065 = validateParameter(valid_602065, JString, required = false,
                                 default = nil)
  if valid_602065 != nil:
    section.add "X-Amz-Date", valid_602065
  var valid_602066 = header.getOrDefault("X-Amz-Credential")
  valid_602066 = validateParameter(valid_602066, JString, required = false,
                                 default = nil)
  if valid_602066 != nil:
    section.add "X-Amz-Credential", valid_602066
  var valid_602067 = header.getOrDefault("X-Amz-Security-Token")
  valid_602067 = validateParameter(valid_602067, JString, required = false,
                                 default = nil)
  if valid_602067 != nil:
    section.add "X-Amz-Security-Token", valid_602067
  var valid_602068 = header.getOrDefault("X-Amz-Algorithm")
  valid_602068 = validateParameter(valid_602068, JString, required = false,
                                 default = nil)
  if valid_602068 != nil:
    section.add "X-Amz-Algorithm", valid_602068
  var valid_602069 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602069 = validateParameter(valid_602069, JString, required = false,
                                 default = nil)
  if valid_602069 != nil:
    section.add "X-Amz-SignedHeaders", valid_602069
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_602070 = formData.getOrDefault("SnapshotIdentifier")
  valid_602070 = validateParameter(valid_602070, JString, required = true,
                                 default = nil)
  if valid_602070 != nil:
    section.add "SnapshotIdentifier", valid_602070
  var valid_602071 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_602071 = validateParameter(valid_602071, JString, required = true,
                                 default = nil)
  if valid_602071 != nil:
    section.add "AccountWithRestoreAccess", valid_602071
  var valid_602072 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_602072 = validateParameter(valid_602072, JString, required = false,
                                 default = nil)
  if valid_602072 != nil:
    section.add "SnapshotClusterIdentifier", valid_602072
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602073: Call_PostAuthorizeSnapshotAccess_602058; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602073.validator(path, query, header, formData, body)
  let scheme = call_602073.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602073.url(scheme.get, call_602073.host, call_602073.base,
                         call_602073.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602073, url, valid)

proc call*(call_602074: Call_PostAuthorizeSnapshotAccess_602058;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          Action: string = "AuthorizeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Action: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Version: string (required)
  var query_602075 = newJObject()
  var formData_602076 = newJObject()
  add(formData_602076, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_602075, "Action", newJString(Action))
  add(formData_602076, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_602076, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_602075, "Version", newJString(Version))
  result = call_602074.call(nil, query_602075, nil, formData_602076, nil)

var postAuthorizeSnapshotAccess* = Call_PostAuthorizeSnapshotAccess_602058(
    name: "postAuthorizeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_PostAuthorizeSnapshotAccess_602059, base: "/",
    url: url_PostAuthorizeSnapshotAccess_602060,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeSnapshotAccess_602040 = ref object of OpenApiRestCall_601373
proc url_GetAuthorizeSnapshotAccess_602042(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeSnapshotAccess_602041(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_602043 = query.getOrDefault("SnapshotIdentifier")
  valid_602043 = validateParameter(valid_602043, JString, required = true,
                                 default = nil)
  if valid_602043 != nil:
    section.add "SnapshotIdentifier", valid_602043
  var valid_602044 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_602044 = validateParameter(valid_602044, JString, required = false,
                                 default = nil)
  if valid_602044 != nil:
    section.add "SnapshotClusterIdentifier", valid_602044
  var valid_602045 = query.getOrDefault("Action")
  valid_602045 = validateParameter(valid_602045, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_602045 != nil:
    section.add "Action", valid_602045
  var valid_602046 = query.getOrDefault("Version")
  valid_602046 = validateParameter(valid_602046, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602046 != nil:
    section.add "Version", valid_602046
  var valid_602047 = query.getOrDefault("AccountWithRestoreAccess")
  valid_602047 = validateParameter(valid_602047, JString, required = true,
                                 default = nil)
  if valid_602047 != nil:
    section.add "AccountWithRestoreAccess", valid_602047
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602048 = header.getOrDefault("X-Amz-Signature")
  valid_602048 = validateParameter(valid_602048, JString, required = false,
                                 default = nil)
  if valid_602048 != nil:
    section.add "X-Amz-Signature", valid_602048
  var valid_602049 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602049 = validateParameter(valid_602049, JString, required = false,
                                 default = nil)
  if valid_602049 != nil:
    section.add "X-Amz-Content-Sha256", valid_602049
  var valid_602050 = header.getOrDefault("X-Amz-Date")
  valid_602050 = validateParameter(valid_602050, JString, required = false,
                                 default = nil)
  if valid_602050 != nil:
    section.add "X-Amz-Date", valid_602050
  var valid_602051 = header.getOrDefault("X-Amz-Credential")
  valid_602051 = validateParameter(valid_602051, JString, required = false,
                                 default = nil)
  if valid_602051 != nil:
    section.add "X-Amz-Credential", valid_602051
  var valid_602052 = header.getOrDefault("X-Amz-Security-Token")
  valid_602052 = validateParameter(valid_602052, JString, required = false,
                                 default = nil)
  if valid_602052 != nil:
    section.add "X-Amz-Security-Token", valid_602052
  var valid_602053 = header.getOrDefault("X-Amz-Algorithm")
  valid_602053 = validateParameter(valid_602053, JString, required = false,
                                 default = nil)
  if valid_602053 != nil:
    section.add "X-Amz-Algorithm", valid_602053
  var valid_602054 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602054 = validateParameter(valid_602054, JString, required = false,
                                 default = nil)
  if valid_602054 != nil:
    section.add "X-Amz-SignedHeaders", valid_602054
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602055: Call_GetAuthorizeSnapshotAccess_602040; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602055.validator(path, query, header, formData, body)
  let scheme = call_602055.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602055.url(scheme.get, call_602055.host, call_602055.base,
                         call_602055.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602055, url, valid)

proc call*(call_602056: Call_GetAuthorizeSnapshotAccess_602040;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "AuthorizeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  var query_602057 = newJObject()
  add(query_602057, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_602057, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_602057, "Action", newJString(Action))
  add(query_602057, "Version", newJString(Version))
  add(query_602057, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  result = call_602056.call(nil, query_602057, nil, nil, nil)

var getAuthorizeSnapshotAccess* = Call_GetAuthorizeSnapshotAccess_602040(
    name: "getAuthorizeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_GetAuthorizeSnapshotAccess_602041, base: "/",
    url: url_GetAuthorizeSnapshotAccess_602042,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchDeleteClusterSnapshots_602093 = ref object of OpenApiRestCall_601373
proc url_PostBatchDeleteClusterSnapshots_602095(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchDeleteClusterSnapshots_602094(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602096 = query.getOrDefault("Action")
  valid_602096 = validateParameter(valid_602096, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_602096 != nil:
    section.add "Action", valid_602096
  var valid_602097 = query.getOrDefault("Version")
  valid_602097 = validateParameter(valid_602097, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602097 != nil:
    section.add "Version", valid_602097
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602098 = header.getOrDefault("X-Amz-Signature")
  valid_602098 = validateParameter(valid_602098, JString, required = false,
                                 default = nil)
  if valid_602098 != nil:
    section.add "X-Amz-Signature", valid_602098
  var valid_602099 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602099 = validateParameter(valid_602099, JString, required = false,
                                 default = nil)
  if valid_602099 != nil:
    section.add "X-Amz-Content-Sha256", valid_602099
  var valid_602100 = header.getOrDefault("X-Amz-Date")
  valid_602100 = validateParameter(valid_602100, JString, required = false,
                                 default = nil)
  if valid_602100 != nil:
    section.add "X-Amz-Date", valid_602100
  var valid_602101 = header.getOrDefault("X-Amz-Credential")
  valid_602101 = validateParameter(valid_602101, JString, required = false,
                                 default = nil)
  if valid_602101 != nil:
    section.add "X-Amz-Credential", valid_602101
  var valid_602102 = header.getOrDefault("X-Amz-Security-Token")
  valid_602102 = validateParameter(valid_602102, JString, required = false,
                                 default = nil)
  if valid_602102 != nil:
    section.add "X-Amz-Security-Token", valid_602102
  var valid_602103 = header.getOrDefault("X-Amz-Algorithm")
  valid_602103 = validateParameter(valid_602103, JString, required = false,
                                 default = nil)
  if valid_602103 != nil:
    section.add "X-Amz-Algorithm", valid_602103
  var valid_602104 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602104 = validateParameter(valid_602104, JString, required = false,
                                 default = nil)
  if valid_602104 != nil:
    section.add "X-Amz-SignedHeaders", valid_602104
  result.add "header", section
  ## parameters in `formData` object:
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Identifiers` field"
  var valid_602105 = formData.getOrDefault("Identifiers")
  valid_602105 = validateParameter(valid_602105, JArray, required = true, default = nil)
  if valid_602105 != nil:
    section.add "Identifiers", valid_602105
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602106: Call_PostBatchDeleteClusterSnapshots_602093;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_602106.validator(path, query, header, formData, body)
  let scheme = call_602106.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602106.url(scheme.get, call_602106.host, call_602106.base,
                         call_602106.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602106, url, valid)

proc call*(call_602107: Call_PostBatchDeleteClusterSnapshots_602093;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## postBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602108 = newJObject()
  var formData_602109 = newJObject()
  if Identifiers != nil:
    formData_602109.add "Identifiers", Identifiers
  add(query_602108, "Action", newJString(Action))
  add(query_602108, "Version", newJString(Version))
  result = call_602107.call(nil, query_602108, nil, formData_602109, nil)

var postBatchDeleteClusterSnapshots* = Call_PostBatchDeleteClusterSnapshots_602093(
    name: "postBatchDeleteClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_PostBatchDeleteClusterSnapshots_602094, base: "/",
    url: url_PostBatchDeleteClusterSnapshots_602095,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchDeleteClusterSnapshots_602077 = ref object of OpenApiRestCall_601373
proc url_GetBatchDeleteClusterSnapshots_602079(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchDeleteClusterSnapshots_602078(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602080 = query.getOrDefault("Action")
  valid_602080 = validateParameter(valid_602080, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_602080 != nil:
    section.add "Action", valid_602080
  var valid_602081 = query.getOrDefault("Identifiers")
  valid_602081 = validateParameter(valid_602081, JArray, required = true, default = nil)
  if valid_602081 != nil:
    section.add "Identifiers", valid_602081
  var valid_602082 = query.getOrDefault("Version")
  valid_602082 = validateParameter(valid_602082, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602082 != nil:
    section.add "Version", valid_602082
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602083 = header.getOrDefault("X-Amz-Signature")
  valid_602083 = validateParameter(valid_602083, JString, required = false,
                                 default = nil)
  if valid_602083 != nil:
    section.add "X-Amz-Signature", valid_602083
  var valid_602084 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602084 = validateParameter(valid_602084, JString, required = false,
                                 default = nil)
  if valid_602084 != nil:
    section.add "X-Amz-Content-Sha256", valid_602084
  var valid_602085 = header.getOrDefault("X-Amz-Date")
  valid_602085 = validateParameter(valid_602085, JString, required = false,
                                 default = nil)
  if valid_602085 != nil:
    section.add "X-Amz-Date", valid_602085
  var valid_602086 = header.getOrDefault("X-Amz-Credential")
  valid_602086 = validateParameter(valid_602086, JString, required = false,
                                 default = nil)
  if valid_602086 != nil:
    section.add "X-Amz-Credential", valid_602086
  var valid_602087 = header.getOrDefault("X-Amz-Security-Token")
  valid_602087 = validateParameter(valid_602087, JString, required = false,
                                 default = nil)
  if valid_602087 != nil:
    section.add "X-Amz-Security-Token", valid_602087
  var valid_602088 = header.getOrDefault("X-Amz-Algorithm")
  valid_602088 = validateParameter(valid_602088, JString, required = false,
                                 default = nil)
  if valid_602088 != nil:
    section.add "X-Amz-Algorithm", valid_602088
  var valid_602089 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602089 = validateParameter(valid_602089, JString, required = false,
                                 default = nil)
  if valid_602089 != nil:
    section.add "X-Amz-SignedHeaders", valid_602089
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602090: Call_GetBatchDeleteClusterSnapshots_602077; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_602090.validator(path, query, header, formData, body)
  let scheme = call_602090.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602090.url(scheme.get, call_602090.host, call_602090.base,
                         call_602090.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602090, url, valid)

proc call*(call_602091: Call_GetBatchDeleteClusterSnapshots_602077;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Action: string (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: string (required)
  var query_602092 = newJObject()
  add(query_602092, "Action", newJString(Action))
  if Identifiers != nil:
    query_602092.add "Identifiers", Identifiers
  add(query_602092, "Version", newJString(Version))
  result = call_602091.call(nil, query_602092, nil, nil, nil)

var getBatchDeleteClusterSnapshots* = Call_GetBatchDeleteClusterSnapshots_602077(
    name: "getBatchDeleteClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_GetBatchDeleteClusterSnapshots_602078, base: "/",
    url: url_GetBatchDeleteClusterSnapshots_602079,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchModifyClusterSnapshots_602128 = ref object of OpenApiRestCall_601373
proc url_PostBatchModifyClusterSnapshots_602130(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchModifyClusterSnapshots_602129(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602131 = query.getOrDefault("Action")
  valid_602131 = validateParameter(valid_602131, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_602131 != nil:
    section.add "Action", valid_602131
  var valid_602132 = query.getOrDefault("Version")
  valid_602132 = validateParameter(valid_602132, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602132 != nil:
    section.add "Version", valid_602132
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602133 = header.getOrDefault("X-Amz-Signature")
  valid_602133 = validateParameter(valid_602133, JString, required = false,
                                 default = nil)
  if valid_602133 != nil:
    section.add "X-Amz-Signature", valid_602133
  var valid_602134 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602134 = validateParameter(valid_602134, JString, required = false,
                                 default = nil)
  if valid_602134 != nil:
    section.add "X-Amz-Content-Sha256", valid_602134
  var valid_602135 = header.getOrDefault("X-Amz-Date")
  valid_602135 = validateParameter(valid_602135, JString, required = false,
                                 default = nil)
  if valid_602135 != nil:
    section.add "X-Amz-Date", valid_602135
  var valid_602136 = header.getOrDefault("X-Amz-Credential")
  valid_602136 = validateParameter(valid_602136, JString, required = false,
                                 default = nil)
  if valid_602136 != nil:
    section.add "X-Amz-Credential", valid_602136
  var valid_602137 = header.getOrDefault("X-Amz-Security-Token")
  valid_602137 = validateParameter(valid_602137, JString, required = false,
                                 default = nil)
  if valid_602137 != nil:
    section.add "X-Amz-Security-Token", valid_602137
  var valid_602138 = header.getOrDefault("X-Amz-Algorithm")
  valid_602138 = validateParameter(valid_602138, JString, required = false,
                                 default = nil)
  if valid_602138 != nil:
    section.add "X-Amz-Algorithm", valid_602138
  var valid_602139 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602139 = validateParameter(valid_602139, JString, required = false,
                                 default = nil)
  if valid_602139 != nil:
    section.add "X-Amz-SignedHeaders", valid_602139
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  var valid_602140 = formData.getOrDefault("Force")
  valid_602140 = validateParameter(valid_602140, JBool, required = false, default = nil)
  if valid_602140 != nil:
    section.add "Force", valid_602140
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_602141 = formData.getOrDefault("SnapshotIdentifierList")
  valid_602141 = validateParameter(valid_602141, JArray, required = true, default = nil)
  if valid_602141 != nil:
    section.add "SnapshotIdentifierList", valid_602141
  var valid_602142 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602142 = validateParameter(valid_602142, JInt, required = false, default = nil)
  if valid_602142 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602142
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602143: Call_PostBatchModifyClusterSnapshots_602128;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_602143.validator(path, query, header, formData, body)
  let scheme = call_602143.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602143.url(scheme.get, call_602143.host, call_602143.base,
                         call_602143.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602143, url, valid)

proc call*(call_602144: Call_PostBatchModifyClusterSnapshots_602128;
          SnapshotIdentifierList: JsonNode; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  var query_602145 = newJObject()
  var formData_602146 = newJObject()
  add(formData_602146, "Force", newJBool(Force))
  if SnapshotIdentifierList != nil:
    formData_602146.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_602145, "Action", newJString(Action))
  add(query_602145, "Version", newJString(Version))
  add(formData_602146, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_602144.call(nil, query_602145, nil, formData_602146, nil)

var postBatchModifyClusterSnapshots* = Call_PostBatchModifyClusterSnapshots_602128(
    name: "postBatchModifyClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_PostBatchModifyClusterSnapshots_602129, base: "/",
    url: url_PostBatchModifyClusterSnapshots_602130,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchModifyClusterSnapshots_602110 = ref object of OpenApiRestCall_601373
proc url_GetBatchModifyClusterSnapshots_602112(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchModifyClusterSnapshots_602111(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   Action: JString (required)
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Version: JString (required)
  section = newJObject()
  var valid_602113 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602113 = validateParameter(valid_602113, JInt, required = false, default = nil)
  if valid_602113 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602113
  var valid_602114 = query.getOrDefault("Force")
  valid_602114 = validateParameter(valid_602114, JBool, required = false, default = nil)
  if valid_602114 != nil:
    section.add "Force", valid_602114
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602115 = query.getOrDefault("Action")
  valid_602115 = validateParameter(valid_602115, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_602115 != nil:
    section.add "Action", valid_602115
  var valid_602116 = query.getOrDefault("SnapshotIdentifierList")
  valid_602116 = validateParameter(valid_602116, JArray, required = true, default = nil)
  if valid_602116 != nil:
    section.add "SnapshotIdentifierList", valid_602116
  var valid_602117 = query.getOrDefault("Version")
  valid_602117 = validateParameter(valid_602117, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602117 != nil:
    section.add "Version", valid_602117
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602118 = header.getOrDefault("X-Amz-Signature")
  valid_602118 = validateParameter(valid_602118, JString, required = false,
                                 default = nil)
  if valid_602118 != nil:
    section.add "X-Amz-Signature", valid_602118
  var valid_602119 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602119 = validateParameter(valid_602119, JString, required = false,
                                 default = nil)
  if valid_602119 != nil:
    section.add "X-Amz-Content-Sha256", valid_602119
  var valid_602120 = header.getOrDefault("X-Amz-Date")
  valid_602120 = validateParameter(valid_602120, JString, required = false,
                                 default = nil)
  if valid_602120 != nil:
    section.add "X-Amz-Date", valid_602120
  var valid_602121 = header.getOrDefault("X-Amz-Credential")
  valid_602121 = validateParameter(valid_602121, JString, required = false,
                                 default = nil)
  if valid_602121 != nil:
    section.add "X-Amz-Credential", valid_602121
  var valid_602122 = header.getOrDefault("X-Amz-Security-Token")
  valid_602122 = validateParameter(valid_602122, JString, required = false,
                                 default = nil)
  if valid_602122 != nil:
    section.add "X-Amz-Security-Token", valid_602122
  var valid_602123 = header.getOrDefault("X-Amz-Algorithm")
  valid_602123 = validateParameter(valid_602123, JString, required = false,
                                 default = nil)
  if valid_602123 != nil:
    section.add "X-Amz-Algorithm", valid_602123
  var valid_602124 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602124 = validateParameter(valid_602124, JString, required = false,
                                 default = nil)
  if valid_602124 != nil:
    section.add "X-Amz-SignedHeaders", valid_602124
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602125: Call_GetBatchModifyClusterSnapshots_602110; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_602125.validator(path, query, header, formData, body)
  let scheme = call_602125.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602125.url(scheme.get, call_602125.host, call_602125.base,
                         call_602125.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602125, url, valid)

proc call*(call_602126: Call_GetBatchModifyClusterSnapshots_602110;
          SnapshotIdentifierList: JsonNode;
          ManualSnapshotRetentionPeriod: int = 0; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   Action: string (required)
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Version: string (required)
  var query_602127 = newJObject()
  add(query_602127, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_602127, "Force", newJBool(Force))
  add(query_602127, "Action", newJString(Action))
  if SnapshotIdentifierList != nil:
    query_602127.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_602127, "Version", newJString(Version))
  result = call_602126.call(nil, query_602127, nil, nil, nil)

var getBatchModifyClusterSnapshots* = Call_GetBatchModifyClusterSnapshots_602110(
    name: "getBatchModifyClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_GetBatchModifyClusterSnapshots_602111, base: "/",
    url: url_GetBatchModifyClusterSnapshots_602112,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCancelResize_602163 = ref object of OpenApiRestCall_601373
proc url_PostCancelResize_602165(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCancelResize_602164(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602166 = query.getOrDefault("Action")
  valid_602166 = validateParameter(valid_602166, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_602166 != nil:
    section.add "Action", valid_602166
  var valid_602167 = query.getOrDefault("Version")
  valid_602167 = validateParameter(valid_602167, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602167 != nil:
    section.add "Version", valid_602167
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602168 = header.getOrDefault("X-Amz-Signature")
  valid_602168 = validateParameter(valid_602168, JString, required = false,
                                 default = nil)
  if valid_602168 != nil:
    section.add "X-Amz-Signature", valid_602168
  var valid_602169 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602169 = validateParameter(valid_602169, JString, required = false,
                                 default = nil)
  if valid_602169 != nil:
    section.add "X-Amz-Content-Sha256", valid_602169
  var valid_602170 = header.getOrDefault("X-Amz-Date")
  valid_602170 = validateParameter(valid_602170, JString, required = false,
                                 default = nil)
  if valid_602170 != nil:
    section.add "X-Amz-Date", valid_602170
  var valid_602171 = header.getOrDefault("X-Amz-Credential")
  valid_602171 = validateParameter(valid_602171, JString, required = false,
                                 default = nil)
  if valid_602171 != nil:
    section.add "X-Amz-Credential", valid_602171
  var valid_602172 = header.getOrDefault("X-Amz-Security-Token")
  valid_602172 = validateParameter(valid_602172, JString, required = false,
                                 default = nil)
  if valid_602172 != nil:
    section.add "X-Amz-Security-Token", valid_602172
  var valid_602173 = header.getOrDefault("X-Amz-Algorithm")
  valid_602173 = validateParameter(valid_602173, JString, required = false,
                                 default = nil)
  if valid_602173 != nil:
    section.add "X-Amz-Algorithm", valid_602173
  var valid_602174 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602174 = validateParameter(valid_602174, JString, required = false,
                                 default = nil)
  if valid_602174 != nil:
    section.add "X-Amz-SignedHeaders", valid_602174
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_602175 = formData.getOrDefault("ClusterIdentifier")
  valid_602175 = validateParameter(valid_602175, JString, required = true,
                                 default = nil)
  if valid_602175 != nil:
    section.add "ClusterIdentifier", valid_602175
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602176: Call_PostCancelResize_602163; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_602176.validator(path, query, header, formData, body)
  let scheme = call_602176.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602176.url(scheme.get, call_602176.host, call_602176.base,
                         call_602176.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602176, url, valid)

proc call*(call_602177: Call_PostCancelResize_602163; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## postCancelResize
  ## Cancels a resize operation.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602178 = newJObject()
  var formData_602179 = newJObject()
  add(formData_602179, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602178, "Action", newJString(Action))
  add(query_602178, "Version", newJString(Version))
  result = call_602177.call(nil, query_602178, nil, formData_602179, nil)

var postCancelResize* = Call_PostCancelResize_602163(name: "postCancelResize",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_PostCancelResize_602164,
    base: "/", url: url_PostCancelResize_602165,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCancelResize_602147 = ref object of OpenApiRestCall_601373
proc url_GetCancelResize_602149(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCancelResize_602148(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602150 = query.getOrDefault("Action")
  valid_602150 = validateParameter(valid_602150, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_602150 != nil:
    section.add "Action", valid_602150
  var valid_602151 = query.getOrDefault("ClusterIdentifier")
  valid_602151 = validateParameter(valid_602151, JString, required = true,
                                 default = nil)
  if valid_602151 != nil:
    section.add "ClusterIdentifier", valid_602151
  var valid_602152 = query.getOrDefault("Version")
  valid_602152 = validateParameter(valid_602152, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602152 != nil:
    section.add "Version", valid_602152
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602153 = header.getOrDefault("X-Amz-Signature")
  valid_602153 = validateParameter(valid_602153, JString, required = false,
                                 default = nil)
  if valid_602153 != nil:
    section.add "X-Amz-Signature", valid_602153
  var valid_602154 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602154 = validateParameter(valid_602154, JString, required = false,
                                 default = nil)
  if valid_602154 != nil:
    section.add "X-Amz-Content-Sha256", valid_602154
  var valid_602155 = header.getOrDefault("X-Amz-Date")
  valid_602155 = validateParameter(valid_602155, JString, required = false,
                                 default = nil)
  if valid_602155 != nil:
    section.add "X-Amz-Date", valid_602155
  var valid_602156 = header.getOrDefault("X-Amz-Credential")
  valid_602156 = validateParameter(valid_602156, JString, required = false,
                                 default = nil)
  if valid_602156 != nil:
    section.add "X-Amz-Credential", valid_602156
  var valid_602157 = header.getOrDefault("X-Amz-Security-Token")
  valid_602157 = validateParameter(valid_602157, JString, required = false,
                                 default = nil)
  if valid_602157 != nil:
    section.add "X-Amz-Security-Token", valid_602157
  var valid_602158 = header.getOrDefault("X-Amz-Algorithm")
  valid_602158 = validateParameter(valid_602158, JString, required = false,
                                 default = nil)
  if valid_602158 != nil:
    section.add "X-Amz-Algorithm", valid_602158
  var valid_602159 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602159 = validateParameter(valid_602159, JString, required = false,
                                 default = nil)
  if valid_602159 != nil:
    section.add "X-Amz-SignedHeaders", valid_602159
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602160: Call_GetCancelResize_602147; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_602160.validator(path, query, header, formData, body)
  let scheme = call_602160.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602160.url(scheme.get, call_602160.host, call_602160.base,
                         call_602160.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602160, url, valid)

proc call*(call_602161: Call_GetCancelResize_602147; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## getCancelResize
  ## Cancels a resize operation.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_602162 = newJObject()
  add(query_602162, "Action", newJString(Action))
  add(query_602162, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602162, "Version", newJString(Version))
  result = call_602161.call(nil, query_602162, nil, nil, nil)

var getCancelResize* = Call_GetCancelResize_602147(name: "getCancelResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_GetCancelResize_602148,
    base: "/", url: url_GetCancelResize_602149, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCopyClusterSnapshot_602199 = ref object of OpenApiRestCall_601373
proc url_PostCopyClusterSnapshot_602201(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCopyClusterSnapshot_602200(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602202 = query.getOrDefault("Action")
  valid_602202 = validateParameter(valid_602202, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_602202 != nil:
    section.add "Action", valid_602202
  var valid_602203 = query.getOrDefault("Version")
  valid_602203 = validateParameter(valid_602203, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602203 != nil:
    section.add "Version", valid_602203
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602204 = header.getOrDefault("X-Amz-Signature")
  valid_602204 = validateParameter(valid_602204, JString, required = false,
                                 default = nil)
  if valid_602204 != nil:
    section.add "X-Amz-Signature", valid_602204
  var valid_602205 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602205 = validateParameter(valid_602205, JString, required = false,
                                 default = nil)
  if valid_602205 != nil:
    section.add "X-Amz-Content-Sha256", valid_602205
  var valid_602206 = header.getOrDefault("X-Amz-Date")
  valid_602206 = validateParameter(valid_602206, JString, required = false,
                                 default = nil)
  if valid_602206 != nil:
    section.add "X-Amz-Date", valid_602206
  var valid_602207 = header.getOrDefault("X-Amz-Credential")
  valid_602207 = validateParameter(valid_602207, JString, required = false,
                                 default = nil)
  if valid_602207 != nil:
    section.add "X-Amz-Credential", valid_602207
  var valid_602208 = header.getOrDefault("X-Amz-Security-Token")
  valid_602208 = validateParameter(valid_602208, JString, required = false,
                                 default = nil)
  if valid_602208 != nil:
    section.add "X-Amz-Security-Token", valid_602208
  var valid_602209 = header.getOrDefault("X-Amz-Algorithm")
  valid_602209 = validateParameter(valid_602209, JString, required = false,
                                 default = nil)
  if valid_602209 != nil:
    section.add "X-Amz-Algorithm", valid_602209
  var valid_602210 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602210 = validateParameter(valid_602210, JString, required = false,
                                 default = nil)
  if valid_602210 != nil:
    section.add "X-Amz-SignedHeaders", valid_602210
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_602211 = formData.getOrDefault("SourceSnapshotIdentifier")
  valid_602211 = validateParameter(valid_602211, JString, required = true,
                                 default = nil)
  if valid_602211 != nil:
    section.add "SourceSnapshotIdentifier", valid_602211
  var valid_602212 = formData.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_602212 = validateParameter(valid_602212, JString, required = false,
                                 default = nil)
  if valid_602212 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_602212
  var valid_602213 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602213 = validateParameter(valid_602213, JInt, required = false, default = nil)
  if valid_602213 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602213
  var valid_602214 = formData.getOrDefault("TargetSnapshotIdentifier")
  valid_602214 = validateParameter(valid_602214, JString, required = true,
                                 default = nil)
  if valid_602214 != nil:
    section.add "TargetSnapshotIdentifier", valid_602214
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602215: Call_PostCopyClusterSnapshot_602199; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602215.validator(path, query, header, formData, body)
  let scheme = call_602215.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602215.url(scheme.get, call_602215.host, call_602215.base,
                         call_602215.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602215, url, valid)

proc call*(call_602216: Call_PostCopyClusterSnapshot_602199;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          SourceSnapshotClusterIdentifier: string = "";
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  var query_602217 = newJObject()
  var formData_602218 = newJObject()
  add(formData_602218, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(formData_602218, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(query_602217, "Action", newJString(Action))
  add(query_602217, "Version", newJString(Version))
  add(formData_602218, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_602218, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  result = call_602216.call(nil, query_602217, nil, formData_602218, nil)

var postCopyClusterSnapshot* = Call_PostCopyClusterSnapshot_602199(
    name: "postCopyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_PostCopyClusterSnapshot_602200, base: "/",
    url: url_PostCopyClusterSnapshot_602201, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCopyClusterSnapshot_602180 = ref object of OpenApiRestCall_601373
proc url_GetCopyClusterSnapshot_602182(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCopyClusterSnapshot_602181(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  section = newJObject()
  var valid_602183 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602183 = validateParameter(valid_602183, JInt, required = false, default = nil)
  if valid_602183 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602183
  assert query != nil, "query argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_602184 = query.getOrDefault("SourceSnapshotIdentifier")
  valid_602184 = validateParameter(valid_602184, JString, required = true,
                                 default = nil)
  if valid_602184 != nil:
    section.add "SourceSnapshotIdentifier", valid_602184
  var valid_602185 = query.getOrDefault("TargetSnapshotIdentifier")
  valid_602185 = validateParameter(valid_602185, JString, required = true,
                                 default = nil)
  if valid_602185 != nil:
    section.add "TargetSnapshotIdentifier", valid_602185
  var valid_602186 = query.getOrDefault("Action")
  valid_602186 = validateParameter(valid_602186, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_602186 != nil:
    section.add "Action", valid_602186
  var valid_602187 = query.getOrDefault("Version")
  valid_602187 = validateParameter(valid_602187, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602187 != nil:
    section.add "Version", valid_602187
  var valid_602188 = query.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_602188 = validateParameter(valid_602188, JString, required = false,
                                 default = nil)
  if valid_602188 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_602188
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602189 = header.getOrDefault("X-Amz-Signature")
  valid_602189 = validateParameter(valid_602189, JString, required = false,
                                 default = nil)
  if valid_602189 != nil:
    section.add "X-Amz-Signature", valid_602189
  var valid_602190 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602190 = validateParameter(valid_602190, JString, required = false,
                                 default = nil)
  if valid_602190 != nil:
    section.add "X-Amz-Content-Sha256", valid_602190
  var valid_602191 = header.getOrDefault("X-Amz-Date")
  valid_602191 = validateParameter(valid_602191, JString, required = false,
                                 default = nil)
  if valid_602191 != nil:
    section.add "X-Amz-Date", valid_602191
  var valid_602192 = header.getOrDefault("X-Amz-Credential")
  valid_602192 = validateParameter(valid_602192, JString, required = false,
                                 default = nil)
  if valid_602192 != nil:
    section.add "X-Amz-Credential", valid_602192
  var valid_602193 = header.getOrDefault("X-Amz-Security-Token")
  valid_602193 = validateParameter(valid_602193, JString, required = false,
                                 default = nil)
  if valid_602193 != nil:
    section.add "X-Amz-Security-Token", valid_602193
  var valid_602194 = header.getOrDefault("X-Amz-Algorithm")
  valid_602194 = validateParameter(valid_602194, JString, required = false,
                                 default = nil)
  if valid_602194 != nil:
    section.add "X-Amz-Algorithm", valid_602194
  var valid_602195 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602195 = validateParameter(valid_602195, JString, required = false,
                                 default = nil)
  if valid_602195 != nil:
    section.add "X-Amz-SignedHeaders", valid_602195
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602196: Call_GetCopyClusterSnapshot_602180; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602196.validator(path, query, header, formData, body)
  let scheme = call_602196.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602196.url(scheme.get, call_602196.host, call_602196.base,
                         call_602196.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602196, url, valid)

proc call*(call_602197: Call_GetCopyClusterSnapshot_602180;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0;
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          SourceSnapshotClusterIdentifier: string = ""): Recallable =
  ## getCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  var query_602198 = newJObject()
  add(query_602198, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_602198, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(query_602198, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_602198, "Action", newJString(Action))
  add(query_602198, "Version", newJString(Version))
  add(query_602198, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  result = call_602197.call(nil, query_602198, nil, nil, nil)

var getCopyClusterSnapshot* = Call_GetCopyClusterSnapshot_602180(
    name: "getCopyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_GetCopyClusterSnapshot_602181, base: "/",
    url: url_GetCopyClusterSnapshot_602182, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateCluster_602264 = ref object of OpenApiRestCall_601373
proc url_PostCreateCluster_602266(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateCluster_602265(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602267 = query.getOrDefault("Action")
  valid_602267 = validateParameter(valid_602267, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_602267 != nil:
    section.add "Action", valid_602267
  var valid_602268 = query.getOrDefault("Version")
  valid_602268 = validateParameter(valid_602268, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602268 != nil:
    section.add "Version", valid_602268
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602269 = header.getOrDefault("X-Amz-Signature")
  valid_602269 = validateParameter(valid_602269, JString, required = false,
                                 default = nil)
  if valid_602269 != nil:
    section.add "X-Amz-Signature", valid_602269
  var valid_602270 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602270 = validateParameter(valid_602270, JString, required = false,
                                 default = nil)
  if valid_602270 != nil:
    section.add "X-Amz-Content-Sha256", valid_602270
  var valid_602271 = header.getOrDefault("X-Amz-Date")
  valid_602271 = validateParameter(valid_602271, JString, required = false,
                                 default = nil)
  if valid_602271 != nil:
    section.add "X-Amz-Date", valid_602271
  var valid_602272 = header.getOrDefault("X-Amz-Credential")
  valid_602272 = validateParameter(valid_602272, JString, required = false,
                                 default = nil)
  if valid_602272 != nil:
    section.add "X-Amz-Credential", valid_602272
  var valid_602273 = header.getOrDefault("X-Amz-Security-Token")
  valid_602273 = validateParameter(valid_602273, JString, required = false,
                                 default = nil)
  if valid_602273 != nil:
    section.add "X-Amz-Security-Token", valid_602273
  var valid_602274 = header.getOrDefault("X-Amz-Algorithm")
  valid_602274 = validateParameter(valid_602274, JString, required = false,
                                 default = nil)
  if valid_602274 != nil:
    section.add "X-Amz-Algorithm", valid_602274
  var valid_602275 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602275 = validateParameter(valid_602275, JString, required = false,
                                 default = nil)
  if valid_602275 != nil:
    section.add "X-Amz-SignedHeaders", valid_602275
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_602276 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_602276 = validateParameter(valid_602276, JString, required = false,
                                 default = nil)
  if valid_602276 != nil:
    section.add "PreferredMaintenanceWindow", valid_602276
  var valid_602277 = formData.getOrDefault("Port")
  valid_602277 = validateParameter(valid_602277, JInt, required = false, default = nil)
  if valid_602277 != nil:
    section.add "Port", valid_602277
  assert formData != nil,
        "formData argument is necessary due to required `NodeType` field"
  var valid_602278 = formData.getOrDefault("NodeType")
  valid_602278 = validateParameter(valid_602278, JString, required = true,
                                 default = nil)
  if valid_602278 != nil:
    section.add "NodeType", valid_602278
  var valid_602279 = formData.getOrDefault("ClusterIdentifier")
  valid_602279 = validateParameter(valid_602279, JString, required = true,
                                 default = nil)
  if valid_602279 != nil:
    section.add "ClusterIdentifier", valid_602279
  var valid_602280 = formData.getOrDefault("MasterUserPassword")
  valid_602280 = validateParameter(valid_602280, JString, required = true,
                                 default = nil)
  if valid_602280 != nil:
    section.add "MasterUserPassword", valid_602280
  var valid_602281 = formData.getOrDefault("MaintenanceTrackName")
  valid_602281 = validateParameter(valid_602281, JString, required = false,
                                 default = nil)
  if valid_602281 != nil:
    section.add "MaintenanceTrackName", valid_602281
  var valid_602282 = formData.getOrDefault("MasterUsername")
  valid_602282 = validateParameter(valid_602282, JString, required = true,
                                 default = nil)
  if valid_602282 != nil:
    section.add "MasterUsername", valid_602282
  var valid_602283 = formData.getOrDefault("ClusterSecurityGroups")
  valid_602283 = validateParameter(valid_602283, JArray, required = false,
                                 default = nil)
  if valid_602283 != nil:
    section.add "ClusterSecurityGroups", valid_602283
  var valid_602284 = formData.getOrDefault("IamRoles")
  valid_602284 = validateParameter(valid_602284, JArray, required = false,
                                 default = nil)
  if valid_602284 != nil:
    section.add "IamRoles", valid_602284
  var valid_602285 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_602285 = validateParameter(valid_602285, JArray, required = false,
                                 default = nil)
  if valid_602285 != nil:
    section.add "VpcSecurityGroupIds", valid_602285
  var valid_602286 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_602286 = validateParameter(valid_602286, JInt, required = false, default = nil)
  if valid_602286 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_602286
  var valid_602287 = formData.getOrDefault("AvailabilityZone")
  valid_602287 = validateParameter(valid_602287, JString, required = false,
                                 default = nil)
  if valid_602287 != nil:
    section.add "AvailabilityZone", valid_602287
  var valid_602288 = formData.getOrDefault("NumberOfNodes")
  valid_602288 = validateParameter(valid_602288, JInt, required = false, default = nil)
  if valid_602288 != nil:
    section.add "NumberOfNodes", valid_602288
  var valid_602289 = formData.getOrDefault("KmsKeyId")
  valid_602289 = validateParameter(valid_602289, JString, required = false,
                                 default = nil)
  if valid_602289 != nil:
    section.add "KmsKeyId", valid_602289
  var valid_602290 = formData.getOrDefault("EnhancedVpcRouting")
  valid_602290 = validateParameter(valid_602290, JBool, required = false, default = nil)
  if valid_602290 != nil:
    section.add "EnhancedVpcRouting", valid_602290
  var valid_602291 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_602291 = validateParameter(valid_602291, JString, required = false,
                                 default = nil)
  if valid_602291 != nil:
    section.add "ClusterSubnetGroupName", valid_602291
  var valid_602292 = formData.getOrDefault("AllowVersionUpgrade")
  valid_602292 = validateParameter(valid_602292, JBool, required = false, default = nil)
  if valid_602292 != nil:
    section.add "AllowVersionUpgrade", valid_602292
  var valid_602293 = formData.getOrDefault("DBName")
  valid_602293 = validateParameter(valid_602293, JString, required = false,
                                 default = nil)
  if valid_602293 != nil:
    section.add "DBName", valid_602293
  var valid_602294 = formData.getOrDefault("PubliclyAccessible")
  valid_602294 = validateParameter(valid_602294, JBool, required = false, default = nil)
  if valid_602294 != nil:
    section.add "PubliclyAccessible", valid_602294
  var valid_602295 = formData.getOrDefault("ClusterParameterGroupName")
  valid_602295 = validateParameter(valid_602295, JString, required = false,
                                 default = nil)
  if valid_602295 != nil:
    section.add "ClusterParameterGroupName", valid_602295
  var valid_602296 = formData.getOrDefault("ClusterVersion")
  valid_602296 = validateParameter(valid_602296, JString, required = false,
                                 default = nil)
  if valid_602296 != nil:
    section.add "ClusterVersion", valid_602296
  var valid_602297 = formData.getOrDefault("ClusterType")
  valid_602297 = validateParameter(valid_602297, JString, required = false,
                                 default = nil)
  if valid_602297 != nil:
    section.add "ClusterType", valid_602297
  var valid_602298 = formData.getOrDefault("Encrypted")
  valid_602298 = validateParameter(valid_602298, JBool, required = false, default = nil)
  if valid_602298 != nil:
    section.add "Encrypted", valid_602298
  var valid_602299 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_602299 = validateParameter(valid_602299, JString, required = false,
                                 default = nil)
  if valid_602299 != nil:
    section.add "HsmClientCertificateIdentifier", valid_602299
  var valid_602300 = formData.getOrDefault("Tags")
  valid_602300 = validateParameter(valid_602300, JArray, required = false,
                                 default = nil)
  if valid_602300 != nil:
    section.add "Tags", valid_602300
  var valid_602301 = formData.getOrDefault("AdditionalInfo")
  valid_602301 = validateParameter(valid_602301, JString, required = false,
                                 default = nil)
  if valid_602301 != nil:
    section.add "AdditionalInfo", valid_602301
  var valid_602302 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_602302 = validateParameter(valid_602302, JString, required = false,
                                 default = nil)
  if valid_602302 != nil:
    section.add "SnapshotScheduleIdentifier", valid_602302
  var valid_602303 = formData.getOrDefault("ElasticIp")
  valid_602303 = validateParameter(valid_602303, JString, required = false,
                                 default = nil)
  if valid_602303 != nil:
    section.add "ElasticIp", valid_602303
  var valid_602304 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_602304 = validateParameter(valid_602304, JString, required = false,
                                 default = nil)
  if valid_602304 != nil:
    section.add "HsmConfigurationIdentifier", valid_602304
  var valid_602305 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602305 = validateParameter(valid_602305, JInt, required = false, default = nil)
  if valid_602305 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602305
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602306: Call_PostCreateCluster_602264; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602306.validator(path, query, header, formData, body)
  let scheme = call_602306.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602306.url(scheme.get, call_602306.host, call_602306.base,
                         call_602306.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602306, url, valid)

proc call*(call_602307: Call_PostCreateCluster_602264; NodeType: string;
          ClusterIdentifier: string; MasterUserPassword: string;
          MasterUsername: string; PreferredMaintenanceWindow: string = "";
          Port: int = 0; MaintenanceTrackName: string = "";
          ClusterSecurityGroups: JsonNode = nil; IamRoles: JsonNode = nil;
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0; AvailabilityZone: string = "";
          NumberOfNodes: int = 0; KmsKeyId: string = "";
          EnhancedVpcRouting: bool = false; ClusterSubnetGroupName: string = "";
          AllowVersionUpgrade: bool = false; DBName: string = "";
          PubliclyAccessible: bool = false; Action: string = "CreateCluster";
          ClusterParameterGroupName: string = ""; ClusterVersion: string = "";
          ClusterType: string = ""; Encrypted: bool = false;
          HsmClientCertificateIdentifier: string = ""; Tags: JsonNode = nil;
          AdditionalInfo: string = ""; SnapshotScheduleIdentifier: string = "";
          Version: string = "2012-12-01"; ElasticIp: string = "";
          HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_602308 = newJObject()
  var formData_602309 = newJObject()
  add(formData_602309, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_602309, "Port", newJInt(Port))
  add(formData_602309, "NodeType", newJString(NodeType))
  add(formData_602309, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_602309, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_602309, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_602309, "MasterUsername", newJString(MasterUsername))
  if ClusterSecurityGroups != nil:
    formData_602309.add "ClusterSecurityGroups", ClusterSecurityGroups
  if IamRoles != nil:
    formData_602309.add "IamRoles", IamRoles
  if VpcSecurityGroupIds != nil:
    formData_602309.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_602309, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_602309, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_602309, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_602309, "KmsKeyId", newJString(KmsKeyId))
  add(formData_602309, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_602309, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_602309, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_602309, "DBName", newJString(DBName))
  add(formData_602309, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_602308, "Action", newJString(Action))
  add(formData_602309, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_602309, "ClusterVersion", newJString(ClusterVersion))
  add(formData_602309, "ClusterType", newJString(ClusterType))
  add(formData_602309, "Encrypted", newJBool(Encrypted))
  add(formData_602309, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    formData_602309.add "Tags", Tags
  add(formData_602309, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_602309, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_602308, "Version", newJString(Version))
  add(formData_602309, "ElasticIp", newJString(ElasticIp))
  add(formData_602309, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_602309, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_602307.call(nil, query_602308, nil, formData_602309, nil)

var postCreateCluster* = Call_PostCreateCluster_602264(name: "postCreateCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_PostCreateCluster_602265,
    base: "/", url: url_PostCreateCluster_602266,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateCluster_602219 = ref object of OpenApiRestCall_601373
proc url_GetCreateCluster_602221(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateCluster_602220(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  section = newJObject()
  var valid_602222 = query.getOrDefault("ClusterSubnetGroupName")
  valid_602222 = validateParameter(valid_602222, JString, required = false,
                                 default = nil)
  if valid_602222 != nil:
    section.add "ClusterSubnetGroupName", valid_602222
  var valid_602223 = query.getOrDefault("MaintenanceTrackName")
  valid_602223 = validateParameter(valid_602223, JString, required = false,
                                 default = nil)
  if valid_602223 != nil:
    section.add "MaintenanceTrackName", valid_602223
  var valid_602224 = query.getOrDefault("DBName")
  valid_602224 = validateParameter(valid_602224, JString, required = false,
                                 default = nil)
  if valid_602224 != nil:
    section.add "DBName", valid_602224
  var valid_602225 = query.getOrDefault("Encrypted")
  valid_602225 = validateParameter(valid_602225, JBool, required = false, default = nil)
  if valid_602225 != nil:
    section.add "Encrypted", valid_602225
  var valid_602226 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602226 = validateParameter(valid_602226, JInt, required = false, default = nil)
  if valid_602226 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602226
  var valid_602227 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_602227 = validateParameter(valid_602227, JString, required = false,
                                 default = nil)
  if valid_602227 != nil:
    section.add "HsmClientCertificateIdentifier", valid_602227
  var valid_602228 = query.getOrDefault("ClusterSecurityGroups")
  valid_602228 = validateParameter(valid_602228, JArray, required = false,
                                 default = nil)
  if valid_602228 != nil:
    section.add "ClusterSecurityGroups", valid_602228
  var valid_602229 = query.getOrDefault("Tags")
  valid_602229 = validateParameter(valid_602229, JArray, required = false,
                                 default = nil)
  if valid_602229 != nil:
    section.add "Tags", valid_602229
  var valid_602230 = query.getOrDefault("KmsKeyId")
  valid_602230 = validateParameter(valid_602230, JString, required = false,
                                 default = nil)
  if valid_602230 != nil:
    section.add "KmsKeyId", valid_602230
  var valid_602231 = query.getOrDefault("ClusterParameterGroupName")
  valid_602231 = validateParameter(valid_602231, JString, required = false,
                                 default = nil)
  if valid_602231 != nil:
    section.add "ClusterParameterGroupName", valid_602231
  assert query != nil,
        "query argument is necessary due to required `NodeType` field"
  var valid_602232 = query.getOrDefault("NodeType")
  valid_602232 = validateParameter(valid_602232, JString, required = true,
                                 default = nil)
  if valid_602232 != nil:
    section.add "NodeType", valid_602232
  var valid_602233 = query.getOrDefault("ClusterVersion")
  valid_602233 = validateParameter(valid_602233, JString, required = false,
                                 default = nil)
  if valid_602233 != nil:
    section.add "ClusterVersion", valid_602233
  var valid_602234 = query.getOrDefault("IamRoles")
  valid_602234 = validateParameter(valid_602234, JArray, required = false,
                                 default = nil)
  if valid_602234 != nil:
    section.add "IamRoles", valid_602234
  var valid_602235 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_602235 = validateParameter(valid_602235, JString, required = false,
                                 default = nil)
  if valid_602235 != nil:
    section.add "SnapshotScheduleIdentifier", valid_602235
  var valid_602236 = query.getOrDefault("ClusterType")
  valid_602236 = validateParameter(valid_602236, JString, required = false,
                                 default = nil)
  if valid_602236 != nil:
    section.add "ClusterType", valid_602236
  var valid_602237 = query.getOrDefault("NumberOfNodes")
  valid_602237 = validateParameter(valid_602237, JInt, required = false, default = nil)
  if valid_602237 != nil:
    section.add "NumberOfNodes", valid_602237
  var valid_602238 = query.getOrDefault("MasterUsername")
  valid_602238 = validateParameter(valid_602238, JString, required = true,
                                 default = nil)
  if valid_602238 != nil:
    section.add "MasterUsername", valid_602238
  var valid_602239 = query.getOrDefault("AdditionalInfo")
  valid_602239 = validateParameter(valid_602239, JString, required = false,
                                 default = nil)
  if valid_602239 != nil:
    section.add "AdditionalInfo", valid_602239
  var valid_602240 = query.getOrDefault("AllowVersionUpgrade")
  valid_602240 = validateParameter(valid_602240, JBool, required = false, default = nil)
  if valid_602240 != nil:
    section.add "AllowVersionUpgrade", valid_602240
  var valid_602241 = query.getOrDefault("ElasticIp")
  valid_602241 = validateParameter(valid_602241, JString, required = false,
                                 default = nil)
  if valid_602241 != nil:
    section.add "ElasticIp", valid_602241
  var valid_602242 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_602242 = validateParameter(valid_602242, JInt, required = false, default = nil)
  if valid_602242 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_602242
  var valid_602243 = query.getOrDefault("EnhancedVpcRouting")
  valid_602243 = validateParameter(valid_602243, JBool, required = false, default = nil)
  if valid_602243 != nil:
    section.add "EnhancedVpcRouting", valid_602243
  var valid_602244 = query.getOrDefault("Action")
  valid_602244 = validateParameter(valid_602244, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_602244 != nil:
    section.add "Action", valid_602244
  var valid_602245 = query.getOrDefault("ClusterIdentifier")
  valid_602245 = validateParameter(valid_602245, JString, required = true,
                                 default = nil)
  if valid_602245 != nil:
    section.add "ClusterIdentifier", valid_602245
  var valid_602246 = query.getOrDefault("Port")
  valid_602246 = validateParameter(valid_602246, JInt, required = false, default = nil)
  if valid_602246 != nil:
    section.add "Port", valid_602246
  var valid_602247 = query.getOrDefault("VpcSecurityGroupIds")
  valid_602247 = validateParameter(valid_602247, JArray, required = false,
                                 default = nil)
  if valid_602247 != nil:
    section.add "VpcSecurityGroupIds", valid_602247
  var valid_602248 = query.getOrDefault("MasterUserPassword")
  valid_602248 = validateParameter(valid_602248, JString, required = true,
                                 default = nil)
  if valid_602248 != nil:
    section.add "MasterUserPassword", valid_602248
  var valid_602249 = query.getOrDefault("AvailabilityZone")
  valid_602249 = validateParameter(valid_602249, JString, required = false,
                                 default = nil)
  if valid_602249 != nil:
    section.add "AvailabilityZone", valid_602249
  var valid_602250 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_602250 = validateParameter(valid_602250, JString, required = false,
                                 default = nil)
  if valid_602250 != nil:
    section.add "HsmConfigurationIdentifier", valid_602250
  var valid_602251 = query.getOrDefault("Version")
  valid_602251 = validateParameter(valid_602251, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602251 != nil:
    section.add "Version", valid_602251
  var valid_602252 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_602252 = validateParameter(valid_602252, JString, required = false,
                                 default = nil)
  if valid_602252 != nil:
    section.add "PreferredMaintenanceWindow", valid_602252
  var valid_602253 = query.getOrDefault("PubliclyAccessible")
  valid_602253 = validateParameter(valid_602253, JBool, required = false, default = nil)
  if valid_602253 != nil:
    section.add "PubliclyAccessible", valid_602253
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602254 = header.getOrDefault("X-Amz-Signature")
  valid_602254 = validateParameter(valid_602254, JString, required = false,
                                 default = nil)
  if valid_602254 != nil:
    section.add "X-Amz-Signature", valid_602254
  var valid_602255 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602255 = validateParameter(valid_602255, JString, required = false,
                                 default = nil)
  if valid_602255 != nil:
    section.add "X-Amz-Content-Sha256", valid_602255
  var valid_602256 = header.getOrDefault("X-Amz-Date")
  valid_602256 = validateParameter(valid_602256, JString, required = false,
                                 default = nil)
  if valid_602256 != nil:
    section.add "X-Amz-Date", valid_602256
  var valid_602257 = header.getOrDefault("X-Amz-Credential")
  valid_602257 = validateParameter(valid_602257, JString, required = false,
                                 default = nil)
  if valid_602257 != nil:
    section.add "X-Amz-Credential", valid_602257
  var valid_602258 = header.getOrDefault("X-Amz-Security-Token")
  valid_602258 = validateParameter(valid_602258, JString, required = false,
                                 default = nil)
  if valid_602258 != nil:
    section.add "X-Amz-Security-Token", valid_602258
  var valid_602259 = header.getOrDefault("X-Amz-Algorithm")
  valid_602259 = validateParameter(valid_602259, JString, required = false,
                                 default = nil)
  if valid_602259 != nil:
    section.add "X-Amz-Algorithm", valid_602259
  var valid_602260 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602260 = validateParameter(valid_602260, JString, required = false,
                                 default = nil)
  if valid_602260 != nil:
    section.add "X-Amz-SignedHeaders", valid_602260
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602261: Call_GetCreateCluster_602219; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602261.validator(path, query, header, formData, body)
  let scheme = call_602261.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602261.url(scheme.get, call_602261.host, call_602261.base,
                         call_602261.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602261, url, valid)

proc call*(call_602262: Call_GetCreateCluster_602219; NodeType: string;
          MasterUsername: string; ClusterIdentifier: string;
          MasterUserPassword: string; ClusterSubnetGroupName: string = "";
          MaintenanceTrackName: string = ""; DBName: string = "";
          Encrypted: bool = false; ManualSnapshotRetentionPeriod: int = 0;
          HsmClientCertificateIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil; Tags: JsonNode = nil;
          KmsKeyId: string = ""; ClusterParameterGroupName: string = "";
          ClusterVersion: string = ""; IamRoles: JsonNode = nil;
          SnapshotScheduleIdentifier: string = ""; ClusterType: string = "";
          NumberOfNodes: int = 0; AdditionalInfo: string = "";
          AllowVersionUpgrade: bool = false; ElasticIp: string = "";
          AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false; Action: string = "CreateCluster";
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil;
          AvailabilityZone: string = ""; HsmConfigurationIdentifier: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  var query_602263 = newJObject()
  add(query_602263, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_602263, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_602263, "DBName", newJString(DBName))
  add(query_602263, "Encrypted", newJBool(Encrypted))
  add(query_602263, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_602263, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if ClusterSecurityGroups != nil:
    query_602263.add "ClusterSecurityGroups", ClusterSecurityGroups
  if Tags != nil:
    query_602263.add "Tags", Tags
  add(query_602263, "KmsKeyId", newJString(KmsKeyId))
  add(query_602263, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_602263, "NodeType", newJString(NodeType))
  add(query_602263, "ClusterVersion", newJString(ClusterVersion))
  if IamRoles != nil:
    query_602263.add "IamRoles", IamRoles
  add(query_602263, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_602263, "ClusterType", newJString(ClusterType))
  add(query_602263, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_602263, "MasterUsername", newJString(MasterUsername))
  add(query_602263, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_602263, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_602263, "ElasticIp", newJString(ElasticIp))
  add(query_602263, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_602263, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_602263, "Action", newJString(Action))
  add(query_602263, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602263, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    query_602263.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_602263, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_602263, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_602263, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_602263, "Version", newJString(Version))
  add(query_602263, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_602263, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_602262.call(nil, query_602263, nil, nil, nil)

var getCreateCluster* = Call_GetCreateCluster_602219(name: "getCreateCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_GetCreateCluster_602220,
    base: "/", url: url_GetCreateCluster_602221,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterParameterGroup_602329 = ref object of OpenApiRestCall_601373
proc url_PostCreateClusterParameterGroup_602331(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterParameterGroup_602330(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602332 = query.getOrDefault("Action")
  valid_602332 = validateParameter(valid_602332, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_602332 != nil:
    section.add "Action", valid_602332
  var valid_602333 = query.getOrDefault("Version")
  valid_602333 = validateParameter(valid_602333, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602333 != nil:
    section.add "Version", valid_602333
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602334 = header.getOrDefault("X-Amz-Signature")
  valid_602334 = validateParameter(valid_602334, JString, required = false,
                                 default = nil)
  if valid_602334 != nil:
    section.add "X-Amz-Signature", valid_602334
  var valid_602335 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602335 = validateParameter(valid_602335, JString, required = false,
                                 default = nil)
  if valid_602335 != nil:
    section.add "X-Amz-Content-Sha256", valid_602335
  var valid_602336 = header.getOrDefault("X-Amz-Date")
  valid_602336 = validateParameter(valid_602336, JString, required = false,
                                 default = nil)
  if valid_602336 != nil:
    section.add "X-Amz-Date", valid_602336
  var valid_602337 = header.getOrDefault("X-Amz-Credential")
  valid_602337 = validateParameter(valid_602337, JString, required = false,
                                 default = nil)
  if valid_602337 != nil:
    section.add "X-Amz-Credential", valid_602337
  var valid_602338 = header.getOrDefault("X-Amz-Security-Token")
  valid_602338 = validateParameter(valid_602338, JString, required = false,
                                 default = nil)
  if valid_602338 != nil:
    section.add "X-Amz-Security-Token", valid_602338
  var valid_602339 = header.getOrDefault("X-Amz-Algorithm")
  valid_602339 = validateParameter(valid_602339, JString, required = false,
                                 default = nil)
  if valid_602339 != nil:
    section.add "X-Amz-Algorithm", valid_602339
  var valid_602340 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602340 = validateParameter(valid_602340, JString, required = false,
                                 default = nil)
  if valid_602340 != nil:
    section.add "X-Amz-SignedHeaders", valid_602340
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_602341 = formData.getOrDefault("Description")
  valid_602341 = validateParameter(valid_602341, JString, required = true,
                                 default = nil)
  if valid_602341 != nil:
    section.add "Description", valid_602341
  var valid_602342 = formData.getOrDefault("ParameterGroupFamily")
  valid_602342 = validateParameter(valid_602342, JString, required = true,
                                 default = nil)
  if valid_602342 != nil:
    section.add "ParameterGroupFamily", valid_602342
  var valid_602343 = formData.getOrDefault("Tags")
  valid_602343 = validateParameter(valid_602343, JArray, required = false,
                                 default = nil)
  if valid_602343 != nil:
    section.add "Tags", valid_602343
  var valid_602344 = formData.getOrDefault("ParameterGroupName")
  valid_602344 = validateParameter(valid_602344, JString, required = true,
                                 default = nil)
  if valid_602344 != nil:
    section.add "ParameterGroupName", valid_602344
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602345: Call_PostCreateClusterParameterGroup_602329;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602345.validator(path, query, header, formData, body)
  let scheme = call_602345.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602345.url(scheme.get, call_602345.host, call_602345.base,
                         call_602345.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602345, url, valid)

proc call*(call_602346: Call_PostCreateClusterParameterGroup_602329;
          Description: string; ParameterGroupFamily: string;
          ParameterGroupName: string;
          Action: string = "CreateClusterParameterGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: string (required)
  var query_602347 = newJObject()
  var formData_602348 = newJObject()
  add(formData_602348, "Description", newJString(Description))
  add(formData_602348, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_602347, "Action", newJString(Action))
  if Tags != nil:
    formData_602348.add "Tags", Tags
  add(formData_602348, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_602347, "Version", newJString(Version))
  result = call_602346.call(nil, query_602347, nil, formData_602348, nil)

var postCreateClusterParameterGroup* = Call_PostCreateClusterParameterGroup_602329(
    name: "postCreateClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_PostCreateClusterParameterGroup_602330, base: "/",
    url: url_PostCreateClusterParameterGroup_602331,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterParameterGroup_602310 = ref object of OpenApiRestCall_601373
proc url_GetCreateClusterParameterGroup_602312(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterParameterGroup_602311(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: JString (required)
  section = newJObject()
  var valid_602313 = query.getOrDefault("Tags")
  valid_602313 = validateParameter(valid_602313, JArray, required = false,
                                 default = nil)
  if valid_602313 != nil:
    section.add "Tags", valid_602313
  assert query != nil, "query argument is necessary due to required `ParameterGroupFamily` field"
  var valid_602314 = query.getOrDefault("ParameterGroupFamily")
  valid_602314 = validateParameter(valid_602314, JString, required = true,
                                 default = nil)
  if valid_602314 != nil:
    section.add "ParameterGroupFamily", valid_602314
  var valid_602315 = query.getOrDefault("Action")
  valid_602315 = validateParameter(valid_602315, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_602315 != nil:
    section.add "Action", valid_602315
  var valid_602316 = query.getOrDefault("Description")
  valid_602316 = validateParameter(valid_602316, JString, required = true,
                                 default = nil)
  if valid_602316 != nil:
    section.add "Description", valid_602316
  var valid_602317 = query.getOrDefault("ParameterGroupName")
  valid_602317 = validateParameter(valid_602317, JString, required = true,
                                 default = nil)
  if valid_602317 != nil:
    section.add "ParameterGroupName", valid_602317
  var valid_602318 = query.getOrDefault("Version")
  valid_602318 = validateParameter(valid_602318, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602318 != nil:
    section.add "Version", valid_602318
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602319 = header.getOrDefault("X-Amz-Signature")
  valid_602319 = validateParameter(valid_602319, JString, required = false,
                                 default = nil)
  if valid_602319 != nil:
    section.add "X-Amz-Signature", valid_602319
  var valid_602320 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602320 = validateParameter(valid_602320, JString, required = false,
                                 default = nil)
  if valid_602320 != nil:
    section.add "X-Amz-Content-Sha256", valid_602320
  var valid_602321 = header.getOrDefault("X-Amz-Date")
  valid_602321 = validateParameter(valid_602321, JString, required = false,
                                 default = nil)
  if valid_602321 != nil:
    section.add "X-Amz-Date", valid_602321
  var valid_602322 = header.getOrDefault("X-Amz-Credential")
  valid_602322 = validateParameter(valid_602322, JString, required = false,
                                 default = nil)
  if valid_602322 != nil:
    section.add "X-Amz-Credential", valid_602322
  var valid_602323 = header.getOrDefault("X-Amz-Security-Token")
  valid_602323 = validateParameter(valid_602323, JString, required = false,
                                 default = nil)
  if valid_602323 != nil:
    section.add "X-Amz-Security-Token", valid_602323
  var valid_602324 = header.getOrDefault("X-Amz-Algorithm")
  valid_602324 = validateParameter(valid_602324, JString, required = false,
                                 default = nil)
  if valid_602324 != nil:
    section.add "X-Amz-Algorithm", valid_602324
  var valid_602325 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602325 = validateParameter(valid_602325, JString, required = false,
                                 default = nil)
  if valid_602325 != nil:
    section.add "X-Amz-SignedHeaders", valid_602325
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602326: Call_GetCreateClusterParameterGroup_602310; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602326.validator(path, query, header, formData, body)
  let scheme = call_602326.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602326.url(scheme.get, call_602326.host, call_602326.base,
                         call_602326.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602326, url, valid)

proc call*(call_602327: Call_GetCreateClusterParameterGroup_602310;
          ParameterGroupFamily: string; Description: string;
          ParameterGroupName: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: string (required)
  var query_602328 = newJObject()
  if Tags != nil:
    query_602328.add "Tags", Tags
  add(query_602328, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_602328, "Action", newJString(Action))
  add(query_602328, "Description", newJString(Description))
  add(query_602328, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_602328, "Version", newJString(Version))
  result = call_602327.call(nil, query_602328, nil, nil, nil)

var getCreateClusterParameterGroup* = Call_GetCreateClusterParameterGroup_602310(
    name: "getCreateClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_GetCreateClusterParameterGroup_602311, base: "/",
    url: url_GetCreateClusterParameterGroup_602312,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSecurityGroup_602367 = ref object of OpenApiRestCall_601373
proc url_PostCreateClusterSecurityGroup_602369(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSecurityGroup_602368(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602370 = query.getOrDefault("Action")
  valid_602370 = validateParameter(valid_602370, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_602370 != nil:
    section.add "Action", valid_602370
  var valid_602371 = query.getOrDefault("Version")
  valid_602371 = validateParameter(valid_602371, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602371 != nil:
    section.add "Version", valid_602371
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602372 = header.getOrDefault("X-Amz-Signature")
  valid_602372 = validateParameter(valid_602372, JString, required = false,
                                 default = nil)
  if valid_602372 != nil:
    section.add "X-Amz-Signature", valid_602372
  var valid_602373 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602373 = validateParameter(valid_602373, JString, required = false,
                                 default = nil)
  if valid_602373 != nil:
    section.add "X-Amz-Content-Sha256", valid_602373
  var valid_602374 = header.getOrDefault("X-Amz-Date")
  valid_602374 = validateParameter(valid_602374, JString, required = false,
                                 default = nil)
  if valid_602374 != nil:
    section.add "X-Amz-Date", valid_602374
  var valid_602375 = header.getOrDefault("X-Amz-Credential")
  valid_602375 = validateParameter(valid_602375, JString, required = false,
                                 default = nil)
  if valid_602375 != nil:
    section.add "X-Amz-Credential", valid_602375
  var valid_602376 = header.getOrDefault("X-Amz-Security-Token")
  valid_602376 = validateParameter(valid_602376, JString, required = false,
                                 default = nil)
  if valid_602376 != nil:
    section.add "X-Amz-Security-Token", valid_602376
  var valid_602377 = header.getOrDefault("X-Amz-Algorithm")
  valid_602377 = validateParameter(valid_602377, JString, required = false,
                                 default = nil)
  if valid_602377 != nil:
    section.add "X-Amz-Algorithm", valid_602377
  var valid_602378 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602378 = validateParameter(valid_602378, JString, required = false,
                                 default = nil)
  if valid_602378 != nil:
    section.add "X-Amz-SignedHeaders", valid_602378
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_602379 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_602379 = validateParameter(valid_602379, JString, required = true,
                                 default = nil)
  if valid_602379 != nil:
    section.add "ClusterSecurityGroupName", valid_602379
  var valid_602380 = formData.getOrDefault("Description")
  valid_602380 = validateParameter(valid_602380, JString, required = true,
                                 default = nil)
  if valid_602380 != nil:
    section.add "Description", valid_602380
  var valid_602381 = formData.getOrDefault("Tags")
  valid_602381 = validateParameter(valid_602381, JArray, required = false,
                                 default = nil)
  if valid_602381 != nil:
    section.add "Tags", valid_602381
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602382: Call_PostCreateClusterSecurityGroup_602367; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602382.validator(path, query, header, formData, body)
  let scheme = call_602382.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602382.url(scheme.get, call_602382.host, call_602382.base,
                         call_602382.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602382, url, valid)

proc call*(call_602383: Call_PostCreateClusterSecurityGroup_602367;
          ClusterSecurityGroupName: string; Description: string;
          Action: string = "CreateClusterSecurityGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_602384 = newJObject()
  var formData_602385 = newJObject()
  add(formData_602385, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_602385, "Description", newJString(Description))
  add(query_602384, "Action", newJString(Action))
  if Tags != nil:
    formData_602385.add "Tags", Tags
  add(query_602384, "Version", newJString(Version))
  result = call_602383.call(nil, query_602384, nil, formData_602385, nil)

var postCreateClusterSecurityGroup* = Call_PostCreateClusterSecurityGroup_602367(
    name: "postCreateClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_PostCreateClusterSecurityGroup_602368, base: "/",
    url: url_PostCreateClusterSecurityGroup_602369,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSecurityGroup_602349 = ref object of OpenApiRestCall_601373
proc url_GetCreateClusterSecurityGroup_602351(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSecurityGroup_602350(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Version: JString (required)
  section = newJObject()
  var valid_602352 = query.getOrDefault("Tags")
  valid_602352 = validateParameter(valid_602352, JArray, required = false,
                                 default = nil)
  if valid_602352 != nil:
    section.add "Tags", valid_602352
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_602353 = query.getOrDefault("ClusterSecurityGroupName")
  valid_602353 = validateParameter(valid_602353, JString, required = true,
                                 default = nil)
  if valid_602353 != nil:
    section.add "ClusterSecurityGroupName", valid_602353
  var valid_602354 = query.getOrDefault("Action")
  valid_602354 = validateParameter(valid_602354, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_602354 != nil:
    section.add "Action", valid_602354
  var valid_602355 = query.getOrDefault("Description")
  valid_602355 = validateParameter(valid_602355, JString, required = true,
                                 default = nil)
  if valid_602355 != nil:
    section.add "Description", valid_602355
  var valid_602356 = query.getOrDefault("Version")
  valid_602356 = validateParameter(valid_602356, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602356 != nil:
    section.add "Version", valid_602356
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602357 = header.getOrDefault("X-Amz-Signature")
  valid_602357 = validateParameter(valid_602357, JString, required = false,
                                 default = nil)
  if valid_602357 != nil:
    section.add "X-Amz-Signature", valid_602357
  var valid_602358 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602358 = validateParameter(valid_602358, JString, required = false,
                                 default = nil)
  if valid_602358 != nil:
    section.add "X-Amz-Content-Sha256", valid_602358
  var valid_602359 = header.getOrDefault("X-Amz-Date")
  valid_602359 = validateParameter(valid_602359, JString, required = false,
                                 default = nil)
  if valid_602359 != nil:
    section.add "X-Amz-Date", valid_602359
  var valid_602360 = header.getOrDefault("X-Amz-Credential")
  valid_602360 = validateParameter(valid_602360, JString, required = false,
                                 default = nil)
  if valid_602360 != nil:
    section.add "X-Amz-Credential", valid_602360
  var valid_602361 = header.getOrDefault("X-Amz-Security-Token")
  valid_602361 = validateParameter(valid_602361, JString, required = false,
                                 default = nil)
  if valid_602361 != nil:
    section.add "X-Amz-Security-Token", valid_602361
  var valid_602362 = header.getOrDefault("X-Amz-Algorithm")
  valid_602362 = validateParameter(valid_602362, JString, required = false,
                                 default = nil)
  if valid_602362 != nil:
    section.add "X-Amz-Algorithm", valid_602362
  var valid_602363 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602363 = validateParameter(valid_602363, JString, required = false,
                                 default = nil)
  if valid_602363 != nil:
    section.add "X-Amz-SignedHeaders", valid_602363
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602364: Call_GetCreateClusterSecurityGroup_602349; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602364.validator(path, query, header, formData, body)
  let scheme = call_602364.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602364.url(scheme.get, call_602364.host, call_602364.base,
                         call_602364.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602364, url, valid)

proc call*(call_602365: Call_GetCreateClusterSecurityGroup_602349;
          ClusterSecurityGroupName: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Version: string (required)
  var query_602366 = newJObject()
  if Tags != nil:
    query_602366.add "Tags", Tags
  add(query_602366, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_602366, "Action", newJString(Action))
  add(query_602366, "Description", newJString(Description))
  add(query_602366, "Version", newJString(Version))
  result = call_602365.call(nil, query_602366, nil, nil, nil)

var getCreateClusterSecurityGroup* = Call_GetCreateClusterSecurityGroup_602349(
    name: "getCreateClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_GetCreateClusterSecurityGroup_602350, base: "/",
    url: url_GetCreateClusterSecurityGroup_602351,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSnapshot_602405 = ref object of OpenApiRestCall_601373
proc url_PostCreateClusterSnapshot_602407(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSnapshot_602406(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602408 = query.getOrDefault("Action")
  valid_602408 = validateParameter(valid_602408, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_602408 != nil:
    section.add "Action", valid_602408
  var valid_602409 = query.getOrDefault("Version")
  valid_602409 = validateParameter(valid_602409, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602409 != nil:
    section.add "Version", valid_602409
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602410 = header.getOrDefault("X-Amz-Signature")
  valid_602410 = validateParameter(valid_602410, JString, required = false,
                                 default = nil)
  if valid_602410 != nil:
    section.add "X-Amz-Signature", valid_602410
  var valid_602411 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602411 = validateParameter(valid_602411, JString, required = false,
                                 default = nil)
  if valid_602411 != nil:
    section.add "X-Amz-Content-Sha256", valid_602411
  var valid_602412 = header.getOrDefault("X-Amz-Date")
  valid_602412 = validateParameter(valid_602412, JString, required = false,
                                 default = nil)
  if valid_602412 != nil:
    section.add "X-Amz-Date", valid_602412
  var valid_602413 = header.getOrDefault("X-Amz-Credential")
  valid_602413 = validateParameter(valid_602413, JString, required = false,
                                 default = nil)
  if valid_602413 != nil:
    section.add "X-Amz-Credential", valid_602413
  var valid_602414 = header.getOrDefault("X-Amz-Security-Token")
  valid_602414 = validateParameter(valid_602414, JString, required = false,
                                 default = nil)
  if valid_602414 != nil:
    section.add "X-Amz-Security-Token", valid_602414
  var valid_602415 = header.getOrDefault("X-Amz-Algorithm")
  valid_602415 = validateParameter(valid_602415, JString, required = false,
                                 default = nil)
  if valid_602415 != nil:
    section.add "X-Amz-Algorithm", valid_602415
  var valid_602416 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602416 = validateParameter(valid_602416, JString, required = false,
                                 default = nil)
  if valid_602416 != nil:
    section.add "X-Amz-SignedHeaders", valid_602416
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_602417 = formData.getOrDefault("ClusterIdentifier")
  valid_602417 = validateParameter(valid_602417, JString, required = true,
                                 default = nil)
  if valid_602417 != nil:
    section.add "ClusterIdentifier", valid_602417
  var valid_602418 = formData.getOrDefault("SnapshotIdentifier")
  valid_602418 = validateParameter(valid_602418, JString, required = true,
                                 default = nil)
  if valid_602418 != nil:
    section.add "SnapshotIdentifier", valid_602418
  var valid_602419 = formData.getOrDefault("Tags")
  valid_602419 = validateParameter(valid_602419, JArray, required = false,
                                 default = nil)
  if valid_602419 != nil:
    section.add "Tags", valid_602419
  var valid_602420 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602420 = validateParameter(valid_602420, JInt, required = false, default = nil)
  if valid_602420 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602420
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602421: Call_PostCreateClusterSnapshot_602405; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602421.validator(path, query, header, formData, body)
  let scheme = call_602421.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602421.url(scheme.get, call_602421.host, call_602421.base,
                         call_602421.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602421, url, valid)

proc call*(call_602422: Call_PostCreateClusterSnapshot_602405;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Action: string = "CreateClusterSnapshot"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_602423 = newJObject()
  var formData_602424 = newJObject()
  add(formData_602424, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_602424, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_602423, "Action", newJString(Action))
  if Tags != nil:
    formData_602424.add "Tags", Tags
  add(query_602423, "Version", newJString(Version))
  add(formData_602424, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_602422.call(nil, query_602423, nil, formData_602424, nil)

var postCreateClusterSnapshot* = Call_PostCreateClusterSnapshot_602405(
    name: "postCreateClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_PostCreateClusterSnapshot_602406, base: "/",
    url: url_PostCreateClusterSnapshot_602407,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSnapshot_602386 = ref object of OpenApiRestCall_601373
proc url_GetCreateClusterSnapshot_602388(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSnapshot_602387(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_602389 = query.getOrDefault("SnapshotIdentifier")
  valid_602389 = validateParameter(valid_602389, JString, required = true,
                                 default = nil)
  if valid_602389 != nil:
    section.add "SnapshotIdentifier", valid_602389
  var valid_602390 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602390 = validateParameter(valid_602390, JInt, required = false, default = nil)
  if valid_602390 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602390
  var valid_602391 = query.getOrDefault("Tags")
  valid_602391 = validateParameter(valid_602391, JArray, required = false,
                                 default = nil)
  if valid_602391 != nil:
    section.add "Tags", valid_602391
  var valid_602392 = query.getOrDefault("Action")
  valid_602392 = validateParameter(valid_602392, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_602392 != nil:
    section.add "Action", valid_602392
  var valid_602393 = query.getOrDefault("ClusterIdentifier")
  valid_602393 = validateParameter(valid_602393, JString, required = true,
                                 default = nil)
  if valid_602393 != nil:
    section.add "ClusterIdentifier", valid_602393
  var valid_602394 = query.getOrDefault("Version")
  valid_602394 = validateParameter(valid_602394, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602394 != nil:
    section.add "Version", valid_602394
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602395 = header.getOrDefault("X-Amz-Signature")
  valid_602395 = validateParameter(valid_602395, JString, required = false,
                                 default = nil)
  if valid_602395 != nil:
    section.add "X-Amz-Signature", valid_602395
  var valid_602396 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602396 = validateParameter(valid_602396, JString, required = false,
                                 default = nil)
  if valid_602396 != nil:
    section.add "X-Amz-Content-Sha256", valid_602396
  var valid_602397 = header.getOrDefault("X-Amz-Date")
  valid_602397 = validateParameter(valid_602397, JString, required = false,
                                 default = nil)
  if valid_602397 != nil:
    section.add "X-Amz-Date", valid_602397
  var valid_602398 = header.getOrDefault("X-Amz-Credential")
  valid_602398 = validateParameter(valid_602398, JString, required = false,
                                 default = nil)
  if valid_602398 != nil:
    section.add "X-Amz-Credential", valid_602398
  var valid_602399 = header.getOrDefault("X-Amz-Security-Token")
  valid_602399 = validateParameter(valid_602399, JString, required = false,
                                 default = nil)
  if valid_602399 != nil:
    section.add "X-Amz-Security-Token", valid_602399
  var valid_602400 = header.getOrDefault("X-Amz-Algorithm")
  valid_602400 = validateParameter(valid_602400, JString, required = false,
                                 default = nil)
  if valid_602400 != nil:
    section.add "X-Amz-Algorithm", valid_602400
  var valid_602401 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602401 = validateParameter(valid_602401, JString, required = false,
                                 default = nil)
  if valid_602401 != nil:
    section.add "X-Amz-SignedHeaders", valid_602401
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602402: Call_GetCreateClusterSnapshot_602386; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602402.validator(path, query, header, formData, body)
  let scheme = call_602402.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602402.url(scheme.get, call_602402.host, call_602402.base,
                         call_602402.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602402, url, valid)

proc call*(call_602403: Call_GetCreateClusterSnapshot_602386;
          SnapshotIdentifier: string; ClusterIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0; Tags: JsonNode = nil;
          Action: string = "CreateClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   Version: string (required)
  var query_602404 = newJObject()
  add(query_602404, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_602404, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  if Tags != nil:
    query_602404.add "Tags", Tags
  add(query_602404, "Action", newJString(Action))
  add(query_602404, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602404, "Version", newJString(Version))
  result = call_602403.call(nil, query_602404, nil, nil, nil)

var getCreateClusterSnapshot* = Call_GetCreateClusterSnapshot_602386(
    name: "getCreateClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_GetCreateClusterSnapshot_602387, base: "/",
    url: url_GetCreateClusterSnapshot_602388, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSubnetGroup_602444 = ref object of OpenApiRestCall_601373
proc url_PostCreateClusterSubnetGroup_602446(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSubnetGroup_602445(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602447 = query.getOrDefault("Action")
  valid_602447 = validateParameter(valid_602447, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_602447 != nil:
    section.add "Action", valid_602447
  var valid_602448 = query.getOrDefault("Version")
  valid_602448 = validateParameter(valid_602448, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602448 != nil:
    section.add "Version", valid_602448
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602449 = header.getOrDefault("X-Amz-Signature")
  valid_602449 = validateParameter(valid_602449, JString, required = false,
                                 default = nil)
  if valid_602449 != nil:
    section.add "X-Amz-Signature", valid_602449
  var valid_602450 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602450 = validateParameter(valid_602450, JString, required = false,
                                 default = nil)
  if valid_602450 != nil:
    section.add "X-Amz-Content-Sha256", valid_602450
  var valid_602451 = header.getOrDefault("X-Amz-Date")
  valid_602451 = validateParameter(valid_602451, JString, required = false,
                                 default = nil)
  if valid_602451 != nil:
    section.add "X-Amz-Date", valid_602451
  var valid_602452 = header.getOrDefault("X-Amz-Credential")
  valid_602452 = validateParameter(valid_602452, JString, required = false,
                                 default = nil)
  if valid_602452 != nil:
    section.add "X-Amz-Credential", valid_602452
  var valid_602453 = header.getOrDefault("X-Amz-Security-Token")
  valid_602453 = validateParameter(valid_602453, JString, required = false,
                                 default = nil)
  if valid_602453 != nil:
    section.add "X-Amz-Security-Token", valid_602453
  var valid_602454 = header.getOrDefault("X-Amz-Algorithm")
  valid_602454 = validateParameter(valid_602454, JString, required = false,
                                 default = nil)
  if valid_602454 != nil:
    section.add "X-Amz-Algorithm", valid_602454
  var valid_602455 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602455 = validateParameter(valid_602455, JString, required = false,
                                 default = nil)
  if valid_602455 != nil:
    section.add "X-Amz-SignedHeaders", valid_602455
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_602456 = formData.getOrDefault("Description")
  valid_602456 = validateParameter(valid_602456, JString, required = true,
                                 default = nil)
  if valid_602456 != nil:
    section.add "Description", valid_602456
  var valid_602457 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_602457 = validateParameter(valid_602457, JString, required = true,
                                 default = nil)
  if valid_602457 != nil:
    section.add "ClusterSubnetGroupName", valid_602457
  var valid_602458 = formData.getOrDefault("Tags")
  valid_602458 = validateParameter(valid_602458, JArray, required = false,
                                 default = nil)
  if valid_602458 != nil:
    section.add "Tags", valid_602458
  var valid_602459 = formData.getOrDefault("SubnetIds")
  valid_602459 = validateParameter(valid_602459, JArray, required = true, default = nil)
  if valid_602459 != nil:
    section.add "SubnetIds", valid_602459
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602460: Call_PostCreateClusterSubnetGroup_602444; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602460.validator(path, query, header, formData, body)
  let scheme = call_602460.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602460.url(scheme.get, call_602460.host, call_602460.base,
                         call_602460.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602460, url, valid)

proc call*(call_602461: Call_PostCreateClusterSubnetGroup_602444;
          Description: string; ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Action: string = "CreateClusterSubnetGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  var query_602462 = newJObject()
  var formData_602463 = newJObject()
  add(formData_602463, "Description", newJString(Description))
  add(formData_602463, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_602462, "Action", newJString(Action))
  if Tags != nil:
    formData_602463.add "Tags", Tags
  add(query_602462, "Version", newJString(Version))
  if SubnetIds != nil:
    formData_602463.add "SubnetIds", SubnetIds
  result = call_602461.call(nil, query_602462, nil, formData_602463, nil)

var postCreateClusterSubnetGroup* = Call_PostCreateClusterSubnetGroup_602444(
    name: "postCreateClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_PostCreateClusterSubnetGroup_602445, base: "/",
    url: url_PostCreateClusterSubnetGroup_602446,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSubnetGroup_602425 = ref object of OpenApiRestCall_601373
proc url_GetCreateClusterSubnetGroup_602427(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSubnetGroup_602426(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_602428 = query.getOrDefault("ClusterSubnetGroupName")
  valid_602428 = validateParameter(valid_602428, JString, required = true,
                                 default = nil)
  if valid_602428 != nil:
    section.add "ClusterSubnetGroupName", valid_602428
  var valid_602429 = query.getOrDefault("Tags")
  valid_602429 = validateParameter(valid_602429, JArray, required = false,
                                 default = nil)
  if valid_602429 != nil:
    section.add "Tags", valid_602429
  var valid_602430 = query.getOrDefault("SubnetIds")
  valid_602430 = validateParameter(valid_602430, JArray, required = true, default = nil)
  if valid_602430 != nil:
    section.add "SubnetIds", valid_602430
  var valid_602431 = query.getOrDefault("Action")
  valid_602431 = validateParameter(valid_602431, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_602431 != nil:
    section.add "Action", valid_602431
  var valid_602432 = query.getOrDefault("Description")
  valid_602432 = validateParameter(valid_602432, JString, required = true,
                                 default = nil)
  if valid_602432 != nil:
    section.add "Description", valid_602432
  var valid_602433 = query.getOrDefault("Version")
  valid_602433 = validateParameter(valid_602433, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602433 != nil:
    section.add "Version", valid_602433
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602434 = header.getOrDefault("X-Amz-Signature")
  valid_602434 = validateParameter(valid_602434, JString, required = false,
                                 default = nil)
  if valid_602434 != nil:
    section.add "X-Amz-Signature", valid_602434
  var valid_602435 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602435 = validateParameter(valid_602435, JString, required = false,
                                 default = nil)
  if valid_602435 != nil:
    section.add "X-Amz-Content-Sha256", valid_602435
  var valid_602436 = header.getOrDefault("X-Amz-Date")
  valid_602436 = validateParameter(valid_602436, JString, required = false,
                                 default = nil)
  if valid_602436 != nil:
    section.add "X-Amz-Date", valid_602436
  var valid_602437 = header.getOrDefault("X-Amz-Credential")
  valid_602437 = validateParameter(valid_602437, JString, required = false,
                                 default = nil)
  if valid_602437 != nil:
    section.add "X-Amz-Credential", valid_602437
  var valid_602438 = header.getOrDefault("X-Amz-Security-Token")
  valid_602438 = validateParameter(valid_602438, JString, required = false,
                                 default = nil)
  if valid_602438 != nil:
    section.add "X-Amz-Security-Token", valid_602438
  var valid_602439 = header.getOrDefault("X-Amz-Algorithm")
  valid_602439 = validateParameter(valid_602439, JString, required = false,
                                 default = nil)
  if valid_602439 != nil:
    section.add "X-Amz-Algorithm", valid_602439
  var valid_602440 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602440 = validateParameter(valid_602440, JString, required = false,
                                 default = nil)
  if valid_602440 != nil:
    section.add "X-Amz-SignedHeaders", valid_602440
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602441: Call_GetCreateClusterSubnetGroup_602425; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602441.validator(path, query, header, formData, body)
  let scheme = call_602441.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602441.url(scheme.get, call_602441.host, call_602441.base,
                         call_602441.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602441, url, valid)

proc call*(call_602442: Call_GetCreateClusterSubnetGroup_602425;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   Version: string (required)
  var query_602443 = newJObject()
  add(query_602443, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  if Tags != nil:
    query_602443.add "Tags", Tags
  if SubnetIds != nil:
    query_602443.add "SubnetIds", SubnetIds
  add(query_602443, "Action", newJString(Action))
  add(query_602443, "Description", newJString(Description))
  add(query_602443, "Version", newJString(Version))
  result = call_602442.call(nil, query_602443, nil, nil, nil)

var getCreateClusterSubnetGroup* = Call_GetCreateClusterSubnetGroup_602425(
    name: "getCreateClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_GetCreateClusterSubnetGroup_602426, base: "/",
    url: url_GetCreateClusterSubnetGroup_602427,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateEventSubscription_602487 = ref object of OpenApiRestCall_601373
proc url_PostCreateEventSubscription_602489(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateEventSubscription_602488(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602490 = query.getOrDefault("Action")
  valid_602490 = validateParameter(valid_602490, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_602490 != nil:
    section.add "Action", valid_602490
  var valid_602491 = query.getOrDefault("Version")
  valid_602491 = validateParameter(valid_602491, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602491 != nil:
    section.add "Version", valid_602491
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602492 = header.getOrDefault("X-Amz-Signature")
  valid_602492 = validateParameter(valid_602492, JString, required = false,
                                 default = nil)
  if valid_602492 != nil:
    section.add "X-Amz-Signature", valid_602492
  var valid_602493 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602493 = validateParameter(valid_602493, JString, required = false,
                                 default = nil)
  if valid_602493 != nil:
    section.add "X-Amz-Content-Sha256", valid_602493
  var valid_602494 = header.getOrDefault("X-Amz-Date")
  valid_602494 = validateParameter(valid_602494, JString, required = false,
                                 default = nil)
  if valid_602494 != nil:
    section.add "X-Amz-Date", valid_602494
  var valid_602495 = header.getOrDefault("X-Amz-Credential")
  valid_602495 = validateParameter(valid_602495, JString, required = false,
                                 default = nil)
  if valid_602495 != nil:
    section.add "X-Amz-Credential", valid_602495
  var valid_602496 = header.getOrDefault("X-Amz-Security-Token")
  valid_602496 = validateParameter(valid_602496, JString, required = false,
                                 default = nil)
  if valid_602496 != nil:
    section.add "X-Amz-Security-Token", valid_602496
  var valid_602497 = header.getOrDefault("X-Amz-Algorithm")
  valid_602497 = validateParameter(valid_602497, JString, required = false,
                                 default = nil)
  if valid_602497 != nil:
    section.add "X-Amz-Algorithm", valid_602497
  var valid_602498 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602498 = validateParameter(valid_602498, JString, required = false,
                                 default = nil)
  if valid_602498 != nil:
    section.add "X-Amz-SignedHeaders", valid_602498
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  var valid_602499 = formData.getOrDefault("SourceIds")
  valid_602499 = validateParameter(valid_602499, JArray, required = false,
                                 default = nil)
  if valid_602499 != nil:
    section.add "SourceIds", valid_602499
  assert formData != nil,
        "formData argument is necessary due to required `SnsTopicArn` field"
  var valid_602500 = formData.getOrDefault("SnsTopicArn")
  valid_602500 = validateParameter(valid_602500, JString, required = true,
                                 default = nil)
  if valid_602500 != nil:
    section.add "SnsTopicArn", valid_602500
  var valid_602501 = formData.getOrDefault("Enabled")
  valid_602501 = validateParameter(valid_602501, JBool, required = false, default = nil)
  if valid_602501 != nil:
    section.add "Enabled", valid_602501
  var valid_602502 = formData.getOrDefault("SubscriptionName")
  valid_602502 = validateParameter(valid_602502, JString, required = true,
                                 default = nil)
  if valid_602502 != nil:
    section.add "SubscriptionName", valid_602502
  var valid_602503 = formData.getOrDefault("SourceType")
  valid_602503 = validateParameter(valid_602503, JString, required = false,
                                 default = nil)
  if valid_602503 != nil:
    section.add "SourceType", valid_602503
  var valid_602504 = formData.getOrDefault("Severity")
  valid_602504 = validateParameter(valid_602504, JString, required = false,
                                 default = nil)
  if valid_602504 != nil:
    section.add "Severity", valid_602504
  var valid_602505 = formData.getOrDefault("EventCategories")
  valid_602505 = validateParameter(valid_602505, JArray, required = false,
                                 default = nil)
  if valid_602505 != nil:
    section.add "EventCategories", valid_602505
  var valid_602506 = formData.getOrDefault("Tags")
  valid_602506 = validateParameter(valid_602506, JArray, required = false,
                                 default = nil)
  if valid_602506 != nil:
    section.add "Tags", valid_602506
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602507: Call_PostCreateEventSubscription_602487; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_602507.validator(path, query, header, formData, body)
  let scheme = call_602507.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602507.url(scheme.get, call_602507.host, call_602507.base,
                         call_602507.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602507, url, valid)

proc call*(call_602508: Call_PostCreateEventSubscription_602487;
          SnsTopicArn: string; SubscriptionName: string; SourceIds: JsonNode = nil;
          Enabled: bool = false; SourceType: string = ""; Severity: string = "";
          EventCategories: JsonNode = nil;
          Action: string = "CreateEventSubscription"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_602509 = newJObject()
  var formData_602510 = newJObject()
  if SourceIds != nil:
    formData_602510.add "SourceIds", SourceIds
  add(formData_602510, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_602510, "Enabled", newJBool(Enabled))
  add(formData_602510, "SubscriptionName", newJString(SubscriptionName))
  add(formData_602510, "SourceType", newJString(SourceType))
  add(formData_602510, "Severity", newJString(Severity))
  if EventCategories != nil:
    formData_602510.add "EventCategories", EventCategories
  add(query_602509, "Action", newJString(Action))
  if Tags != nil:
    formData_602510.add "Tags", Tags
  add(query_602509, "Version", newJString(Version))
  result = call_602508.call(nil, query_602509, nil, formData_602510, nil)

var postCreateEventSubscription* = Call_PostCreateEventSubscription_602487(
    name: "postCreateEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_PostCreateEventSubscription_602488, base: "/",
    url: url_PostCreateEventSubscription_602489,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateEventSubscription_602464 = ref object of OpenApiRestCall_601373
proc url_GetCreateEventSubscription_602466(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateEventSubscription_602465(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: JString (required)
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Version: JString (required)
  section = newJObject()
  var valid_602467 = query.getOrDefault("Tags")
  valid_602467 = validateParameter(valid_602467, JArray, required = false,
                                 default = nil)
  if valid_602467 != nil:
    section.add "Tags", valid_602467
  var valid_602468 = query.getOrDefault("SourceType")
  valid_602468 = validateParameter(valid_602468, JString, required = false,
                                 default = nil)
  if valid_602468 != nil:
    section.add "SourceType", valid_602468
  var valid_602469 = query.getOrDefault("Enabled")
  valid_602469 = validateParameter(valid_602469, JBool, required = false, default = nil)
  if valid_602469 != nil:
    section.add "Enabled", valid_602469
  var valid_602470 = query.getOrDefault("Severity")
  valid_602470 = validateParameter(valid_602470, JString, required = false,
                                 default = nil)
  if valid_602470 != nil:
    section.add "Severity", valid_602470
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_602471 = query.getOrDefault("SubscriptionName")
  valid_602471 = validateParameter(valid_602471, JString, required = true,
                                 default = nil)
  if valid_602471 != nil:
    section.add "SubscriptionName", valid_602471
  var valid_602472 = query.getOrDefault("EventCategories")
  valid_602472 = validateParameter(valid_602472, JArray, required = false,
                                 default = nil)
  if valid_602472 != nil:
    section.add "EventCategories", valid_602472
  var valid_602473 = query.getOrDefault("SourceIds")
  valid_602473 = validateParameter(valid_602473, JArray, required = false,
                                 default = nil)
  if valid_602473 != nil:
    section.add "SourceIds", valid_602473
  var valid_602474 = query.getOrDefault("Action")
  valid_602474 = validateParameter(valid_602474, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_602474 != nil:
    section.add "Action", valid_602474
  var valid_602475 = query.getOrDefault("SnsTopicArn")
  valid_602475 = validateParameter(valid_602475, JString, required = true,
                                 default = nil)
  if valid_602475 != nil:
    section.add "SnsTopicArn", valid_602475
  var valid_602476 = query.getOrDefault("Version")
  valid_602476 = validateParameter(valid_602476, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602476 != nil:
    section.add "Version", valid_602476
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602477 = header.getOrDefault("X-Amz-Signature")
  valid_602477 = validateParameter(valid_602477, JString, required = false,
                                 default = nil)
  if valid_602477 != nil:
    section.add "X-Amz-Signature", valid_602477
  var valid_602478 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602478 = validateParameter(valid_602478, JString, required = false,
                                 default = nil)
  if valid_602478 != nil:
    section.add "X-Amz-Content-Sha256", valid_602478
  var valid_602479 = header.getOrDefault("X-Amz-Date")
  valid_602479 = validateParameter(valid_602479, JString, required = false,
                                 default = nil)
  if valid_602479 != nil:
    section.add "X-Amz-Date", valid_602479
  var valid_602480 = header.getOrDefault("X-Amz-Credential")
  valid_602480 = validateParameter(valid_602480, JString, required = false,
                                 default = nil)
  if valid_602480 != nil:
    section.add "X-Amz-Credential", valid_602480
  var valid_602481 = header.getOrDefault("X-Amz-Security-Token")
  valid_602481 = validateParameter(valid_602481, JString, required = false,
                                 default = nil)
  if valid_602481 != nil:
    section.add "X-Amz-Security-Token", valid_602481
  var valid_602482 = header.getOrDefault("X-Amz-Algorithm")
  valid_602482 = validateParameter(valid_602482, JString, required = false,
                                 default = nil)
  if valid_602482 != nil:
    section.add "X-Amz-Algorithm", valid_602482
  var valid_602483 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602483 = validateParameter(valid_602483, JString, required = false,
                                 default = nil)
  if valid_602483 != nil:
    section.add "X-Amz-SignedHeaders", valid_602483
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602484: Call_GetCreateEventSubscription_602464; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_602484.validator(path, query, header, formData, body)
  let scheme = call_602484.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602484.url(scheme.get, call_602484.host, call_602484.base,
                         call_602484.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602484, url, valid)

proc call*(call_602485: Call_GetCreateEventSubscription_602464;
          SubscriptionName: string; SnsTopicArn: string; Tags: JsonNode = nil;
          SourceType: string = ""; Enabled: bool = false; Severity: string = "";
          EventCategories: JsonNode = nil; SourceIds: JsonNode = nil;
          Action: string = "CreateEventSubscription"; Version: string = "2012-12-01"): Recallable =
  ## getCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: string (required)
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Version: string (required)
  var query_602486 = newJObject()
  if Tags != nil:
    query_602486.add "Tags", Tags
  add(query_602486, "SourceType", newJString(SourceType))
  add(query_602486, "Enabled", newJBool(Enabled))
  add(query_602486, "Severity", newJString(Severity))
  add(query_602486, "SubscriptionName", newJString(SubscriptionName))
  if EventCategories != nil:
    query_602486.add "EventCategories", EventCategories
  if SourceIds != nil:
    query_602486.add "SourceIds", SourceIds
  add(query_602486, "Action", newJString(Action))
  add(query_602486, "SnsTopicArn", newJString(SnsTopicArn))
  add(query_602486, "Version", newJString(Version))
  result = call_602485.call(nil, query_602486, nil, nil, nil)

var getCreateEventSubscription* = Call_GetCreateEventSubscription_602464(
    name: "getCreateEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_GetCreateEventSubscription_602465, base: "/",
    url: url_GetCreateEventSubscription_602466,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmClientCertificate_602528 = ref object of OpenApiRestCall_601373
proc url_PostCreateHsmClientCertificate_602530(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmClientCertificate_602529(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602531 = query.getOrDefault("Action")
  valid_602531 = validateParameter(valid_602531, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_602531 != nil:
    section.add "Action", valid_602531
  var valid_602532 = query.getOrDefault("Version")
  valid_602532 = validateParameter(valid_602532, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602532 != nil:
    section.add "Version", valid_602532
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602533 = header.getOrDefault("X-Amz-Signature")
  valid_602533 = validateParameter(valid_602533, JString, required = false,
                                 default = nil)
  if valid_602533 != nil:
    section.add "X-Amz-Signature", valid_602533
  var valid_602534 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602534 = validateParameter(valid_602534, JString, required = false,
                                 default = nil)
  if valid_602534 != nil:
    section.add "X-Amz-Content-Sha256", valid_602534
  var valid_602535 = header.getOrDefault("X-Amz-Date")
  valid_602535 = validateParameter(valid_602535, JString, required = false,
                                 default = nil)
  if valid_602535 != nil:
    section.add "X-Amz-Date", valid_602535
  var valid_602536 = header.getOrDefault("X-Amz-Credential")
  valid_602536 = validateParameter(valid_602536, JString, required = false,
                                 default = nil)
  if valid_602536 != nil:
    section.add "X-Amz-Credential", valid_602536
  var valid_602537 = header.getOrDefault("X-Amz-Security-Token")
  valid_602537 = validateParameter(valid_602537, JString, required = false,
                                 default = nil)
  if valid_602537 != nil:
    section.add "X-Amz-Security-Token", valid_602537
  var valid_602538 = header.getOrDefault("X-Amz-Algorithm")
  valid_602538 = validateParameter(valid_602538, JString, required = false,
                                 default = nil)
  if valid_602538 != nil:
    section.add "X-Amz-Algorithm", valid_602538
  var valid_602539 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602539 = validateParameter(valid_602539, JString, required = false,
                                 default = nil)
  if valid_602539 != nil:
    section.add "X-Amz-SignedHeaders", valid_602539
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_602540 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_602540 = validateParameter(valid_602540, JString, required = true,
                                 default = nil)
  if valid_602540 != nil:
    section.add "HsmClientCertificateIdentifier", valid_602540
  var valid_602541 = formData.getOrDefault("Tags")
  valid_602541 = validateParameter(valid_602541, JArray, required = false,
                                 default = nil)
  if valid_602541 != nil:
    section.add "Tags", valid_602541
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602542: Call_PostCreateHsmClientCertificate_602528; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_602542.validator(path, query, header, formData, body)
  let scheme = call_602542.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602542.url(scheme.get, call_602542.host, call_602542.base,
                         call_602542.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602542, url, valid)

proc call*(call_602543: Call_PostCreateHsmClientCertificate_602528;
          HsmClientCertificateIdentifier: string;
          Action: string = "CreateHsmClientCertificate"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_602544 = newJObject()
  var formData_602545 = newJObject()
  add(query_602544, "Action", newJString(Action))
  add(formData_602545, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    formData_602545.add "Tags", Tags
  add(query_602544, "Version", newJString(Version))
  result = call_602543.call(nil, query_602544, nil, formData_602545, nil)

var postCreateHsmClientCertificate* = Call_PostCreateHsmClientCertificate_602528(
    name: "postCreateHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_PostCreateHsmClientCertificate_602529, base: "/",
    url: url_PostCreateHsmClientCertificate_602530,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmClientCertificate_602511 = ref object of OpenApiRestCall_601373
proc url_GetCreateHsmClientCertificate_602513(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmClientCertificate_602512(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_602514 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_602514 = validateParameter(valid_602514, JString, required = true,
                                 default = nil)
  if valid_602514 != nil:
    section.add "HsmClientCertificateIdentifier", valid_602514
  var valid_602515 = query.getOrDefault("Tags")
  valid_602515 = validateParameter(valid_602515, JArray, required = false,
                                 default = nil)
  if valid_602515 != nil:
    section.add "Tags", valid_602515
  var valid_602516 = query.getOrDefault("Action")
  valid_602516 = validateParameter(valid_602516, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_602516 != nil:
    section.add "Action", valid_602516
  var valid_602517 = query.getOrDefault("Version")
  valid_602517 = validateParameter(valid_602517, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602517 != nil:
    section.add "Version", valid_602517
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602518 = header.getOrDefault("X-Amz-Signature")
  valid_602518 = validateParameter(valid_602518, JString, required = false,
                                 default = nil)
  if valid_602518 != nil:
    section.add "X-Amz-Signature", valid_602518
  var valid_602519 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602519 = validateParameter(valid_602519, JString, required = false,
                                 default = nil)
  if valid_602519 != nil:
    section.add "X-Amz-Content-Sha256", valid_602519
  var valid_602520 = header.getOrDefault("X-Amz-Date")
  valid_602520 = validateParameter(valid_602520, JString, required = false,
                                 default = nil)
  if valid_602520 != nil:
    section.add "X-Amz-Date", valid_602520
  var valid_602521 = header.getOrDefault("X-Amz-Credential")
  valid_602521 = validateParameter(valid_602521, JString, required = false,
                                 default = nil)
  if valid_602521 != nil:
    section.add "X-Amz-Credential", valid_602521
  var valid_602522 = header.getOrDefault("X-Amz-Security-Token")
  valid_602522 = validateParameter(valid_602522, JString, required = false,
                                 default = nil)
  if valid_602522 != nil:
    section.add "X-Amz-Security-Token", valid_602522
  var valid_602523 = header.getOrDefault("X-Amz-Algorithm")
  valid_602523 = validateParameter(valid_602523, JString, required = false,
                                 default = nil)
  if valid_602523 != nil:
    section.add "X-Amz-Algorithm", valid_602523
  var valid_602524 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602524 = validateParameter(valid_602524, JString, required = false,
                                 default = nil)
  if valid_602524 != nil:
    section.add "X-Amz-SignedHeaders", valid_602524
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602525: Call_GetCreateHsmClientCertificate_602511; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_602525.validator(path, query, header, formData, body)
  let scheme = call_602525.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602525.url(scheme.get, call_602525.host, call_602525.base,
                         call_602525.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602525, url, valid)

proc call*(call_602526: Call_GetCreateHsmClientCertificate_602511;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602527 = newJObject()
  add(query_602527, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    query_602527.add "Tags", Tags
  add(query_602527, "Action", newJString(Action))
  add(query_602527, "Version", newJString(Version))
  result = call_602526.call(nil, query_602527, nil, nil, nil)

var getCreateHsmClientCertificate* = Call_GetCreateHsmClientCertificate_602511(
    name: "getCreateHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_GetCreateHsmClientCertificate_602512, base: "/",
    url: url_GetCreateHsmClientCertificate_602513,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmConfiguration_602568 = ref object of OpenApiRestCall_601373
proc url_PostCreateHsmConfiguration_602570(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmConfiguration_602569(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602571 = query.getOrDefault("Action")
  valid_602571 = validateParameter(valid_602571, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_602571 != nil:
    section.add "Action", valid_602571
  var valid_602572 = query.getOrDefault("Version")
  valid_602572 = validateParameter(valid_602572, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602572 != nil:
    section.add "Version", valid_602572
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602573 = header.getOrDefault("X-Amz-Signature")
  valid_602573 = validateParameter(valid_602573, JString, required = false,
                                 default = nil)
  if valid_602573 != nil:
    section.add "X-Amz-Signature", valid_602573
  var valid_602574 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602574 = validateParameter(valid_602574, JString, required = false,
                                 default = nil)
  if valid_602574 != nil:
    section.add "X-Amz-Content-Sha256", valid_602574
  var valid_602575 = header.getOrDefault("X-Amz-Date")
  valid_602575 = validateParameter(valid_602575, JString, required = false,
                                 default = nil)
  if valid_602575 != nil:
    section.add "X-Amz-Date", valid_602575
  var valid_602576 = header.getOrDefault("X-Amz-Credential")
  valid_602576 = validateParameter(valid_602576, JString, required = false,
                                 default = nil)
  if valid_602576 != nil:
    section.add "X-Amz-Credential", valid_602576
  var valid_602577 = header.getOrDefault("X-Amz-Security-Token")
  valid_602577 = validateParameter(valid_602577, JString, required = false,
                                 default = nil)
  if valid_602577 != nil:
    section.add "X-Amz-Security-Token", valid_602577
  var valid_602578 = header.getOrDefault("X-Amz-Algorithm")
  valid_602578 = validateParameter(valid_602578, JString, required = false,
                                 default = nil)
  if valid_602578 != nil:
    section.add "X-Amz-Algorithm", valid_602578
  var valid_602579 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602579 = validateParameter(valid_602579, JString, required = false,
                                 default = nil)
  if valid_602579 != nil:
    section.add "X-Amz-SignedHeaders", valid_602579
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_602580 = formData.getOrDefault("Description")
  valid_602580 = validateParameter(valid_602580, JString, required = true,
                                 default = nil)
  if valid_602580 != nil:
    section.add "Description", valid_602580
  var valid_602581 = formData.getOrDefault("Tags")
  valid_602581 = validateParameter(valid_602581, JArray, required = false,
                                 default = nil)
  if valid_602581 != nil:
    section.add "Tags", valid_602581
  var valid_602582 = formData.getOrDefault("HsmPartitionPassword")
  valid_602582 = validateParameter(valid_602582, JString, required = true,
                                 default = nil)
  if valid_602582 != nil:
    section.add "HsmPartitionPassword", valid_602582
  var valid_602583 = formData.getOrDefault("HsmPartitionName")
  valid_602583 = validateParameter(valid_602583, JString, required = true,
                                 default = nil)
  if valid_602583 != nil:
    section.add "HsmPartitionName", valid_602583
  var valid_602584 = formData.getOrDefault("HsmServerPublicCertificate")
  valid_602584 = validateParameter(valid_602584, JString, required = true,
                                 default = nil)
  if valid_602584 != nil:
    section.add "HsmServerPublicCertificate", valid_602584
  var valid_602585 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_602585 = validateParameter(valid_602585, JString, required = true,
                                 default = nil)
  if valid_602585 != nil:
    section.add "HsmConfigurationIdentifier", valid_602585
  var valid_602586 = formData.getOrDefault("HsmIpAddress")
  valid_602586 = validateParameter(valid_602586, JString, required = true,
                                 default = nil)
  if valid_602586 != nil:
    section.add "HsmIpAddress", valid_602586
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602587: Call_PostCreateHsmConfiguration_602568; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_602587.validator(path, query, header, formData, body)
  let scheme = call_602587.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602587.url(scheme.get, call_602587.host, call_602587.base,
                         call_602587.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602587, url, valid)

proc call*(call_602588: Call_PostCreateHsmConfiguration_602568;
          Description: string; HsmPartitionPassword: string;
          HsmPartitionName: string; HsmServerPublicCertificate: string;
          HsmConfigurationIdentifier: string; HsmIpAddress: string;
          Action: string = "CreateHsmConfiguration"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   Version: string (required)
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  var query_602589 = newJObject()
  var formData_602590 = newJObject()
  add(formData_602590, "Description", newJString(Description))
  add(query_602589, "Action", newJString(Action))
  if Tags != nil:
    formData_602590.add "Tags", Tags
  add(formData_602590, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_602589, "Version", newJString(Version))
  add(formData_602590, "HsmPartitionName", newJString(HsmPartitionName))
  add(formData_602590, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(formData_602590, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_602590, "HsmIpAddress", newJString(HsmIpAddress))
  result = call_602588.call(nil, query_602589, nil, formData_602590, nil)

var postCreateHsmConfiguration* = Call_PostCreateHsmConfiguration_602568(
    name: "postCreateHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_PostCreateHsmConfiguration_602569, base: "/",
    url: url_PostCreateHsmConfiguration_602570,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmConfiguration_602546 = ref object of OpenApiRestCall_601373
proc url_GetCreateHsmConfiguration_602548(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmConfiguration_602547(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Version: JString (required)
  section = newJObject()
  var valid_602549 = query.getOrDefault("Tags")
  valid_602549 = validateParameter(valid_602549, JArray, required = false,
                                 default = nil)
  if valid_602549 != nil:
    section.add "Tags", valid_602549
  assert query != nil,
        "query argument is necessary due to required `HsmIpAddress` field"
  var valid_602550 = query.getOrDefault("HsmIpAddress")
  valid_602550 = validateParameter(valid_602550, JString, required = true,
                                 default = nil)
  if valid_602550 != nil:
    section.add "HsmIpAddress", valid_602550
  var valid_602551 = query.getOrDefault("HsmPartitionPassword")
  valid_602551 = validateParameter(valid_602551, JString, required = true,
                                 default = nil)
  if valid_602551 != nil:
    section.add "HsmPartitionPassword", valid_602551
  var valid_602552 = query.getOrDefault("HsmServerPublicCertificate")
  valid_602552 = validateParameter(valid_602552, JString, required = true,
                                 default = nil)
  if valid_602552 != nil:
    section.add "HsmServerPublicCertificate", valid_602552
  var valid_602553 = query.getOrDefault("HsmPartitionName")
  valid_602553 = validateParameter(valid_602553, JString, required = true,
                                 default = nil)
  if valid_602553 != nil:
    section.add "HsmPartitionName", valid_602553
  var valid_602554 = query.getOrDefault("Action")
  valid_602554 = validateParameter(valid_602554, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_602554 != nil:
    section.add "Action", valid_602554
  var valid_602555 = query.getOrDefault("Description")
  valid_602555 = validateParameter(valid_602555, JString, required = true,
                                 default = nil)
  if valid_602555 != nil:
    section.add "Description", valid_602555
  var valid_602556 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_602556 = validateParameter(valid_602556, JString, required = true,
                                 default = nil)
  if valid_602556 != nil:
    section.add "HsmConfigurationIdentifier", valid_602556
  var valid_602557 = query.getOrDefault("Version")
  valid_602557 = validateParameter(valid_602557, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602557 != nil:
    section.add "Version", valid_602557
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602558 = header.getOrDefault("X-Amz-Signature")
  valid_602558 = validateParameter(valid_602558, JString, required = false,
                                 default = nil)
  if valid_602558 != nil:
    section.add "X-Amz-Signature", valid_602558
  var valid_602559 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602559 = validateParameter(valid_602559, JString, required = false,
                                 default = nil)
  if valid_602559 != nil:
    section.add "X-Amz-Content-Sha256", valid_602559
  var valid_602560 = header.getOrDefault("X-Amz-Date")
  valid_602560 = validateParameter(valid_602560, JString, required = false,
                                 default = nil)
  if valid_602560 != nil:
    section.add "X-Amz-Date", valid_602560
  var valid_602561 = header.getOrDefault("X-Amz-Credential")
  valid_602561 = validateParameter(valid_602561, JString, required = false,
                                 default = nil)
  if valid_602561 != nil:
    section.add "X-Amz-Credential", valid_602561
  var valid_602562 = header.getOrDefault("X-Amz-Security-Token")
  valid_602562 = validateParameter(valid_602562, JString, required = false,
                                 default = nil)
  if valid_602562 != nil:
    section.add "X-Amz-Security-Token", valid_602562
  var valid_602563 = header.getOrDefault("X-Amz-Algorithm")
  valid_602563 = validateParameter(valid_602563, JString, required = false,
                                 default = nil)
  if valid_602563 != nil:
    section.add "X-Amz-Algorithm", valid_602563
  var valid_602564 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602564 = validateParameter(valid_602564, JString, required = false,
                                 default = nil)
  if valid_602564 != nil:
    section.add "X-Amz-SignedHeaders", valid_602564
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602565: Call_GetCreateHsmConfiguration_602546; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_602565.validator(path, query, header, formData, body)
  let scheme = call_602565.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602565.url(scheme.get, call_602565.host, call_602565.base,
                         call_602565.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602565, url, valid)

proc call*(call_602566: Call_GetCreateHsmConfiguration_602546;
          HsmIpAddress: string; HsmPartitionPassword: string;
          HsmServerPublicCertificate: string; HsmPartitionName: string;
          Description: string; HsmConfigurationIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Version: string (required)
  var query_602567 = newJObject()
  if Tags != nil:
    query_602567.add "Tags", Tags
  add(query_602567, "HsmIpAddress", newJString(HsmIpAddress))
  add(query_602567, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_602567, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_602567, "HsmPartitionName", newJString(HsmPartitionName))
  add(query_602567, "Action", newJString(Action))
  add(query_602567, "Description", newJString(Description))
  add(query_602567, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_602567, "Version", newJString(Version))
  result = call_602566.call(nil, query_602567, nil, nil, nil)

var getCreateHsmConfiguration* = Call_GetCreateHsmConfiguration_602546(
    name: "getCreateHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_GetCreateHsmConfiguration_602547, base: "/",
    url: url_GetCreateHsmConfiguration_602548,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateScheduledAction_602614 = ref object of OpenApiRestCall_601373
proc url_PostCreateScheduledAction_602616(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateScheduledAction_602615(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602617 = query.getOrDefault("Action")
  valid_602617 = validateParameter(valid_602617, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_602617 != nil:
    section.add "Action", valid_602617
  var valid_602618 = query.getOrDefault("Version")
  valid_602618 = validateParameter(valid_602618, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602618 != nil:
    section.add "Version", valid_602618
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602619 = header.getOrDefault("X-Amz-Signature")
  valid_602619 = validateParameter(valid_602619, JString, required = false,
                                 default = nil)
  if valid_602619 != nil:
    section.add "X-Amz-Signature", valid_602619
  var valid_602620 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602620 = validateParameter(valid_602620, JString, required = false,
                                 default = nil)
  if valid_602620 != nil:
    section.add "X-Amz-Content-Sha256", valid_602620
  var valid_602621 = header.getOrDefault("X-Amz-Date")
  valid_602621 = validateParameter(valid_602621, JString, required = false,
                                 default = nil)
  if valid_602621 != nil:
    section.add "X-Amz-Date", valid_602621
  var valid_602622 = header.getOrDefault("X-Amz-Credential")
  valid_602622 = validateParameter(valid_602622, JString, required = false,
                                 default = nil)
  if valid_602622 != nil:
    section.add "X-Amz-Credential", valid_602622
  var valid_602623 = header.getOrDefault("X-Amz-Security-Token")
  valid_602623 = validateParameter(valid_602623, JString, required = false,
                                 default = nil)
  if valid_602623 != nil:
    section.add "X-Amz-Security-Token", valid_602623
  var valid_602624 = header.getOrDefault("X-Amz-Algorithm")
  valid_602624 = validateParameter(valid_602624, JString, required = false,
                                 default = nil)
  if valid_602624 != nil:
    section.add "X-Amz-Algorithm", valid_602624
  var valid_602625 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602625 = validateParameter(valid_602625, JString, required = false,
                                 default = nil)
  if valid_602625 != nil:
    section.add "X-Amz-SignedHeaders", valid_602625
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  section = newJObject()
  var valid_602626 = formData.getOrDefault("Enable")
  valid_602626 = validateParameter(valid_602626, JBool, required = false, default = nil)
  if valid_602626 != nil:
    section.add "Enable", valid_602626
  var valid_602627 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_602627 = validateParameter(valid_602627, JString, required = false,
                                 default = nil)
  if valid_602627 != nil:
    section.add "TargetAction.ResizeCluster", valid_602627
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_602628 = formData.getOrDefault("ScheduledActionName")
  valid_602628 = validateParameter(valid_602628, JString, required = true,
                                 default = nil)
  if valid_602628 != nil:
    section.add "ScheduledActionName", valid_602628
  var valid_602629 = formData.getOrDefault("ScheduledActionDescription")
  valid_602629 = validateParameter(valid_602629, JString, required = false,
                                 default = nil)
  if valid_602629 != nil:
    section.add "ScheduledActionDescription", valid_602629
  var valid_602630 = formData.getOrDefault("Schedule")
  valid_602630 = validateParameter(valid_602630, JString, required = true,
                                 default = nil)
  if valid_602630 != nil:
    section.add "Schedule", valid_602630
  var valid_602631 = formData.getOrDefault("EndTime")
  valid_602631 = validateParameter(valid_602631, JString, required = false,
                                 default = nil)
  if valid_602631 != nil:
    section.add "EndTime", valid_602631
  var valid_602632 = formData.getOrDefault("StartTime")
  valid_602632 = validateParameter(valid_602632, JString, required = false,
                                 default = nil)
  if valid_602632 != nil:
    section.add "StartTime", valid_602632
  var valid_602633 = formData.getOrDefault("IamRole")
  valid_602633 = validateParameter(valid_602633, JString, required = true,
                                 default = nil)
  if valid_602633 != nil:
    section.add "IamRole", valid_602633
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602634: Call_PostCreateScheduledAction_602614; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_602634.validator(path, query, header, formData, body)
  let scheme = call_602634.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602634.url(scheme.get, call_602634.host, call_602634.base,
                         call_602634.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602634, url, valid)

proc call*(call_602635: Call_PostCreateScheduledAction_602614;
          ScheduledActionName: string; Schedule: string; IamRole: string;
          Enable: bool = false; TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = ""; EndTime: string = "";
          StartTime: string = ""; Action: string = "CreateScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  var query_602636 = newJObject()
  var formData_602637 = newJObject()
  add(formData_602637, "Enable", newJBool(Enable))
  add(formData_602637, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_602637, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_602637, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_602637, "Schedule", newJString(Schedule))
  add(formData_602637, "EndTime", newJString(EndTime))
  add(formData_602637, "StartTime", newJString(StartTime))
  add(query_602636, "Action", newJString(Action))
  add(query_602636, "Version", newJString(Version))
  add(formData_602637, "IamRole", newJString(IamRole))
  result = call_602635.call(nil, query_602636, nil, formData_602637, nil)

var postCreateScheduledAction* = Call_PostCreateScheduledAction_602614(
    name: "postCreateScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_PostCreateScheduledAction_602615, base: "/",
    url: url_PostCreateScheduledAction_602616,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateScheduledAction_602591 = ref object of OpenApiRestCall_601373
proc url_GetCreateScheduledAction_602593(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateScheduledAction_602592(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Schedule` field"
  var valid_602594 = query.getOrDefault("Schedule")
  valid_602594 = validateParameter(valid_602594, JString, required = true,
                                 default = nil)
  if valid_602594 != nil:
    section.add "Schedule", valid_602594
  var valid_602595 = query.getOrDefault("Enable")
  valid_602595 = validateParameter(valid_602595, JBool, required = false, default = nil)
  if valid_602595 != nil:
    section.add "Enable", valid_602595
  var valid_602596 = query.getOrDefault("ScheduledActionName")
  valid_602596 = validateParameter(valid_602596, JString, required = true,
                                 default = nil)
  if valid_602596 != nil:
    section.add "ScheduledActionName", valid_602596
  var valid_602597 = query.getOrDefault("IamRole")
  valid_602597 = validateParameter(valid_602597, JString, required = true,
                                 default = nil)
  if valid_602597 != nil:
    section.add "IamRole", valid_602597
  var valid_602598 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_602598 = validateParameter(valid_602598, JString, required = false,
                                 default = nil)
  if valid_602598 != nil:
    section.add "TargetAction.ResizeCluster", valid_602598
  var valid_602599 = query.getOrDefault("ScheduledActionDescription")
  valid_602599 = validateParameter(valid_602599, JString, required = false,
                                 default = nil)
  if valid_602599 != nil:
    section.add "ScheduledActionDescription", valid_602599
  var valid_602600 = query.getOrDefault("Action")
  valid_602600 = validateParameter(valid_602600, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_602600 != nil:
    section.add "Action", valid_602600
  var valid_602601 = query.getOrDefault("StartTime")
  valid_602601 = validateParameter(valid_602601, JString, required = false,
                                 default = nil)
  if valid_602601 != nil:
    section.add "StartTime", valid_602601
  var valid_602602 = query.getOrDefault("EndTime")
  valid_602602 = validateParameter(valid_602602, JString, required = false,
                                 default = nil)
  if valid_602602 != nil:
    section.add "EndTime", valid_602602
  var valid_602603 = query.getOrDefault("Version")
  valid_602603 = validateParameter(valid_602603, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602603 != nil:
    section.add "Version", valid_602603
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602604 = header.getOrDefault("X-Amz-Signature")
  valid_602604 = validateParameter(valid_602604, JString, required = false,
                                 default = nil)
  if valid_602604 != nil:
    section.add "X-Amz-Signature", valid_602604
  var valid_602605 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602605 = validateParameter(valid_602605, JString, required = false,
                                 default = nil)
  if valid_602605 != nil:
    section.add "X-Amz-Content-Sha256", valid_602605
  var valid_602606 = header.getOrDefault("X-Amz-Date")
  valid_602606 = validateParameter(valid_602606, JString, required = false,
                                 default = nil)
  if valid_602606 != nil:
    section.add "X-Amz-Date", valid_602606
  var valid_602607 = header.getOrDefault("X-Amz-Credential")
  valid_602607 = validateParameter(valid_602607, JString, required = false,
                                 default = nil)
  if valid_602607 != nil:
    section.add "X-Amz-Credential", valid_602607
  var valid_602608 = header.getOrDefault("X-Amz-Security-Token")
  valid_602608 = validateParameter(valid_602608, JString, required = false,
                                 default = nil)
  if valid_602608 != nil:
    section.add "X-Amz-Security-Token", valid_602608
  var valid_602609 = header.getOrDefault("X-Amz-Algorithm")
  valid_602609 = validateParameter(valid_602609, JString, required = false,
                                 default = nil)
  if valid_602609 != nil:
    section.add "X-Amz-Algorithm", valid_602609
  var valid_602610 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602610 = validateParameter(valid_602610, JString, required = false,
                                 default = nil)
  if valid_602610 != nil:
    section.add "X-Amz-SignedHeaders", valid_602610
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602611: Call_GetCreateScheduledAction_602591; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_602611.validator(path, query, header, formData, body)
  let scheme = call_602611.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602611.url(scheme.get, call_602611.host, call_602611.base,
                         call_602611.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602611, url, valid)

proc call*(call_602612: Call_GetCreateScheduledAction_602591; Schedule: string;
          ScheduledActionName: string; IamRole: string; Enable: bool = false;
          TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = "";
          Action: string = "CreateScheduledAction"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_602613 = newJObject()
  add(query_602613, "Schedule", newJString(Schedule))
  add(query_602613, "Enable", newJBool(Enable))
  add(query_602613, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_602613, "IamRole", newJString(IamRole))
  add(query_602613, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(query_602613, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_602613, "Action", newJString(Action))
  add(query_602613, "StartTime", newJString(StartTime))
  add(query_602613, "EndTime", newJString(EndTime))
  add(query_602613, "Version", newJString(Version))
  result = call_602612.call(nil, query_602613, nil, nil, nil)

var getCreateScheduledAction* = Call_GetCreateScheduledAction_602591(
    name: "getCreateScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_GetCreateScheduledAction_602592, base: "/",
    url: url_GetCreateScheduledAction_602593, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotCopyGrant_602656 = ref object of OpenApiRestCall_601373
proc url_PostCreateSnapshotCopyGrant_602658(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotCopyGrant_602657(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602659 = query.getOrDefault("Action")
  valid_602659 = validateParameter(valid_602659, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_602659 != nil:
    section.add "Action", valid_602659
  var valid_602660 = query.getOrDefault("Version")
  valid_602660 = validateParameter(valid_602660, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602660 != nil:
    section.add "Version", valid_602660
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602661 = header.getOrDefault("X-Amz-Signature")
  valid_602661 = validateParameter(valid_602661, JString, required = false,
                                 default = nil)
  if valid_602661 != nil:
    section.add "X-Amz-Signature", valid_602661
  var valid_602662 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602662 = validateParameter(valid_602662, JString, required = false,
                                 default = nil)
  if valid_602662 != nil:
    section.add "X-Amz-Content-Sha256", valid_602662
  var valid_602663 = header.getOrDefault("X-Amz-Date")
  valid_602663 = validateParameter(valid_602663, JString, required = false,
                                 default = nil)
  if valid_602663 != nil:
    section.add "X-Amz-Date", valid_602663
  var valid_602664 = header.getOrDefault("X-Amz-Credential")
  valid_602664 = validateParameter(valid_602664, JString, required = false,
                                 default = nil)
  if valid_602664 != nil:
    section.add "X-Amz-Credential", valid_602664
  var valid_602665 = header.getOrDefault("X-Amz-Security-Token")
  valid_602665 = validateParameter(valid_602665, JString, required = false,
                                 default = nil)
  if valid_602665 != nil:
    section.add "X-Amz-Security-Token", valid_602665
  var valid_602666 = header.getOrDefault("X-Amz-Algorithm")
  valid_602666 = validateParameter(valid_602666, JString, required = false,
                                 default = nil)
  if valid_602666 != nil:
    section.add "X-Amz-Algorithm", valid_602666
  var valid_602667 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602667 = validateParameter(valid_602667, JString, required = false,
                                 default = nil)
  if valid_602667 != nil:
    section.add "X-Amz-SignedHeaders", valid_602667
  result.add "header", section
  ## parameters in `formData` object:
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  section = newJObject()
  var valid_602668 = formData.getOrDefault("KmsKeyId")
  valid_602668 = validateParameter(valid_602668, JString, required = false,
                                 default = nil)
  if valid_602668 != nil:
    section.add "KmsKeyId", valid_602668
  var valid_602669 = formData.getOrDefault("Tags")
  valid_602669 = validateParameter(valid_602669, JArray, required = false,
                                 default = nil)
  if valid_602669 != nil:
    section.add "Tags", valid_602669
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_602670 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_602670 = validateParameter(valid_602670, JString, required = true,
                                 default = nil)
  if valid_602670 != nil:
    section.add "SnapshotCopyGrantName", valid_602670
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602671: Call_PostCreateSnapshotCopyGrant_602656; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_602671.validator(path, query, header, formData, body)
  let scheme = call_602671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602671.url(scheme.get, call_602671.host, call_602671.base,
                         call_602671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602671, url, valid)

proc call*(call_602672: Call_PostCreateSnapshotCopyGrant_602656;
          SnapshotCopyGrantName: string; KmsKeyId: string = "";
          Action: string = "CreateSnapshotCopyGrant"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: string (required)
  var query_602673 = newJObject()
  var formData_602674 = newJObject()
  add(formData_602674, "KmsKeyId", newJString(KmsKeyId))
  add(query_602673, "Action", newJString(Action))
  if Tags != nil:
    formData_602674.add "Tags", Tags
  add(formData_602674, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_602673, "Version", newJString(Version))
  result = call_602672.call(nil, query_602673, nil, formData_602674, nil)

var postCreateSnapshotCopyGrant* = Call_PostCreateSnapshotCopyGrant_602656(
    name: "postCreateSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_PostCreateSnapshotCopyGrant_602657, base: "/",
    url: url_PostCreateSnapshotCopyGrant_602658,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotCopyGrant_602638 = ref object of OpenApiRestCall_601373
proc url_GetCreateSnapshotCopyGrant_602640(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotCopyGrant_602639(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  section = newJObject()
  var valid_602641 = query.getOrDefault("Tags")
  valid_602641 = validateParameter(valid_602641, JArray, required = false,
                                 default = nil)
  if valid_602641 != nil:
    section.add "Tags", valid_602641
  var valid_602642 = query.getOrDefault("KmsKeyId")
  valid_602642 = validateParameter(valid_602642, JString, required = false,
                                 default = nil)
  if valid_602642 != nil:
    section.add "KmsKeyId", valid_602642
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602643 = query.getOrDefault("Action")
  valid_602643 = validateParameter(valid_602643, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_602643 != nil:
    section.add "Action", valid_602643
  var valid_602644 = query.getOrDefault("Version")
  valid_602644 = validateParameter(valid_602644, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602644 != nil:
    section.add "Version", valid_602644
  var valid_602645 = query.getOrDefault("SnapshotCopyGrantName")
  valid_602645 = validateParameter(valid_602645, JString, required = true,
                                 default = nil)
  if valid_602645 != nil:
    section.add "SnapshotCopyGrantName", valid_602645
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602646 = header.getOrDefault("X-Amz-Signature")
  valid_602646 = validateParameter(valid_602646, JString, required = false,
                                 default = nil)
  if valid_602646 != nil:
    section.add "X-Amz-Signature", valid_602646
  var valid_602647 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602647 = validateParameter(valid_602647, JString, required = false,
                                 default = nil)
  if valid_602647 != nil:
    section.add "X-Amz-Content-Sha256", valid_602647
  var valid_602648 = header.getOrDefault("X-Amz-Date")
  valid_602648 = validateParameter(valid_602648, JString, required = false,
                                 default = nil)
  if valid_602648 != nil:
    section.add "X-Amz-Date", valid_602648
  var valid_602649 = header.getOrDefault("X-Amz-Credential")
  valid_602649 = validateParameter(valid_602649, JString, required = false,
                                 default = nil)
  if valid_602649 != nil:
    section.add "X-Amz-Credential", valid_602649
  var valid_602650 = header.getOrDefault("X-Amz-Security-Token")
  valid_602650 = validateParameter(valid_602650, JString, required = false,
                                 default = nil)
  if valid_602650 != nil:
    section.add "X-Amz-Security-Token", valid_602650
  var valid_602651 = header.getOrDefault("X-Amz-Algorithm")
  valid_602651 = validateParameter(valid_602651, JString, required = false,
                                 default = nil)
  if valid_602651 != nil:
    section.add "X-Amz-Algorithm", valid_602651
  var valid_602652 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602652 = validateParameter(valid_602652, JString, required = false,
                                 default = nil)
  if valid_602652 != nil:
    section.add "X-Amz-SignedHeaders", valid_602652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602653: Call_GetCreateSnapshotCopyGrant_602638; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_602653.validator(path, query, header, formData, body)
  let scheme = call_602653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602653.url(scheme.get, call_602653.host, call_602653.base,
                         call_602653.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602653, url, valid)

proc call*(call_602654: Call_GetCreateSnapshotCopyGrant_602638;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil; KmsKeyId: string = "";
          Action: string = "CreateSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  var query_602655 = newJObject()
  if Tags != nil:
    query_602655.add "Tags", Tags
  add(query_602655, "KmsKeyId", newJString(KmsKeyId))
  add(query_602655, "Action", newJString(Action))
  add(query_602655, "Version", newJString(Version))
  add(query_602655, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_602654.call(nil, query_602655, nil, nil, nil)

var getCreateSnapshotCopyGrant* = Call_GetCreateSnapshotCopyGrant_602638(
    name: "getCreateSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_GetCreateSnapshotCopyGrant_602639, base: "/",
    url: url_GetCreateSnapshotCopyGrant_602640,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotSchedule_602696 = ref object of OpenApiRestCall_601373
proc url_PostCreateSnapshotSchedule_602698(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotSchedule_602697(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602699 = query.getOrDefault("Action")
  valid_602699 = validateParameter(valid_602699, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_602699 != nil:
    section.add "Action", valid_602699
  var valid_602700 = query.getOrDefault("Version")
  valid_602700 = validateParameter(valid_602700, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602700 != nil:
    section.add "Version", valid_602700
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602701 = header.getOrDefault("X-Amz-Signature")
  valid_602701 = validateParameter(valid_602701, JString, required = false,
                                 default = nil)
  if valid_602701 != nil:
    section.add "X-Amz-Signature", valid_602701
  var valid_602702 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602702 = validateParameter(valid_602702, JString, required = false,
                                 default = nil)
  if valid_602702 != nil:
    section.add "X-Amz-Content-Sha256", valid_602702
  var valid_602703 = header.getOrDefault("X-Amz-Date")
  valid_602703 = validateParameter(valid_602703, JString, required = false,
                                 default = nil)
  if valid_602703 != nil:
    section.add "X-Amz-Date", valid_602703
  var valid_602704 = header.getOrDefault("X-Amz-Credential")
  valid_602704 = validateParameter(valid_602704, JString, required = false,
                                 default = nil)
  if valid_602704 != nil:
    section.add "X-Amz-Credential", valid_602704
  var valid_602705 = header.getOrDefault("X-Amz-Security-Token")
  valid_602705 = validateParameter(valid_602705, JString, required = false,
                                 default = nil)
  if valid_602705 != nil:
    section.add "X-Amz-Security-Token", valid_602705
  var valid_602706 = header.getOrDefault("X-Amz-Algorithm")
  valid_602706 = validateParameter(valid_602706, JString, required = false,
                                 default = nil)
  if valid_602706 != nil:
    section.add "X-Amz-Algorithm", valid_602706
  var valid_602707 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602707 = validateParameter(valid_602707, JString, required = false,
                                 default = nil)
  if valid_602707 != nil:
    section.add "X-Amz-SignedHeaders", valid_602707
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   DryRun: JBool
  ##         : <p/>
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  section = newJObject()
  var valid_602708 = formData.getOrDefault("ScheduleDefinitions")
  valid_602708 = validateParameter(valid_602708, JArray, required = false,
                                 default = nil)
  if valid_602708 != nil:
    section.add "ScheduleDefinitions", valid_602708
  var valid_602709 = formData.getOrDefault("ScheduleDescription")
  valid_602709 = validateParameter(valid_602709, JString, required = false,
                                 default = nil)
  if valid_602709 != nil:
    section.add "ScheduleDescription", valid_602709
  var valid_602710 = formData.getOrDefault("DryRun")
  valid_602710 = validateParameter(valid_602710, JBool, required = false, default = nil)
  if valid_602710 != nil:
    section.add "DryRun", valid_602710
  var valid_602711 = formData.getOrDefault("NextInvocations")
  valid_602711 = validateParameter(valid_602711, JInt, required = false, default = nil)
  if valid_602711 != nil:
    section.add "NextInvocations", valid_602711
  var valid_602712 = formData.getOrDefault("Tags")
  valid_602712 = validateParameter(valid_602712, JArray, required = false,
                                 default = nil)
  if valid_602712 != nil:
    section.add "Tags", valid_602712
  var valid_602713 = formData.getOrDefault("ScheduleIdentifier")
  valid_602713 = validateParameter(valid_602713, JString, required = false,
                                 default = nil)
  if valid_602713 != nil:
    section.add "ScheduleIdentifier", valid_602713
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602714: Call_PostCreateSnapshotSchedule_602696; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_602714.validator(path, query, header, formData, body)
  let scheme = call_602714.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602714.url(scheme.get, call_602714.host, call_602714.base,
                         call_602714.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602714, url, valid)

proc call*(call_602715: Call_PostCreateSnapshotSchedule_602696;
          ScheduleDefinitions: JsonNode = nil; ScheduleDescription: string = "";
          DryRun: bool = false; NextInvocations: int = 0;
          Action: string = "CreateSnapshotSchedule"; Tags: JsonNode = nil;
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   DryRun: bool
  ##         : <p/>
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   Version: string (required)
  var query_602716 = newJObject()
  var formData_602717 = newJObject()
  if ScheduleDefinitions != nil:
    formData_602717.add "ScheduleDefinitions", ScheduleDefinitions
  add(formData_602717, "ScheduleDescription", newJString(ScheduleDescription))
  add(formData_602717, "DryRun", newJBool(DryRun))
  add(formData_602717, "NextInvocations", newJInt(NextInvocations))
  add(query_602716, "Action", newJString(Action))
  if Tags != nil:
    formData_602717.add "Tags", Tags
  add(formData_602717, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_602716, "Version", newJString(Version))
  result = call_602715.call(nil, query_602716, nil, formData_602717, nil)

var postCreateSnapshotSchedule* = Call_PostCreateSnapshotSchedule_602696(
    name: "postCreateSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_PostCreateSnapshotSchedule_602697, base: "/",
    url: url_PostCreateSnapshotSchedule_602698,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotSchedule_602675 = ref object of OpenApiRestCall_601373
proc url_GetCreateSnapshotSchedule_602677(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotSchedule_602676(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   DryRun: JBool
  ##         : <p/>
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_602678 = query.getOrDefault("Tags")
  valid_602678 = validateParameter(valid_602678, JArray, required = false,
                                 default = nil)
  if valid_602678 != nil:
    section.add "Tags", valid_602678
  var valid_602679 = query.getOrDefault("ScheduleIdentifier")
  valid_602679 = validateParameter(valid_602679, JString, required = false,
                                 default = nil)
  if valid_602679 != nil:
    section.add "ScheduleIdentifier", valid_602679
  var valid_602680 = query.getOrDefault("DryRun")
  valid_602680 = validateParameter(valid_602680, JBool, required = false, default = nil)
  if valid_602680 != nil:
    section.add "DryRun", valid_602680
  var valid_602681 = query.getOrDefault("NextInvocations")
  valid_602681 = validateParameter(valid_602681, JInt, required = false, default = nil)
  if valid_602681 != nil:
    section.add "NextInvocations", valid_602681
  var valid_602682 = query.getOrDefault("ScheduleDefinitions")
  valid_602682 = validateParameter(valid_602682, JArray, required = false,
                                 default = nil)
  if valid_602682 != nil:
    section.add "ScheduleDefinitions", valid_602682
  var valid_602683 = query.getOrDefault("ScheduleDescription")
  valid_602683 = validateParameter(valid_602683, JString, required = false,
                                 default = nil)
  if valid_602683 != nil:
    section.add "ScheduleDescription", valid_602683
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602684 = query.getOrDefault("Action")
  valid_602684 = validateParameter(valid_602684, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_602684 != nil:
    section.add "Action", valid_602684
  var valid_602685 = query.getOrDefault("Version")
  valid_602685 = validateParameter(valid_602685, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602685 != nil:
    section.add "Version", valid_602685
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602686 = header.getOrDefault("X-Amz-Signature")
  valid_602686 = validateParameter(valid_602686, JString, required = false,
                                 default = nil)
  if valid_602686 != nil:
    section.add "X-Amz-Signature", valid_602686
  var valid_602687 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602687 = validateParameter(valid_602687, JString, required = false,
                                 default = nil)
  if valid_602687 != nil:
    section.add "X-Amz-Content-Sha256", valid_602687
  var valid_602688 = header.getOrDefault("X-Amz-Date")
  valid_602688 = validateParameter(valid_602688, JString, required = false,
                                 default = nil)
  if valid_602688 != nil:
    section.add "X-Amz-Date", valid_602688
  var valid_602689 = header.getOrDefault("X-Amz-Credential")
  valid_602689 = validateParameter(valid_602689, JString, required = false,
                                 default = nil)
  if valid_602689 != nil:
    section.add "X-Amz-Credential", valid_602689
  var valid_602690 = header.getOrDefault("X-Amz-Security-Token")
  valid_602690 = validateParameter(valid_602690, JString, required = false,
                                 default = nil)
  if valid_602690 != nil:
    section.add "X-Amz-Security-Token", valid_602690
  var valid_602691 = header.getOrDefault("X-Amz-Algorithm")
  valid_602691 = validateParameter(valid_602691, JString, required = false,
                                 default = nil)
  if valid_602691 != nil:
    section.add "X-Amz-Algorithm", valid_602691
  var valid_602692 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602692 = validateParameter(valid_602692, JString, required = false,
                                 default = nil)
  if valid_602692 != nil:
    section.add "X-Amz-SignedHeaders", valid_602692
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602693: Call_GetCreateSnapshotSchedule_602675; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_602693.validator(path, query, header, formData, body)
  let scheme = call_602693.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602693.url(scheme.get, call_602693.host, call_602693.base,
                         call_602693.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602693, url, valid)

proc call*(call_602694: Call_GetCreateSnapshotSchedule_602675;
          Tags: JsonNode = nil; ScheduleIdentifier: string = ""; DryRun: bool = false;
          NextInvocations: int = 0; ScheduleDefinitions: JsonNode = nil;
          ScheduleDescription: string = "";
          Action: string = "CreateSnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   DryRun: bool
  ##         : <p/>
  ##   NextInvocations: int
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602695 = newJObject()
  if Tags != nil:
    query_602695.add "Tags", Tags
  add(query_602695, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_602695, "DryRun", newJBool(DryRun))
  add(query_602695, "NextInvocations", newJInt(NextInvocations))
  if ScheduleDefinitions != nil:
    query_602695.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_602695, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_602695, "Action", newJString(Action))
  add(query_602695, "Version", newJString(Version))
  result = call_602694.call(nil, query_602695, nil, nil, nil)

var getCreateSnapshotSchedule* = Call_GetCreateSnapshotSchedule_602675(
    name: "getCreateSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_GetCreateSnapshotSchedule_602676, base: "/",
    url: url_GetCreateSnapshotSchedule_602677,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateTags_602735 = ref object of OpenApiRestCall_601373
proc url_PostCreateTags_602737(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateTags_602736(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602738 = query.getOrDefault("Action")
  valid_602738 = validateParameter(valid_602738, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_602738 != nil:
    section.add "Action", valid_602738
  var valid_602739 = query.getOrDefault("Version")
  valid_602739 = validateParameter(valid_602739, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602739 != nil:
    section.add "Version", valid_602739
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602740 = header.getOrDefault("X-Amz-Signature")
  valid_602740 = validateParameter(valid_602740, JString, required = false,
                                 default = nil)
  if valid_602740 != nil:
    section.add "X-Amz-Signature", valid_602740
  var valid_602741 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602741 = validateParameter(valid_602741, JString, required = false,
                                 default = nil)
  if valid_602741 != nil:
    section.add "X-Amz-Content-Sha256", valid_602741
  var valid_602742 = header.getOrDefault("X-Amz-Date")
  valid_602742 = validateParameter(valid_602742, JString, required = false,
                                 default = nil)
  if valid_602742 != nil:
    section.add "X-Amz-Date", valid_602742
  var valid_602743 = header.getOrDefault("X-Amz-Credential")
  valid_602743 = validateParameter(valid_602743, JString, required = false,
                                 default = nil)
  if valid_602743 != nil:
    section.add "X-Amz-Credential", valid_602743
  var valid_602744 = header.getOrDefault("X-Amz-Security-Token")
  valid_602744 = validateParameter(valid_602744, JString, required = false,
                                 default = nil)
  if valid_602744 != nil:
    section.add "X-Amz-Security-Token", valid_602744
  var valid_602745 = header.getOrDefault("X-Amz-Algorithm")
  valid_602745 = validateParameter(valid_602745, JString, required = false,
                                 default = nil)
  if valid_602745 != nil:
    section.add "X-Amz-Algorithm", valid_602745
  var valid_602746 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602746 = validateParameter(valid_602746, JString, required = false,
                                 default = nil)
  if valid_602746 != nil:
    section.add "X-Amz-SignedHeaders", valid_602746
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Tags` field"
  var valid_602747 = formData.getOrDefault("Tags")
  valid_602747 = validateParameter(valid_602747, JArray, required = true, default = nil)
  if valid_602747 != nil:
    section.add "Tags", valid_602747
  var valid_602748 = formData.getOrDefault("ResourceName")
  valid_602748 = validateParameter(valid_602748, JString, required = true,
                                 default = nil)
  if valid_602748 != nil:
    section.add "ResourceName", valid_602748
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602749: Call_PostCreateTags_602735; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_602749.validator(path, query, header, formData, body)
  let scheme = call_602749.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602749.url(scheme.get, call_602749.host, call_602749.base,
                         call_602749.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602749, url, valid)

proc call*(call_602750: Call_PostCreateTags_602735; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Action: string (required)
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Version: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  var query_602751 = newJObject()
  var formData_602752 = newJObject()
  add(query_602751, "Action", newJString(Action))
  if Tags != nil:
    formData_602752.add "Tags", Tags
  add(query_602751, "Version", newJString(Version))
  add(formData_602752, "ResourceName", newJString(ResourceName))
  result = call_602750.call(nil, query_602751, nil, formData_602752, nil)

var postCreateTags* = Call_PostCreateTags_602735(name: "postCreateTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_PostCreateTags_602736,
    base: "/", url: url_PostCreateTags_602737, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateTags_602718 = ref object of OpenApiRestCall_601373
proc url_GetCreateTags_602720(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateTags_602719(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Tags` field"
  var valid_602721 = query.getOrDefault("Tags")
  valid_602721 = validateParameter(valid_602721, JArray, required = true, default = nil)
  if valid_602721 != nil:
    section.add "Tags", valid_602721
  var valid_602722 = query.getOrDefault("ResourceName")
  valid_602722 = validateParameter(valid_602722, JString, required = true,
                                 default = nil)
  if valid_602722 != nil:
    section.add "ResourceName", valid_602722
  var valid_602723 = query.getOrDefault("Action")
  valid_602723 = validateParameter(valid_602723, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_602723 != nil:
    section.add "Action", valid_602723
  var valid_602724 = query.getOrDefault("Version")
  valid_602724 = validateParameter(valid_602724, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602724 != nil:
    section.add "Version", valid_602724
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602725 = header.getOrDefault("X-Amz-Signature")
  valid_602725 = validateParameter(valid_602725, JString, required = false,
                                 default = nil)
  if valid_602725 != nil:
    section.add "X-Amz-Signature", valid_602725
  var valid_602726 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602726 = validateParameter(valid_602726, JString, required = false,
                                 default = nil)
  if valid_602726 != nil:
    section.add "X-Amz-Content-Sha256", valid_602726
  var valid_602727 = header.getOrDefault("X-Amz-Date")
  valid_602727 = validateParameter(valid_602727, JString, required = false,
                                 default = nil)
  if valid_602727 != nil:
    section.add "X-Amz-Date", valid_602727
  var valid_602728 = header.getOrDefault("X-Amz-Credential")
  valid_602728 = validateParameter(valid_602728, JString, required = false,
                                 default = nil)
  if valid_602728 != nil:
    section.add "X-Amz-Credential", valid_602728
  var valid_602729 = header.getOrDefault("X-Amz-Security-Token")
  valid_602729 = validateParameter(valid_602729, JString, required = false,
                                 default = nil)
  if valid_602729 != nil:
    section.add "X-Amz-Security-Token", valid_602729
  var valid_602730 = header.getOrDefault("X-Amz-Algorithm")
  valid_602730 = validateParameter(valid_602730, JString, required = false,
                                 default = nil)
  if valid_602730 != nil:
    section.add "X-Amz-Algorithm", valid_602730
  var valid_602731 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602731 = validateParameter(valid_602731, JString, required = false,
                                 default = nil)
  if valid_602731 != nil:
    section.add "X-Amz-SignedHeaders", valid_602731
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602732: Call_GetCreateTags_602718; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_602732.validator(path, query, header, formData, body)
  let scheme = call_602732.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602732.url(scheme.get, call_602732.host, call_602732.base,
                         call_602732.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602732, url, valid)

proc call*(call_602733: Call_GetCreateTags_602718; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602734 = newJObject()
  if Tags != nil:
    query_602734.add "Tags", Tags
  add(query_602734, "ResourceName", newJString(ResourceName))
  add(query_602734, "Action", newJString(Action))
  add(query_602734, "Version", newJString(Version))
  result = call_602733.call(nil, query_602734, nil, nil, nil)

var getCreateTags* = Call_GetCreateTags_602718(name: "getCreateTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_GetCreateTags_602719,
    base: "/", url: url_GetCreateTags_602720, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteCluster_602772 = ref object of OpenApiRestCall_601373
proc url_PostDeleteCluster_602774(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteCluster_602773(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602775 = query.getOrDefault("Action")
  valid_602775 = validateParameter(valid_602775, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_602775 != nil:
    section.add "Action", valid_602775
  var valid_602776 = query.getOrDefault("Version")
  valid_602776 = validateParameter(valid_602776, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602776 != nil:
    section.add "Version", valid_602776
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602777 = header.getOrDefault("X-Amz-Signature")
  valid_602777 = validateParameter(valid_602777, JString, required = false,
                                 default = nil)
  if valid_602777 != nil:
    section.add "X-Amz-Signature", valid_602777
  var valid_602778 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602778 = validateParameter(valid_602778, JString, required = false,
                                 default = nil)
  if valid_602778 != nil:
    section.add "X-Amz-Content-Sha256", valid_602778
  var valid_602779 = header.getOrDefault("X-Amz-Date")
  valid_602779 = validateParameter(valid_602779, JString, required = false,
                                 default = nil)
  if valid_602779 != nil:
    section.add "X-Amz-Date", valid_602779
  var valid_602780 = header.getOrDefault("X-Amz-Credential")
  valid_602780 = validateParameter(valid_602780, JString, required = false,
                                 default = nil)
  if valid_602780 != nil:
    section.add "X-Amz-Credential", valid_602780
  var valid_602781 = header.getOrDefault("X-Amz-Security-Token")
  valid_602781 = validateParameter(valid_602781, JString, required = false,
                                 default = nil)
  if valid_602781 != nil:
    section.add "X-Amz-Security-Token", valid_602781
  var valid_602782 = header.getOrDefault("X-Amz-Algorithm")
  valid_602782 = validateParameter(valid_602782, JString, required = false,
                                 default = nil)
  if valid_602782 != nil:
    section.add "X-Amz-Algorithm", valid_602782
  var valid_602783 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602783 = validateParameter(valid_602783, JString, required = false,
                                 default = nil)
  if valid_602783 != nil:
    section.add "X-Amz-SignedHeaders", valid_602783
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_602784 = formData.getOrDefault("ClusterIdentifier")
  valid_602784 = validateParameter(valid_602784, JString, required = true,
                                 default = nil)
  if valid_602784 != nil:
    section.add "ClusterIdentifier", valid_602784
  var valid_602785 = formData.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_602785 = validateParameter(valid_602785, JString, required = false,
                                 default = nil)
  if valid_602785 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_602785
  var valid_602786 = formData.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_602786 = validateParameter(valid_602786, JInt, required = false, default = nil)
  if valid_602786 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_602786
  var valid_602787 = formData.getOrDefault("SkipFinalClusterSnapshot")
  valid_602787 = validateParameter(valid_602787, JBool, required = false, default = nil)
  if valid_602787 != nil:
    section.add "SkipFinalClusterSnapshot", valid_602787
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602788: Call_PostDeleteCluster_602772; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602788.validator(path, query, header, formData, body)
  let scheme = call_602788.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602788.url(scheme.get, call_602788.host, call_602788.base,
                         call_602788.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602788, url, valid)

proc call*(call_602789: Call_PostDeleteCluster_602772; ClusterIdentifier: string;
          FinalClusterSnapshotIdentifier: string = "";
          Action: string = "DeleteCluster";
          FinalClusterSnapshotRetentionPeriod: int = 0;
          Version: string = "2012-12-01"; SkipFinalClusterSnapshot: bool = false): Recallable =
  ## postDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  var query_602790 = newJObject()
  var formData_602791 = newJObject()
  add(formData_602791, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_602791, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_602790, "Action", newJString(Action))
  add(formData_602791, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(query_602790, "Version", newJString(Version))
  add(formData_602791, "SkipFinalClusterSnapshot",
      newJBool(SkipFinalClusterSnapshot))
  result = call_602789.call(nil, query_602790, nil, formData_602791, nil)

var postDeleteCluster* = Call_PostDeleteCluster_602772(name: "postDeleteCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_PostDeleteCluster_602773,
    base: "/", url: url_PostDeleteCluster_602774,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteCluster_602753 = ref object of OpenApiRestCall_601373
proc url_GetDeleteCluster_602755(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteCluster_602754(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: JString (required)
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602756 = query.getOrDefault("Action")
  valid_602756 = validateParameter(valid_602756, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_602756 != nil:
    section.add "Action", valid_602756
  var valid_602757 = query.getOrDefault("SkipFinalClusterSnapshot")
  valid_602757 = validateParameter(valid_602757, JBool, required = false, default = nil)
  if valid_602757 != nil:
    section.add "SkipFinalClusterSnapshot", valid_602757
  var valid_602758 = query.getOrDefault("ClusterIdentifier")
  valid_602758 = validateParameter(valid_602758, JString, required = true,
                                 default = nil)
  if valid_602758 != nil:
    section.add "ClusterIdentifier", valid_602758
  var valid_602759 = query.getOrDefault("Version")
  valid_602759 = validateParameter(valid_602759, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602759 != nil:
    section.add "Version", valid_602759
  var valid_602760 = query.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_602760 = validateParameter(valid_602760, JString, required = false,
                                 default = nil)
  if valid_602760 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_602760
  var valid_602761 = query.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_602761 = validateParameter(valid_602761, JInt, required = false, default = nil)
  if valid_602761 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_602761
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602762 = header.getOrDefault("X-Amz-Signature")
  valid_602762 = validateParameter(valid_602762, JString, required = false,
                                 default = nil)
  if valid_602762 != nil:
    section.add "X-Amz-Signature", valid_602762
  var valid_602763 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602763 = validateParameter(valid_602763, JString, required = false,
                                 default = nil)
  if valid_602763 != nil:
    section.add "X-Amz-Content-Sha256", valid_602763
  var valid_602764 = header.getOrDefault("X-Amz-Date")
  valid_602764 = validateParameter(valid_602764, JString, required = false,
                                 default = nil)
  if valid_602764 != nil:
    section.add "X-Amz-Date", valid_602764
  var valid_602765 = header.getOrDefault("X-Amz-Credential")
  valid_602765 = validateParameter(valid_602765, JString, required = false,
                                 default = nil)
  if valid_602765 != nil:
    section.add "X-Amz-Credential", valid_602765
  var valid_602766 = header.getOrDefault("X-Amz-Security-Token")
  valid_602766 = validateParameter(valid_602766, JString, required = false,
                                 default = nil)
  if valid_602766 != nil:
    section.add "X-Amz-Security-Token", valid_602766
  var valid_602767 = header.getOrDefault("X-Amz-Algorithm")
  valid_602767 = validateParameter(valid_602767, JString, required = false,
                                 default = nil)
  if valid_602767 != nil:
    section.add "X-Amz-Algorithm", valid_602767
  var valid_602768 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602768 = validateParameter(valid_602768, JString, required = false,
                                 default = nil)
  if valid_602768 != nil:
    section.add "X-Amz-SignedHeaders", valid_602768
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602769: Call_GetDeleteCluster_602753; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602769.validator(path, query, header, formData, body)
  let scheme = call_602769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602769.url(scheme.get, call_602769.host, call_602769.base,
                         call_602769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602769, url, valid)

proc call*(call_602770: Call_GetDeleteCluster_602753; ClusterIdentifier: string;
          Action: string = "DeleteCluster"; SkipFinalClusterSnapshot: bool = false;
          Version: string = "2012-12-01";
          FinalClusterSnapshotIdentifier: string = "";
          FinalClusterSnapshotRetentionPeriod: int = 0): Recallable =
  ## getDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: string (required)
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_602771 = newJObject()
  add(query_602771, "Action", newJString(Action))
  add(query_602771, "SkipFinalClusterSnapshot", newJBool(SkipFinalClusterSnapshot))
  add(query_602771, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602771, "Version", newJString(Version))
  add(query_602771, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_602771, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  result = call_602770.call(nil, query_602771, nil, nil, nil)

var getDeleteCluster* = Call_GetDeleteCluster_602753(name: "getDeleteCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_GetDeleteCluster_602754,
    base: "/", url: url_GetDeleteCluster_602755,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterParameterGroup_602808 = ref object of OpenApiRestCall_601373
proc url_PostDeleteClusterParameterGroup_602810(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterParameterGroup_602809(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602811 = query.getOrDefault("Action")
  valid_602811 = validateParameter(valid_602811, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_602811 != nil:
    section.add "Action", valid_602811
  var valid_602812 = query.getOrDefault("Version")
  valid_602812 = validateParameter(valid_602812, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602812 != nil:
    section.add "Version", valid_602812
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602813 = header.getOrDefault("X-Amz-Signature")
  valid_602813 = validateParameter(valid_602813, JString, required = false,
                                 default = nil)
  if valid_602813 != nil:
    section.add "X-Amz-Signature", valid_602813
  var valid_602814 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602814 = validateParameter(valid_602814, JString, required = false,
                                 default = nil)
  if valid_602814 != nil:
    section.add "X-Amz-Content-Sha256", valid_602814
  var valid_602815 = header.getOrDefault("X-Amz-Date")
  valid_602815 = validateParameter(valid_602815, JString, required = false,
                                 default = nil)
  if valid_602815 != nil:
    section.add "X-Amz-Date", valid_602815
  var valid_602816 = header.getOrDefault("X-Amz-Credential")
  valid_602816 = validateParameter(valid_602816, JString, required = false,
                                 default = nil)
  if valid_602816 != nil:
    section.add "X-Amz-Credential", valid_602816
  var valid_602817 = header.getOrDefault("X-Amz-Security-Token")
  valid_602817 = validateParameter(valid_602817, JString, required = false,
                                 default = nil)
  if valid_602817 != nil:
    section.add "X-Amz-Security-Token", valid_602817
  var valid_602818 = header.getOrDefault("X-Amz-Algorithm")
  valid_602818 = validateParameter(valid_602818, JString, required = false,
                                 default = nil)
  if valid_602818 != nil:
    section.add "X-Amz-Algorithm", valid_602818
  var valid_602819 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602819 = validateParameter(valid_602819, JString, required = false,
                                 default = nil)
  if valid_602819 != nil:
    section.add "X-Amz-SignedHeaders", valid_602819
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_602820 = formData.getOrDefault("ParameterGroupName")
  valid_602820 = validateParameter(valid_602820, JString, required = true,
                                 default = nil)
  if valid_602820 != nil:
    section.add "ParameterGroupName", valid_602820
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602821: Call_PostDeleteClusterParameterGroup_602808;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_602821.validator(path, query, header, formData, body)
  let scheme = call_602821.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602821.url(scheme.get, call_602821.host, call_602821.base,
                         call_602821.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602821, url, valid)

proc call*(call_602822: Call_PostDeleteClusterParameterGroup_602808;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: string (required)
  var query_602823 = newJObject()
  var formData_602824 = newJObject()
  add(query_602823, "Action", newJString(Action))
  add(formData_602824, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_602823, "Version", newJString(Version))
  result = call_602822.call(nil, query_602823, nil, formData_602824, nil)

var postDeleteClusterParameterGroup* = Call_PostDeleteClusterParameterGroup_602808(
    name: "postDeleteClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_PostDeleteClusterParameterGroup_602809, base: "/",
    url: url_PostDeleteClusterParameterGroup_602810,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterParameterGroup_602792 = ref object of OpenApiRestCall_601373
proc url_GetDeleteClusterParameterGroup_602794(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterParameterGroup_602793(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602795 = query.getOrDefault("Action")
  valid_602795 = validateParameter(valid_602795, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_602795 != nil:
    section.add "Action", valid_602795
  var valid_602796 = query.getOrDefault("ParameterGroupName")
  valid_602796 = validateParameter(valid_602796, JString, required = true,
                                 default = nil)
  if valid_602796 != nil:
    section.add "ParameterGroupName", valid_602796
  var valid_602797 = query.getOrDefault("Version")
  valid_602797 = validateParameter(valid_602797, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602797 != nil:
    section.add "Version", valid_602797
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602798 = header.getOrDefault("X-Amz-Signature")
  valid_602798 = validateParameter(valid_602798, JString, required = false,
                                 default = nil)
  if valid_602798 != nil:
    section.add "X-Amz-Signature", valid_602798
  var valid_602799 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602799 = validateParameter(valid_602799, JString, required = false,
                                 default = nil)
  if valid_602799 != nil:
    section.add "X-Amz-Content-Sha256", valid_602799
  var valid_602800 = header.getOrDefault("X-Amz-Date")
  valid_602800 = validateParameter(valid_602800, JString, required = false,
                                 default = nil)
  if valid_602800 != nil:
    section.add "X-Amz-Date", valid_602800
  var valid_602801 = header.getOrDefault("X-Amz-Credential")
  valid_602801 = validateParameter(valid_602801, JString, required = false,
                                 default = nil)
  if valid_602801 != nil:
    section.add "X-Amz-Credential", valid_602801
  var valid_602802 = header.getOrDefault("X-Amz-Security-Token")
  valid_602802 = validateParameter(valid_602802, JString, required = false,
                                 default = nil)
  if valid_602802 != nil:
    section.add "X-Amz-Security-Token", valid_602802
  var valid_602803 = header.getOrDefault("X-Amz-Algorithm")
  valid_602803 = validateParameter(valid_602803, JString, required = false,
                                 default = nil)
  if valid_602803 != nil:
    section.add "X-Amz-Algorithm", valid_602803
  var valid_602804 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602804 = validateParameter(valid_602804, JString, required = false,
                                 default = nil)
  if valid_602804 != nil:
    section.add "X-Amz-SignedHeaders", valid_602804
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602805: Call_GetDeleteClusterParameterGroup_602792; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_602805.validator(path, query, header, formData, body)
  let scheme = call_602805.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602805.url(scheme.get, call_602805.host, call_602805.base,
                         call_602805.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602805, url, valid)

proc call*(call_602806: Call_GetDeleteClusterParameterGroup_602792;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: string (required)
  var query_602807 = newJObject()
  add(query_602807, "Action", newJString(Action))
  add(query_602807, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_602807, "Version", newJString(Version))
  result = call_602806.call(nil, query_602807, nil, nil, nil)

var getDeleteClusterParameterGroup* = Call_GetDeleteClusterParameterGroup_602792(
    name: "getDeleteClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_GetDeleteClusterParameterGroup_602793, base: "/",
    url: url_GetDeleteClusterParameterGroup_602794,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSecurityGroup_602841 = ref object of OpenApiRestCall_601373
proc url_PostDeleteClusterSecurityGroup_602843(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSecurityGroup_602842(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602844 = query.getOrDefault("Action")
  valid_602844 = validateParameter(valid_602844, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_602844 != nil:
    section.add "Action", valid_602844
  var valid_602845 = query.getOrDefault("Version")
  valid_602845 = validateParameter(valid_602845, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602845 != nil:
    section.add "Version", valid_602845
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602846 = header.getOrDefault("X-Amz-Signature")
  valid_602846 = validateParameter(valid_602846, JString, required = false,
                                 default = nil)
  if valid_602846 != nil:
    section.add "X-Amz-Signature", valid_602846
  var valid_602847 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602847 = validateParameter(valid_602847, JString, required = false,
                                 default = nil)
  if valid_602847 != nil:
    section.add "X-Amz-Content-Sha256", valid_602847
  var valid_602848 = header.getOrDefault("X-Amz-Date")
  valid_602848 = validateParameter(valid_602848, JString, required = false,
                                 default = nil)
  if valid_602848 != nil:
    section.add "X-Amz-Date", valid_602848
  var valid_602849 = header.getOrDefault("X-Amz-Credential")
  valid_602849 = validateParameter(valid_602849, JString, required = false,
                                 default = nil)
  if valid_602849 != nil:
    section.add "X-Amz-Credential", valid_602849
  var valid_602850 = header.getOrDefault("X-Amz-Security-Token")
  valid_602850 = validateParameter(valid_602850, JString, required = false,
                                 default = nil)
  if valid_602850 != nil:
    section.add "X-Amz-Security-Token", valid_602850
  var valid_602851 = header.getOrDefault("X-Amz-Algorithm")
  valid_602851 = validateParameter(valid_602851, JString, required = false,
                                 default = nil)
  if valid_602851 != nil:
    section.add "X-Amz-Algorithm", valid_602851
  var valid_602852 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602852 = validateParameter(valid_602852, JString, required = false,
                                 default = nil)
  if valid_602852 != nil:
    section.add "X-Amz-SignedHeaders", valid_602852
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_602853 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_602853 = validateParameter(valid_602853, JString, required = true,
                                 default = nil)
  if valid_602853 != nil:
    section.add "ClusterSecurityGroupName", valid_602853
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602854: Call_PostDeleteClusterSecurityGroup_602841; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602854.validator(path, query, header, formData, body)
  let scheme = call_602854.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602854.url(scheme.get, call_602854.host, call_602854.base,
                         call_602854.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602854, url, valid)

proc call*(call_602855: Call_PostDeleteClusterSecurityGroup_602841;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602856 = newJObject()
  var formData_602857 = newJObject()
  add(formData_602857, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_602856, "Action", newJString(Action))
  add(query_602856, "Version", newJString(Version))
  result = call_602855.call(nil, query_602856, nil, formData_602857, nil)

var postDeleteClusterSecurityGroup* = Call_PostDeleteClusterSecurityGroup_602841(
    name: "postDeleteClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_PostDeleteClusterSecurityGroup_602842, base: "/",
    url: url_PostDeleteClusterSecurityGroup_602843,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSecurityGroup_602825 = ref object of OpenApiRestCall_601373
proc url_GetDeleteClusterSecurityGroup_602827(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSecurityGroup_602826(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_602828 = query.getOrDefault("ClusterSecurityGroupName")
  valid_602828 = validateParameter(valid_602828, JString, required = true,
                                 default = nil)
  if valid_602828 != nil:
    section.add "ClusterSecurityGroupName", valid_602828
  var valid_602829 = query.getOrDefault("Action")
  valid_602829 = validateParameter(valid_602829, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_602829 != nil:
    section.add "Action", valid_602829
  var valid_602830 = query.getOrDefault("Version")
  valid_602830 = validateParameter(valid_602830, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602830 != nil:
    section.add "Version", valid_602830
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602831 = header.getOrDefault("X-Amz-Signature")
  valid_602831 = validateParameter(valid_602831, JString, required = false,
                                 default = nil)
  if valid_602831 != nil:
    section.add "X-Amz-Signature", valid_602831
  var valid_602832 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602832 = validateParameter(valid_602832, JString, required = false,
                                 default = nil)
  if valid_602832 != nil:
    section.add "X-Amz-Content-Sha256", valid_602832
  var valid_602833 = header.getOrDefault("X-Amz-Date")
  valid_602833 = validateParameter(valid_602833, JString, required = false,
                                 default = nil)
  if valid_602833 != nil:
    section.add "X-Amz-Date", valid_602833
  var valid_602834 = header.getOrDefault("X-Amz-Credential")
  valid_602834 = validateParameter(valid_602834, JString, required = false,
                                 default = nil)
  if valid_602834 != nil:
    section.add "X-Amz-Credential", valid_602834
  var valid_602835 = header.getOrDefault("X-Amz-Security-Token")
  valid_602835 = validateParameter(valid_602835, JString, required = false,
                                 default = nil)
  if valid_602835 != nil:
    section.add "X-Amz-Security-Token", valid_602835
  var valid_602836 = header.getOrDefault("X-Amz-Algorithm")
  valid_602836 = validateParameter(valid_602836, JString, required = false,
                                 default = nil)
  if valid_602836 != nil:
    section.add "X-Amz-Algorithm", valid_602836
  var valid_602837 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602837 = validateParameter(valid_602837, JString, required = false,
                                 default = nil)
  if valid_602837 != nil:
    section.add "X-Amz-SignedHeaders", valid_602837
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602838: Call_GetDeleteClusterSecurityGroup_602825; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602838.validator(path, query, header, formData, body)
  let scheme = call_602838.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602838.url(scheme.get, call_602838.host, call_602838.base,
                         call_602838.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602838, url, valid)

proc call*(call_602839: Call_GetDeleteClusterSecurityGroup_602825;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602840 = newJObject()
  add(query_602840, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_602840, "Action", newJString(Action))
  add(query_602840, "Version", newJString(Version))
  result = call_602839.call(nil, query_602840, nil, nil, nil)

var getDeleteClusterSecurityGroup* = Call_GetDeleteClusterSecurityGroup_602825(
    name: "getDeleteClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_GetDeleteClusterSecurityGroup_602826, base: "/",
    url: url_GetDeleteClusterSecurityGroup_602827,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSnapshot_602875 = ref object of OpenApiRestCall_601373
proc url_PostDeleteClusterSnapshot_602877(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSnapshot_602876(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602878 = query.getOrDefault("Action")
  valid_602878 = validateParameter(valid_602878, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_602878 != nil:
    section.add "Action", valid_602878
  var valid_602879 = query.getOrDefault("Version")
  valid_602879 = validateParameter(valid_602879, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602879 != nil:
    section.add "Version", valid_602879
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602880 = header.getOrDefault("X-Amz-Signature")
  valid_602880 = validateParameter(valid_602880, JString, required = false,
                                 default = nil)
  if valid_602880 != nil:
    section.add "X-Amz-Signature", valid_602880
  var valid_602881 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602881 = validateParameter(valid_602881, JString, required = false,
                                 default = nil)
  if valid_602881 != nil:
    section.add "X-Amz-Content-Sha256", valid_602881
  var valid_602882 = header.getOrDefault("X-Amz-Date")
  valid_602882 = validateParameter(valid_602882, JString, required = false,
                                 default = nil)
  if valid_602882 != nil:
    section.add "X-Amz-Date", valid_602882
  var valid_602883 = header.getOrDefault("X-Amz-Credential")
  valid_602883 = validateParameter(valid_602883, JString, required = false,
                                 default = nil)
  if valid_602883 != nil:
    section.add "X-Amz-Credential", valid_602883
  var valid_602884 = header.getOrDefault("X-Amz-Security-Token")
  valid_602884 = validateParameter(valid_602884, JString, required = false,
                                 default = nil)
  if valid_602884 != nil:
    section.add "X-Amz-Security-Token", valid_602884
  var valid_602885 = header.getOrDefault("X-Amz-Algorithm")
  valid_602885 = validateParameter(valid_602885, JString, required = false,
                                 default = nil)
  if valid_602885 != nil:
    section.add "X-Amz-Algorithm", valid_602885
  var valid_602886 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602886 = validateParameter(valid_602886, JString, required = false,
                                 default = nil)
  if valid_602886 != nil:
    section.add "X-Amz-SignedHeaders", valid_602886
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_602887 = formData.getOrDefault("SnapshotIdentifier")
  valid_602887 = validateParameter(valid_602887, JString, required = true,
                                 default = nil)
  if valid_602887 != nil:
    section.add "SnapshotIdentifier", valid_602887
  var valid_602888 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_602888 = validateParameter(valid_602888, JString, required = false,
                                 default = nil)
  if valid_602888 != nil:
    section.add "SnapshotClusterIdentifier", valid_602888
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602889: Call_PostDeleteClusterSnapshot_602875; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_602889.validator(path, query, header, formData, body)
  let scheme = call_602889.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602889.url(scheme.get, call_602889.host, call_602889.base,
                         call_602889.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602889, url, valid)

proc call*(call_602890: Call_PostDeleteClusterSnapshot_602875;
          SnapshotIdentifier: string; Action: string = "DeleteClusterSnapshot";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Version: string (required)
  var query_602891 = newJObject()
  var formData_602892 = newJObject()
  add(formData_602892, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_602891, "Action", newJString(Action))
  add(formData_602892, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_602891, "Version", newJString(Version))
  result = call_602890.call(nil, query_602891, nil, formData_602892, nil)

var postDeleteClusterSnapshot* = Call_PostDeleteClusterSnapshot_602875(
    name: "postDeleteClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_PostDeleteClusterSnapshot_602876, base: "/",
    url: url_PostDeleteClusterSnapshot_602877,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSnapshot_602858 = ref object of OpenApiRestCall_601373
proc url_GetDeleteClusterSnapshot_602860(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSnapshot_602859(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_602861 = query.getOrDefault("SnapshotIdentifier")
  valid_602861 = validateParameter(valid_602861, JString, required = true,
                                 default = nil)
  if valid_602861 != nil:
    section.add "SnapshotIdentifier", valid_602861
  var valid_602862 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_602862 = validateParameter(valid_602862, JString, required = false,
                                 default = nil)
  if valid_602862 != nil:
    section.add "SnapshotClusterIdentifier", valid_602862
  var valid_602863 = query.getOrDefault("Action")
  valid_602863 = validateParameter(valid_602863, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_602863 != nil:
    section.add "Action", valid_602863
  var valid_602864 = query.getOrDefault("Version")
  valid_602864 = validateParameter(valid_602864, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602864 != nil:
    section.add "Version", valid_602864
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602865 = header.getOrDefault("X-Amz-Signature")
  valid_602865 = validateParameter(valid_602865, JString, required = false,
                                 default = nil)
  if valid_602865 != nil:
    section.add "X-Amz-Signature", valid_602865
  var valid_602866 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602866 = validateParameter(valid_602866, JString, required = false,
                                 default = nil)
  if valid_602866 != nil:
    section.add "X-Amz-Content-Sha256", valid_602866
  var valid_602867 = header.getOrDefault("X-Amz-Date")
  valid_602867 = validateParameter(valid_602867, JString, required = false,
                                 default = nil)
  if valid_602867 != nil:
    section.add "X-Amz-Date", valid_602867
  var valid_602868 = header.getOrDefault("X-Amz-Credential")
  valid_602868 = validateParameter(valid_602868, JString, required = false,
                                 default = nil)
  if valid_602868 != nil:
    section.add "X-Amz-Credential", valid_602868
  var valid_602869 = header.getOrDefault("X-Amz-Security-Token")
  valid_602869 = validateParameter(valid_602869, JString, required = false,
                                 default = nil)
  if valid_602869 != nil:
    section.add "X-Amz-Security-Token", valid_602869
  var valid_602870 = header.getOrDefault("X-Amz-Algorithm")
  valid_602870 = validateParameter(valid_602870, JString, required = false,
                                 default = nil)
  if valid_602870 != nil:
    section.add "X-Amz-Algorithm", valid_602870
  var valid_602871 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602871 = validateParameter(valid_602871, JString, required = false,
                                 default = nil)
  if valid_602871 != nil:
    section.add "X-Amz-SignedHeaders", valid_602871
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602872: Call_GetDeleteClusterSnapshot_602858; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_602872.validator(path, query, header, formData, body)
  let scheme = call_602872.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602872.url(scheme.get, call_602872.host, call_602872.base,
                         call_602872.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602872, url, valid)

proc call*(call_602873: Call_GetDeleteClusterSnapshot_602858;
          SnapshotIdentifier: string; SnapshotClusterIdentifier: string = "";
          Action: string = "DeleteClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602874 = newJObject()
  add(query_602874, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_602874, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_602874, "Action", newJString(Action))
  add(query_602874, "Version", newJString(Version))
  result = call_602873.call(nil, query_602874, nil, nil, nil)

var getDeleteClusterSnapshot* = Call_GetDeleteClusterSnapshot_602858(
    name: "getDeleteClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_GetDeleteClusterSnapshot_602859, base: "/",
    url: url_GetDeleteClusterSnapshot_602860, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSubnetGroup_602909 = ref object of OpenApiRestCall_601373
proc url_PostDeleteClusterSubnetGroup_602911(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSubnetGroup_602910(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602912 = query.getOrDefault("Action")
  valid_602912 = validateParameter(valid_602912, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_602912 != nil:
    section.add "Action", valid_602912
  var valid_602913 = query.getOrDefault("Version")
  valid_602913 = validateParameter(valid_602913, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602913 != nil:
    section.add "Version", valid_602913
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602914 = header.getOrDefault("X-Amz-Signature")
  valid_602914 = validateParameter(valid_602914, JString, required = false,
                                 default = nil)
  if valid_602914 != nil:
    section.add "X-Amz-Signature", valid_602914
  var valid_602915 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602915 = validateParameter(valid_602915, JString, required = false,
                                 default = nil)
  if valid_602915 != nil:
    section.add "X-Amz-Content-Sha256", valid_602915
  var valid_602916 = header.getOrDefault("X-Amz-Date")
  valid_602916 = validateParameter(valid_602916, JString, required = false,
                                 default = nil)
  if valid_602916 != nil:
    section.add "X-Amz-Date", valid_602916
  var valid_602917 = header.getOrDefault("X-Amz-Credential")
  valid_602917 = validateParameter(valid_602917, JString, required = false,
                                 default = nil)
  if valid_602917 != nil:
    section.add "X-Amz-Credential", valid_602917
  var valid_602918 = header.getOrDefault("X-Amz-Security-Token")
  valid_602918 = validateParameter(valid_602918, JString, required = false,
                                 default = nil)
  if valid_602918 != nil:
    section.add "X-Amz-Security-Token", valid_602918
  var valid_602919 = header.getOrDefault("X-Amz-Algorithm")
  valid_602919 = validateParameter(valid_602919, JString, required = false,
                                 default = nil)
  if valid_602919 != nil:
    section.add "X-Amz-Algorithm", valid_602919
  var valid_602920 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602920 = validateParameter(valid_602920, JString, required = false,
                                 default = nil)
  if valid_602920 != nil:
    section.add "X-Amz-SignedHeaders", valid_602920
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_602921 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_602921 = validateParameter(valid_602921, JString, required = true,
                                 default = nil)
  if valid_602921 != nil:
    section.add "ClusterSubnetGroupName", valid_602921
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602922: Call_PostDeleteClusterSubnetGroup_602909; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_602922.validator(path, query, header, formData, body)
  let scheme = call_602922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602922.url(scheme.get, call_602922.host, call_602922.base,
                         call_602922.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602922, url, valid)

proc call*(call_602923: Call_PostDeleteClusterSubnetGroup_602909;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602924 = newJObject()
  var formData_602925 = newJObject()
  add(formData_602925, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_602924, "Action", newJString(Action))
  add(query_602924, "Version", newJString(Version))
  result = call_602923.call(nil, query_602924, nil, formData_602925, nil)

var postDeleteClusterSubnetGroup* = Call_PostDeleteClusterSubnetGroup_602909(
    name: "postDeleteClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_PostDeleteClusterSubnetGroup_602910, base: "/",
    url: url_PostDeleteClusterSubnetGroup_602911,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSubnetGroup_602893 = ref object of OpenApiRestCall_601373
proc url_GetDeleteClusterSubnetGroup_602895(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSubnetGroup_602894(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_602896 = query.getOrDefault("ClusterSubnetGroupName")
  valid_602896 = validateParameter(valid_602896, JString, required = true,
                                 default = nil)
  if valid_602896 != nil:
    section.add "ClusterSubnetGroupName", valid_602896
  var valid_602897 = query.getOrDefault("Action")
  valid_602897 = validateParameter(valid_602897, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_602897 != nil:
    section.add "Action", valid_602897
  var valid_602898 = query.getOrDefault("Version")
  valid_602898 = validateParameter(valid_602898, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602898 != nil:
    section.add "Version", valid_602898
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602899 = header.getOrDefault("X-Amz-Signature")
  valid_602899 = validateParameter(valid_602899, JString, required = false,
                                 default = nil)
  if valid_602899 != nil:
    section.add "X-Amz-Signature", valid_602899
  var valid_602900 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602900 = validateParameter(valid_602900, JString, required = false,
                                 default = nil)
  if valid_602900 != nil:
    section.add "X-Amz-Content-Sha256", valid_602900
  var valid_602901 = header.getOrDefault("X-Amz-Date")
  valid_602901 = validateParameter(valid_602901, JString, required = false,
                                 default = nil)
  if valid_602901 != nil:
    section.add "X-Amz-Date", valid_602901
  var valid_602902 = header.getOrDefault("X-Amz-Credential")
  valid_602902 = validateParameter(valid_602902, JString, required = false,
                                 default = nil)
  if valid_602902 != nil:
    section.add "X-Amz-Credential", valid_602902
  var valid_602903 = header.getOrDefault("X-Amz-Security-Token")
  valid_602903 = validateParameter(valid_602903, JString, required = false,
                                 default = nil)
  if valid_602903 != nil:
    section.add "X-Amz-Security-Token", valid_602903
  var valid_602904 = header.getOrDefault("X-Amz-Algorithm")
  valid_602904 = validateParameter(valid_602904, JString, required = false,
                                 default = nil)
  if valid_602904 != nil:
    section.add "X-Amz-Algorithm", valid_602904
  var valid_602905 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602905 = validateParameter(valid_602905, JString, required = false,
                                 default = nil)
  if valid_602905 != nil:
    section.add "X-Amz-SignedHeaders", valid_602905
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602906: Call_GetDeleteClusterSubnetGroup_602893; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_602906.validator(path, query, header, formData, body)
  let scheme = call_602906.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602906.url(scheme.get, call_602906.host, call_602906.base,
                         call_602906.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602906, url, valid)

proc call*(call_602907: Call_GetDeleteClusterSubnetGroup_602893;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602908 = newJObject()
  add(query_602908, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_602908, "Action", newJString(Action))
  add(query_602908, "Version", newJString(Version))
  result = call_602907.call(nil, query_602908, nil, nil, nil)

var getDeleteClusterSubnetGroup* = Call_GetDeleteClusterSubnetGroup_602893(
    name: "getDeleteClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_GetDeleteClusterSubnetGroup_602894, base: "/",
    url: url_GetDeleteClusterSubnetGroup_602895,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteEventSubscription_602942 = ref object of OpenApiRestCall_601373
proc url_PostDeleteEventSubscription_602944(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteEventSubscription_602943(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602945 = query.getOrDefault("Action")
  valid_602945 = validateParameter(valid_602945, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_602945 != nil:
    section.add "Action", valid_602945
  var valid_602946 = query.getOrDefault("Version")
  valid_602946 = validateParameter(valid_602946, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602946 != nil:
    section.add "Version", valid_602946
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602947 = header.getOrDefault("X-Amz-Signature")
  valid_602947 = validateParameter(valid_602947, JString, required = false,
                                 default = nil)
  if valid_602947 != nil:
    section.add "X-Amz-Signature", valid_602947
  var valid_602948 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602948 = validateParameter(valid_602948, JString, required = false,
                                 default = nil)
  if valid_602948 != nil:
    section.add "X-Amz-Content-Sha256", valid_602948
  var valid_602949 = header.getOrDefault("X-Amz-Date")
  valid_602949 = validateParameter(valid_602949, JString, required = false,
                                 default = nil)
  if valid_602949 != nil:
    section.add "X-Amz-Date", valid_602949
  var valid_602950 = header.getOrDefault("X-Amz-Credential")
  valid_602950 = validateParameter(valid_602950, JString, required = false,
                                 default = nil)
  if valid_602950 != nil:
    section.add "X-Amz-Credential", valid_602950
  var valid_602951 = header.getOrDefault("X-Amz-Security-Token")
  valid_602951 = validateParameter(valid_602951, JString, required = false,
                                 default = nil)
  if valid_602951 != nil:
    section.add "X-Amz-Security-Token", valid_602951
  var valid_602952 = header.getOrDefault("X-Amz-Algorithm")
  valid_602952 = validateParameter(valid_602952, JString, required = false,
                                 default = nil)
  if valid_602952 != nil:
    section.add "X-Amz-Algorithm", valid_602952
  var valid_602953 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602953 = validateParameter(valid_602953, JString, required = false,
                                 default = nil)
  if valid_602953 != nil:
    section.add "X-Amz-SignedHeaders", valid_602953
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_602954 = formData.getOrDefault("SubscriptionName")
  valid_602954 = validateParameter(valid_602954, JString, required = true,
                                 default = nil)
  if valid_602954 != nil:
    section.add "SubscriptionName", valid_602954
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602955: Call_PostDeleteEventSubscription_602942; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_602955.validator(path, query, header, formData, body)
  let scheme = call_602955.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602955.url(scheme.get, call_602955.host, call_602955.base,
                         call_602955.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602955, url, valid)

proc call*(call_602956: Call_PostDeleteEventSubscription_602942;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602957 = newJObject()
  var formData_602958 = newJObject()
  add(formData_602958, "SubscriptionName", newJString(SubscriptionName))
  add(query_602957, "Action", newJString(Action))
  add(query_602957, "Version", newJString(Version))
  result = call_602956.call(nil, query_602957, nil, formData_602958, nil)

var postDeleteEventSubscription* = Call_PostDeleteEventSubscription_602942(
    name: "postDeleteEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_PostDeleteEventSubscription_602943, base: "/",
    url: url_PostDeleteEventSubscription_602944,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteEventSubscription_602926 = ref object of OpenApiRestCall_601373
proc url_GetDeleteEventSubscription_602928(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteEventSubscription_602927(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_602929 = query.getOrDefault("SubscriptionName")
  valid_602929 = validateParameter(valid_602929, JString, required = true,
                                 default = nil)
  if valid_602929 != nil:
    section.add "SubscriptionName", valid_602929
  var valid_602930 = query.getOrDefault("Action")
  valid_602930 = validateParameter(valid_602930, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_602930 != nil:
    section.add "Action", valid_602930
  var valid_602931 = query.getOrDefault("Version")
  valid_602931 = validateParameter(valid_602931, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602931 != nil:
    section.add "Version", valid_602931
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602932 = header.getOrDefault("X-Amz-Signature")
  valid_602932 = validateParameter(valid_602932, JString, required = false,
                                 default = nil)
  if valid_602932 != nil:
    section.add "X-Amz-Signature", valid_602932
  var valid_602933 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602933 = validateParameter(valid_602933, JString, required = false,
                                 default = nil)
  if valid_602933 != nil:
    section.add "X-Amz-Content-Sha256", valid_602933
  var valid_602934 = header.getOrDefault("X-Amz-Date")
  valid_602934 = validateParameter(valid_602934, JString, required = false,
                                 default = nil)
  if valid_602934 != nil:
    section.add "X-Amz-Date", valid_602934
  var valid_602935 = header.getOrDefault("X-Amz-Credential")
  valid_602935 = validateParameter(valid_602935, JString, required = false,
                                 default = nil)
  if valid_602935 != nil:
    section.add "X-Amz-Credential", valid_602935
  var valid_602936 = header.getOrDefault("X-Amz-Security-Token")
  valid_602936 = validateParameter(valid_602936, JString, required = false,
                                 default = nil)
  if valid_602936 != nil:
    section.add "X-Amz-Security-Token", valid_602936
  var valid_602937 = header.getOrDefault("X-Amz-Algorithm")
  valid_602937 = validateParameter(valid_602937, JString, required = false,
                                 default = nil)
  if valid_602937 != nil:
    section.add "X-Amz-Algorithm", valid_602937
  var valid_602938 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602938 = validateParameter(valid_602938, JString, required = false,
                                 default = nil)
  if valid_602938 != nil:
    section.add "X-Amz-SignedHeaders", valid_602938
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602939: Call_GetDeleteEventSubscription_602926; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_602939.validator(path, query, header, formData, body)
  let scheme = call_602939.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602939.url(scheme.get, call_602939.host, call_602939.base,
                         call_602939.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602939, url, valid)

proc call*(call_602940: Call_GetDeleteEventSubscription_602926;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602941 = newJObject()
  add(query_602941, "SubscriptionName", newJString(SubscriptionName))
  add(query_602941, "Action", newJString(Action))
  add(query_602941, "Version", newJString(Version))
  result = call_602940.call(nil, query_602941, nil, nil, nil)

var getDeleteEventSubscription* = Call_GetDeleteEventSubscription_602926(
    name: "getDeleteEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_GetDeleteEventSubscription_602927, base: "/",
    url: url_GetDeleteEventSubscription_602928,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmClientCertificate_602975 = ref object of OpenApiRestCall_601373
proc url_PostDeleteHsmClientCertificate_602977(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmClientCertificate_602976(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602978 = query.getOrDefault("Action")
  valid_602978 = validateParameter(valid_602978, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_602978 != nil:
    section.add "Action", valid_602978
  var valid_602979 = query.getOrDefault("Version")
  valid_602979 = validateParameter(valid_602979, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602979 != nil:
    section.add "Version", valid_602979
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602980 = header.getOrDefault("X-Amz-Signature")
  valid_602980 = validateParameter(valid_602980, JString, required = false,
                                 default = nil)
  if valid_602980 != nil:
    section.add "X-Amz-Signature", valid_602980
  var valid_602981 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602981 = validateParameter(valid_602981, JString, required = false,
                                 default = nil)
  if valid_602981 != nil:
    section.add "X-Amz-Content-Sha256", valid_602981
  var valid_602982 = header.getOrDefault("X-Amz-Date")
  valid_602982 = validateParameter(valid_602982, JString, required = false,
                                 default = nil)
  if valid_602982 != nil:
    section.add "X-Amz-Date", valid_602982
  var valid_602983 = header.getOrDefault("X-Amz-Credential")
  valid_602983 = validateParameter(valid_602983, JString, required = false,
                                 default = nil)
  if valid_602983 != nil:
    section.add "X-Amz-Credential", valid_602983
  var valid_602984 = header.getOrDefault("X-Amz-Security-Token")
  valid_602984 = validateParameter(valid_602984, JString, required = false,
                                 default = nil)
  if valid_602984 != nil:
    section.add "X-Amz-Security-Token", valid_602984
  var valid_602985 = header.getOrDefault("X-Amz-Algorithm")
  valid_602985 = validateParameter(valid_602985, JString, required = false,
                                 default = nil)
  if valid_602985 != nil:
    section.add "X-Amz-Algorithm", valid_602985
  var valid_602986 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602986 = validateParameter(valid_602986, JString, required = false,
                                 default = nil)
  if valid_602986 != nil:
    section.add "X-Amz-SignedHeaders", valid_602986
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_602987 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_602987 = validateParameter(valid_602987, JString, required = true,
                                 default = nil)
  if valid_602987 != nil:
    section.add "HsmClientCertificateIdentifier", valid_602987
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602988: Call_PostDeleteHsmClientCertificate_602975; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_602988.validator(path, query, header, formData, body)
  let scheme = call_602988.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602988.url(scheme.get, call_602988.host, call_602988.base,
                         call_602988.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602988, url, valid)

proc call*(call_602989: Call_PostDeleteHsmClientCertificate_602975;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Version: string (required)
  var query_602990 = newJObject()
  var formData_602991 = newJObject()
  add(query_602990, "Action", newJString(Action))
  add(formData_602991, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_602990, "Version", newJString(Version))
  result = call_602989.call(nil, query_602990, nil, formData_602991, nil)

var postDeleteHsmClientCertificate* = Call_PostDeleteHsmClientCertificate_602975(
    name: "postDeleteHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_PostDeleteHsmClientCertificate_602976, base: "/",
    url: url_PostDeleteHsmClientCertificate_602977,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmClientCertificate_602959 = ref object of OpenApiRestCall_601373
proc url_GetDeleteHsmClientCertificate_602961(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmClientCertificate_602960(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_602962 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_602962 = validateParameter(valid_602962, JString, required = true,
                                 default = nil)
  if valid_602962 != nil:
    section.add "HsmClientCertificateIdentifier", valid_602962
  var valid_602963 = query.getOrDefault("Action")
  valid_602963 = validateParameter(valid_602963, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_602963 != nil:
    section.add "Action", valid_602963
  var valid_602964 = query.getOrDefault("Version")
  valid_602964 = validateParameter(valid_602964, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602964 != nil:
    section.add "Version", valid_602964
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602965 = header.getOrDefault("X-Amz-Signature")
  valid_602965 = validateParameter(valid_602965, JString, required = false,
                                 default = nil)
  if valid_602965 != nil:
    section.add "X-Amz-Signature", valid_602965
  var valid_602966 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602966 = validateParameter(valid_602966, JString, required = false,
                                 default = nil)
  if valid_602966 != nil:
    section.add "X-Amz-Content-Sha256", valid_602966
  var valid_602967 = header.getOrDefault("X-Amz-Date")
  valid_602967 = validateParameter(valid_602967, JString, required = false,
                                 default = nil)
  if valid_602967 != nil:
    section.add "X-Amz-Date", valid_602967
  var valid_602968 = header.getOrDefault("X-Amz-Credential")
  valid_602968 = validateParameter(valid_602968, JString, required = false,
                                 default = nil)
  if valid_602968 != nil:
    section.add "X-Amz-Credential", valid_602968
  var valid_602969 = header.getOrDefault("X-Amz-Security-Token")
  valid_602969 = validateParameter(valid_602969, JString, required = false,
                                 default = nil)
  if valid_602969 != nil:
    section.add "X-Amz-Security-Token", valid_602969
  var valid_602970 = header.getOrDefault("X-Amz-Algorithm")
  valid_602970 = validateParameter(valid_602970, JString, required = false,
                                 default = nil)
  if valid_602970 != nil:
    section.add "X-Amz-Algorithm", valid_602970
  var valid_602971 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602971 = validateParameter(valid_602971, JString, required = false,
                                 default = nil)
  if valid_602971 != nil:
    section.add "X-Amz-SignedHeaders", valid_602971
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602972: Call_GetDeleteHsmClientCertificate_602959; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_602972.validator(path, query, header, formData, body)
  let scheme = call_602972.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602972.url(scheme.get, call_602972.host, call_602972.base,
                         call_602972.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602972, url, valid)

proc call*(call_602973: Call_GetDeleteHsmClientCertificate_602959;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602974 = newJObject()
  add(query_602974, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_602974, "Action", newJString(Action))
  add(query_602974, "Version", newJString(Version))
  result = call_602973.call(nil, query_602974, nil, nil, nil)

var getDeleteHsmClientCertificate* = Call_GetDeleteHsmClientCertificate_602959(
    name: "getDeleteHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_GetDeleteHsmClientCertificate_602960, base: "/",
    url: url_GetDeleteHsmClientCertificate_602961,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmConfiguration_603008 = ref object of OpenApiRestCall_601373
proc url_PostDeleteHsmConfiguration_603010(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmConfiguration_603009(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603011 = query.getOrDefault("Action")
  valid_603011 = validateParameter(valid_603011, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_603011 != nil:
    section.add "Action", valid_603011
  var valid_603012 = query.getOrDefault("Version")
  valid_603012 = validateParameter(valid_603012, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603012 != nil:
    section.add "Version", valid_603012
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603013 = header.getOrDefault("X-Amz-Signature")
  valid_603013 = validateParameter(valid_603013, JString, required = false,
                                 default = nil)
  if valid_603013 != nil:
    section.add "X-Amz-Signature", valid_603013
  var valid_603014 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603014 = validateParameter(valid_603014, JString, required = false,
                                 default = nil)
  if valid_603014 != nil:
    section.add "X-Amz-Content-Sha256", valid_603014
  var valid_603015 = header.getOrDefault("X-Amz-Date")
  valid_603015 = validateParameter(valid_603015, JString, required = false,
                                 default = nil)
  if valid_603015 != nil:
    section.add "X-Amz-Date", valid_603015
  var valid_603016 = header.getOrDefault("X-Amz-Credential")
  valid_603016 = validateParameter(valid_603016, JString, required = false,
                                 default = nil)
  if valid_603016 != nil:
    section.add "X-Amz-Credential", valid_603016
  var valid_603017 = header.getOrDefault("X-Amz-Security-Token")
  valid_603017 = validateParameter(valid_603017, JString, required = false,
                                 default = nil)
  if valid_603017 != nil:
    section.add "X-Amz-Security-Token", valid_603017
  var valid_603018 = header.getOrDefault("X-Amz-Algorithm")
  valid_603018 = validateParameter(valid_603018, JString, required = false,
                                 default = nil)
  if valid_603018 != nil:
    section.add "X-Amz-Algorithm", valid_603018
  var valid_603019 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603019 = validateParameter(valid_603019, JString, required = false,
                                 default = nil)
  if valid_603019 != nil:
    section.add "X-Amz-SignedHeaders", valid_603019
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_603020 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_603020 = validateParameter(valid_603020, JString, required = true,
                                 default = nil)
  if valid_603020 != nil:
    section.add "HsmConfigurationIdentifier", valid_603020
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603021: Call_PostDeleteHsmConfiguration_603008; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_603021.validator(path, query, header, formData, body)
  let scheme = call_603021.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603021.url(scheme.get, call_603021.host, call_603021.base,
                         call_603021.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603021, url, valid)

proc call*(call_603022: Call_PostDeleteHsmConfiguration_603008;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  var query_603023 = newJObject()
  var formData_603024 = newJObject()
  add(query_603023, "Action", newJString(Action))
  add(query_603023, "Version", newJString(Version))
  add(formData_603024, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  result = call_603022.call(nil, query_603023, nil, formData_603024, nil)

var postDeleteHsmConfiguration* = Call_PostDeleteHsmConfiguration_603008(
    name: "postDeleteHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_PostDeleteHsmConfiguration_603009, base: "/",
    url: url_PostDeleteHsmConfiguration_603010,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmConfiguration_602992 = ref object of OpenApiRestCall_601373
proc url_GetDeleteHsmConfiguration_602994(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmConfiguration_602993(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602995 = query.getOrDefault("Action")
  valid_602995 = validateParameter(valid_602995, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_602995 != nil:
    section.add "Action", valid_602995
  var valid_602996 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_602996 = validateParameter(valid_602996, JString, required = true,
                                 default = nil)
  if valid_602996 != nil:
    section.add "HsmConfigurationIdentifier", valid_602996
  var valid_602997 = query.getOrDefault("Version")
  valid_602997 = validateParameter(valid_602997, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602997 != nil:
    section.add "Version", valid_602997
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_602998 = header.getOrDefault("X-Amz-Signature")
  valid_602998 = validateParameter(valid_602998, JString, required = false,
                                 default = nil)
  if valid_602998 != nil:
    section.add "X-Amz-Signature", valid_602998
  var valid_602999 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602999 = validateParameter(valid_602999, JString, required = false,
                                 default = nil)
  if valid_602999 != nil:
    section.add "X-Amz-Content-Sha256", valid_602999
  var valid_603000 = header.getOrDefault("X-Amz-Date")
  valid_603000 = validateParameter(valid_603000, JString, required = false,
                                 default = nil)
  if valid_603000 != nil:
    section.add "X-Amz-Date", valid_603000
  var valid_603001 = header.getOrDefault("X-Amz-Credential")
  valid_603001 = validateParameter(valid_603001, JString, required = false,
                                 default = nil)
  if valid_603001 != nil:
    section.add "X-Amz-Credential", valid_603001
  var valid_603002 = header.getOrDefault("X-Amz-Security-Token")
  valid_603002 = validateParameter(valid_603002, JString, required = false,
                                 default = nil)
  if valid_603002 != nil:
    section.add "X-Amz-Security-Token", valid_603002
  var valid_603003 = header.getOrDefault("X-Amz-Algorithm")
  valid_603003 = validateParameter(valid_603003, JString, required = false,
                                 default = nil)
  if valid_603003 != nil:
    section.add "X-Amz-Algorithm", valid_603003
  var valid_603004 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603004 = validateParameter(valid_603004, JString, required = false,
                                 default = nil)
  if valid_603004 != nil:
    section.add "X-Amz-SignedHeaders", valid_603004
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603005: Call_GetDeleteHsmConfiguration_602992; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_603005.validator(path, query, header, formData, body)
  let scheme = call_603005.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603005.url(scheme.get, call_603005.host, call_603005.base,
                         call_603005.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603005, url, valid)

proc call*(call_603006: Call_GetDeleteHsmConfiguration_602992;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Version: string (required)
  var query_603007 = newJObject()
  add(query_603007, "Action", newJString(Action))
  add(query_603007, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_603007, "Version", newJString(Version))
  result = call_603006.call(nil, query_603007, nil, nil, nil)

var getDeleteHsmConfiguration* = Call_GetDeleteHsmConfiguration_602992(
    name: "getDeleteHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_GetDeleteHsmConfiguration_602993, base: "/",
    url: url_GetDeleteHsmConfiguration_602994,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteScheduledAction_603041 = ref object of OpenApiRestCall_601373
proc url_PostDeleteScheduledAction_603043(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteScheduledAction_603042(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603044 = query.getOrDefault("Action")
  valid_603044 = validateParameter(valid_603044, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_603044 != nil:
    section.add "Action", valid_603044
  var valid_603045 = query.getOrDefault("Version")
  valid_603045 = validateParameter(valid_603045, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603045 != nil:
    section.add "Version", valid_603045
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603046 = header.getOrDefault("X-Amz-Signature")
  valid_603046 = validateParameter(valid_603046, JString, required = false,
                                 default = nil)
  if valid_603046 != nil:
    section.add "X-Amz-Signature", valid_603046
  var valid_603047 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603047 = validateParameter(valid_603047, JString, required = false,
                                 default = nil)
  if valid_603047 != nil:
    section.add "X-Amz-Content-Sha256", valid_603047
  var valid_603048 = header.getOrDefault("X-Amz-Date")
  valid_603048 = validateParameter(valid_603048, JString, required = false,
                                 default = nil)
  if valid_603048 != nil:
    section.add "X-Amz-Date", valid_603048
  var valid_603049 = header.getOrDefault("X-Amz-Credential")
  valid_603049 = validateParameter(valid_603049, JString, required = false,
                                 default = nil)
  if valid_603049 != nil:
    section.add "X-Amz-Credential", valid_603049
  var valid_603050 = header.getOrDefault("X-Amz-Security-Token")
  valid_603050 = validateParameter(valid_603050, JString, required = false,
                                 default = nil)
  if valid_603050 != nil:
    section.add "X-Amz-Security-Token", valid_603050
  var valid_603051 = header.getOrDefault("X-Amz-Algorithm")
  valid_603051 = validateParameter(valid_603051, JString, required = false,
                                 default = nil)
  if valid_603051 != nil:
    section.add "X-Amz-Algorithm", valid_603051
  var valid_603052 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603052 = validateParameter(valid_603052, JString, required = false,
                                 default = nil)
  if valid_603052 != nil:
    section.add "X-Amz-SignedHeaders", valid_603052
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_603053 = formData.getOrDefault("ScheduledActionName")
  valid_603053 = validateParameter(valid_603053, JString, required = true,
                                 default = nil)
  if valid_603053 != nil:
    section.add "ScheduledActionName", valid_603053
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603054: Call_PostDeleteScheduledAction_603041; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_603054.validator(path, query, header, formData, body)
  let scheme = call_603054.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603054.url(scheme.get, call_603054.host, call_603054.base,
                         call_603054.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603054, url, valid)

proc call*(call_603055: Call_PostDeleteScheduledAction_603041;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603056 = newJObject()
  var formData_603057 = newJObject()
  add(formData_603057, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_603056, "Action", newJString(Action))
  add(query_603056, "Version", newJString(Version))
  result = call_603055.call(nil, query_603056, nil, formData_603057, nil)

var postDeleteScheduledAction* = Call_PostDeleteScheduledAction_603041(
    name: "postDeleteScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_PostDeleteScheduledAction_603042, base: "/",
    url: url_PostDeleteScheduledAction_603043,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteScheduledAction_603025 = ref object of OpenApiRestCall_601373
proc url_GetDeleteScheduledAction_603027(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteScheduledAction_603026(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_603028 = query.getOrDefault("ScheduledActionName")
  valid_603028 = validateParameter(valid_603028, JString, required = true,
                                 default = nil)
  if valid_603028 != nil:
    section.add "ScheduledActionName", valid_603028
  var valid_603029 = query.getOrDefault("Action")
  valid_603029 = validateParameter(valid_603029, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_603029 != nil:
    section.add "Action", valid_603029
  var valid_603030 = query.getOrDefault("Version")
  valid_603030 = validateParameter(valid_603030, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603030 != nil:
    section.add "Version", valid_603030
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603031 = header.getOrDefault("X-Amz-Signature")
  valid_603031 = validateParameter(valid_603031, JString, required = false,
                                 default = nil)
  if valid_603031 != nil:
    section.add "X-Amz-Signature", valid_603031
  var valid_603032 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603032 = validateParameter(valid_603032, JString, required = false,
                                 default = nil)
  if valid_603032 != nil:
    section.add "X-Amz-Content-Sha256", valid_603032
  var valid_603033 = header.getOrDefault("X-Amz-Date")
  valid_603033 = validateParameter(valid_603033, JString, required = false,
                                 default = nil)
  if valid_603033 != nil:
    section.add "X-Amz-Date", valid_603033
  var valid_603034 = header.getOrDefault("X-Amz-Credential")
  valid_603034 = validateParameter(valid_603034, JString, required = false,
                                 default = nil)
  if valid_603034 != nil:
    section.add "X-Amz-Credential", valid_603034
  var valid_603035 = header.getOrDefault("X-Amz-Security-Token")
  valid_603035 = validateParameter(valid_603035, JString, required = false,
                                 default = nil)
  if valid_603035 != nil:
    section.add "X-Amz-Security-Token", valid_603035
  var valid_603036 = header.getOrDefault("X-Amz-Algorithm")
  valid_603036 = validateParameter(valid_603036, JString, required = false,
                                 default = nil)
  if valid_603036 != nil:
    section.add "X-Amz-Algorithm", valid_603036
  var valid_603037 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603037 = validateParameter(valid_603037, JString, required = false,
                                 default = nil)
  if valid_603037 != nil:
    section.add "X-Amz-SignedHeaders", valid_603037
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603038: Call_GetDeleteScheduledAction_603025; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_603038.validator(path, query, header, formData, body)
  let scheme = call_603038.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603038.url(scheme.get, call_603038.host, call_603038.base,
                         call_603038.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603038, url, valid)

proc call*(call_603039: Call_GetDeleteScheduledAction_603025;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603040 = newJObject()
  add(query_603040, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_603040, "Action", newJString(Action))
  add(query_603040, "Version", newJString(Version))
  result = call_603039.call(nil, query_603040, nil, nil, nil)

var getDeleteScheduledAction* = Call_GetDeleteScheduledAction_603025(
    name: "getDeleteScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_GetDeleteScheduledAction_603026, base: "/",
    url: url_GetDeleteScheduledAction_603027, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotCopyGrant_603074 = ref object of OpenApiRestCall_601373
proc url_PostDeleteSnapshotCopyGrant_603076(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotCopyGrant_603075(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603077 = query.getOrDefault("Action")
  valid_603077 = validateParameter(valid_603077, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_603077 != nil:
    section.add "Action", valid_603077
  var valid_603078 = query.getOrDefault("Version")
  valid_603078 = validateParameter(valid_603078, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603078 != nil:
    section.add "Version", valid_603078
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603079 = header.getOrDefault("X-Amz-Signature")
  valid_603079 = validateParameter(valid_603079, JString, required = false,
                                 default = nil)
  if valid_603079 != nil:
    section.add "X-Amz-Signature", valid_603079
  var valid_603080 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603080 = validateParameter(valid_603080, JString, required = false,
                                 default = nil)
  if valid_603080 != nil:
    section.add "X-Amz-Content-Sha256", valid_603080
  var valid_603081 = header.getOrDefault("X-Amz-Date")
  valid_603081 = validateParameter(valid_603081, JString, required = false,
                                 default = nil)
  if valid_603081 != nil:
    section.add "X-Amz-Date", valid_603081
  var valid_603082 = header.getOrDefault("X-Amz-Credential")
  valid_603082 = validateParameter(valid_603082, JString, required = false,
                                 default = nil)
  if valid_603082 != nil:
    section.add "X-Amz-Credential", valid_603082
  var valid_603083 = header.getOrDefault("X-Amz-Security-Token")
  valid_603083 = validateParameter(valid_603083, JString, required = false,
                                 default = nil)
  if valid_603083 != nil:
    section.add "X-Amz-Security-Token", valid_603083
  var valid_603084 = header.getOrDefault("X-Amz-Algorithm")
  valid_603084 = validateParameter(valid_603084, JString, required = false,
                                 default = nil)
  if valid_603084 != nil:
    section.add "X-Amz-Algorithm", valid_603084
  var valid_603085 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603085 = validateParameter(valid_603085, JString, required = false,
                                 default = nil)
  if valid_603085 != nil:
    section.add "X-Amz-SignedHeaders", valid_603085
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_603086 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_603086 = validateParameter(valid_603086, JString, required = true,
                                 default = nil)
  if valid_603086 != nil:
    section.add "SnapshotCopyGrantName", valid_603086
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603087: Call_PostDeleteSnapshotCopyGrant_603074; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_603087.validator(path, query, header, formData, body)
  let scheme = call_603087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603087.url(scheme.get, call_603087.host, call_603087.base,
                         call_603087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603087, url, valid)

proc call*(call_603088: Call_PostDeleteSnapshotCopyGrant_603074;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_603089 = newJObject()
  var formData_603090 = newJObject()
  add(query_603089, "Action", newJString(Action))
  add(formData_603090, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_603089, "Version", newJString(Version))
  result = call_603088.call(nil, query_603089, nil, formData_603090, nil)

var postDeleteSnapshotCopyGrant* = Call_PostDeleteSnapshotCopyGrant_603074(
    name: "postDeleteSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_PostDeleteSnapshotCopyGrant_603075, base: "/",
    url: url_PostDeleteSnapshotCopyGrant_603076,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotCopyGrant_603058 = ref object of OpenApiRestCall_601373
proc url_GetDeleteSnapshotCopyGrant_603060(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotCopyGrant_603059(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603061 = query.getOrDefault("Action")
  valid_603061 = validateParameter(valid_603061, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_603061 != nil:
    section.add "Action", valid_603061
  var valid_603062 = query.getOrDefault("Version")
  valid_603062 = validateParameter(valid_603062, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603062 != nil:
    section.add "Version", valid_603062
  var valid_603063 = query.getOrDefault("SnapshotCopyGrantName")
  valid_603063 = validateParameter(valid_603063, JString, required = true,
                                 default = nil)
  if valid_603063 != nil:
    section.add "SnapshotCopyGrantName", valid_603063
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603064 = header.getOrDefault("X-Amz-Signature")
  valid_603064 = validateParameter(valid_603064, JString, required = false,
                                 default = nil)
  if valid_603064 != nil:
    section.add "X-Amz-Signature", valid_603064
  var valid_603065 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603065 = validateParameter(valid_603065, JString, required = false,
                                 default = nil)
  if valid_603065 != nil:
    section.add "X-Amz-Content-Sha256", valid_603065
  var valid_603066 = header.getOrDefault("X-Amz-Date")
  valid_603066 = validateParameter(valid_603066, JString, required = false,
                                 default = nil)
  if valid_603066 != nil:
    section.add "X-Amz-Date", valid_603066
  var valid_603067 = header.getOrDefault("X-Amz-Credential")
  valid_603067 = validateParameter(valid_603067, JString, required = false,
                                 default = nil)
  if valid_603067 != nil:
    section.add "X-Amz-Credential", valid_603067
  var valid_603068 = header.getOrDefault("X-Amz-Security-Token")
  valid_603068 = validateParameter(valid_603068, JString, required = false,
                                 default = nil)
  if valid_603068 != nil:
    section.add "X-Amz-Security-Token", valid_603068
  var valid_603069 = header.getOrDefault("X-Amz-Algorithm")
  valid_603069 = validateParameter(valid_603069, JString, required = false,
                                 default = nil)
  if valid_603069 != nil:
    section.add "X-Amz-Algorithm", valid_603069
  var valid_603070 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603070 = validateParameter(valid_603070, JString, required = false,
                                 default = nil)
  if valid_603070 != nil:
    section.add "X-Amz-SignedHeaders", valid_603070
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603071: Call_GetDeleteSnapshotCopyGrant_603058; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_603071.validator(path, query, header, formData, body)
  let scheme = call_603071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603071.url(scheme.get, call_603071.host, call_603071.base,
                         call_603071.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603071, url, valid)

proc call*(call_603072: Call_GetDeleteSnapshotCopyGrant_603058;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  var query_603073 = newJObject()
  add(query_603073, "Action", newJString(Action))
  add(query_603073, "Version", newJString(Version))
  add(query_603073, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_603072.call(nil, query_603073, nil, nil, nil)

var getDeleteSnapshotCopyGrant* = Call_GetDeleteSnapshotCopyGrant_603058(
    name: "getDeleteSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_GetDeleteSnapshotCopyGrant_603059, base: "/",
    url: url_GetDeleteSnapshotCopyGrant_603060,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotSchedule_603107 = ref object of OpenApiRestCall_601373
proc url_PostDeleteSnapshotSchedule_603109(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotSchedule_603108(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603110 = query.getOrDefault("Action")
  valid_603110 = validateParameter(valid_603110, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_603110 != nil:
    section.add "Action", valid_603110
  var valid_603111 = query.getOrDefault("Version")
  valid_603111 = validateParameter(valid_603111, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603111 != nil:
    section.add "Version", valid_603111
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603112 = header.getOrDefault("X-Amz-Signature")
  valid_603112 = validateParameter(valid_603112, JString, required = false,
                                 default = nil)
  if valid_603112 != nil:
    section.add "X-Amz-Signature", valid_603112
  var valid_603113 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603113 = validateParameter(valid_603113, JString, required = false,
                                 default = nil)
  if valid_603113 != nil:
    section.add "X-Amz-Content-Sha256", valid_603113
  var valid_603114 = header.getOrDefault("X-Amz-Date")
  valid_603114 = validateParameter(valid_603114, JString, required = false,
                                 default = nil)
  if valid_603114 != nil:
    section.add "X-Amz-Date", valid_603114
  var valid_603115 = header.getOrDefault("X-Amz-Credential")
  valid_603115 = validateParameter(valid_603115, JString, required = false,
                                 default = nil)
  if valid_603115 != nil:
    section.add "X-Amz-Credential", valid_603115
  var valid_603116 = header.getOrDefault("X-Amz-Security-Token")
  valid_603116 = validateParameter(valid_603116, JString, required = false,
                                 default = nil)
  if valid_603116 != nil:
    section.add "X-Amz-Security-Token", valid_603116
  var valid_603117 = header.getOrDefault("X-Amz-Algorithm")
  valid_603117 = validateParameter(valid_603117, JString, required = false,
                                 default = nil)
  if valid_603117 != nil:
    section.add "X-Amz-Algorithm", valid_603117
  var valid_603118 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603118 = validateParameter(valid_603118, JString, required = false,
                                 default = nil)
  if valid_603118 != nil:
    section.add "X-Amz-SignedHeaders", valid_603118
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleIdentifier` field"
  var valid_603119 = formData.getOrDefault("ScheduleIdentifier")
  valid_603119 = validateParameter(valid_603119, JString, required = true,
                                 default = nil)
  if valid_603119 != nil:
    section.add "ScheduleIdentifier", valid_603119
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603120: Call_PostDeleteSnapshotSchedule_603107; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_603120.validator(path, query, header, formData, body)
  let scheme = call_603120.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603120.url(scheme.get, call_603120.host, call_603120.base,
                         call_603120.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603120, url, valid)

proc call*(call_603121: Call_PostDeleteSnapshotSchedule_603107;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_603122 = newJObject()
  var formData_603123 = newJObject()
  add(query_603122, "Action", newJString(Action))
  add(formData_603123, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_603122, "Version", newJString(Version))
  result = call_603121.call(nil, query_603122, nil, formData_603123, nil)

var postDeleteSnapshotSchedule* = Call_PostDeleteSnapshotSchedule_603107(
    name: "postDeleteSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_PostDeleteSnapshotSchedule_603108, base: "/",
    url: url_PostDeleteSnapshotSchedule_603109,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotSchedule_603091 = ref object of OpenApiRestCall_601373
proc url_GetDeleteSnapshotSchedule_603093(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotSchedule_603092(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleIdentifier` field"
  var valid_603094 = query.getOrDefault("ScheduleIdentifier")
  valid_603094 = validateParameter(valid_603094, JString, required = true,
                                 default = nil)
  if valid_603094 != nil:
    section.add "ScheduleIdentifier", valid_603094
  var valid_603095 = query.getOrDefault("Action")
  valid_603095 = validateParameter(valid_603095, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_603095 != nil:
    section.add "Action", valid_603095
  var valid_603096 = query.getOrDefault("Version")
  valid_603096 = validateParameter(valid_603096, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603096 != nil:
    section.add "Version", valid_603096
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603097 = header.getOrDefault("X-Amz-Signature")
  valid_603097 = validateParameter(valid_603097, JString, required = false,
                                 default = nil)
  if valid_603097 != nil:
    section.add "X-Amz-Signature", valid_603097
  var valid_603098 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603098 = validateParameter(valid_603098, JString, required = false,
                                 default = nil)
  if valid_603098 != nil:
    section.add "X-Amz-Content-Sha256", valid_603098
  var valid_603099 = header.getOrDefault("X-Amz-Date")
  valid_603099 = validateParameter(valid_603099, JString, required = false,
                                 default = nil)
  if valid_603099 != nil:
    section.add "X-Amz-Date", valid_603099
  var valid_603100 = header.getOrDefault("X-Amz-Credential")
  valid_603100 = validateParameter(valid_603100, JString, required = false,
                                 default = nil)
  if valid_603100 != nil:
    section.add "X-Amz-Credential", valid_603100
  var valid_603101 = header.getOrDefault("X-Amz-Security-Token")
  valid_603101 = validateParameter(valid_603101, JString, required = false,
                                 default = nil)
  if valid_603101 != nil:
    section.add "X-Amz-Security-Token", valid_603101
  var valid_603102 = header.getOrDefault("X-Amz-Algorithm")
  valid_603102 = validateParameter(valid_603102, JString, required = false,
                                 default = nil)
  if valid_603102 != nil:
    section.add "X-Amz-Algorithm", valid_603102
  var valid_603103 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603103 = validateParameter(valid_603103, JString, required = false,
                                 default = nil)
  if valid_603103 != nil:
    section.add "X-Amz-SignedHeaders", valid_603103
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603104: Call_GetDeleteSnapshotSchedule_603091; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_603104.validator(path, query, header, formData, body)
  let scheme = call_603104.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603104.url(scheme.get, call_603104.host, call_603104.base,
                         call_603104.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603104, url, valid)

proc call*(call_603105: Call_GetDeleteSnapshotSchedule_603091;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603106 = newJObject()
  add(query_603106, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_603106, "Action", newJString(Action))
  add(query_603106, "Version", newJString(Version))
  result = call_603105.call(nil, query_603106, nil, nil, nil)

var getDeleteSnapshotSchedule* = Call_GetDeleteSnapshotSchedule_603091(
    name: "getDeleteSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_GetDeleteSnapshotSchedule_603092, base: "/",
    url: url_GetDeleteSnapshotSchedule_603093,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteTags_603141 = ref object of OpenApiRestCall_601373
proc url_PostDeleteTags_603143(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteTags_603142(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603144 = query.getOrDefault("Action")
  valid_603144 = validateParameter(valid_603144, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_603144 != nil:
    section.add "Action", valid_603144
  var valid_603145 = query.getOrDefault("Version")
  valid_603145 = validateParameter(valid_603145, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603145 != nil:
    section.add "Version", valid_603145
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603146 = header.getOrDefault("X-Amz-Signature")
  valid_603146 = validateParameter(valid_603146, JString, required = false,
                                 default = nil)
  if valid_603146 != nil:
    section.add "X-Amz-Signature", valid_603146
  var valid_603147 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603147 = validateParameter(valid_603147, JString, required = false,
                                 default = nil)
  if valid_603147 != nil:
    section.add "X-Amz-Content-Sha256", valid_603147
  var valid_603148 = header.getOrDefault("X-Amz-Date")
  valid_603148 = validateParameter(valid_603148, JString, required = false,
                                 default = nil)
  if valid_603148 != nil:
    section.add "X-Amz-Date", valid_603148
  var valid_603149 = header.getOrDefault("X-Amz-Credential")
  valid_603149 = validateParameter(valid_603149, JString, required = false,
                                 default = nil)
  if valid_603149 != nil:
    section.add "X-Amz-Credential", valid_603149
  var valid_603150 = header.getOrDefault("X-Amz-Security-Token")
  valid_603150 = validateParameter(valid_603150, JString, required = false,
                                 default = nil)
  if valid_603150 != nil:
    section.add "X-Amz-Security-Token", valid_603150
  var valid_603151 = header.getOrDefault("X-Amz-Algorithm")
  valid_603151 = validateParameter(valid_603151, JString, required = false,
                                 default = nil)
  if valid_603151 != nil:
    section.add "X-Amz-Algorithm", valid_603151
  var valid_603152 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603152 = validateParameter(valid_603152, JString, required = false,
                                 default = nil)
  if valid_603152 != nil:
    section.add "X-Amz-SignedHeaders", valid_603152
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `TagKeys` field"
  var valid_603153 = formData.getOrDefault("TagKeys")
  valid_603153 = validateParameter(valid_603153, JArray, required = true, default = nil)
  if valid_603153 != nil:
    section.add "TagKeys", valid_603153
  var valid_603154 = formData.getOrDefault("ResourceName")
  valid_603154 = validateParameter(valid_603154, JString, required = true,
                                 default = nil)
  if valid_603154 != nil:
    section.add "ResourceName", valid_603154
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603155: Call_PostDeleteTags_603141; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_603155.validator(path, query, header, formData, body)
  let scheme = call_603155.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603155.url(scheme.get, call_603155.host, call_603155.base,
                         call_603155.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603155, url, valid)

proc call*(call_603156: Call_PostDeleteTags_603141; TagKeys: JsonNode;
          ResourceName: string; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  var query_603157 = newJObject()
  var formData_603158 = newJObject()
  if TagKeys != nil:
    formData_603158.add "TagKeys", TagKeys
  add(query_603157, "Action", newJString(Action))
  add(query_603157, "Version", newJString(Version))
  add(formData_603158, "ResourceName", newJString(ResourceName))
  result = call_603156.call(nil, query_603157, nil, formData_603158, nil)

var postDeleteTags* = Call_PostDeleteTags_603141(name: "postDeleteTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_PostDeleteTags_603142,
    base: "/", url: url_PostDeleteTags_603143, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteTags_603124 = ref object of OpenApiRestCall_601373
proc url_GetDeleteTags_603126(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteTags_603125(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `ResourceName` field"
  var valid_603127 = query.getOrDefault("ResourceName")
  valid_603127 = validateParameter(valid_603127, JString, required = true,
                                 default = nil)
  if valid_603127 != nil:
    section.add "ResourceName", valid_603127
  var valid_603128 = query.getOrDefault("TagKeys")
  valid_603128 = validateParameter(valid_603128, JArray, required = true, default = nil)
  if valid_603128 != nil:
    section.add "TagKeys", valid_603128
  var valid_603129 = query.getOrDefault("Action")
  valid_603129 = validateParameter(valid_603129, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_603129 != nil:
    section.add "Action", valid_603129
  var valid_603130 = query.getOrDefault("Version")
  valid_603130 = validateParameter(valid_603130, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603130 != nil:
    section.add "Version", valid_603130
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603131 = header.getOrDefault("X-Amz-Signature")
  valid_603131 = validateParameter(valid_603131, JString, required = false,
                                 default = nil)
  if valid_603131 != nil:
    section.add "X-Amz-Signature", valid_603131
  var valid_603132 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603132 = validateParameter(valid_603132, JString, required = false,
                                 default = nil)
  if valid_603132 != nil:
    section.add "X-Amz-Content-Sha256", valid_603132
  var valid_603133 = header.getOrDefault("X-Amz-Date")
  valid_603133 = validateParameter(valid_603133, JString, required = false,
                                 default = nil)
  if valid_603133 != nil:
    section.add "X-Amz-Date", valid_603133
  var valid_603134 = header.getOrDefault("X-Amz-Credential")
  valid_603134 = validateParameter(valid_603134, JString, required = false,
                                 default = nil)
  if valid_603134 != nil:
    section.add "X-Amz-Credential", valid_603134
  var valid_603135 = header.getOrDefault("X-Amz-Security-Token")
  valid_603135 = validateParameter(valid_603135, JString, required = false,
                                 default = nil)
  if valid_603135 != nil:
    section.add "X-Amz-Security-Token", valid_603135
  var valid_603136 = header.getOrDefault("X-Amz-Algorithm")
  valid_603136 = validateParameter(valid_603136, JString, required = false,
                                 default = nil)
  if valid_603136 != nil:
    section.add "X-Amz-Algorithm", valid_603136
  var valid_603137 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603137 = validateParameter(valid_603137, JString, required = false,
                                 default = nil)
  if valid_603137 != nil:
    section.add "X-Amz-SignedHeaders", valid_603137
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603138: Call_GetDeleteTags_603124; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_603138.validator(path, query, header, formData, body)
  let scheme = call_603138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603138.url(scheme.get, call_603138.host, call_603138.base,
                         call_603138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603138, url, valid)

proc call*(call_603139: Call_GetDeleteTags_603124; ResourceName: string;
          TagKeys: JsonNode; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603140 = newJObject()
  add(query_603140, "ResourceName", newJString(ResourceName))
  if TagKeys != nil:
    query_603140.add "TagKeys", TagKeys
  add(query_603140, "Action", newJString(Action))
  add(query_603140, "Version", newJString(Version))
  result = call_603139.call(nil, query_603140, nil, nil, nil)

var getDeleteTags* = Call_GetDeleteTags_603124(name: "getDeleteTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_GetDeleteTags_603125,
    base: "/", url: url_GetDeleteTags_603126, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeAccountAttributes_603175 = ref object of OpenApiRestCall_601373
proc url_PostDescribeAccountAttributes_603177(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeAccountAttributes_603176(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603178 = query.getOrDefault("Action")
  valid_603178 = validateParameter(valid_603178, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_603178 != nil:
    section.add "Action", valid_603178
  var valid_603179 = query.getOrDefault("Version")
  valid_603179 = validateParameter(valid_603179, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603179 != nil:
    section.add "Version", valid_603179
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603180 = header.getOrDefault("X-Amz-Signature")
  valid_603180 = validateParameter(valid_603180, JString, required = false,
                                 default = nil)
  if valid_603180 != nil:
    section.add "X-Amz-Signature", valid_603180
  var valid_603181 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603181 = validateParameter(valid_603181, JString, required = false,
                                 default = nil)
  if valid_603181 != nil:
    section.add "X-Amz-Content-Sha256", valid_603181
  var valid_603182 = header.getOrDefault("X-Amz-Date")
  valid_603182 = validateParameter(valid_603182, JString, required = false,
                                 default = nil)
  if valid_603182 != nil:
    section.add "X-Amz-Date", valid_603182
  var valid_603183 = header.getOrDefault("X-Amz-Credential")
  valid_603183 = validateParameter(valid_603183, JString, required = false,
                                 default = nil)
  if valid_603183 != nil:
    section.add "X-Amz-Credential", valid_603183
  var valid_603184 = header.getOrDefault("X-Amz-Security-Token")
  valid_603184 = validateParameter(valid_603184, JString, required = false,
                                 default = nil)
  if valid_603184 != nil:
    section.add "X-Amz-Security-Token", valid_603184
  var valid_603185 = header.getOrDefault("X-Amz-Algorithm")
  valid_603185 = validateParameter(valid_603185, JString, required = false,
                                 default = nil)
  if valid_603185 != nil:
    section.add "X-Amz-Algorithm", valid_603185
  var valid_603186 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603186 = validateParameter(valid_603186, JString, required = false,
                                 default = nil)
  if valid_603186 != nil:
    section.add "X-Amz-SignedHeaders", valid_603186
  result.add "header", section
  ## parameters in `formData` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  section = newJObject()
  var valid_603187 = formData.getOrDefault("AttributeNames")
  valid_603187 = validateParameter(valid_603187, JArray, required = false,
                                 default = nil)
  if valid_603187 != nil:
    section.add "AttributeNames", valid_603187
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603188: Call_PostDescribeAccountAttributes_603175; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_603188.validator(path, query, header, formData, body)
  let scheme = call_603188.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603188.url(scheme.get, call_603188.host, call_603188.base,
                         call_603188.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603188, url, valid)

proc call*(call_603189: Call_PostDescribeAccountAttributes_603175;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603190 = newJObject()
  var formData_603191 = newJObject()
  if AttributeNames != nil:
    formData_603191.add "AttributeNames", AttributeNames
  add(query_603190, "Action", newJString(Action))
  add(query_603190, "Version", newJString(Version))
  result = call_603189.call(nil, query_603190, nil, formData_603191, nil)

var postDescribeAccountAttributes* = Call_PostDescribeAccountAttributes_603175(
    name: "postDescribeAccountAttributes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_PostDescribeAccountAttributes_603176, base: "/",
    url: url_PostDescribeAccountAttributes_603177,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeAccountAttributes_603159 = ref object of OpenApiRestCall_601373
proc url_GetDescribeAccountAttributes_603161(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeAccountAttributes_603160(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_603162 = query.getOrDefault("AttributeNames")
  valid_603162 = validateParameter(valid_603162, JArray, required = false,
                                 default = nil)
  if valid_603162 != nil:
    section.add "AttributeNames", valid_603162
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603163 = query.getOrDefault("Action")
  valid_603163 = validateParameter(valid_603163, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_603163 != nil:
    section.add "Action", valid_603163
  var valid_603164 = query.getOrDefault("Version")
  valid_603164 = validateParameter(valid_603164, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603164 != nil:
    section.add "Version", valid_603164
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603165 = header.getOrDefault("X-Amz-Signature")
  valid_603165 = validateParameter(valid_603165, JString, required = false,
                                 default = nil)
  if valid_603165 != nil:
    section.add "X-Amz-Signature", valid_603165
  var valid_603166 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603166 = validateParameter(valid_603166, JString, required = false,
                                 default = nil)
  if valid_603166 != nil:
    section.add "X-Amz-Content-Sha256", valid_603166
  var valid_603167 = header.getOrDefault("X-Amz-Date")
  valid_603167 = validateParameter(valid_603167, JString, required = false,
                                 default = nil)
  if valid_603167 != nil:
    section.add "X-Amz-Date", valid_603167
  var valid_603168 = header.getOrDefault("X-Amz-Credential")
  valid_603168 = validateParameter(valid_603168, JString, required = false,
                                 default = nil)
  if valid_603168 != nil:
    section.add "X-Amz-Credential", valid_603168
  var valid_603169 = header.getOrDefault("X-Amz-Security-Token")
  valid_603169 = validateParameter(valid_603169, JString, required = false,
                                 default = nil)
  if valid_603169 != nil:
    section.add "X-Amz-Security-Token", valid_603169
  var valid_603170 = header.getOrDefault("X-Amz-Algorithm")
  valid_603170 = validateParameter(valid_603170, JString, required = false,
                                 default = nil)
  if valid_603170 != nil:
    section.add "X-Amz-Algorithm", valid_603170
  var valid_603171 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603171 = validateParameter(valid_603171, JString, required = false,
                                 default = nil)
  if valid_603171 != nil:
    section.add "X-Amz-SignedHeaders", valid_603171
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603172: Call_GetDescribeAccountAttributes_603159; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_603172.validator(path, query, header, formData, body)
  let scheme = call_603172.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603172.url(scheme.get, call_603172.host, call_603172.base,
                         call_603172.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603172, url, valid)

proc call*(call_603173: Call_GetDescribeAccountAttributes_603159;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603174 = newJObject()
  if AttributeNames != nil:
    query_603174.add "AttributeNames", AttributeNames
  add(query_603174, "Action", newJString(Action))
  add(query_603174, "Version", newJString(Version))
  result = call_603173.call(nil, query_603174, nil, nil, nil)

var getDescribeAccountAttributes* = Call_GetDescribeAccountAttributes_603159(
    name: "getDescribeAccountAttributes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_GetDescribeAccountAttributes_603160, base: "/",
    url: url_GetDescribeAccountAttributes_603161,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterDbRevisions_603210 = ref object of OpenApiRestCall_601373
proc url_PostDescribeClusterDbRevisions_603212(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterDbRevisions_603211(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603213 = query.getOrDefault("Action")
  valid_603213 = validateParameter(valid_603213, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_603213 != nil:
    section.add "Action", valid_603213
  var valid_603214 = query.getOrDefault("Version")
  valid_603214 = validateParameter(valid_603214, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603214 != nil:
    section.add "Version", valid_603214
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603215 = header.getOrDefault("X-Amz-Signature")
  valid_603215 = validateParameter(valid_603215, JString, required = false,
                                 default = nil)
  if valid_603215 != nil:
    section.add "X-Amz-Signature", valid_603215
  var valid_603216 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603216 = validateParameter(valid_603216, JString, required = false,
                                 default = nil)
  if valid_603216 != nil:
    section.add "X-Amz-Content-Sha256", valid_603216
  var valid_603217 = header.getOrDefault("X-Amz-Date")
  valid_603217 = validateParameter(valid_603217, JString, required = false,
                                 default = nil)
  if valid_603217 != nil:
    section.add "X-Amz-Date", valid_603217
  var valid_603218 = header.getOrDefault("X-Amz-Credential")
  valid_603218 = validateParameter(valid_603218, JString, required = false,
                                 default = nil)
  if valid_603218 != nil:
    section.add "X-Amz-Credential", valid_603218
  var valid_603219 = header.getOrDefault("X-Amz-Security-Token")
  valid_603219 = validateParameter(valid_603219, JString, required = false,
                                 default = nil)
  if valid_603219 != nil:
    section.add "X-Amz-Security-Token", valid_603219
  var valid_603220 = header.getOrDefault("X-Amz-Algorithm")
  valid_603220 = validateParameter(valid_603220, JString, required = false,
                                 default = nil)
  if valid_603220 != nil:
    section.add "X-Amz-Algorithm", valid_603220
  var valid_603221 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603221 = validateParameter(valid_603221, JString, required = false,
                                 default = nil)
  if valid_603221 != nil:
    section.add "X-Amz-SignedHeaders", valid_603221
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  section = newJObject()
  var valid_603222 = formData.getOrDefault("ClusterIdentifier")
  valid_603222 = validateParameter(valid_603222, JString, required = false,
                                 default = nil)
  if valid_603222 != nil:
    section.add "ClusterIdentifier", valid_603222
  var valid_603223 = formData.getOrDefault("MaxRecords")
  valid_603223 = validateParameter(valid_603223, JInt, required = false, default = nil)
  if valid_603223 != nil:
    section.add "MaxRecords", valid_603223
  var valid_603224 = formData.getOrDefault("Marker")
  valid_603224 = validateParameter(valid_603224, JString, required = false,
                                 default = nil)
  if valid_603224 != nil:
    section.add "Marker", valid_603224
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603225: Call_PostDescribeClusterDbRevisions_603210; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_603225.validator(path, query, header, formData, body)
  let scheme = call_603225.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603225.url(scheme.get, call_603225.host, call_603225.base,
                         call_603225.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603225, url, valid)

proc call*(call_603226: Call_PostDescribeClusterDbRevisions_603210;
          ClusterIdentifier: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeClusterDbRevisions";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603227 = newJObject()
  var formData_603228 = newJObject()
  add(formData_603228, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_603228, "MaxRecords", newJInt(MaxRecords))
  add(formData_603228, "Marker", newJString(Marker))
  add(query_603227, "Action", newJString(Action))
  add(query_603227, "Version", newJString(Version))
  result = call_603226.call(nil, query_603227, nil, formData_603228, nil)

var postDescribeClusterDbRevisions* = Call_PostDescribeClusterDbRevisions_603210(
    name: "postDescribeClusterDbRevisions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_PostDescribeClusterDbRevisions_603211, base: "/",
    url: url_PostDescribeClusterDbRevisions_603212,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterDbRevisions_603192 = ref object of OpenApiRestCall_601373
proc url_GetDescribeClusterDbRevisions_603194(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterDbRevisions_603193(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_603195 = query.getOrDefault("Marker")
  valid_603195 = validateParameter(valid_603195, JString, required = false,
                                 default = nil)
  if valid_603195 != nil:
    section.add "Marker", valid_603195
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603196 = query.getOrDefault("Action")
  valid_603196 = validateParameter(valid_603196, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_603196 != nil:
    section.add "Action", valid_603196
  var valid_603197 = query.getOrDefault("ClusterIdentifier")
  valid_603197 = validateParameter(valid_603197, JString, required = false,
                                 default = nil)
  if valid_603197 != nil:
    section.add "ClusterIdentifier", valid_603197
  var valid_603198 = query.getOrDefault("Version")
  valid_603198 = validateParameter(valid_603198, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603198 != nil:
    section.add "Version", valid_603198
  var valid_603199 = query.getOrDefault("MaxRecords")
  valid_603199 = validateParameter(valid_603199, JInt, required = false, default = nil)
  if valid_603199 != nil:
    section.add "MaxRecords", valid_603199
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603200 = header.getOrDefault("X-Amz-Signature")
  valid_603200 = validateParameter(valid_603200, JString, required = false,
                                 default = nil)
  if valid_603200 != nil:
    section.add "X-Amz-Signature", valid_603200
  var valid_603201 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603201 = validateParameter(valid_603201, JString, required = false,
                                 default = nil)
  if valid_603201 != nil:
    section.add "X-Amz-Content-Sha256", valid_603201
  var valid_603202 = header.getOrDefault("X-Amz-Date")
  valid_603202 = validateParameter(valid_603202, JString, required = false,
                                 default = nil)
  if valid_603202 != nil:
    section.add "X-Amz-Date", valid_603202
  var valid_603203 = header.getOrDefault("X-Amz-Credential")
  valid_603203 = validateParameter(valid_603203, JString, required = false,
                                 default = nil)
  if valid_603203 != nil:
    section.add "X-Amz-Credential", valid_603203
  var valid_603204 = header.getOrDefault("X-Amz-Security-Token")
  valid_603204 = validateParameter(valid_603204, JString, required = false,
                                 default = nil)
  if valid_603204 != nil:
    section.add "X-Amz-Security-Token", valid_603204
  var valid_603205 = header.getOrDefault("X-Amz-Algorithm")
  valid_603205 = validateParameter(valid_603205, JString, required = false,
                                 default = nil)
  if valid_603205 != nil:
    section.add "X-Amz-Algorithm", valid_603205
  var valid_603206 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603206 = validateParameter(valid_603206, JString, required = false,
                                 default = nil)
  if valid_603206 != nil:
    section.add "X-Amz-SignedHeaders", valid_603206
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603207: Call_GetDescribeClusterDbRevisions_603192; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_603207.validator(path, query, header, formData, body)
  let scheme = call_603207.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603207.url(scheme.get, call_603207.host, call_603207.base,
                         call_603207.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603207, url, valid)

proc call*(call_603208: Call_GetDescribeClusterDbRevisions_603192;
          Marker: string = ""; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0): Recallable =
  ## getDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_603209 = newJObject()
  add(query_603209, "Marker", newJString(Marker))
  add(query_603209, "Action", newJString(Action))
  add(query_603209, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603209, "Version", newJString(Version))
  add(query_603209, "MaxRecords", newJInt(MaxRecords))
  result = call_603208.call(nil, query_603209, nil, nil, nil)

var getDescribeClusterDbRevisions* = Call_GetDescribeClusterDbRevisions_603192(
    name: "getDescribeClusterDbRevisions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_GetDescribeClusterDbRevisions_603193, base: "/",
    url: url_GetDescribeClusterDbRevisions_603194,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameterGroups_603249 = ref object of OpenApiRestCall_601373
proc url_PostDescribeClusterParameterGroups_603251(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameterGroups_603250(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603252 = query.getOrDefault("Action")
  valid_603252 = validateParameter(valid_603252, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_603252 != nil:
    section.add "Action", valid_603252
  var valid_603253 = query.getOrDefault("Version")
  valid_603253 = validateParameter(valid_603253, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603253 != nil:
    section.add "Version", valid_603253
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603254 = header.getOrDefault("X-Amz-Signature")
  valid_603254 = validateParameter(valid_603254, JString, required = false,
                                 default = nil)
  if valid_603254 != nil:
    section.add "X-Amz-Signature", valid_603254
  var valid_603255 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603255 = validateParameter(valid_603255, JString, required = false,
                                 default = nil)
  if valid_603255 != nil:
    section.add "X-Amz-Content-Sha256", valid_603255
  var valid_603256 = header.getOrDefault("X-Amz-Date")
  valid_603256 = validateParameter(valid_603256, JString, required = false,
                                 default = nil)
  if valid_603256 != nil:
    section.add "X-Amz-Date", valid_603256
  var valid_603257 = header.getOrDefault("X-Amz-Credential")
  valid_603257 = validateParameter(valid_603257, JString, required = false,
                                 default = nil)
  if valid_603257 != nil:
    section.add "X-Amz-Credential", valid_603257
  var valid_603258 = header.getOrDefault("X-Amz-Security-Token")
  valid_603258 = validateParameter(valid_603258, JString, required = false,
                                 default = nil)
  if valid_603258 != nil:
    section.add "X-Amz-Security-Token", valid_603258
  var valid_603259 = header.getOrDefault("X-Amz-Algorithm")
  valid_603259 = validateParameter(valid_603259, JString, required = false,
                                 default = nil)
  if valid_603259 != nil:
    section.add "X-Amz-Algorithm", valid_603259
  var valid_603260 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603260 = validateParameter(valid_603260, JString, required = false,
                                 default = nil)
  if valid_603260 != nil:
    section.add "X-Amz-SignedHeaders", valid_603260
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  section = newJObject()
  var valid_603261 = formData.getOrDefault("TagKeys")
  valid_603261 = validateParameter(valid_603261, JArray, required = false,
                                 default = nil)
  if valid_603261 != nil:
    section.add "TagKeys", valid_603261
  var valid_603262 = formData.getOrDefault("MaxRecords")
  valid_603262 = validateParameter(valid_603262, JInt, required = false, default = nil)
  if valid_603262 != nil:
    section.add "MaxRecords", valid_603262
  var valid_603263 = formData.getOrDefault("Marker")
  valid_603263 = validateParameter(valid_603263, JString, required = false,
                                 default = nil)
  if valid_603263 != nil:
    section.add "Marker", valid_603263
  var valid_603264 = formData.getOrDefault("TagValues")
  valid_603264 = validateParameter(valid_603264, JArray, required = false,
                                 default = nil)
  if valid_603264 != nil:
    section.add "TagValues", valid_603264
  var valid_603265 = formData.getOrDefault("ParameterGroupName")
  valid_603265 = validateParameter(valid_603265, JString, required = false,
                                 default = nil)
  if valid_603265 != nil:
    section.add "ParameterGroupName", valid_603265
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603266: Call_PostDescribeClusterParameterGroups_603249;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603266.validator(path, query, header, formData, body)
  let scheme = call_603266.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603266.url(scheme.get, call_603266.host, call_603266.base,
                         call_603266.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603266, url, valid)

proc call*(call_603267: Call_PostDescribeClusterParameterGroups_603249;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil;
          Action: string = "DescribeClusterParameterGroups";
          ParameterGroupName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: string (required)
  var query_603268 = newJObject()
  var formData_603269 = newJObject()
  if TagKeys != nil:
    formData_603269.add "TagKeys", TagKeys
  add(formData_603269, "MaxRecords", newJInt(MaxRecords))
  add(formData_603269, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_603269.add "TagValues", TagValues
  add(query_603268, "Action", newJString(Action))
  add(formData_603269, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_603268, "Version", newJString(Version))
  result = call_603267.call(nil, query_603268, nil, formData_603269, nil)

var postDescribeClusterParameterGroups* = Call_PostDescribeClusterParameterGroups_603249(
    name: "postDescribeClusterParameterGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_PostDescribeClusterParameterGroups_603250, base: "/",
    url: url_PostDescribeClusterParameterGroups_603251,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameterGroups_603229 = ref object of OpenApiRestCall_601373
proc url_GetDescribeClusterParameterGroups_603231(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameterGroups_603230(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603232 = query.getOrDefault("Marker")
  valid_603232 = validateParameter(valid_603232, JString, required = false,
                                 default = nil)
  if valid_603232 != nil:
    section.add "Marker", valid_603232
  var valid_603233 = query.getOrDefault("TagKeys")
  valid_603233 = validateParameter(valid_603233, JArray, required = false,
                                 default = nil)
  if valid_603233 != nil:
    section.add "TagKeys", valid_603233
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603234 = query.getOrDefault("Action")
  valid_603234 = validateParameter(valid_603234, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_603234 != nil:
    section.add "Action", valid_603234
  var valid_603235 = query.getOrDefault("ParameterGroupName")
  valid_603235 = validateParameter(valid_603235, JString, required = false,
                                 default = nil)
  if valid_603235 != nil:
    section.add "ParameterGroupName", valid_603235
  var valid_603236 = query.getOrDefault("Version")
  valid_603236 = validateParameter(valid_603236, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603236 != nil:
    section.add "Version", valid_603236
  var valid_603237 = query.getOrDefault("MaxRecords")
  valid_603237 = validateParameter(valid_603237, JInt, required = false, default = nil)
  if valid_603237 != nil:
    section.add "MaxRecords", valid_603237
  var valid_603238 = query.getOrDefault("TagValues")
  valid_603238 = validateParameter(valid_603238, JArray, required = false,
                                 default = nil)
  if valid_603238 != nil:
    section.add "TagValues", valid_603238
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603239 = header.getOrDefault("X-Amz-Signature")
  valid_603239 = validateParameter(valid_603239, JString, required = false,
                                 default = nil)
  if valid_603239 != nil:
    section.add "X-Amz-Signature", valid_603239
  var valid_603240 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603240 = validateParameter(valid_603240, JString, required = false,
                                 default = nil)
  if valid_603240 != nil:
    section.add "X-Amz-Content-Sha256", valid_603240
  var valid_603241 = header.getOrDefault("X-Amz-Date")
  valid_603241 = validateParameter(valid_603241, JString, required = false,
                                 default = nil)
  if valid_603241 != nil:
    section.add "X-Amz-Date", valid_603241
  var valid_603242 = header.getOrDefault("X-Amz-Credential")
  valid_603242 = validateParameter(valid_603242, JString, required = false,
                                 default = nil)
  if valid_603242 != nil:
    section.add "X-Amz-Credential", valid_603242
  var valid_603243 = header.getOrDefault("X-Amz-Security-Token")
  valid_603243 = validateParameter(valid_603243, JString, required = false,
                                 default = nil)
  if valid_603243 != nil:
    section.add "X-Amz-Security-Token", valid_603243
  var valid_603244 = header.getOrDefault("X-Amz-Algorithm")
  valid_603244 = validateParameter(valid_603244, JString, required = false,
                                 default = nil)
  if valid_603244 != nil:
    section.add "X-Amz-Algorithm", valid_603244
  var valid_603245 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603245 = validateParameter(valid_603245, JString, required = false,
                                 default = nil)
  if valid_603245 != nil:
    section.add "X-Amz-SignedHeaders", valid_603245
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603246: Call_GetDescribeClusterParameterGroups_603229;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603246.validator(path, query, header, formData, body)
  let scheme = call_603246.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603246.url(scheme.get, call_603246.host, call_603246.base,
                         call_603246.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603246, url, valid)

proc call*(call_603247: Call_GetDescribeClusterParameterGroups_603229;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeClusterParameterGroups";
          ParameterGroupName: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  var query_603248 = newJObject()
  add(query_603248, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_603248.add "TagKeys", TagKeys
  add(query_603248, "Action", newJString(Action))
  add(query_603248, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_603248, "Version", newJString(Version))
  add(query_603248, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_603248.add "TagValues", TagValues
  result = call_603247.call(nil, query_603248, nil, nil, nil)

var getDescribeClusterParameterGroups* = Call_GetDescribeClusterParameterGroups_603229(
    name: "getDescribeClusterParameterGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_GetDescribeClusterParameterGroups_603230, base: "/",
    url: url_GetDescribeClusterParameterGroups_603231,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameters_603289 = ref object of OpenApiRestCall_601373
proc url_PostDescribeClusterParameters_603291(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameters_603290(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603292 = query.getOrDefault("Action")
  valid_603292 = validateParameter(valid_603292, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_603292 != nil:
    section.add "Action", valid_603292
  var valid_603293 = query.getOrDefault("Version")
  valid_603293 = validateParameter(valid_603293, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603293 != nil:
    section.add "Version", valid_603293
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603294 = header.getOrDefault("X-Amz-Signature")
  valid_603294 = validateParameter(valid_603294, JString, required = false,
                                 default = nil)
  if valid_603294 != nil:
    section.add "X-Amz-Signature", valid_603294
  var valid_603295 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603295 = validateParameter(valid_603295, JString, required = false,
                                 default = nil)
  if valid_603295 != nil:
    section.add "X-Amz-Content-Sha256", valid_603295
  var valid_603296 = header.getOrDefault("X-Amz-Date")
  valid_603296 = validateParameter(valid_603296, JString, required = false,
                                 default = nil)
  if valid_603296 != nil:
    section.add "X-Amz-Date", valid_603296
  var valid_603297 = header.getOrDefault("X-Amz-Credential")
  valid_603297 = validateParameter(valid_603297, JString, required = false,
                                 default = nil)
  if valid_603297 != nil:
    section.add "X-Amz-Credential", valid_603297
  var valid_603298 = header.getOrDefault("X-Amz-Security-Token")
  valid_603298 = validateParameter(valid_603298, JString, required = false,
                                 default = nil)
  if valid_603298 != nil:
    section.add "X-Amz-Security-Token", valid_603298
  var valid_603299 = header.getOrDefault("X-Amz-Algorithm")
  valid_603299 = validateParameter(valid_603299, JString, required = false,
                                 default = nil)
  if valid_603299 != nil:
    section.add "X-Amz-Algorithm", valid_603299
  var valid_603300 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603300 = validateParameter(valid_603300, JString, required = false,
                                 default = nil)
  if valid_603300 != nil:
    section.add "X-Amz-SignedHeaders", valid_603300
  result.add "header", section
  ## parameters in `formData` object:
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  section = newJObject()
  var valid_603301 = formData.getOrDefault("Source")
  valid_603301 = validateParameter(valid_603301, JString, required = false,
                                 default = nil)
  if valid_603301 != nil:
    section.add "Source", valid_603301
  var valid_603302 = formData.getOrDefault("MaxRecords")
  valid_603302 = validateParameter(valid_603302, JInt, required = false, default = nil)
  if valid_603302 != nil:
    section.add "MaxRecords", valid_603302
  var valid_603303 = formData.getOrDefault("Marker")
  valid_603303 = validateParameter(valid_603303, JString, required = false,
                                 default = nil)
  if valid_603303 != nil:
    section.add "Marker", valid_603303
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_603304 = formData.getOrDefault("ParameterGroupName")
  valid_603304 = validateParameter(valid_603304, JString, required = true,
                                 default = nil)
  if valid_603304 != nil:
    section.add "ParameterGroupName", valid_603304
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603305: Call_PostDescribeClusterParameters_603289; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603305.validator(path, query, header, formData, body)
  let scheme = call_603305.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603305.url(scheme.get, call_603305.host, call_603305.base,
                         call_603305.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603305, url, valid)

proc call*(call_603306: Call_PostDescribeClusterParameters_603289;
          ParameterGroupName: string; Source: string = ""; MaxRecords: int = 0;
          Marker: string = ""; Action: string = "DescribeClusterParameters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: string (required)
  var query_603307 = newJObject()
  var formData_603308 = newJObject()
  add(formData_603308, "Source", newJString(Source))
  add(formData_603308, "MaxRecords", newJInt(MaxRecords))
  add(formData_603308, "Marker", newJString(Marker))
  add(query_603307, "Action", newJString(Action))
  add(formData_603308, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_603307, "Version", newJString(Version))
  result = call_603306.call(nil, query_603307, nil, formData_603308, nil)

var postDescribeClusterParameters* = Call_PostDescribeClusterParameters_603289(
    name: "postDescribeClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_PostDescribeClusterParameters_603290, base: "/",
    url: url_PostDescribeClusterParameters_603291,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameters_603270 = ref object of OpenApiRestCall_601373
proc url_GetDescribeClusterParameters_603272(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameters_603271(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_603273 = query.getOrDefault("Marker")
  valid_603273 = validateParameter(valid_603273, JString, required = false,
                                 default = nil)
  if valid_603273 != nil:
    section.add "Marker", valid_603273
  var valid_603274 = query.getOrDefault("Source")
  valid_603274 = validateParameter(valid_603274, JString, required = false,
                                 default = nil)
  if valid_603274 != nil:
    section.add "Source", valid_603274
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603275 = query.getOrDefault("Action")
  valid_603275 = validateParameter(valid_603275, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_603275 != nil:
    section.add "Action", valid_603275
  var valid_603276 = query.getOrDefault("ParameterGroupName")
  valid_603276 = validateParameter(valid_603276, JString, required = true,
                                 default = nil)
  if valid_603276 != nil:
    section.add "ParameterGroupName", valid_603276
  var valid_603277 = query.getOrDefault("Version")
  valid_603277 = validateParameter(valid_603277, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603277 != nil:
    section.add "Version", valid_603277
  var valid_603278 = query.getOrDefault("MaxRecords")
  valid_603278 = validateParameter(valid_603278, JInt, required = false, default = nil)
  if valid_603278 != nil:
    section.add "MaxRecords", valid_603278
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603279 = header.getOrDefault("X-Amz-Signature")
  valid_603279 = validateParameter(valid_603279, JString, required = false,
                                 default = nil)
  if valid_603279 != nil:
    section.add "X-Amz-Signature", valid_603279
  var valid_603280 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603280 = validateParameter(valid_603280, JString, required = false,
                                 default = nil)
  if valid_603280 != nil:
    section.add "X-Amz-Content-Sha256", valid_603280
  var valid_603281 = header.getOrDefault("X-Amz-Date")
  valid_603281 = validateParameter(valid_603281, JString, required = false,
                                 default = nil)
  if valid_603281 != nil:
    section.add "X-Amz-Date", valid_603281
  var valid_603282 = header.getOrDefault("X-Amz-Credential")
  valid_603282 = validateParameter(valid_603282, JString, required = false,
                                 default = nil)
  if valid_603282 != nil:
    section.add "X-Amz-Credential", valid_603282
  var valid_603283 = header.getOrDefault("X-Amz-Security-Token")
  valid_603283 = validateParameter(valid_603283, JString, required = false,
                                 default = nil)
  if valid_603283 != nil:
    section.add "X-Amz-Security-Token", valid_603283
  var valid_603284 = header.getOrDefault("X-Amz-Algorithm")
  valid_603284 = validateParameter(valid_603284, JString, required = false,
                                 default = nil)
  if valid_603284 != nil:
    section.add "X-Amz-Algorithm", valid_603284
  var valid_603285 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603285 = validateParameter(valid_603285, JString, required = false,
                                 default = nil)
  if valid_603285 != nil:
    section.add "X-Amz-SignedHeaders", valid_603285
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603286: Call_GetDescribeClusterParameters_603270; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603286.validator(path, query, header, formData, body)
  let scheme = call_603286.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603286.url(scheme.get, call_603286.host, call_603286.base,
                         call_603286.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603286, url, valid)

proc call*(call_603287: Call_GetDescribeClusterParameters_603270;
          ParameterGroupName: string; Marker: string = ""; Source: string = "";
          Action: string = "DescribeClusterParameters";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_603288 = newJObject()
  add(query_603288, "Marker", newJString(Marker))
  add(query_603288, "Source", newJString(Source))
  add(query_603288, "Action", newJString(Action))
  add(query_603288, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_603288, "Version", newJString(Version))
  add(query_603288, "MaxRecords", newJInt(MaxRecords))
  result = call_603287.call(nil, query_603288, nil, nil, nil)

var getDescribeClusterParameters* = Call_GetDescribeClusterParameters_603270(
    name: "getDescribeClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_GetDescribeClusterParameters_603271, base: "/",
    url: url_GetDescribeClusterParameters_603272,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSecurityGroups_603329 = ref object of OpenApiRestCall_601373
proc url_PostDescribeClusterSecurityGroups_603331(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSecurityGroups_603330(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603332 = query.getOrDefault("Action")
  valid_603332 = validateParameter(valid_603332, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_603332 != nil:
    section.add "Action", valid_603332
  var valid_603333 = query.getOrDefault("Version")
  valid_603333 = validateParameter(valid_603333, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603333 != nil:
    section.add "Version", valid_603333
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603334 = header.getOrDefault("X-Amz-Signature")
  valid_603334 = validateParameter(valid_603334, JString, required = false,
                                 default = nil)
  if valid_603334 != nil:
    section.add "X-Amz-Signature", valid_603334
  var valid_603335 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603335 = validateParameter(valid_603335, JString, required = false,
                                 default = nil)
  if valid_603335 != nil:
    section.add "X-Amz-Content-Sha256", valid_603335
  var valid_603336 = header.getOrDefault("X-Amz-Date")
  valid_603336 = validateParameter(valid_603336, JString, required = false,
                                 default = nil)
  if valid_603336 != nil:
    section.add "X-Amz-Date", valid_603336
  var valid_603337 = header.getOrDefault("X-Amz-Credential")
  valid_603337 = validateParameter(valid_603337, JString, required = false,
                                 default = nil)
  if valid_603337 != nil:
    section.add "X-Amz-Credential", valid_603337
  var valid_603338 = header.getOrDefault("X-Amz-Security-Token")
  valid_603338 = validateParameter(valid_603338, JString, required = false,
                                 default = nil)
  if valid_603338 != nil:
    section.add "X-Amz-Security-Token", valid_603338
  var valid_603339 = header.getOrDefault("X-Amz-Algorithm")
  valid_603339 = validateParameter(valid_603339, JString, required = false,
                                 default = nil)
  if valid_603339 != nil:
    section.add "X-Amz-Algorithm", valid_603339
  var valid_603340 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603340 = validateParameter(valid_603340, JString, required = false,
                                 default = nil)
  if valid_603340 != nil:
    section.add "X-Amz-SignedHeaders", valid_603340
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603341 = formData.getOrDefault("TagKeys")
  valid_603341 = validateParameter(valid_603341, JArray, required = false,
                                 default = nil)
  if valid_603341 != nil:
    section.add "TagKeys", valid_603341
  var valid_603342 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_603342 = validateParameter(valid_603342, JString, required = false,
                                 default = nil)
  if valid_603342 != nil:
    section.add "ClusterSecurityGroupName", valid_603342
  var valid_603343 = formData.getOrDefault("MaxRecords")
  valid_603343 = validateParameter(valid_603343, JInt, required = false, default = nil)
  if valid_603343 != nil:
    section.add "MaxRecords", valid_603343
  var valid_603344 = formData.getOrDefault("Marker")
  valid_603344 = validateParameter(valid_603344, JString, required = false,
                                 default = nil)
  if valid_603344 != nil:
    section.add "Marker", valid_603344
  var valid_603345 = formData.getOrDefault("TagValues")
  valid_603345 = validateParameter(valid_603345, JArray, required = false,
                                 default = nil)
  if valid_603345 != nil:
    section.add "TagValues", valid_603345
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603346: Call_PostDescribeClusterSecurityGroups_603329;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603346.validator(path, query, header, formData, body)
  let scheme = call_603346.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603346.url(scheme.get, call_603346.host, call_603346.base,
                         call_603346.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603346, url, valid)

proc call*(call_603347: Call_PostDescribeClusterSecurityGroups_603329;
          TagKeys: JsonNode = nil; ClusterSecurityGroupName: string = "";
          MaxRecords: int = 0; Marker: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeClusterSecurityGroups";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603348 = newJObject()
  var formData_603349 = newJObject()
  if TagKeys != nil:
    formData_603349.add "TagKeys", TagKeys
  add(formData_603349, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_603349, "MaxRecords", newJInt(MaxRecords))
  add(formData_603349, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_603349.add "TagValues", TagValues
  add(query_603348, "Action", newJString(Action))
  add(query_603348, "Version", newJString(Version))
  result = call_603347.call(nil, query_603348, nil, formData_603349, nil)

var postDescribeClusterSecurityGroups* = Call_PostDescribeClusterSecurityGroups_603329(
    name: "postDescribeClusterSecurityGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_PostDescribeClusterSecurityGroups_603330, base: "/",
    url: url_PostDescribeClusterSecurityGroups_603331,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSecurityGroups_603309 = ref object of OpenApiRestCall_601373
proc url_GetDescribeClusterSecurityGroups_603311(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSecurityGroups_603310(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603312 = query.getOrDefault("Marker")
  valid_603312 = validateParameter(valid_603312, JString, required = false,
                                 default = nil)
  if valid_603312 != nil:
    section.add "Marker", valid_603312
  var valid_603313 = query.getOrDefault("TagKeys")
  valid_603313 = validateParameter(valid_603313, JArray, required = false,
                                 default = nil)
  if valid_603313 != nil:
    section.add "TagKeys", valid_603313
  var valid_603314 = query.getOrDefault("ClusterSecurityGroupName")
  valid_603314 = validateParameter(valid_603314, JString, required = false,
                                 default = nil)
  if valid_603314 != nil:
    section.add "ClusterSecurityGroupName", valid_603314
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603315 = query.getOrDefault("Action")
  valid_603315 = validateParameter(valid_603315, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_603315 != nil:
    section.add "Action", valid_603315
  var valid_603316 = query.getOrDefault("Version")
  valid_603316 = validateParameter(valid_603316, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603316 != nil:
    section.add "Version", valid_603316
  var valid_603317 = query.getOrDefault("MaxRecords")
  valid_603317 = validateParameter(valid_603317, JInt, required = false, default = nil)
  if valid_603317 != nil:
    section.add "MaxRecords", valid_603317
  var valid_603318 = query.getOrDefault("TagValues")
  valid_603318 = validateParameter(valid_603318, JArray, required = false,
                                 default = nil)
  if valid_603318 != nil:
    section.add "TagValues", valid_603318
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603319 = header.getOrDefault("X-Amz-Signature")
  valid_603319 = validateParameter(valid_603319, JString, required = false,
                                 default = nil)
  if valid_603319 != nil:
    section.add "X-Amz-Signature", valid_603319
  var valid_603320 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603320 = validateParameter(valid_603320, JString, required = false,
                                 default = nil)
  if valid_603320 != nil:
    section.add "X-Amz-Content-Sha256", valid_603320
  var valid_603321 = header.getOrDefault("X-Amz-Date")
  valid_603321 = validateParameter(valid_603321, JString, required = false,
                                 default = nil)
  if valid_603321 != nil:
    section.add "X-Amz-Date", valid_603321
  var valid_603322 = header.getOrDefault("X-Amz-Credential")
  valid_603322 = validateParameter(valid_603322, JString, required = false,
                                 default = nil)
  if valid_603322 != nil:
    section.add "X-Amz-Credential", valid_603322
  var valid_603323 = header.getOrDefault("X-Amz-Security-Token")
  valid_603323 = validateParameter(valid_603323, JString, required = false,
                                 default = nil)
  if valid_603323 != nil:
    section.add "X-Amz-Security-Token", valid_603323
  var valid_603324 = header.getOrDefault("X-Amz-Algorithm")
  valid_603324 = validateParameter(valid_603324, JString, required = false,
                                 default = nil)
  if valid_603324 != nil:
    section.add "X-Amz-Algorithm", valid_603324
  var valid_603325 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603325 = validateParameter(valid_603325, JString, required = false,
                                 default = nil)
  if valid_603325 != nil:
    section.add "X-Amz-SignedHeaders", valid_603325
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603326: Call_GetDescribeClusterSecurityGroups_603309;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603326.validator(path, query, header, formData, body)
  let scheme = call_603326.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603326.url(scheme.get, call_603326.host, call_603326.base,
                         call_603326.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603326, url, valid)

proc call*(call_603327: Call_GetDescribeClusterSecurityGroups_603309;
          Marker: string = ""; TagKeys: JsonNode = nil;
          ClusterSecurityGroupName: string = "";
          Action: string = "DescribeClusterSecurityGroups";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  var query_603328 = newJObject()
  add(query_603328, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_603328.add "TagKeys", TagKeys
  add(query_603328, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_603328, "Action", newJString(Action))
  add(query_603328, "Version", newJString(Version))
  add(query_603328, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_603328.add "TagValues", TagValues
  result = call_603327.call(nil, query_603328, nil, nil, nil)

var getDescribeClusterSecurityGroups* = Call_GetDescribeClusterSecurityGroups_603309(
    name: "getDescribeClusterSecurityGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_GetDescribeClusterSecurityGroups_603310, base: "/",
    url: url_GetDescribeClusterSecurityGroups_603311,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSnapshots_603377 = ref object of OpenApiRestCall_601373
proc url_PostDescribeClusterSnapshots_603379(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSnapshots_603378(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603380 = query.getOrDefault("Action")
  valid_603380 = validateParameter(valid_603380, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_603380 != nil:
    section.add "Action", valid_603380
  var valid_603381 = query.getOrDefault("Version")
  valid_603381 = validateParameter(valid_603381, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603381 != nil:
    section.add "Version", valid_603381
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603382 = header.getOrDefault("X-Amz-Signature")
  valid_603382 = validateParameter(valid_603382, JString, required = false,
                                 default = nil)
  if valid_603382 != nil:
    section.add "X-Amz-Signature", valid_603382
  var valid_603383 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603383 = validateParameter(valid_603383, JString, required = false,
                                 default = nil)
  if valid_603383 != nil:
    section.add "X-Amz-Content-Sha256", valid_603383
  var valid_603384 = header.getOrDefault("X-Amz-Date")
  valid_603384 = validateParameter(valid_603384, JString, required = false,
                                 default = nil)
  if valid_603384 != nil:
    section.add "X-Amz-Date", valid_603384
  var valid_603385 = header.getOrDefault("X-Amz-Credential")
  valid_603385 = validateParameter(valid_603385, JString, required = false,
                                 default = nil)
  if valid_603385 != nil:
    section.add "X-Amz-Credential", valid_603385
  var valid_603386 = header.getOrDefault("X-Amz-Security-Token")
  valid_603386 = validateParameter(valid_603386, JString, required = false,
                                 default = nil)
  if valid_603386 != nil:
    section.add "X-Amz-Security-Token", valid_603386
  var valid_603387 = header.getOrDefault("X-Amz-Algorithm")
  valid_603387 = validateParameter(valid_603387, JString, required = false,
                                 default = nil)
  if valid_603387 != nil:
    section.add "X-Amz-Algorithm", valid_603387
  var valid_603388 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603388 = validateParameter(valid_603388, JString, required = false,
                                 default = nil)
  if valid_603388 != nil:
    section.add "X-Amz-SignedHeaders", valid_603388
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   SortingEntities: JArray
  ##                  : <p/>
  section = newJObject()
  var valid_603389 = formData.getOrDefault("TagKeys")
  valid_603389 = validateParameter(valid_603389, JArray, required = false,
                                 default = nil)
  if valid_603389 != nil:
    section.add "TagKeys", valid_603389
  var valid_603390 = formData.getOrDefault("ClusterIdentifier")
  valid_603390 = validateParameter(valid_603390, JString, required = false,
                                 default = nil)
  if valid_603390 != nil:
    section.add "ClusterIdentifier", valid_603390
  var valid_603391 = formData.getOrDefault("SnapshotType")
  valid_603391 = validateParameter(valid_603391, JString, required = false,
                                 default = nil)
  if valid_603391 != nil:
    section.add "SnapshotType", valid_603391
  var valid_603392 = formData.getOrDefault("MaxRecords")
  valid_603392 = validateParameter(valid_603392, JInt, required = false, default = nil)
  if valid_603392 != nil:
    section.add "MaxRecords", valid_603392
  var valid_603393 = formData.getOrDefault("OwnerAccount")
  valid_603393 = validateParameter(valid_603393, JString, required = false,
                                 default = nil)
  if valid_603393 != nil:
    section.add "OwnerAccount", valid_603393
  var valid_603394 = formData.getOrDefault("Marker")
  valid_603394 = validateParameter(valid_603394, JString, required = false,
                                 default = nil)
  if valid_603394 != nil:
    section.add "Marker", valid_603394
  var valid_603395 = formData.getOrDefault("ClusterExists")
  valid_603395 = validateParameter(valid_603395, JBool, required = false, default = nil)
  if valid_603395 != nil:
    section.add "ClusterExists", valid_603395
  var valid_603396 = formData.getOrDefault("TagValues")
  valid_603396 = validateParameter(valid_603396, JArray, required = false,
                                 default = nil)
  if valid_603396 != nil:
    section.add "TagValues", valid_603396
  var valid_603397 = formData.getOrDefault("EndTime")
  valid_603397 = validateParameter(valid_603397, JString, required = false,
                                 default = nil)
  if valid_603397 != nil:
    section.add "EndTime", valid_603397
  var valid_603398 = formData.getOrDefault("StartTime")
  valid_603398 = validateParameter(valid_603398, JString, required = false,
                                 default = nil)
  if valid_603398 != nil:
    section.add "StartTime", valid_603398
  var valid_603399 = formData.getOrDefault("SnapshotIdentifier")
  valid_603399 = validateParameter(valid_603399, JString, required = false,
                                 default = nil)
  if valid_603399 != nil:
    section.add "SnapshotIdentifier", valid_603399
  var valid_603400 = formData.getOrDefault("SortingEntities")
  valid_603400 = validateParameter(valid_603400, JArray, required = false,
                                 default = nil)
  if valid_603400 != nil:
    section.add "SortingEntities", valid_603400
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603401: Call_PostDescribeClusterSnapshots_603377; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603401.validator(path, query, header, formData, body)
  let scheme = call_603401.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603401.url(scheme.get, call_603401.host, call_603401.base,
                         call_603401.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603401, url, valid)

proc call*(call_603402: Call_PostDescribeClusterSnapshots_603377;
          TagKeys: JsonNode = nil; ClusterIdentifier: string = "";
          SnapshotType: string = ""; MaxRecords: int = 0; OwnerAccount: string = "";
          Marker: string = ""; ClusterExists: bool = false; TagValues: JsonNode = nil;
          EndTime: string = ""; StartTime: string = ""; SnapshotIdentifier: string = "";
          Action: string = "DescribeClusterSnapshots";
          SortingEntities: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   Action: string (required)
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   Version: string (required)
  var query_603403 = newJObject()
  var formData_603404 = newJObject()
  if TagKeys != nil:
    formData_603404.add "TagKeys", TagKeys
  add(formData_603404, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_603404, "SnapshotType", newJString(SnapshotType))
  add(formData_603404, "MaxRecords", newJInt(MaxRecords))
  add(formData_603404, "OwnerAccount", newJString(OwnerAccount))
  add(formData_603404, "Marker", newJString(Marker))
  add(formData_603404, "ClusterExists", newJBool(ClusterExists))
  if TagValues != nil:
    formData_603404.add "TagValues", TagValues
  add(formData_603404, "EndTime", newJString(EndTime))
  add(formData_603404, "StartTime", newJString(StartTime))
  add(formData_603404, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603403, "Action", newJString(Action))
  if SortingEntities != nil:
    formData_603404.add "SortingEntities", SortingEntities
  add(query_603403, "Version", newJString(Version))
  result = call_603402.call(nil, query_603403, nil, formData_603404, nil)

var postDescribeClusterSnapshots* = Call_PostDescribeClusterSnapshots_603377(
    name: "postDescribeClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_PostDescribeClusterSnapshots_603378, base: "/",
    url: url_PostDescribeClusterSnapshots_603379,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSnapshots_603350 = ref object of OpenApiRestCall_601373
proc url_GetDescribeClusterSnapshots_603352(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSnapshots_603351(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603353 = query.getOrDefault("Marker")
  valid_603353 = validateParameter(valid_603353, JString, required = false,
                                 default = nil)
  if valid_603353 != nil:
    section.add "Marker", valid_603353
  var valid_603354 = query.getOrDefault("SortingEntities")
  valid_603354 = validateParameter(valid_603354, JArray, required = false,
                                 default = nil)
  if valid_603354 != nil:
    section.add "SortingEntities", valid_603354
  var valid_603355 = query.getOrDefault("SnapshotIdentifier")
  valid_603355 = validateParameter(valid_603355, JString, required = false,
                                 default = nil)
  if valid_603355 != nil:
    section.add "SnapshotIdentifier", valid_603355
  var valid_603356 = query.getOrDefault("ClusterExists")
  valid_603356 = validateParameter(valid_603356, JBool, required = false, default = nil)
  if valid_603356 != nil:
    section.add "ClusterExists", valid_603356
  var valid_603357 = query.getOrDefault("TagKeys")
  valid_603357 = validateParameter(valid_603357, JArray, required = false,
                                 default = nil)
  if valid_603357 != nil:
    section.add "TagKeys", valid_603357
  var valid_603358 = query.getOrDefault("SnapshotType")
  valid_603358 = validateParameter(valid_603358, JString, required = false,
                                 default = nil)
  if valid_603358 != nil:
    section.add "SnapshotType", valid_603358
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603359 = query.getOrDefault("Action")
  valid_603359 = validateParameter(valid_603359, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_603359 != nil:
    section.add "Action", valid_603359
  var valid_603360 = query.getOrDefault("StartTime")
  valid_603360 = validateParameter(valid_603360, JString, required = false,
                                 default = nil)
  if valid_603360 != nil:
    section.add "StartTime", valid_603360
  var valid_603361 = query.getOrDefault("ClusterIdentifier")
  valid_603361 = validateParameter(valid_603361, JString, required = false,
                                 default = nil)
  if valid_603361 != nil:
    section.add "ClusterIdentifier", valid_603361
  var valid_603362 = query.getOrDefault("EndTime")
  valid_603362 = validateParameter(valid_603362, JString, required = false,
                                 default = nil)
  if valid_603362 != nil:
    section.add "EndTime", valid_603362
  var valid_603363 = query.getOrDefault("OwnerAccount")
  valid_603363 = validateParameter(valid_603363, JString, required = false,
                                 default = nil)
  if valid_603363 != nil:
    section.add "OwnerAccount", valid_603363
  var valid_603364 = query.getOrDefault("Version")
  valid_603364 = validateParameter(valid_603364, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603364 != nil:
    section.add "Version", valid_603364
  var valid_603365 = query.getOrDefault("MaxRecords")
  valid_603365 = validateParameter(valid_603365, JInt, required = false, default = nil)
  if valid_603365 != nil:
    section.add "MaxRecords", valid_603365
  var valid_603366 = query.getOrDefault("TagValues")
  valid_603366 = validateParameter(valid_603366, JArray, required = false,
                                 default = nil)
  if valid_603366 != nil:
    section.add "TagValues", valid_603366
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603367 = header.getOrDefault("X-Amz-Signature")
  valid_603367 = validateParameter(valid_603367, JString, required = false,
                                 default = nil)
  if valid_603367 != nil:
    section.add "X-Amz-Signature", valid_603367
  var valid_603368 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603368 = validateParameter(valid_603368, JString, required = false,
                                 default = nil)
  if valid_603368 != nil:
    section.add "X-Amz-Content-Sha256", valid_603368
  var valid_603369 = header.getOrDefault("X-Amz-Date")
  valid_603369 = validateParameter(valid_603369, JString, required = false,
                                 default = nil)
  if valid_603369 != nil:
    section.add "X-Amz-Date", valid_603369
  var valid_603370 = header.getOrDefault("X-Amz-Credential")
  valid_603370 = validateParameter(valid_603370, JString, required = false,
                                 default = nil)
  if valid_603370 != nil:
    section.add "X-Amz-Credential", valid_603370
  var valid_603371 = header.getOrDefault("X-Amz-Security-Token")
  valid_603371 = validateParameter(valid_603371, JString, required = false,
                                 default = nil)
  if valid_603371 != nil:
    section.add "X-Amz-Security-Token", valid_603371
  var valid_603372 = header.getOrDefault("X-Amz-Algorithm")
  valid_603372 = validateParameter(valid_603372, JString, required = false,
                                 default = nil)
  if valid_603372 != nil:
    section.add "X-Amz-Algorithm", valid_603372
  var valid_603373 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603373 = validateParameter(valid_603373, JString, required = false,
                                 default = nil)
  if valid_603373 != nil:
    section.add "X-Amz-SignedHeaders", valid_603373
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603374: Call_GetDescribeClusterSnapshots_603350; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603374.validator(path, query, header, formData, body)
  let scheme = call_603374.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603374.url(scheme.get, call_603374.host, call_603374.base,
                         call_603374.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603374, url, valid)

proc call*(call_603375: Call_GetDescribeClusterSnapshots_603350;
          Marker: string = ""; SortingEntities: JsonNode = nil;
          SnapshotIdentifier: string = ""; ClusterExists: bool = false;
          TagKeys: JsonNode = nil; SnapshotType: string = "";
          Action: string = "DescribeClusterSnapshots"; StartTime: string = "";
          ClusterIdentifier: string = ""; EndTime: string = "";
          OwnerAccount: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Action: string (required)
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  var query_603376 = newJObject()
  add(query_603376, "Marker", newJString(Marker))
  if SortingEntities != nil:
    query_603376.add "SortingEntities", SortingEntities
  add(query_603376, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603376, "ClusterExists", newJBool(ClusterExists))
  if TagKeys != nil:
    query_603376.add "TagKeys", TagKeys
  add(query_603376, "SnapshotType", newJString(SnapshotType))
  add(query_603376, "Action", newJString(Action))
  add(query_603376, "StartTime", newJString(StartTime))
  add(query_603376, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603376, "EndTime", newJString(EndTime))
  add(query_603376, "OwnerAccount", newJString(OwnerAccount))
  add(query_603376, "Version", newJString(Version))
  add(query_603376, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_603376.add "TagValues", TagValues
  result = call_603375.call(nil, query_603376, nil, nil, nil)

var getDescribeClusterSnapshots* = Call_GetDescribeClusterSnapshots_603350(
    name: "getDescribeClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_GetDescribeClusterSnapshots_603351, base: "/",
    url: url_GetDescribeClusterSnapshots_603352,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSubnetGroups_603425 = ref object of OpenApiRestCall_601373
proc url_PostDescribeClusterSubnetGroups_603427(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSubnetGroups_603426(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603428 = query.getOrDefault("Action")
  valid_603428 = validateParameter(valid_603428, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_603428 != nil:
    section.add "Action", valid_603428
  var valid_603429 = query.getOrDefault("Version")
  valid_603429 = validateParameter(valid_603429, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603429 != nil:
    section.add "Version", valid_603429
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603430 = header.getOrDefault("X-Amz-Signature")
  valid_603430 = validateParameter(valid_603430, JString, required = false,
                                 default = nil)
  if valid_603430 != nil:
    section.add "X-Amz-Signature", valid_603430
  var valid_603431 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603431 = validateParameter(valid_603431, JString, required = false,
                                 default = nil)
  if valid_603431 != nil:
    section.add "X-Amz-Content-Sha256", valid_603431
  var valid_603432 = header.getOrDefault("X-Amz-Date")
  valid_603432 = validateParameter(valid_603432, JString, required = false,
                                 default = nil)
  if valid_603432 != nil:
    section.add "X-Amz-Date", valid_603432
  var valid_603433 = header.getOrDefault("X-Amz-Credential")
  valid_603433 = validateParameter(valid_603433, JString, required = false,
                                 default = nil)
  if valid_603433 != nil:
    section.add "X-Amz-Credential", valid_603433
  var valid_603434 = header.getOrDefault("X-Amz-Security-Token")
  valid_603434 = validateParameter(valid_603434, JString, required = false,
                                 default = nil)
  if valid_603434 != nil:
    section.add "X-Amz-Security-Token", valid_603434
  var valid_603435 = header.getOrDefault("X-Amz-Algorithm")
  valid_603435 = validateParameter(valid_603435, JString, required = false,
                                 default = nil)
  if valid_603435 != nil:
    section.add "X-Amz-Algorithm", valid_603435
  var valid_603436 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603436 = validateParameter(valid_603436, JString, required = false,
                                 default = nil)
  if valid_603436 != nil:
    section.add "X-Amz-SignedHeaders", valid_603436
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603437 = formData.getOrDefault("TagKeys")
  valid_603437 = validateParameter(valid_603437, JArray, required = false,
                                 default = nil)
  if valid_603437 != nil:
    section.add "TagKeys", valid_603437
  var valid_603438 = formData.getOrDefault("MaxRecords")
  valid_603438 = validateParameter(valid_603438, JInt, required = false, default = nil)
  if valid_603438 != nil:
    section.add "MaxRecords", valid_603438
  var valid_603439 = formData.getOrDefault("Marker")
  valid_603439 = validateParameter(valid_603439, JString, required = false,
                                 default = nil)
  if valid_603439 != nil:
    section.add "Marker", valid_603439
  var valid_603440 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_603440 = validateParameter(valid_603440, JString, required = false,
                                 default = nil)
  if valid_603440 != nil:
    section.add "ClusterSubnetGroupName", valid_603440
  var valid_603441 = formData.getOrDefault("TagValues")
  valid_603441 = validateParameter(valid_603441, JArray, required = false,
                                 default = nil)
  if valid_603441 != nil:
    section.add "TagValues", valid_603441
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603442: Call_PostDescribeClusterSubnetGroups_603425;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603442.validator(path, query, header, formData, body)
  let scheme = call_603442.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603442.url(scheme.get, call_603442.host, call_603442.base,
                         call_603442.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603442, url, valid)

proc call*(call_603443: Call_PostDescribeClusterSubnetGroups_603425;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          ClusterSubnetGroupName: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeClusterSubnetGroups";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603444 = newJObject()
  var formData_603445 = newJObject()
  if TagKeys != nil:
    formData_603445.add "TagKeys", TagKeys
  add(formData_603445, "MaxRecords", newJInt(MaxRecords))
  add(formData_603445, "Marker", newJString(Marker))
  add(formData_603445, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  if TagValues != nil:
    formData_603445.add "TagValues", TagValues
  add(query_603444, "Action", newJString(Action))
  add(query_603444, "Version", newJString(Version))
  result = call_603443.call(nil, query_603444, nil, formData_603445, nil)

var postDescribeClusterSubnetGroups* = Call_PostDescribeClusterSubnetGroups_603425(
    name: "postDescribeClusterSubnetGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_PostDescribeClusterSubnetGroups_603426, base: "/",
    url: url_PostDescribeClusterSubnetGroups_603427,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSubnetGroups_603405 = ref object of OpenApiRestCall_601373
proc url_GetDescribeClusterSubnetGroups_603407(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSubnetGroups_603406(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603408 = query.getOrDefault("ClusterSubnetGroupName")
  valid_603408 = validateParameter(valid_603408, JString, required = false,
                                 default = nil)
  if valid_603408 != nil:
    section.add "ClusterSubnetGroupName", valid_603408
  var valid_603409 = query.getOrDefault("Marker")
  valid_603409 = validateParameter(valid_603409, JString, required = false,
                                 default = nil)
  if valid_603409 != nil:
    section.add "Marker", valid_603409
  var valid_603410 = query.getOrDefault("TagKeys")
  valid_603410 = validateParameter(valid_603410, JArray, required = false,
                                 default = nil)
  if valid_603410 != nil:
    section.add "TagKeys", valid_603410
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603411 = query.getOrDefault("Action")
  valid_603411 = validateParameter(valid_603411, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_603411 != nil:
    section.add "Action", valid_603411
  var valid_603412 = query.getOrDefault("Version")
  valid_603412 = validateParameter(valid_603412, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603412 != nil:
    section.add "Version", valid_603412
  var valid_603413 = query.getOrDefault("MaxRecords")
  valid_603413 = validateParameter(valid_603413, JInt, required = false, default = nil)
  if valid_603413 != nil:
    section.add "MaxRecords", valid_603413
  var valid_603414 = query.getOrDefault("TagValues")
  valid_603414 = validateParameter(valid_603414, JArray, required = false,
                                 default = nil)
  if valid_603414 != nil:
    section.add "TagValues", valid_603414
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603415 = header.getOrDefault("X-Amz-Signature")
  valid_603415 = validateParameter(valid_603415, JString, required = false,
                                 default = nil)
  if valid_603415 != nil:
    section.add "X-Amz-Signature", valid_603415
  var valid_603416 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603416 = validateParameter(valid_603416, JString, required = false,
                                 default = nil)
  if valid_603416 != nil:
    section.add "X-Amz-Content-Sha256", valid_603416
  var valid_603417 = header.getOrDefault("X-Amz-Date")
  valid_603417 = validateParameter(valid_603417, JString, required = false,
                                 default = nil)
  if valid_603417 != nil:
    section.add "X-Amz-Date", valid_603417
  var valid_603418 = header.getOrDefault("X-Amz-Credential")
  valid_603418 = validateParameter(valid_603418, JString, required = false,
                                 default = nil)
  if valid_603418 != nil:
    section.add "X-Amz-Credential", valid_603418
  var valid_603419 = header.getOrDefault("X-Amz-Security-Token")
  valid_603419 = validateParameter(valid_603419, JString, required = false,
                                 default = nil)
  if valid_603419 != nil:
    section.add "X-Amz-Security-Token", valid_603419
  var valid_603420 = header.getOrDefault("X-Amz-Algorithm")
  valid_603420 = validateParameter(valid_603420, JString, required = false,
                                 default = nil)
  if valid_603420 != nil:
    section.add "X-Amz-Algorithm", valid_603420
  var valid_603421 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603421 = validateParameter(valid_603421, JString, required = false,
                                 default = nil)
  if valid_603421 != nil:
    section.add "X-Amz-SignedHeaders", valid_603421
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603422: Call_GetDescribeClusterSubnetGroups_603405; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603422.validator(path, query, header, formData, body)
  let scheme = call_603422.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603422.url(scheme.get, call_603422.host, call_603422.base,
                         call_603422.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603422, url, valid)

proc call*(call_603423: Call_GetDescribeClusterSubnetGroups_603405;
          ClusterSubnetGroupName: string = ""; Marker: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeClusterSubnetGroups";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  var query_603424 = newJObject()
  add(query_603424, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_603424, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_603424.add "TagKeys", TagKeys
  add(query_603424, "Action", newJString(Action))
  add(query_603424, "Version", newJString(Version))
  add(query_603424, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_603424.add "TagValues", TagValues
  result = call_603423.call(nil, query_603424, nil, nil, nil)

var getDescribeClusterSubnetGroups* = Call_GetDescribeClusterSubnetGroups_603405(
    name: "getDescribeClusterSubnetGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_GetDescribeClusterSubnetGroups_603406, base: "/",
    url: url_GetDescribeClusterSubnetGroups_603407,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterTracks_603464 = ref object of OpenApiRestCall_601373
proc url_PostDescribeClusterTracks_603466(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterTracks_603465(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603467 = query.getOrDefault("Action")
  valid_603467 = validateParameter(valid_603467, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_603467 != nil:
    section.add "Action", valid_603467
  var valid_603468 = query.getOrDefault("Version")
  valid_603468 = validateParameter(valid_603468, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603468 != nil:
    section.add "Version", valid_603468
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603469 = header.getOrDefault("X-Amz-Signature")
  valid_603469 = validateParameter(valid_603469, JString, required = false,
                                 default = nil)
  if valid_603469 != nil:
    section.add "X-Amz-Signature", valid_603469
  var valid_603470 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603470 = validateParameter(valid_603470, JString, required = false,
                                 default = nil)
  if valid_603470 != nil:
    section.add "X-Amz-Content-Sha256", valid_603470
  var valid_603471 = header.getOrDefault("X-Amz-Date")
  valid_603471 = validateParameter(valid_603471, JString, required = false,
                                 default = nil)
  if valid_603471 != nil:
    section.add "X-Amz-Date", valid_603471
  var valid_603472 = header.getOrDefault("X-Amz-Credential")
  valid_603472 = validateParameter(valid_603472, JString, required = false,
                                 default = nil)
  if valid_603472 != nil:
    section.add "X-Amz-Credential", valid_603472
  var valid_603473 = header.getOrDefault("X-Amz-Security-Token")
  valid_603473 = validateParameter(valid_603473, JString, required = false,
                                 default = nil)
  if valid_603473 != nil:
    section.add "X-Amz-Security-Token", valid_603473
  var valid_603474 = header.getOrDefault("X-Amz-Algorithm")
  valid_603474 = validateParameter(valid_603474, JString, required = false,
                                 default = nil)
  if valid_603474 != nil:
    section.add "X-Amz-Algorithm", valid_603474
  var valid_603475 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603475 = validateParameter(valid_603475, JString, required = false,
                                 default = nil)
  if valid_603475 != nil:
    section.add "X-Amz-SignedHeaders", valid_603475
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_603476 = formData.getOrDefault("MaintenanceTrackName")
  valid_603476 = validateParameter(valid_603476, JString, required = false,
                                 default = nil)
  if valid_603476 != nil:
    section.add "MaintenanceTrackName", valid_603476
  var valid_603477 = formData.getOrDefault("MaxRecords")
  valid_603477 = validateParameter(valid_603477, JInt, required = false, default = nil)
  if valid_603477 != nil:
    section.add "MaxRecords", valid_603477
  var valid_603478 = formData.getOrDefault("Marker")
  valid_603478 = validateParameter(valid_603478, JString, required = false,
                                 default = nil)
  if valid_603478 != nil:
    section.add "Marker", valid_603478
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603479: Call_PostDescribeClusterTracks_603464; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_603479.validator(path, query, header, formData, body)
  let scheme = call_603479.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603479.url(scheme.get, call_603479.host, call_603479.base,
                         call_603479.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603479, url, valid)

proc call*(call_603480: Call_PostDescribeClusterTracks_603464;
          MaintenanceTrackName: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeClusterTracks"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603481 = newJObject()
  var formData_603482 = newJObject()
  add(formData_603482, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_603482, "MaxRecords", newJInt(MaxRecords))
  add(formData_603482, "Marker", newJString(Marker))
  add(query_603481, "Action", newJString(Action))
  add(query_603481, "Version", newJString(Version))
  result = call_603480.call(nil, query_603481, nil, formData_603482, nil)

var postDescribeClusterTracks* = Call_PostDescribeClusterTracks_603464(
    name: "postDescribeClusterTracks", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_PostDescribeClusterTracks_603465, base: "/",
    url: url_PostDescribeClusterTracks_603466,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterTracks_603446 = ref object of OpenApiRestCall_601373
proc url_GetDescribeClusterTracks_603448(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterTracks_603447(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  section = newJObject()
  var valid_603449 = query.getOrDefault("Marker")
  valid_603449 = validateParameter(valid_603449, JString, required = false,
                                 default = nil)
  if valid_603449 != nil:
    section.add "Marker", valid_603449
  var valid_603450 = query.getOrDefault("MaintenanceTrackName")
  valid_603450 = validateParameter(valid_603450, JString, required = false,
                                 default = nil)
  if valid_603450 != nil:
    section.add "MaintenanceTrackName", valid_603450
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603451 = query.getOrDefault("Action")
  valid_603451 = validateParameter(valid_603451, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_603451 != nil:
    section.add "Action", valid_603451
  var valid_603452 = query.getOrDefault("Version")
  valid_603452 = validateParameter(valid_603452, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603452 != nil:
    section.add "Version", valid_603452
  var valid_603453 = query.getOrDefault("MaxRecords")
  valid_603453 = validateParameter(valid_603453, JInt, required = false, default = nil)
  if valid_603453 != nil:
    section.add "MaxRecords", valid_603453
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603454 = header.getOrDefault("X-Amz-Signature")
  valid_603454 = validateParameter(valid_603454, JString, required = false,
                                 default = nil)
  if valid_603454 != nil:
    section.add "X-Amz-Signature", valid_603454
  var valid_603455 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603455 = validateParameter(valid_603455, JString, required = false,
                                 default = nil)
  if valid_603455 != nil:
    section.add "X-Amz-Content-Sha256", valid_603455
  var valid_603456 = header.getOrDefault("X-Amz-Date")
  valid_603456 = validateParameter(valid_603456, JString, required = false,
                                 default = nil)
  if valid_603456 != nil:
    section.add "X-Amz-Date", valid_603456
  var valid_603457 = header.getOrDefault("X-Amz-Credential")
  valid_603457 = validateParameter(valid_603457, JString, required = false,
                                 default = nil)
  if valid_603457 != nil:
    section.add "X-Amz-Credential", valid_603457
  var valid_603458 = header.getOrDefault("X-Amz-Security-Token")
  valid_603458 = validateParameter(valid_603458, JString, required = false,
                                 default = nil)
  if valid_603458 != nil:
    section.add "X-Amz-Security-Token", valid_603458
  var valid_603459 = header.getOrDefault("X-Amz-Algorithm")
  valid_603459 = validateParameter(valid_603459, JString, required = false,
                                 default = nil)
  if valid_603459 != nil:
    section.add "X-Amz-Algorithm", valid_603459
  var valid_603460 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603460 = validateParameter(valid_603460, JString, required = false,
                                 default = nil)
  if valid_603460 != nil:
    section.add "X-Amz-SignedHeaders", valid_603460
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603461: Call_GetDescribeClusterTracks_603446; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_603461.validator(path, query, header, formData, body)
  let scheme = call_603461.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603461.url(scheme.get, call_603461.host, call_603461.base,
                         call_603461.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603461, url, valid)

proc call*(call_603462: Call_GetDescribeClusterTracks_603446; Marker: string = "";
          MaintenanceTrackName: string = "";
          Action: string = "DescribeClusterTracks"; Version: string = "2012-12-01";
          MaxRecords: int = 0): Recallable =
  ## getDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  var query_603463 = newJObject()
  add(query_603463, "Marker", newJString(Marker))
  add(query_603463, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_603463, "Action", newJString(Action))
  add(query_603463, "Version", newJString(Version))
  add(query_603463, "MaxRecords", newJInt(MaxRecords))
  result = call_603462.call(nil, query_603463, nil, nil, nil)

var getDescribeClusterTracks* = Call_GetDescribeClusterTracks_603446(
    name: "getDescribeClusterTracks", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_GetDescribeClusterTracks_603447, base: "/",
    url: url_GetDescribeClusterTracks_603448, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterVersions_603502 = ref object of OpenApiRestCall_601373
proc url_PostDescribeClusterVersions_603504(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterVersions_603503(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603505 = query.getOrDefault("Action")
  valid_603505 = validateParameter(valid_603505, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_603505 != nil:
    section.add "Action", valid_603505
  var valid_603506 = query.getOrDefault("Version")
  valid_603506 = validateParameter(valid_603506, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603506 != nil:
    section.add "Version", valid_603506
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603507 = header.getOrDefault("X-Amz-Signature")
  valid_603507 = validateParameter(valid_603507, JString, required = false,
                                 default = nil)
  if valid_603507 != nil:
    section.add "X-Amz-Signature", valid_603507
  var valid_603508 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603508 = validateParameter(valid_603508, JString, required = false,
                                 default = nil)
  if valid_603508 != nil:
    section.add "X-Amz-Content-Sha256", valid_603508
  var valid_603509 = header.getOrDefault("X-Amz-Date")
  valid_603509 = validateParameter(valid_603509, JString, required = false,
                                 default = nil)
  if valid_603509 != nil:
    section.add "X-Amz-Date", valid_603509
  var valid_603510 = header.getOrDefault("X-Amz-Credential")
  valid_603510 = validateParameter(valid_603510, JString, required = false,
                                 default = nil)
  if valid_603510 != nil:
    section.add "X-Amz-Credential", valid_603510
  var valid_603511 = header.getOrDefault("X-Amz-Security-Token")
  valid_603511 = validateParameter(valid_603511, JString, required = false,
                                 default = nil)
  if valid_603511 != nil:
    section.add "X-Amz-Security-Token", valid_603511
  var valid_603512 = header.getOrDefault("X-Amz-Algorithm")
  valid_603512 = validateParameter(valid_603512, JString, required = false,
                                 default = nil)
  if valid_603512 != nil:
    section.add "X-Amz-Algorithm", valid_603512
  var valid_603513 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603513 = validateParameter(valid_603513, JString, required = false,
                                 default = nil)
  if valid_603513 != nil:
    section.add "X-Amz-SignedHeaders", valid_603513
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  section = newJObject()
  var valid_603514 = formData.getOrDefault("MaxRecords")
  valid_603514 = validateParameter(valid_603514, JInt, required = false, default = nil)
  if valid_603514 != nil:
    section.add "MaxRecords", valid_603514
  var valid_603515 = formData.getOrDefault("ClusterParameterGroupFamily")
  valid_603515 = validateParameter(valid_603515, JString, required = false,
                                 default = nil)
  if valid_603515 != nil:
    section.add "ClusterParameterGroupFamily", valid_603515
  var valid_603516 = formData.getOrDefault("Marker")
  valid_603516 = validateParameter(valid_603516, JString, required = false,
                                 default = nil)
  if valid_603516 != nil:
    section.add "Marker", valid_603516
  var valid_603517 = formData.getOrDefault("ClusterVersion")
  valid_603517 = validateParameter(valid_603517, JString, required = false,
                                 default = nil)
  if valid_603517 != nil:
    section.add "ClusterVersion", valid_603517
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603518: Call_PostDescribeClusterVersions_603502; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_603518.validator(path, query, header, formData, body)
  let scheme = call_603518.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603518.url(scheme.get, call_603518.host, call_603518.base,
                         call_603518.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603518, url, valid)

proc call*(call_603519: Call_PostDescribeClusterVersions_603502;
          MaxRecords: int = 0; ClusterParameterGroupFamily: string = "";
          Marker: string = ""; Action: string = "DescribeClusterVersions";
          ClusterVersion: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  var query_603520 = newJObject()
  var formData_603521 = newJObject()
  add(formData_603521, "MaxRecords", newJInt(MaxRecords))
  add(formData_603521, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(formData_603521, "Marker", newJString(Marker))
  add(query_603520, "Action", newJString(Action))
  add(formData_603521, "ClusterVersion", newJString(ClusterVersion))
  add(query_603520, "Version", newJString(Version))
  result = call_603519.call(nil, query_603520, nil, formData_603521, nil)

var postDescribeClusterVersions* = Call_PostDescribeClusterVersions_603502(
    name: "postDescribeClusterVersions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_PostDescribeClusterVersions_603503, base: "/",
    url: url_PostDescribeClusterVersions_603504,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterVersions_603483 = ref object of OpenApiRestCall_601373
proc url_GetDescribeClusterVersions_603485(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterVersions_603484(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_603486 = query.getOrDefault("Marker")
  valid_603486 = validateParameter(valid_603486, JString, required = false,
                                 default = nil)
  if valid_603486 != nil:
    section.add "Marker", valid_603486
  var valid_603487 = query.getOrDefault("ClusterParameterGroupFamily")
  valid_603487 = validateParameter(valid_603487, JString, required = false,
                                 default = nil)
  if valid_603487 != nil:
    section.add "ClusterParameterGroupFamily", valid_603487
  var valid_603488 = query.getOrDefault("ClusterVersion")
  valid_603488 = validateParameter(valid_603488, JString, required = false,
                                 default = nil)
  if valid_603488 != nil:
    section.add "ClusterVersion", valid_603488
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603489 = query.getOrDefault("Action")
  valid_603489 = validateParameter(valid_603489, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_603489 != nil:
    section.add "Action", valid_603489
  var valid_603490 = query.getOrDefault("Version")
  valid_603490 = validateParameter(valid_603490, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603490 != nil:
    section.add "Version", valid_603490
  var valid_603491 = query.getOrDefault("MaxRecords")
  valid_603491 = validateParameter(valid_603491, JInt, required = false, default = nil)
  if valid_603491 != nil:
    section.add "MaxRecords", valid_603491
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603492 = header.getOrDefault("X-Amz-Signature")
  valid_603492 = validateParameter(valid_603492, JString, required = false,
                                 default = nil)
  if valid_603492 != nil:
    section.add "X-Amz-Signature", valid_603492
  var valid_603493 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603493 = validateParameter(valid_603493, JString, required = false,
                                 default = nil)
  if valid_603493 != nil:
    section.add "X-Amz-Content-Sha256", valid_603493
  var valid_603494 = header.getOrDefault("X-Amz-Date")
  valid_603494 = validateParameter(valid_603494, JString, required = false,
                                 default = nil)
  if valid_603494 != nil:
    section.add "X-Amz-Date", valid_603494
  var valid_603495 = header.getOrDefault("X-Amz-Credential")
  valid_603495 = validateParameter(valid_603495, JString, required = false,
                                 default = nil)
  if valid_603495 != nil:
    section.add "X-Amz-Credential", valid_603495
  var valid_603496 = header.getOrDefault("X-Amz-Security-Token")
  valid_603496 = validateParameter(valid_603496, JString, required = false,
                                 default = nil)
  if valid_603496 != nil:
    section.add "X-Amz-Security-Token", valid_603496
  var valid_603497 = header.getOrDefault("X-Amz-Algorithm")
  valid_603497 = validateParameter(valid_603497, JString, required = false,
                                 default = nil)
  if valid_603497 != nil:
    section.add "X-Amz-Algorithm", valid_603497
  var valid_603498 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603498 = validateParameter(valid_603498, JString, required = false,
                                 default = nil)
  if valid_603498 != nil:
    section.add "X-Amz-SignedHeaders", valid_603498
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603499: Call_GetDescribeClusterVersions_603483; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_603499.validator(path, query, header, formData, body)
  let scheme = call_603499.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603499.url(scheme.get, call_603499.host, call_603499.base,
                         call_603499.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603499, url, valid)

proc call*(call_603500: Call_GetDescribeClusterVersions_603483;
          Marker: string = ""; ClusterParameterGroupFamily: string = "";
          ClusterVersion: string = ""; Action: string = "DescribeClusterVersions";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_603501 = newJObject()
  add(query_603501, "Marker", newJString(Marker))
  add(query_603501, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(query_603501, "ClusterVersion", newJString(ClusterVersion))
  add(query_603501, "Action", newJString(Action))
  add(query_603501, "Version", newJString(Version))
  add(query_603501, "MaxRecords", newJInt(MaxRecords))
  result = call_603500.call(nil, query_603501, nil, nil, nil)

var getDescribeClusterVersions* = Call_GetDescribeClusterVersions_603483(
    name: "getDescribeClusterVersions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_GetDescribeClusterVersions_603484, base: "/",
    url: url_GetDescribeClusterVersions_603485,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusters_603542 = ref object of OpenApiRestCall_601373
proc url_PostDescribeClusters_603544(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusters_603543(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603545 = query.getOrDefault("Action")
  valid_603545 = validateParameter(valid_603545, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_603545 != nil:
    section.add "Action", valid_603545
  var valid_603546 = query.getOrDefault("Version")
  valid_603546 = validateParameter(valid_603546, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603546 != nil:
    section.add "Version", valid_603546
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603547 = header.getOrDefault("X-Amz-Signature")
  valid_603547 = validateParameter(valid_603547, JString, required = false,
                                 default = nil)
  if valid_603547 != nil:
    section.add "X-Amz-Signature", valid_603547
  var valid_603548 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603548 = validateParameter(valid_603548, JString, required = false,
                                 default = nil)
  if valid_603548 != nil:
    section.add "X-Amz-Content-Sha256", valid_603548
  var valid_603549 = header.getOrDefault("X-Amz-Date")
  valid_603549 = validateParameter(valid_603549, JString, required = false,
                                 default = nil)
  if valid_603549 != nil:
    section.add "X-Amz-Date", valid_603549
  var valid_603550 = header.getOrDefault("X-Amz-Credential")
  valid_603550 = validateParameter(valid_603550, JString, required = false,
                                 default = nil)
  if valid_603550 != nil:
    section.add "X-Amz-Credential", valid_603550
  var valid_603551 = header.getOrDefault("X-Amz-Security-Token")
  valid_603551 = validateParameter(valid_603551, JString, required = false,
                                 default = nil)
  if valid_603551 != nil:
    section.add "X-Amz-Security-Token", valid_603551
  var valid_603552 = header.getOrDefault("X-Amz-Algorithm")
  valid_603552 = validateParameter(valid_603552, JString, required = false,
                                 default = nil)
  if valid_603552 != nil:
    section.add "X-Amz-Algorithm", valid_603552
  var valid_603553 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603553 = validateParameter(valid_603553, JString, required = false,
                                 default = nil)
  if valid_603553 != nil:
    section.add "X-Amz-SignedHeaders", valid_603553
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603554 = formData.getOrDefault("TagKeys")
  valid_603554 = validateParameter(valid_603554, JArray, required = false,
                                 default = nil)
  if valid_603554 != nil:
    section.add "TagKeys", valid_603554
  var valid_603555 = formData.getOrDefault("ClusterIdentifier")
  valid_603555 = validateParameter(valid_603555, JString, required = false,
                                 default = nil)
  if valid_603555 != nil:
    section.add "ClusterIdentifier", valid_603555
  var valid_603556 = formData.getOrDefault("MaxRecords")
  valid_603556 = validateParameter(valid_603556, JInt, required = false, default = nil)
  if valid_603556 != nil:
    section.add "MaxRecords", valid_603556
  var valid_603557 = formData.getOrDefault("Marker")
  valid_603557 = validateParameter(valid_603557, JString, required = false,
                                 default = nil)
  if valid_603557 != nil:
    section.add "Marker", valid_603557
  var valid_603558 = formData.getOrDefault("TagValues")
  valid_603558 = validateParameter(valid_603558, JArray, required = false,
                                 default = nil)
  if valid_603558 != nil:
    section.add "TagValues", valid_603558
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603559: Call_PostDescribeClusters_603542; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603559.validator(path, query, header, formData, body)
  let scheme = call_603559.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603559.url(scheme.get, call_603559.host, call_603559.base,
                         call_603559.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603559, url, valid)

proc call*(call_603560: Call_PostDescribeClusters_603542; TagKeys: JsonNode = nil;
          ClusterIdentifier: string = ""; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeClusters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603561 = newJObject()
  var formData_603562 = newJObject()
  if TagKeys != nil:
    formData_603562.add "TagKeys", TagKeys
  add(formData_603562, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_603562, "MaxRecords", newJInt(MaxRecords))
  add(formData_603562, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_603562.add "TagValues", TagValues
  add(query_603561, "Action", newJString(Action))
  add(query_603561, "Version", newJString(Version))
  result = call_603560.call(nil, query_603561, nil, formData_603562, nil)

var postDescribeClusters* = Call_PostDescribeClusters_603542(
    name: "postDescribeClusters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_PostDescribeClusters_603543, base: "/",
    url: url_PostDescribeClusters_603544, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusters_603522 = ref object of OpenApiRestCall_601373
proc url_GetDescribeClusters_603524(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusters_603523(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603525 = query.getOrDefault("Marker")
  valid_603525 = validateParameter(valid_603525, JString, required = false,
                                 default = nil)
  if valid_603525 != nil:
    section.add "Marker", valid_603525
  var valid_603526 = query.getOrDefault("TagKeys")
  valid_603526 = validateParameter(valid_603526, JArray, required = false,
                                 default = nil)
  if valid_603526 != nil:
    section.add "TagKeys", valid_603526
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603527 = query.getOrDefault("Action")
  valid_603527 = validateParameter(valid_603527, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_603527 != nil:
    section.add "Action", valid_603527
  var valid_603528 = query.getOrDefault("ClusterIdentifier")
  valid_603528 = validateParameter(valid_603528, JString, required = false,
                                 default = nil)
  if valid_603528 != nil:
    section.add "ClusterIdentifier", valid_603528
  var valid_603529 = query.getOrDefault("Version")
  valid_603529 = validateParameter(valid_603529, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603529 != nil:
    section.add "Version", valid_603529
  var valid_603530 = query.getOrDefault("MaxRecords")
  valid_603530 = validateParameter(valid_603530, JInt, required = false, default = nil)
  if valid_603530 != nil:
    section.add "MaxRecords", valid_603530
  var valid_603531 = query.getOrDefault("TagValues")
  valid_603531 = validateParameter(valid_603531, JArray, required = false,
                                 default = nil)
  if valid_603531 != nil:
    section.add "TagValues", valid_603531
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603532 = header.getOrDefault("X-Amz-Signature")
  valid_603532 = validateParameter(valid_603532, JString, required = false,
                                 default = nil)
  if valid_603532 != nil:
    section.add "X-Amz-Signature", valid_603532
  var valid_603533 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603533 = validateParameter(valid_603533, JString, required = false,
                                 default = nil)
  if valid_603533 != nil:
    section.add "X-Amz-Content-Sha256", valid_603533
  var valid_603534 = header.getOrDefault("X-Amz-Date")
  valid_603534 = validateParameter(valid_603534, JString, required = false,
                                 default = nil)
  if valid_603534 != nil:
    section.add "X-Amz-Date", valid_603534
  var valid_603535 = header.getOrDefault("X-Amz-Credential")
  valid_603535 = validateParameter(valid_603535, JString, required = false,
                                 default = nil)
  if valid_603535 != nil:
    section.add "X-Amz-Credential", valid_603535
  var valid_603536 = header.getOrDefault("X-Amz-Security-Token")
  valid_603536 = validateParameter(valid_603536, JString, required = false,
                                 default = nil)
  if valid_603536 != nil:
    section.add "X-Amz-Security-Token", valid_603536
  var valid_603537 = header.getOrDefault("X-Amz-Algorithm")
  valid_603537 = validateParameter(valid_603537, JString, required = false,
                                 default = nil)
  if valid_603537 != nil:
    section.add "X-Amz-Algorithm", valid_603537
  var valid_603538 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603538 = validateParameter(valid_603538, JString, required = false,
                                 default = nil)
  if valid_603538 != nil:
    section.add "X-Amz-SignedHeaders", valid_603538
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603539: Call_GetDescribeClusters_603522; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603539.validator(path, query, header, formData, body)
  let scheme = call_603539.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603539.url(scheme.get, call_603539.host, call_603539.base,
                         call_603539.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603539, url, valid)

proc call*(call_603540: Call_GetDescribeClusters_603522; Marker: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeClusters";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  var query_603541 = newJObject()
  add(query_603541, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_603541.add "TagKeys", TagKeys
  add(query_603541, "Action", newJString(Action))
  add(query_603541, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603541, "Version", newJString(Version))
  add(query_603541, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_603541.add "TagValues", TagValues
  result = call_603540.call(nil, query_603541, nil, nil, nil)

var getDescribeClusters* = Call_GetDescribeClusters_603522(
    name: "getDescribeClusters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_GetDescribeClusters_603523, base: "/",
    url: url_GetDescribeClusters_603524, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeDefaultClusterParameters_603581 = ref object of OpenApiRestCall_601373
proc url_PostDescribeDefaultClusterParameters_603583(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeDefaultClusterParameters_603582(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603584 = query.getOrDefault("Action")
  valid_603584 = validateParameter(valid_603584, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_603584 != nil:
    section.add "Action", valid_603584
  var valid_603585 = query.getOrDefault("Version")
  valid_603585 = validateParameter(valid_603585, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603585 != nil:
    section.add "Version", valid_603585
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603586 = header.getOrDefault("X-Amz-Signature")
  valid_603586 = validateParameter(valid_603586, JString, required = false,
                                 default = nil)
  if valid_603586 != nil:
    section.add "X-Amz-Signature", valid_603586
  var valid_603587 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603587 = validateParameter(valid_603587, JString, required = false,
                                 default = nil)
  if valid_603587 != nil:
    section.add "X-Amz-Content-Sha256", valid_603587
  var valid_603588 = header.getOrDefault("X-Amz-Date")
  valid_603588 = validateParameter(valid_603588, JString, required = false,
                                 default = nil)
  if valid_603588 != nil:
    section.add "X-Amz-Date", valid_603588
  var valid_603589 = header.getOrDefault("X-Amz-Credential")
  valid_603589 = validateParameter(valid_603589, JString, required = false,
                                 default = nil)
  if valid_603589 != nil:
    section.add "X-Amz-Credential", valid_603589
  var valid_603590 = header.getOrDefault("X-Amz-Security-Token")
  valid_603590 = validateParameter(valid_603590, JString, required = false,
                                 default = nil)
  if valid_603590 != nil:
    section.add "X-Amz-Security-Token", valid_603590
  var valid_603591 = header.getOrDefault("X-Amz-Algorithm")
  valid_603591 = validateParameter(valid_603591, JString, required = false,
                                 default = nil)
  if valid_603591 != nil:
    section.add "X-Amz-Algorithm", valid_603591
  var valid_603592 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603592 = validateParameter(valid_603592, JString, required = false,
                                 default = nil)
  if valid_603592 != nil:
    section.add "X-Amz-SignedHeaders", valid_603592
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  section = newJObject()
  var valid_603593 = formData.getOrDefault("MaxRecords")
  valid_603593 = validateParameter(valid_603593, JInt, required = false, default = nil)
  if valid_603593 != nil:
    section.add "MaxRecords", valid_603593
  var valid_603594 = formData.getOrDefault("Marker")
  valid_603594 = validateParameter(valid_603594, JString, required = false,
                                 default = nil)
  if valid_603594 != nil:
    section.add "Marker", valid_603594
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupFamily` field"
  var valid_603595 = formData.getOrDefault("ParameterGroupFamily")
  valid_603595 = validateParameter(valid_603595, JString, required = true,
                                 default = nil)
  if valid_603595 != nil:
    section.add "ParameterGroupFamily", valid_603595
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603596: Call_PostDescribeDefaultClusterParameters_603581;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603596.validator(path, query, header, formData, body)
  let scheme = call_603596.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603596.url(scheme.get, call_603596.host, call_603596.base,
                         call_603596.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603596, url, valid)

proc call*(call_603597: Call_PostDescribeDefaultClusterParameters_603581;
          ParameterGroupFamily: string; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603598 = newJObject()
  var formData_603599 = newJObject()
  add(formData_603599, "MaxRecords", newJInt(MaxRecords))
  add(formData_603599, "Marker", newJString(Marker))
  add(formData_603599, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_603598, "Action", newJString(Action))
  add(query_603598, "Version", newJString(Version))
  result = call_603597.call(nil, query_603598, nil, formData_603599, nil)

var postDescribeDefaultClusterParameters* = Call_PostDescribeDefaultClusterParameters_603581(
    name: "postDescribeDefaultClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_PostDescribeDefaultClusterParameters_603582, base: "/",
    url: url_PostDescribeDefaultClusterParameters_603583,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeDefaultClusterParameters_603563 = ref object of OpenApiRestCall_601373
proc url_GetDescribeDefaultClusterParameters_603565(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeDefaultClusterParameters_603564(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_603566 = query.getOrDefault("Marker")
  valid_603566 = validateParameter(valid_603566, JString, required = false,
                                 default = nil)
  if valid_603566 != nil:
    section.add "Marker", valid_603566
  assert query != nil, "query argument is necessary due to required `ParameterGroupFamily` field"
  var valid_603567 = query.getOrDefault("ParameterGroupFamily")
  valid_603567 = validateParameter(valid_603567, JString, required = true,
                                 default = nil)
  if valid_603567 != nil:
    section.add "ParameterGroupFamily", valid_603567
  var valid_603568 = query.getOrDefault("Action")
  valid_603568 = validateParameter(valid_603568, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_603568 != nil:
    section.add "Action", valid_603568
  var valid_603569 = query.getOrDefault("Version")
  valid_603569 = validateParameter(valid_603569, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603569 != nil:
    section.add "Version", valid_603569
  var valid_603570 = query.getOrDefault("MaxRecords")
  valid_603570 = validateParameter(valid_603570, JInt, required = false, default = nil)
  if valid_603570 != nil:
    section.add "MaxRecords", valid_603570
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603571 = header.getOrDefault("X-Amz-Signature")
  valid_603571 = validateParameter(valid_603571, JString, required = false,
                                 default = nil)
  if valid_603571 != nil:
    section.add "X-Amz-Signature", valid_603571
  var valid_603572 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603572 = validateParameter(valid_603572, JString, required = false,
                                 default = nil)
  if valid_603572 != nil:
    section.add "X-Amz-Content-Sha256", valid_603572
  var valid_603573 = header.getOrDefault("X-Amz-Date")
  valid_603573 = validateParameter(valid_603573, JString, required = false,
                                 default = nil)
  if valid_603573 != nil:
    section.add "X-Amz-Date", valid_603573
  var valid_603574 = header.getOrDefault("X-Amz-Credential")
  valid_603574 = validateParameter(valid_603574, JString, required = false,
                                 default = nil)
  if valid_603574 != nil:
    section.add "X-Amz-Credential", valid_603574
  var valid_603575 = header.getOrDefault("X-Amz-Security-Token")
  valid_603575 = validateParameter(valid_603575, JString, required = false,
                                 default = nil)
  if valid_603575 != nil:
    section.add "X-Amz-Security-Token", valid_603575
  var valid_603576 = header.getOrDefault("X-Amz-Algorithm")
  valid_603576 = validateParameter(valid_603576, JString, required = false,
                                 default = nil)
  if valid_603576 != nil:
    section.add "X-Amz-Algorithm", valid_603576
  var valid_603577 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603577 = validateParameter(valid_603577, JString, required = false,
                                 default = nil)
  if valid_603577 != nil:
    section.add "X-Amz-SignedHeaders", valid_603577
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603578: Call_GetDescribeDefaultClusterParameters_603563;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603578.validator(path, query, header, formData, body)
  let scheme = call_603578.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603578.url(scheme.get, call_603578.host, call_603578.base,
                         call_603578.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603578, url, valid)

proc call*(call_603579: Call_GetDescribeDefaultClusterParameters_603563;
          ParameterGroupFamily: string; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_603580 = newJObject()
  add(query_603580, "Marker", newJString(Marker))
  add(query_603580, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_603580, "Action", newJString(Action))
  add(query_603580, "Version", newJString(Version))
  add(query_603580, "MaxRecords", newJInt(MaxRecords))
  result = call_603579.call(nil, query_603580, nil, nil, nil)

var getDescribeDefaultClusterParameters* = Call_GetDescribeDefaultClusterParameters_603563(
    name: "getDescribeDefaultClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_GetDescribeDefaultClusterParameters_603564, base: "/",
    url: url_GetDescribeDefaultClusterParameters_603565,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventCategories_603616 = ref object of OpenApiRestCall_601373
proc url_PostDescribeEventCategories_603618(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventCategories_603617(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603619 = query.getOrDefault("Action")
  valid_603619 = validateParameter(valid_603619, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_603619 != nil:
    section.add "Action", valid_603619
  var valid_603620 = query.getOrDefault("Version")
  valid_603620 = validateParameter(valid_603620, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603620 != nil:
    section.add "Version", valid_603620
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603621 = header.getOrDefault("X-Amz-Signature")
  valid_603621 = validateParameter(valid_603621, JString, required = false,
                                 default = nil)
  if valid_603621 != nil:
    section.add "X-Amz-Signature", valid_603621
  var valid_603622 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603622 = validateParameter(valid_603622, JString, required = false,
                                 default = nil)
  if valid_603622 != nil:
    section.add "X-Amz-Content-Sha256", valid_603622
  var valid_603623 = header.getOrDefault("X-Amz-Date")
  valid_603623 = validateParameter(valid_603623, JString, required = false,
                                 default = nil)
  if valid_603623 != nil:
    section.add "X-Amz-Date", valid_603623
  var valid_603624 = header.getOrDefault("X-Amz-Credential")
  valid_603624 = validateParameter(valid_603624, JString, required = false,
                                 default = nil)
  if valid_603624 != nil:
    section.add "X-Amz-Credential", valid_603624
  var valid_603625 = header.getOrDefault("X-Amz-Security-Token")
  valid_603625 = validateParameter(valid_603625, JString, required = false,
                                 default = nil)
  if valid_603625 != nil:
    section.add "X-Amz-Security-Token", valid_603625
  var valid_603626 = header.getOrDefault("X-Amz-Algorithm")
  valid_603626 = validateParameter(valid_603626, JString, required = false,
                                 default = nil)
  if valid_603626 != nil:
    section.add "X-Amz-Algorithm", valid_603626
  var valid_603627 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603627 = validateParameter(valid_603627, JString, required = false,
                                 default = nil)
  if valid_603627 != nil:
    section.add "X-Amz-SignedHeaders", valid_603627
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  section = newJObject()
  var valid_603628 = formData.getOrDefault("SourceType")
  valid_603628 = validateParameter(valid_603628, JString, required = false,
                                 default = nil)
  if valid_603628 != nil:
    section.add "SourceType", valid_603628
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603629: Call_PostDescribeEventCategories_603616; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_603629.validator(path, query, header, formData, body)
  let scheme = call_603629.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603629.url(scheme.get, call_603629.host, call_603629.base,
                         call_603629.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603629, url, valid)

proc call*(call_603630: Call_PostDescribeEventCategories_603616;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603631 = newJObject()
  var formData_603632 = newJObject()
  add(formData_603632, "SourceType", newJString(SourceType))
  add(query_603631, "Action", newJString(Action))
  add(query_603631, "Version", newJString(Version))
  result = call_603630.call(nil, query_603631, nil, formData_603632, nil)

var postDescribeEventCategories* = Call_PostDescribeEventCategories_603616(
    name: "postDescribeEventCategories", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_PostDescribeEventCategories_603617, base: "/",
    url: url_PostDescribeEventCategories_603618,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventCategories_603600 = ref object of OpenApiRestCall_601373
proc url_GetDescribeEventCategories_603602(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventCategories_603601(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_603603 = query.getOrDefault("SourceType")
  valid_603603 = validateParameter(valid_603603, JString, required = false,
                                 default = nil)
  if valid_603603 != nil:
    section.add "SourceType", valid_603603
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603604 = query.getOrDefault("Action")
  valid_603604 = validateParameter(valid_603604, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_603604 != nil:
    section.add "Action", valid_603604
  var valid_603605 = query.getOrDefault("Version")
  valid_603605 = validateParameter(valid_603605, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603605 != nil:
    section.add "Version", valid_603605
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603606 = header.getOrDefault("X-Amz-Signature")
  valid_603606 = validateParameter(valid_603606, JString, required = false,
                                 default = nil)
  if valid_603606 != nil:
    section.add "X-Amz-Signature", valid_603606
  var valid_603607 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603607 = validateParameter(valid_603607, JString, required = false,
                                 default = nil)
  if valid_603607 != nil:
    section.add "X-Amz-Content-Sha256", valid_603607
  var valid_603608 = header.getOrDefault("X-Amz-Date")
  valid_603608 = validateParameter(valid_603608, JString, required = false,
                                 default = nil)
  if valid_603608 != nil:
    section.add "X-Amz-Date", valid_603608
  var valid_603609 = header.getOrDefault("X-Amz-Credential")
  valid_603609 = validateParameter(valid_603609, JString, required = false,
                                 default = nil)
  if valid_603609 != nil:
    section.add "X-Amz-Credential", valid_603609
  var valid_603610 = header.getOrDefault("X-Amz-Security-Token")
  valid_603610 = validateParameter(valid_603610, JString, required = false,
                                 default = nil)
  if valid_603610 != nil:
    section.add "X-Amz-Security-Token", valid_603610
  var valid_603611 = header.getOrDefault("X-Amz-Algorithm")
  valid_603611 = validateParameter(valid_603611, JString, required = false,
                                 default = nil)
  if valid_603611 != nil:
    section.add "X-Amz-Algorithm", valid_603611
  var valid_603612 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603612 = validateParameter(valid_603612, JString, required = false,
                                 default = nil)
  if valid_603612 != nil:
    section.add "X-Amz-SignedHeaders", valid_603612
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603613: Call_GetDescribeEventCategories_603600; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_603613.validator(path, query, header, formData, body)
  let scheme = call_603613.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603613.url(scheme.get, call_603613.host, call_603613.base,
                         call_603613.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603613, url, valid)

proc call*(call_603614: Call_GetDescribeEventCategories_603600;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603615 = newJObject()
  add(query_603615, "SourceType", newJString(SourceType))
  add(query_603615, "Action", newJString(Action))
  add(query_603615, "Version", newJString(Version))
  result = call_603614.call(nil, query_603615, nil, nil, nil)

var getDescribeEventCategories* = Call_GetDescribeEventCategories_603600(
    name: "getDescribeEventCategories", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_GetDescribeEventCategories_603601, base: "/",
    url: url_GetDescribeEventCategories_603602,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventSubscriptions_603653 = ref object of OpenApiRestCall_601373
proc url_PostDescribeEventSubscriptions_603655(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventSubscriptions_603654(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603656 = query.getOrDefault("Action")
  valid_603656 = validateParameter(valid_603656, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_603656 != nil:
    section.add "Action", valid_603656
  var valid_603657 = query.getOrDefault("Version")
  valid_603657 = validateParameter(valid_603657, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603657 != nil:
    section.add "Version", valid_603657
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603658 = header.getOrDefault("X-Amz-Signature")
  valid_603658 = validateParameter(valid_603658, JString, required = false,
                                 default = nil)
  if valid_603658 != nil:
    section.add "X-Amz-Signature", valid_603658
  var valid_603659 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603659 = validateParameter(valid_603659, JString, required = false,
                                 default = nil)
  if valid_603659 != nil:
    section.add "X-Amz-Content-Sha256", valid_603659
  var valid_603660 = header.getOrDefault("X-Amz-Date")
  valid_603660 = validateParameter(valid_603660, JString, required = false,
                                 default = nil)
  if valid_603660 != nil:
    section.add "X-Amz-Date", valid_603660
  var valid_603661 = header.getOrDefault("X-Amz-Credential")
  valid_603661 = validateParameter(valid_603661, JString, required = false,
                                 default = nil)
  if valid_603661 != nil:
    section.add "X-Amz-Credential", valid_603661
  var valid_603662 = header.getOrDefault("X-Amz-Security-Token")
  valid_603662 = validateParameter(valid_603662, JString, required = false,
                                 default = nil)
  if valid_603662 != nil:
    section.add "X-Amz-Security-Token", valid_603662
  var valid_603663 = header.getOrDefault("X-Amz-Algorithm")
  valid_603663 = validateParameter(valid_603663, JString, required = false,
                                 default = nil)
  if valid_603663 != nil:
    section.add "X-Amz-Algorithm", valid_603663
  var valid_603664 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603664 = validateParameter(valid_603664, JString, required = false,
                                 default = nil)
  if valid_603664 != nil:
    section.add "X-Amz-SignedHeaders", valid_603664
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603665 = formData.getOrDefault("TagKeys")
  valid_603665 = validateParameter(valid_603665, JArray, required = false,
                                 default = nil)
  if valid_603665 != nil:
    section.add "TagKeys", valid_603665
  var valid_603666 = formData.getOrDefault("MaxRecords")
  valid_603666 = validateParameter(valid_603666, JInt, required = false, default = nil)
  if valid_603666 != nil:
    section.add "MaxRecords", valid_603666
  var valid_603667 = formData.getOrDefault("Marker")
  valid_603667 = validateParameter(valid_603667, JString, required = false,
                                 default = nil)
  if valid_603667 != nil:
    section.add "Marker", valid_603667
  var valid_603668 = formData.getOrDefault("SubscriptionName")
  valid_603668 = validateParameter(valid_603668, JString, required = false,
                                 default = nil)
  if valid_603668 != nil:
    section.add "SubscriptionName", valid_603668
  var valid_603669 = formData.getOrDefault("TagValues")
  valid_603669 = validateParameter(valid_603669, JArray, required = false,
                                 default = nil)
  if valid_603669 != nil:
    section.add "TagValues", valid_603669
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603670: Call_PostDescribeEventSubscriptions_603653; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603670.validator(path, query, header, formData, body)
  let scheme = call_603670.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603670.url(scheme.get, call_603670.host, call_603670.base,
                         call_603670.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603670, url, valid)

proc call*(call_603671: Call_PostDescribeEventSubscriptions_603653;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          SubscriptionName: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeEventSubscriptions";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603672 = newJObject()
  var formData_603673 = newJObject()
  if TagKeys != nil:
    formData_603673.add "TagKeys", TagKeys
  add(formData_603673, "MaxRecords", newJInt(MaxRecords))
  add(formData_603673, "Marker", newJString(Marker))
  add(formData_603673, "SubscriptionName", newJString(SubscriptionName))
  if TagValues != nil:
    formData_603673.add "TagValues", TagValues
  add(query_603672, "Action", newJString(Action))
  add(query_603672, "Version", newJString(Version))
  result = call_603671.call(nil, query_603672, nil, formData_603673, nil)

var postDescribeEventSubscriptions* = Call_PostDescribeEventSubscriptions_603653(
    name: "postDescribeEventSubscriptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_PostDescribeEventSubscriptions_603654, base: "/",
    url: url_PostDescribeEventSubscriptions_603655,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventSubscriptions_603633 = ref object of OpenApiRestCall_601373
proc url_GetDescribeEventSubscriptions_603635(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventSubscriptions_603634(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603636 = query.getOrDefault("Marker")
  valid_603636 = validateParameter(valid_603636, JString, required = false,
                                 default = nil)
  if valid_603636 != nil:
    section.add "Marker", valid_603636
  var valid_603637 = query.getOrDefault("TagKeys")
  valid_603637 = validateParameter(valid_603637, JArray, required = false,
                                 default = nil)
  if valid_603637 != nil:
    section.add "TagKeys", valid_603637
  var valid_603638 = query.getOrDefault("SubscriptionName")
  valid_603638 = validateParameter(valid_603638, JString, required = false,
                                 default = nil)
  if valid_603638 != nil:
    section.add "SubscriptionName", valid_603638
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603639 = query.getOrDefault("Action")
  valid_603639 = validateParameter(valid_603639, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_603639 != nil:
    section.add "Action", valid_603639
  var valid_603640 = query.getOrDefault("Version")
  valid_603640 = validateParameter(valid_603640, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603640 != nil:
    section.add "Version", valid_603640
  var valid_603641 = query.getOrDefault("MaxRecords")
  valid_603641 = validateParameter(valid_603641, JInt, required = false, default = nil)
  if valid_603641 != nil:
    section.add "MaxRecords", valid_603641
  var valid_603642 = query.getOrDefault("TagValues")
  valid_603642 = validateParameter(valid_603642, JArray, required = false,
                                 default = nil)
  if valid_603642 != nil:
    section.add "TagValues", valid_603642
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603643 = header.getOrDefault("X-Amz-Signature")
  valid_603643 = validateParameter(valid_603643, JString, required = false,
                                 default = nil)
  if valid_603643 != nil:
    section.add "X-Amz-Signature", valid_603643
  var valid_603644 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603644 = validateParameter(valid_603644, JString, required = false,
                                 default = nil)
  if valid_603644 != nil:
    section.add "X-Amz-Content-Sha256", valid_603644
  var valid_603645 = header.getOrDefault("X-Amz-Date")
  valid_603645 = validateParameter(valid_603645, JString, required = false,
                                 default = nil)
  if valid_603645 != nil:
    section.add "X-Amz-Date", valid_603645
  var valid_603646 = header.getOrDefault("X-Amz-Credential")
  valid_603646 = validateParameter(valid_603646, JString, required = false,
                                 default = nil)
  if valid_603646 != nil:
    section.add "X-Amz-Credential", valid_603646
  var valid_603647 = header.getOrDefault("X-Amz-Security-Token")
  valid_603647 = validateParameter(valid_603647, JString, required = false,
                                 default = nil)
  if valid_603647 != nil:
    section.add "X-Amz-Security-Token", valid_603647
  var valid_603648 = header.getOrDefault("X-Amz-Algorithm")
  valid_603648 = validateParameter(valid_603648, JString, required = false,
                                 default = nil)
  if valid_603648 != nil:
    section.add "X-Amz-Algorithm", valid_603648
  var valid_603649 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603649 = validateParameter(valid_603649, JString, required = false,
                                 default = nil)
  if valid_603649 != nil:
    section.add "X-Amz-SignedHeaders", valid_603649
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603650: Call_GetDescribeEventSubscriptions_603633; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603650.validator(path, query, header, formData, body)
  let scheme = call_603650.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603650.url(scheme.get, call_603650.host, call_603650.base,
                         call_603650.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603650, url, valid)

proc call*(call_603651: Call_GetDescribeEventSubscriptions_603633;
          Marker: string = ""; TagKeys: JsonNode = nil; SubscriptionName: string = "";
          Action: string = "DescribeEventSubscriptions";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  var query_603652 = newJObject()
  add(query_603652, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_603652.add "TagKeys", TagKeys
  add(query_603652, "SubscriptionName", newJString(SubscriptionName))
  add(query_603652, "Action", newJString(Action))
  add(query_603652, "Version", newJString(Version))
  add(query_603652, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_603652.add "TagValues", TagValues
  result = call_603651.call(nil, query_603652, nil, nil, nil)

var getDescribeEventSubscriptions* = Call_GetDescribeEventSubscriptions_603633(
    name: "getDescribeEventSubscriptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_GetDescribeEventSubscriptions_603634, base: "/",
    url: url_GetDescribeEventSubscriptions_603635,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEvents_603696 = ref object of OpenApiRestCall_601373
proc url_PostDescribeEvents_603698(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEvents_603697(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603699 = query.getOrDefault("Action")
  valid_603699 = validateParameter(valid_603699, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_603699 != nil:
    section.add "Action", valid_603699
  var valid_603700 = query.getOrDefault("Version")
  valid_603700 = validateParameter(valid_603700, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603700 != nil:
    section.add "Version", valid_603700
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603701 = header.getOrDefault("X-Amz-Signature")
  valid_603701 = validateParameter(valid_603701, JString, required = false,
                                 default = nil)
  if valid_603701 != nil:
    section.add "X-Amz-Signature", valid_603701
  var valid_603702 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603702 = validateParameter(valid_603702, JString, required = false,
                                 default = nil)
  if valid_603702 != nil:
    section.add "X-Amz-Content-Sha256", valid_603702
  var valid_603703 = header.getOrDefault("X-Amz-Date")
  valid_603703 = validateParameter(valid_603703, JString, required = false,
                                 default = nil)
  if valid_603703 != nil:
    section.add "X-Amz-Date", valid_603703
  var valid_603704 = header.getOrDefault("X-Amz-Credential")
  valid_603704 = validateParameter(valid_603704, JString, required = false,
                                 default = nil)
  if valid_603704 != nil:
    section.add "X-Amz-Credential", valid_603704
  var valid_603705 = header.getOrDefault("X-Amz-Security-Token")
  valid_603705 = validateParameter(valid_603705, JString, required = false,
                                 default = nil)
  if valid_603705 != nil:
    section.add "X-Amz-Security-Token", valid_603705
  var valid_603706 = header.getOrDefault("X-Amz-Algorithm")
  valid_603706 = validateParameter(valid_603706, JString, required = false,
                                 default = nil)
  if valid_603706 != nil:
    section.add "X-Amz-Algorithm", valid_603706
  var valid_603707 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603707 = validateParameter(valid_603707, JString, required = false,
                                 default = nil)
  if valid_603707 != nil:
    section.add "X-Amz-SignedHeaders", valid_603707
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  section = newJObject()
  var valid_603708 = formData.getOrDefault("MaxRecords")
  valid_603708 = validateParameter(valid_603708, JInt, required = false, default = nil)
  if valid_603708 != nil:
    section.add "MaxRecords", valid_603708
  var valid_603709 = formData.getOrDefault("Marker")
  valid_603709 = validateParameter(valid_603709, JString, required = false,
                                 default = nil)
  if valid_603709 != nil:
    section.add "Marker", valid_603709
  var valid_603710 = formData.getOrDefault("SourceIdentifier")
  valid_603710 = validateParameter(valid_603710, JString, required = false,
                                 default = nil)
  if valid_603710 != nil:
    section.add "SourceIdentifier", valid_603710
  var valid_603711 = formData.getOrDefault("SourceType")
  valid_603711 = validateParameter(valid_603711, JString, required = false,
                                 default = newJString("cluster"))
  if valid_603711 != nil:
    section.add "SourceType", valid_603711
  var valid_603712 = formData.getOrDefault("Duration")
  valid_603712 = validateParameter(valid_603712, JInt, required = false, default = nil)
  if valid_603712 != nil:
    section.add "Duration", valid_603712
  var valid_603713 = formData.getOrDefault("EndTime")
  valid_603713 = validateParameter(valid_603713, JString, required = false,
                                 default = nil)
  if valid_603713 != nil:
    section.add "EndTime", valid_603713
  var valid_603714 = formData.getOrDefault("StartTime")
  valid_603714 = validateParameter(valid_603714, JString, required = false,
                                 default = nil)
  if valid_603714 != nil:
    section.add "StartTime", valid_603714
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603715: Call_PostDescribeEvents_603696; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_603715.validator(path, query, header, formData, body)
  let scheme = call_603715.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603715.url(scheme.get, call_603715.host, call_603715.base,
                         call_603715.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603715, url, valid)

proc call*(call_603716: Call_PostDescribeEvents_603696; MaxRecords: int = 0;
          Marker: string = ""; SourceIdentifier: string = "";
          SourceType: string = "cluster"; Duration: int = 0; EndTime: string = "";
          StartTime: string = ""; Action: string = "DescribeEvents";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603717 = newJObject()
  var formData_603718 = newJObject()
  add(formData_603718, "MaxRecords", newJInt(MaxRecords))
  add(formData_603718, "Marker", newJString(Marker))
  add(formData_603718, "SourceIdentifier", newJString(SourceIdentifier))
  add(formData_603718, "SourceType", newJString(SourceType))
  add(formData_603718, "Duration", newJInt(Duration))
  add(formData_603718, "EndTime", newJString(EndTime))
  add(formData_603718, "StartTime", newJString(StartTime))
  add(query_603717, "Action", newJString(Action))
  add(query_603717, "Version", newJString(Version))
  result = call_603716.call(nil, query_603717, nil, formData_603718, nil)

var postDescribeEvents* = Call_PostDescribeEvents_603696(
    name: "postDescribeEvents", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEvents",
    validator: validate_PostDescribeEvents_603697, base: "/",
    url: url_PostDescribeEvents_603698, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEvents_603674 = ref object of OpenApiRestCall_601373
proc url_GetDescribeEvents_603676(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEvents_603675(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_603677 = query.getOrDefault("Marker")
  valid_603677 = validateParameter(valid_603677, JString, required = false,
                                 default = nil)
  if valid_603677 != nil:
    section.add "Marker", valid_603677
  var valid_603678 = query.getOrDefault("SourceType")
  valid_603678 = validateParameter(valid_603678, JString, required = false,
                                 default = newJString("cluster"))
  if valid_603678 != nil:
    section.add "SourceType", valid_603678
  var valid_603679 = query.getOrDefault("SourceIdentifier")
  valid_603679 = validateParameter(valid_603679, JString, required = false,
                                 default = nil)
  if valid_603679 != nil:
    section.add "SourceIdentifier", valid_603679
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603680 = query.getOrDefault("Action")
  valid_603680 = validateParameter(valid_603680, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_603680 != nil:
    section.add "Action", valid_603680
  var valid_603681 = query.getOrDefault("StartTime")
  valid_603681 = validateParameter(valid_603681, JString, required = false,
                                 default = nil)
  if valid_603681 != nil:
    section.add "StartTime", valid_603681
  var valid_603682 = query.getOrDefault("Duration")
  valid_603682 = validateParameter(valid_603682, JInt, required = false, default = nil)
  if valid_603682 != nil:
    section.add "Duration", valid_603682
  var valid_603683 = query.getOrDefault("EndTime")
  valid_603683 = validateParameter(valid_603683, JString, required = false,
                                 default = nil)
  if valid_603683 != nil:
    section.add "EndTime", valid_603683
  var valid_603684 = query.getOrDefault("Version")
  valid_603684 = validateParameter(valid_603684, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603684 != nil:
    section.add "Version", valid_603684
  var valid_603685 = query.getOrDefault("MaxRecords")
  valid_603685 = validateParameter(valid_603685, JInt, required = false, default = nil)
  if valid_603685 != nil:
    section.add "MaxRecords", valid_603685
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603686 = header.getOrDefault("X-Amz-Signature")
  valid_603686 = validateParameter(valid_603686, JString, required = false,
                                 default = nil)
  if valid_603686 != nil:
    section.add "X-Amz-Signature", valid_603686
  var valid_603687 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603687 = validateParameter(valid_603687, JString, required = false,
                                 default = nil)
  if valid_603687 != nil:
    section.add "X-Amz-Content-Sha256", valid_603687
  var valid_603688 = header.getOrDefault("X-Amz-Date")
  valid_603688 = validateParameter(valid_603688, JString, required = false,
                                 default = nil)
  if valid_603688 != nil:
    section.add "X-Amz-Date", valid_603688
  var valid_603689 = header.getOrDefault("X-Amz-Credential")
  valid_603689 = validateParameter(valid_603689, JString, required = false,
                                 default = nil)
  if valid_603689 != nil:
    section.add "X-Amz-Credential", valid_603689
  var valid_603690 = header.getOrDefault("X-Amz-Security-Token")
  valid_603690 = validateParameter(valid_603690, JString, required = false,
                                 default = nil)
  if valid_603690 != nil:
    section.add "X-Amz-Security-Token", valid_603690
  var valid_603691 = header.getOrDefault("X-Amz-Algorithm")
  valid_603691 = validateParameter(valid_603691, JString, required = false,
                                 default = nil)
  if valid_603691 != nil:
    section.add "X-Amz-Algorithm", valid_603691
  var valid_603692 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603692 = validateParameter(valid_603692, JString, required = false,
                                 default = nil)
  if valid_603692 != nil:
    section.add "X-Amz-SignedHeaders", valid_603692
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603693: Call_GetDescribeEvents_603674; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_603693.validator(path, query, header, formData, body)
  let scheme = call_603693.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603693.url(scheme.get, call_603693.host, call_603693.base,
                         call_603693.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603693, url, valid)

proc call*(call_603694: Call_GetDescribeEvents_603674; Marker: string = "";
          SourceType: string = "cluster"; SourceIdentifier: string = "";
          Action: string = "DescribeEvents"; StartTime: string = ""; Duration: int = 0;
          EndTime: string = ""; Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Action: string (required)
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_603695 = newJObject()
  add(query_603695, "Marker", newJString(Marker))
  add(query_603695, "SourceType", newJString(SourceType))
  add(query_603695, "SourceIdentifier", newJString(SourceIdentifier))
  add(query_603695, "Action", newJString(Action))
  add(query_603695, "StartTime", newJString(StartTime))
  add(query_603695, "Duration", newJInt(Duration))
  add(query_603695, "EndTime", newJString(EndTime))
  add(query_603695, "Version", newJString(Version))
  add(query_603695, "MaxRecords", newJInt(MaxRecords))
  result = call_603694.call(nil, query_603695, nil, nil, nil)

var getDescribeEvents* = Call_GetDescribeEvents_603674(name: "getDescribeEvents",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeEvents", validator: validate_GetDescribeEvents_603675,
    base: "/", url: url_GetDescribeEvents_603676,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmClientCertificates_603739 = ref object of OpenApiRestCall_601373
proc url_PostDescribeHsmClientCertificates_603741(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmClientCertificates_603740(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603742 = query.getOrDefault("Action")
  valid_603742 = validateParameter(valid_603742, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_603742 != nil:
    section.add "Action", valid_603742
  var valid_603743 = query.getOrDefault("Version")
  valid_603743 = validateParameter(valid_603743, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603743 != nil:
    section.add "Version", valid_603743
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603744 = header.getOrDefault("X-Amz-Signature")
  valid_603744 = validateParameter(valid_603744, JString, required = false,
                                 default = nil)
  if valid_603744 != nil:
    section.add "X-Amz-Signature", valid_603744
  var valid_603745 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603745 = validateParameter(valid_603745, JString, required = false,
                                 default = nil)
  if valid_603745 != nil:
    section.add "X-Amz-Content-Sha256", valid_603745
  var valid_603746 = header.getOrDefault("X-Amz-Date")
  valid_603746 = validateParameter(valid_603746, JString, required = false,
                                 default = nil)
  if valid_603746 != nil:
    section.add "X-Amz-Date", valid_603746
  var valid_603747 = header.getOrDefault("X-Amz-Credential")
  valid_603747 = validateParameter(valid_603747, JString, required = false,
                                 default = nil)
  if valid_603747 != nil:
    section.add "X-Amz-Credential", valid_603747
  var valid_603748 = header.getOrDefault("X-Amz-Security-Token")
  valid_603748 = validateParameter(valid_603748, JString, required = false,
                                 default = nil)
  if valid_603748 != nil:
    section.add "X-Amz-Security-Token", valid_603748
  var valid_603749 = header.getOrDefault("X-Amz-Algorithm")
  valid_603749 = validateParameter(valid_603749, JString, required = false,
                                 default = nil)
  if valid_603749 != nil:
    section.add "X-Amz-Algorithm", valid_603749
  var valid_603750 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603750 = validateParameter(valid_603750, JString, required = false,
                                 default = nil)
  if valid_603750 != nil:
    section.add "X-Amz-SignedHeaders", valid_603750
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  section = newJObject()
  var valid_603751 = formData.getOrDefault("TagKeys")
  valid_603751 = validateParameter(valid_603751, JArray, required = false,
                                 default = nil)
  if valid_603751 != nil:
    section.add "TagKeys", valid_603751
  var valid_603752 = formData.getOrDefault("MaxRecords")
  valid_603752 = validateParameter(valid_603752, JInt, required = false, default = nil)
  if valid_603752 != nil:
    section.add "MaxRecords", valid_603752
  var valid_603753 = formData.getOrDefault("Marker")
  valid_603753 = validateParameter(valid_603753, JString, required = false,
                                 default = nil)
  if valid_603753 != nil:
    section.add "Marker", valid_603753
  var valid_603754 = formData.getOrDefault("TagValues")
  valid_603754 = validateParameter(valid_603754, JArray, required = false,
                                 default = nil)
  if valid_603754 != nil:
    section.add "TagValues", valid_603754
  var valid_603755 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_603755 = validateParameter(valid_603755, JString, required = false,
                                 default = nil)
  if valid_603755 != nil:
    section.add "HsmClientCertificateIdentifier", valid_603755
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603756: Call_PostDescribeHsmClientCertificates_603739;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603756.validator(path, query, header, formData, body)
  let scheme = call_603756.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603756.url(scheme.get, call_603756.host, call_603756.base,
                         call_603756.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603756, url, valid)

proc call*(call_603757: Call_PostDescribeHsmClientCertificates_603739;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil;
          Action: string = "DescribeHsmClientCertificates";
          HsmClientCertificateIdentifier: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   Version: string (required)
  var query_603758 = newJObject()
  var formData_603759 = newJObject()
  if TagKeys != nil:
    formData_603759.add "TagKeys", TagKeys
  add(formData_603759, "MaxRecords", newJInt(MaxRecords))
  add(formData_603759, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_603759.add "TagValues", TagValues
  add(query_603758, "Action", newJString(Action))
  add(formData_603759, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_603758, "Version", newJString(Version))
  result = call_603757.call(nil, query_603758, nil, formData_603759, nil)

var postDescribeHsmClientCertificates* = Call_PostDescribeHsmClientCertificates_603739(
    name: "postDescribeHsmClientCertificates", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_PostDescribeHsmClientCertificates_603740, base: "/",
    url: url_PostDescribeHsmClientCertificates_603741,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmClientCertificates_603719 = ref object of OpenApiRestCall_601373
proc url_GetDescribeHsmClientCertificates_603721(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmClientCertificates_603720(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603722 = query.getOrDefault("Marker")
  valid_603722 = validateParameter(valid_603722, JString, required = false,
                                 default = nil)
  if valid_603722 != nil:
    section.add "Marker", valid_603722
  var valid_603723 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_603723 = validateParameter(valid_603723, JString, required = false,
                                 default = nil)
  if valid_603723 != nil:
    section.add "HsmClientCertificateIdentifier", valid_603723
  var valid_603724 = query.getOrDefault("TagKeys")
  valid_603724 = validateParameter(valid_603724, JArray, required = false,
                                 default = nil)
  if valid_603724 != nil:
    section.add "TagKeys", valid_603724
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603725 = query.getOrDefault("Action")
  valid_603725 = validateParameter(valid_603725, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_603725 != nil:
    section.add "Action", valid_603725
  var valid_603726 = query.getOrDefault("Version")
  valid_603726 = validateParameter(valid_603726, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603726 != nil:
    section.add "Version", valid_603726
  var valid_603727 = query.getOrDefault("MaxRecords")
  valid_603727 = validateParameter(valid_603727, JInt, required = false, default = nil)
  if valid_603727 != nil:
    section.add "MaxRecords", valid_603727
  var valid_603728 = query.getOrDefault("TagValues")
  valid_603728 = validateParameter(valid_603728, JArray, required = false,
                                 default = nil)
  if valid_603728 != nil:
    section.add "TagValues", valid_603728
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603729 = header.getOrDefault("X-Amz-Signature")
  valid_603729 = validateParameter(valid_603729, JString, required = false,
                                 default = nil)
  if valid_603729 != nil:
    section.add "X-Amz-Signature", valid_603729
  var valid_603730 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603730 = validateParameter(valid_603730, JString, required = false,
                                 default = nil)
  if valid_603730 != nil:
    section.add "X-Amz-Content-Sha256", valid_603730
  var valid_603731 = header.getOrDefault("X-Amz-Date")
  valid_603731 = validateParameter(valid_603731, JString, required = false,
                                 default = nil)
  if valid_603731 != nil:
    section.add "X-Amz-Date", valid_603731
  var valid_603732 = header.getOrDefault("X-Amz-Credential")
  valid_603732 = validateParameter(valid_603732, JString, required = false,
                                 default = nil)
  if valid_603732 != nil:
    section.add "X-Amz-Credential", valid_603732
  var valid_603733 = header.getOrDefault("X-Amz-Security-Token")
  valid_603733 = validateParameter(valid_603733, JString, required = false,
                                 default = nil)
  if valid_603733 != nil:
    section.add "X-Amz-Security-Token", valid_603733
  var valid_603734 = header.getOrDefault("X-Amz-Algorithm")
  valid_603734 = validateParameter(valid_603734, JString, required = false,
                                 default = nil)
  if valid_603734 != nil:
    section.add "X-Amz-Algorithm", valid_603734
  var valid_603735 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603735 = validateParameter(valid_603735, JString, required = false,
                                 default = nil)
  if valid_603735 != nil:
    section.add "X-Amz-SignedHeaders", valid_603735
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603736: Call_GetDescribeHsmClientCertificates_603719;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603736.validator(path, query, header, formData, body)
  let scheme = call_603736.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603736.url(scheme.get, call_603736.host, call_603736.base,
                         call_603736.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603736, url, valid)

proc call*(call_603737: Call_GetDescribeHsmClientCertificates_603719;
          Marker: string = ""; HsmClientCertificateIdentifier: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeHsmClientCertificates";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  var query_603738 = newJObject()
  add(query_603738, "Marker", newJString(Marker))
  add(query_603738, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if TagKeys != nil:
    query_603738.add "TagKeys", TagKeys
  add(query_603738, "Action", newJString(Action))
  add(query_603738, "Version", newJString(Version))
  add(query_603738, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_603738.add "TagValues", TagValues
  result = call_603737.call(nil, query_603738, nil, nil, nil)

var getDescribeHsmClientCertificates* = Call_GetDescribeHsmClientCertificates_603719(
    name: "getDescribeHsmClientCertificates", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_GetDescribeHsmClientCertificates_603720, base: "/",
    url: url_GetDescribeHsmClientCertificates_603721,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmConfigurations_603780 = ref object of OpenApiRestCall_601373
proc url_PostDescribeHsmConfigurations_603782(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmConfigurations_603781(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603783 = query.getOrDefault("Action")
  valid_603783 = validateParameter(valid_603783, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_603783 != nil:
    section.add "Action", valid_603783
  var valid_603784 = query.getOrDefault("Version")
  valid_603784 = validateParameter(valid_603784, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603784 != nil:
    section.add "Version", valid_603784
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603785 = header.getOrDefault("X-Amz-Signature")
  valid_603785 = validateParameter(valid_603785, JString, required = false,
                                 default = nil)
  if valid_603785 != nil:
    section.add "X-Amz-Signature", valid_603785
  var valid_603786 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603786 = validateParameter(valid_603786, JString, required = false,
                                 default = nil)
  if valid_603786 != nil:
    section.add "X-Amz-Content-Sha256", valid_603786
  var valid_603787 = header.getOrDefault("X-Amz-Date")
  valid_603787 = validateParameter(valid_603787, JString, required = false,
                                 default = nil)
  if valid_603787 != nil:
    section.add "X-Amz-Date", valid_603787
  var valid_603788 = header.getOrDefault("X-Amz-Credential")
  valid_603788 = validateParameter(valid_603788, JString, required = false,
                                 default = nil)
  if valid_603788 != nil:
    section.add "X-Amz-Credential", valid_603788
  var valid_603789 = header.getOrDefault("X-Amz-Security-Token")
  valid_603789 = validateParameter(valid_603789, JString, required = false,
                                 default = nil)
  if valid_603789 != nil:
    section.add "X-Amz-Security-Token", valid_603789
  var valid_603790 = header.getOrDefault("X-Amz-Algorithm")
  valid_603790 = validateParameter(valid_603790, JString, required = false,
                                 default = nil)
  if valid_603790 != nil:
    section.add "X-Amz-Algorithm", valid_603790
  var valid_603791 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603791 = validateParameter(valid_603791, JString, required = false,
                                 default = nil)
  if valid_603791 != nil:
    section.add "X-Amz-SignedHeaders", valid_603791
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  section = newJObject()
  var valid_603792 = formData.getOrDefault("TagKeys")
  valid_603792 = validateParameter(valid_603792, JArray, required = false,
                                 default = nil)
  if valid_603792 != nil:
    section.add "TagKeys", valid_603792
  var valid_603793 = formData.getOrDefault("MaxRecords")
  valid_603793 = validateParameter(valid_603793, JInt, required = false, default = nil)
  if valid_603793 != nil:
    section.add "MaxRecords", valid_603793
  var valid_603794 = formData.getOrDefault("Marker")
  valid_603794 = validateParameter(valid_603794, JString, required = false,
                                 default = nil)
  if valid_603794 != nil:
    section.add "Marker", valid_603794
  var valid_603795 = formData.getOrDefault("TagValues")
  valid_603795 = validateParameter(valid_603795, JArray, required = false,
                                 default = nil)
  if valid_603795 != nil:
    section.add "TagValues", valid_603795
  var valid_603796 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_603796 = validateParameter(valid_603796, JString, required = false,
                                 default = nil)
  if valid_603796 != nil:
    section.add "HsmConfigurationIdentifier", valid_603796
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603797: Call_PostDescribeHsmConfigurations_603780; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603797.validator(path, query, header, formData, body)
  let scheme = call_603797.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603797.url(scheme.get, call_603797.host, call_603797.base,
                         call_603797.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603797, url, valid)

proc call*(call_603798: Call_PostDescribeHsmConfigurations_603780;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeHsmConfigurations";
          Version: string = "2012-12-01"; HsmConfigurationIdentifier: string = ""): Recallable =
  ## postDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  var query_603799 = newJObject()
  var formData_603800 = newJObject()
  if TagKeys != nil:
    formData_603800.add "TagKeys", TagKeys
  add(formData_603800, "MaxRecords", newJInt(MaxRecords))
  add(formData_603800, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_603800.add "TagValues", TagValues
  add(query_603799, "Action", newJString(Action))
  add(query_603799, "Version", newJString(Version))
  add(formData_603800, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  result = call_603798.call(nil, query_603799, nil, formData_603800, nil)

var postDescribeHsmConfigurations* = Call_PostDescribeHsmConfigurations_603780(
    name: "postDescribeHsmConfigurations", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_PostDescribeHsmConfigurations_603781, base: "/",
    url: url_PostDescribeHsmConfigurations_603782,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmConfigurations_603760 = ref object of OpenApiRestCall_601373
proc url_GetDescribeHsmConfigurations_603762(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmConfigurations_603761(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_603763 = query.getOrDefault("Marker")
  valid_603763 = validateParameter(valid_603763, JString, required = false,
                                 default = nil)
  if valid_603763 != nil:
    section.add "Marker", valid_603763
  var valid_603764 = query.getOrDefault("TagKeys")
  valid_603764 = validateParameter(valid_603764, JArray, required = false,
                                 default = nil)
  if valid_603764 != nil:
    section.add "TagKeys", valid_603764
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603765 = query.getOrDefault("Action")
  valid_603765 = validateParameter(valid_603765, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_603765 != nil:
    section.add "Action", valid_603765
  var valid_603766 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_603766 = validateParameter(valid_603766, JString, required = false,
                                 default = nil)
  if valid_603766 != nil:
    section.add "HsmConfigurationIdentifier", valid_603766
  var valid_603767 = query.getOrDefault("Version")
  valid_603767 = validateParameter(valid_603767, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603767 != nil:
    section.add "Version", valid_603767
  var valid_603768 = query.getOrDefault("MaxRecords")
  valid_603768 = validateParameter(valid_603768, JInt, required = false, default = nil)
  if valid_603768 != nil:
    section.add "MaxRecords", valid_603768
  var valid_603769 = query.getOrDefault("TagValues")
  valid_603769 = validateParameter(valid_603769, JArray, required = false,
                                 default = nil)
  if valid_603769 != nil:
    section.add "TagValues", valid_603769
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603770 = header.getOrDefault("X-Amz-Signature")
  valid_603770 = validateParameter(valid_603770, JString, required = false,
                                 default = nil)
  if valid_603770 != nil:
    section.add "X-Amz-Signature", valid_603770
  var valid_603771 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603771 = validateParameter(valid_603771, JString, required = false,
                                 default = nil)
  if valid_603771 != nil:
    section.add "X-Amz-Content-Sha256", valid_603771
  var valid_603772 = header.getOrDefault("X-Amz-Date")
  valid_603772 = validateParameter(valid_603772, JString, required = false,
                                 default = nil)
  if valid_603772 != nil:
    section.add "X-Amz-Date", valid_603772
  var valid_603773 = header.getOrDefault("X-Amz-Credential")
  valid_603773 = validateParameter(valid_603773, JString, required = false,
                                 default = nil)
  if valid_603773 != nil:
    section.add "X-Amz-Credential", valid_603773
  var valid_603774 = header.getOrDefault("X-Amz-Security-Token")
  valid_603774 = validateParameter(valid_603774, JString, required = false,
                                 default = nil)
  if valid_603774 != nil:
    section.add "X-Amz-Security-Token", valid_603774
  var valid_603775 = header.getOrDefault("X-Amz-Algorithm")
  valid_603775 = validateParameter(valid_603775, JString, required = false,
                                 default = nil)
  if valid_603775 != nil:
    section.add "X-Amz-Algorithm", valid_603775
  var valid_603776 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603776 = validateParameter(valid_603776, JString, required = false,
                                 default = nil)
  if valid_603776 != nil:
    section.add "X-Amz-SignedHeaders", valid_603776
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603777: Call_GetDescribeHsmConfigurations_603760; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_603777.validator(path, query, header, formData, body)
  let scheme = call_603777.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603777.url(scheme.get, call_603777.host, call_603777.base,
                         call_603777.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603777, url, valid)

proc call*(call_603778: Call_GetDescribeHsmConfigurations_603760;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeHsmConfigurations";
          HsmConfigurationIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  var query_603779 = newJObject()
  add(query_603779, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_603779.add "TagKeys", TagKeys
  add(query_603779, "Action", newJString(Action))
  add(query_603779, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_603779, "Version", newJString(Version))
  add(query_603779, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_603779.add "TagValues", TagValues
  result = call_603778.call(nil, query_603779, nil, nil, nil)

var getDescribeHsmConfigurations* = Call_GetDescribeHsmConfigurations_603760(
    name: "getDescribeHsmConfigurations", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_GetDescribeHsmConfigurations_603761, base: "/",
    url: url_GetDescribeHsmConfigurations_603762,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeLoggingStatus_603817 = ref object of OpenApiRestCall_601373
proc url_PostDescribeLoggingStatus_603819(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeLoggingStatus_603818(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603820 = query.getOrDefault("Action")
  valid_603820 = validateParameter(valid_603820, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_603820 != nil:
    section.add "Action", valid_603820
  var valid_603821 = query.getOrDefault("Version")
  valid_603821 = validateParameter(valid_603821, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603821 != nil:
    section.add "Version", valid_603821
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603822 = header.getOrDefault("X-Amz-Signature")
  valid_603822 = validateParameter(valid_603822, JString, required = false,
                                 default = nil)
  if valid_603822 != nil:
    section.add "X-Amz-Signature", valid_603822
  var valid_603823 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603823 = validateParameter(valid_603823, JString, required = false,
                                 default = nil)
  if valid_603823 != nil:
    section.add "X-Amz-Content-Sha256", valid_603823
  var valid_603824 = header.getOrDefault("X-Amz-Date")
  valid_603824 = validateParameter(valid_603824, JString, required = false,
                                 default = nil)
  if valid_603824 != nil:
    section.add "X-Amz-Date", valid_603824
  var valid_603825 = header.getOrDefault("X-Amz-Credential")
  valid_603825 = validateParameter(valid_603825, JString, required = false,
                                 default = nil)
  if valid_603825 != nil:
    section.add "X-Amz-Credential", valid_603825
  var valid_603826 = header.getOrDefault("X-Amz-Security-Token")
  valid_603826 = validateParameter(valid_603826, JString, required = false,
                                 default = nil)
  if valid_603826 != nil:
    section.add "X-Amz-Security-Token", valid_603826
  var valid_603827 = header.getOrDefault("X-Amz-Algorithm")
  valid_603827 = validateParameter(valid_603827, JString, required = false,
                                 default = nil)
  if valid_603827 != nil:
    section.add "X-Amz-Algorithm", valid_603827
  var valid_603828 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603828 = validateParameter(valid_603828, JString, required = false,
                                 default = nil)
  if valid_603828 != nil:
    section.add "X-Amz-SignedHeaders", valid_603828
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_603829 = formData.getOrDefault("ClusterIdentifier")
  valid_603829 = validateParameter(valid_603829, JString, required = true,
                                 default = nil)
  if valid_603829 != nil:
    section.add "ClusterIdentifier", valid_603829
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603830: Call_PostDescribeLoggingStatus_603817; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_603830.validator(path, query, header, formData, body)
  let scheme = call_603830.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603830.url(scheme.get, call_603830.host, call_603830.base,
                         call_603830.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603830, url, valid)

proc call*(call_603831: Call_PostDescribeLoggingStatus_603817;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603832 = newJObject()
  var formData_603833 = newJObject()
  add(formData_603833, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603832, "Action", newJString(Action))
  add(query_603832, "Version", newJString(Version))
  result = call_603831.call(nil, query_603832, nil, formData_603833, nil)

var postDescribeLoggingStatus* = Call_PostDescribeLoggingStatus_603817(
    name: "postDescribeLoggingStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_PostDescribeLoggingStatus_603818, base: "/",
    url: url_PostDescribeLoggingStatus_603819,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeLoggingStatus_603801 = ref object of OpenApiRestCall_601373
proc url_GetDescribeLoggingStatus_603803(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeLoggingStatus_603802(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603804 = query.getOrDefault("Action")
  valid_603804 = validateParameter(valid_603804, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_603804 != nil:
    section.add "Action", valid_603804
  var valid_603805 = query.getOrDefault("ClusterIdentifier")
  valid_603805 = validateParameter(valid_603805, JString, required = true,
                                 default = nil)
  if valid_603805 != nil:
    section.add "ClusterIdentifier", valid_603805
  var valid_603806 = query.getOrDefault("Version")
  valid_603806 = validateParameter(valid_603806, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603806 != nil:
    section.add "Version", valid_603806
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603807 = header.getOrDefault("X-Amz-Signature")
  valid_603807 = validateParameter(valid_603807, JString, required = false,
                                 default = nil)
  if valid_603807 != nil:
    section.add "X-Amz-Signature", valid_603807
  var valid_603808 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603808 = validateParameter(valid_603808, JString, required = false,
                                 default = nil)
  if valid_603808 != nil:
    section.add "X-Amz-Content-Sha256", valid_603808
  var valid_603809 = header.getOrDefault("X-Amz-Date")
  valid_603809 = validateParameter(valid_603809, JString, required = false,
                                 default = nil)
  if valid_603809 != nil:
    section.add "X-Amz-Date", valid_603809
  var valid_603810 = header.getOrDefault("X-Amz-Credential")
  valid_603810 = validateParameter(valid_603810, JString, required = false,
                                 default = nil)
  if valid_603810 != nil:
    section.add "X-Amz-Credential", valid_603810
  var valid_603811 = header.getOrDefault("X-Amz-Security-Token")
  valid_603811 = validateParameter(valid_603811, JString, required = false,
                                 default = nil)
  if valid_603811 != nil:
    section.add "X-Amz-Security-Token", valid_603811
  var valid_603812 = header.getOrDefault("X-Amz-Algorithm")
  valid_603812 = validateParameter(valid_603812, JString, required = false,
                                 default = nil)
  if valid_603812 != nil:
    section.add "X-Amz-Algorithm", valid_603812
  var valid_603813 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603813 = validateParameter(valid_603813, JString, required = false,
                                 default = nil)
  if valid_603813 != nil:
    section.add "X-Amz-SignedHeaders", valid_603813
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603814: Call_GetDescribeLoggingStatus_603801; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_603814.validator(path, query, header, formData, body)
  let scheme = call_603814.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603814.url(scheme.get, call_603814.host, call_603814.base,
                         call_603814.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603814, url, valid)

proc call*(call_603815: Call_GetDescribeLoggingStatus_603801;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_603816 = newJObject()
  add(query_603816, "Action", newJString(Action))
  add(query_603816, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603816, "Version", newJString(Version))
  result = call_603815.call(nil, query_603816, nil, nil, nil)

var getDescribeLoggingStatus* = Call_GetDescribeLoggingStatus_603801(
    name: "getDescribeLoggingStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_GetDescribeLoggingStatus_603802, base: "/",
    url: url_GetDescribeLoggingStatus_603803, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeNodeConfigurationOptions_603856 = ref object of OpenApiRestCall_601373
proc url_PostDescribeNodeConfigurationOptions_603858(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeNodeConfigurationOptions_603857(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603859 = query.getOrDefault("Action")
  valid_603859 = validateParameter(valid_603859, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_603859 != nil:
    section.add "Action", valid_603859
  var valid_603860 = query.getOrDefault("Version")
  valid_603860 = validateParameter(valid_603860, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603860 != nil:
    section.add "Version", valid_603860
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603861 = header.getOrDefault("X-Amz-Signature")
  valid_603861 = validateParameter(valid_603861, JString, required = false,
                                 default = nil)
  if valid_603861 != nil:
    section.add "X-Amz-Signature", valid_603861
  var valid_603862 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603862 = validateParameter(valid_603862, JString, required = false,
                                 default = nil)
  if valid_603862 != nil:
    section.add "X-Amz-Content-Sha256", valid_603862
  var valid_603863 = header.getOrDefault("X-Amz-Date")
  valid_603863 = validateParameter(valid_603863, JString, required = false,
                                 default = nil)
  if valid_603863 != nil:
    section.add "X-Amz-Date", valid_603863
  var valid_603864 = header.getOrDefault("X-Amz-Credential")
  valid_603864 = validateParameter(valid_603864, JString, required = false,
                                 default = nil)
  if valid_603864 != nil:
    section.add "X-Amz-Credential", valid_603864
  var valid_603865 = header.getOrDefault("X-Amz-Security-Token")
  valid_603865 = validateParameter(valid_603865, JString, required = false,
                                 default = nil)
  if valid_603865 != nil:
    section.add "X-Amz-Security-Token", valid_603865
  var valid_603866 = header.getOrDefault("X-Amz-Algorithm")
  valid_603866 = validateParameter(valid_603866, JString, required = false,
                                 default = nil)
  if valid_603866 != nil:
    section.add "X-Amz-Algorithm", valid_603866
  var valid_603867 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603867 = validateParameter(valid_603867, JString, required = false,
                                 default = nil)
  if valid_603867 != nil:
    section.add "X-Amz-SignedHeaders", valid_603867
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  section = newJObject()
  var valid_603868 = formData.getOrDefault("ClusterIdentifier")
  valid_603868 = validateParameter(valid_603868, JString, required = false,
                                 default = nil)
  if valid_603868 != nil:
    section.add "ClusterIdentifier", valid_603868
  var valid_603869 = formData.getOrDefault("MaxRecords")
  valid_603869 = validateParameter(valid_603869, JInt, required = false, default = nil)
  if valid_603869 != nil:
    section.add "MaxRecords", valid_603869
  var valid_603870 = formData.getOrDefault("OwnerAccount")
  valid_603870 = validateParameter(valid_603870, JString, required = false,
                                 default = nil)
  if valid_603870 != nil:
    section.add "OwnerAccount", valid_603870
  var valid_603871 = formData.getOrDefault("Marker")
  valid_603871 = validateParameter(valid_603871, JString, required = false,
                                 default = nil)
  if valid_603871 != nil:
    section.add "Marker", valid_603871
  var valid_603872 = formData.getOrDefault("SnapshotIdentifier")
  valid_603872 = validateParameter(valid_603872, JString, required = false,
                                 default = nil)
  if valid_603872 != nil:
    section.add "SnapshotIdentifier", valid_603872
  assert formData != nil,
        "formData argument is necessary due to required `ActionType` field"
  var valid_603873 = formData.getOrDefault("ActionType")
  valid_603873 = validateParameter(valid_603873, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_603873 != nil:
    section.add "ActionType", valid_603873
  var valid_603874 = formData.getOrDefault("Filter")
  valid_603874 = validateParameter(valid_603874, JArray, required = false,
                                 default = nil)
  if valid_603874 != nil:
    section.add "Filter", valid_603874
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603875: Call_PostDescribeNodeConfigurationOptions_603856;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_603875.validator(path, query, header, formData, body)
  let scheme = call_603875.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603875.url(scheme.get, call_603875.host, call_603875.base,
                         call_603875.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603875, url, valid)

proc call*(call_603876: Call_PostDescribeNodeConfigurationOptions_603856;
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          OwnerAccount: string = ""; Marker: string = "";
          SnapshotIdentifier: string = "";
          Action: string = "DescribeNodeConfigurationOptions";
          Version: string = "2012-12-01"; ActionType: string = "restore-cluster";
          Filter: JsonNode = nil): Recallable =
  ## postDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  var query_603877 = newJObject()
  var formData_603878 = newJObject()
  add(formData_603878, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_603878, "MaxRecords", newJInt(MaxRecords))
  add(formData_603878, "OwnerAccount", newJString(OwnerAccount))
  add(formData_603878, "Marker", newJString(Marker))
  add(formData_603878, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603877, "Action", newJString(Action))
  add(query_603877, "Version", newJString(Version))
  add(formData_603878, "ActionType", newJString(ActionType))
  if Filter != nil:
    formData_603878.add "Filter", Filter
  result = call_603876.call(nil, query_603877, nil, formData_603878, nil)

var postDescribeNodeConfigurationOptions* = Call_PostDescribeNodeConfigurationOptions_603856(
    name: "postDescribeNodeConfigurationOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_PostDescribeNodeConfigurationOptions_603857, base: "/",
    url: url_PostDescribeNodeConfigurationOptions_603858,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeNodeConfigurationOptions_603834 = ref object of OpenApiRestCall_601373
proc url_GetDescribeNodeConfigurationOptions_603836(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeNodeConfigurationOptions_603835(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  section = newJObject()
  var valid_603837 = query.getOrDefault("Marker")
  valid_603837 = validateParameter(valid_603837, JString, required = false,
                                 default = nil)
  if valid_603837 != nil:
    section.add "Marker", valid_603837
  var valid_603838 = query.getOrDefault("SnapshotIdentifier")
  valid_603838 = validateParameter(valid_603838, JString, required = false,
                                 default = nil)
  if valid_603838 != nil:
    section.add "SnapshotIdentifier", valid_603838
  assert query != nil,
        "query argument is necessary due to required `ActionType` field"
  var valid_603839 = query.getOrDefault("ActionType")
  valid_603839 = validateParameter(valid_603839, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_603839 != nil:
    section.add "ActionType", valid_603839
  var valid_603840 = query.getOrDefault("Filter")
  valid_603840 = validateParameter(valid_603840, JArray, required = false,
                                 default = nil)
  if valid_603840 != nil:
    section.add "Filter", valid_603840
  var valid_603841 = query.getOrDefault("Action")
  valid_603841 = validateParameter(valid_603841, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_603841 != nil:
    section.add "Action", valid_603841
  var valid_603842 = query.getOrDefault("ClusterIdentifier")
  valid_603842 = validateParameter(valid_603842, JString, required = false,
                                 default = nil)
  if valid_603842 != nil:
    section.add "ClusterIdentifier", valid_603842
  var valid_603843 = query.getOrDefault("OwnerAccount")
  valid_603843 = validateParameter(valid_603843, JString, required = false,
                                 default = nil)
  if valid_603843 != nil:
    section.add "OwnerAccount", valid_603843
  var valid_603844 = query.getOrDefault("Version")
  valid_603844 = validateParameter(valid_603844, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603844 != nil:
    section.add "Version", valid_603844
  var valid_603845 = query.getOrDefault("MaxRecords")
  valid_603845 = validateParameter(valid_603845, JInt, required = false, default = nil)
  if valid_603845 != nil:
    section.add "MaxRecords", valid_603845
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603846 = header.getOrDefault("X-Amz-Signature")
  valid_603846 = validateParameter(valid_603846, JString, required = false,
                                 default = nil)
  if valid_603846 != nil:
    section.add "X-Amz-Signature", valid_603846
  var valid_603847 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603847 = validateParameter(valid_603847, JString, required = false,
                                 default = nil)
  if valid_603847 != nil:
    section.add "X-Amz-Content-Sha256", valid_603847
  var valid_603848 = header.getOrDefault("X-Amz-Date")
  valid_603848 = validateParameter(valid_603848, JString, required = false,
                                 default = nil)
  if valid_603848 != nil:
    section.add "X-Amz-Date", valid_603848
  var valid_603849 = header.getOrDefault("X-Amz-Credential")
  valid_603849 = validateParameter(valid_603849, JString, required = false,
                                 default = nil)
  if valid_603849 != nil:
    section.add "X-Amz-Credential", valid_603849
  var valid_603850 = header.getOrDefault("X-Amz-Security-Token")
  valid_603850 = validateParameter(valid_603850, JString, required = false,
                                 default = nil)
  if valid_603850 != nil:
    section.add "X-Amz-Security-Token", valid_603850
  var valid_603851 = header.getOrDefault("X-Amz-Algorithm")
  valid_603851 = validateParameter(valid_603851, JString, required = false,
                                 default = nil)
  if valid_603851 != nil:
    section.add "X-Amz-Algorithm", valid_603851
  var valid_603852 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603852 = validateParameter(valid_603852, JString, required = false,
                                 default = nil)
  if valid_603852 != nil:
    section.add "X-Amz-SignedHeaders", valid_603852
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603853: Call_GetDescribeNodeConfigurationOptions_603834;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_603853.validator(path, query, header, formData, body)
  let scheme = call_603853.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603853.url(scheme.get, call_603853.host, call_603853.base,
                         call_603853.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603853, url, valid)

proc call*(call_603854: Call_GetDescribeNodeConfigurationOptions_603834;
          Marker: string = ""; SnapshotIdentifier: string = "";
          ActionType: string = "restore-cluster"; Filter: JsonNode = nil;
          Action: string = "DescribeNodeConfigurationOptions";
          ClusterIdentifier: string = ""; OwnerAccount: string = "";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  var query_603855 = newJObject()
  add(query_603855, "Marker", newJString(Marker))
  add(query_603855, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603855, "ActionType", newJString(ActionType))
  if Filter != nil:
    query_603855.add "Filter", Filter
  add(query_603855, "Action", newJString(Action))
  add(query_603855, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603855, "OwnerAccount", newJString(OwnerAccount))
  add(query_603855, "Version", newJString(Version))
  add(query_603855, "MaxRecords", newJInt(MaxRecords))
  result = call_603854.call(nil, query_603855, nil, nil, nil)

var getDescribeNodeConfigurationOptions* = Call_GetDescribeNodeConfigurationOptions_603834(
    name: "getDescribeNodeConfigurationOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_GetDescribeNodeConfigurationOptions_603835, base: "/",
    url: url_GetDescribeNodeConfigurationOptions_603836,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeOrderableClusterOptions_603898 = ref object of OpenApiRestCall_601373
proc url_PostDescribeOrderableClusterOptions_603900(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeOrderableClusterOptions_603899(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603901 = query.getOrDefault("Action")
  valid_603901 = validateParameter(valid_603901, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_603901 != nil:
    section.add "Action", valid_603901
  var valid_603902 = query.getOrDefault("Version")
  valid_603902 = validateParameter(valid_603902, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603902 != nil:
    section.add "Version", valid_603902
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603903 = header.getOrDefault("X-Amz-Signature")
  valid_603903 = validateParameter(valid_603903, JString, required = false,
                                 default = nil)
  if valid_603903 != nil:
    section.add "X-Amz-Signature", valid_603903
  var valid_603904 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603904 = validateParameter(valid_603904, JString, required = false,
                                 default = nil)
  if valid_603904 != nil:
    section.add "X-Amz-Content-Sha256", valid_603904
  var valid_603905 = header.getOrDefault("X-Amz-Date")
  valid_603905 = validateParameter(valid_603905, JString, required = false,
                                 default = nil)
  if valid_603905 != nil:
    section.add "X-Amz-Date", valid_603905
  var valid_603906 = header.getOrDefault("X-Amz-Credential")
  valid_603906 = validateParameter(valid_603906, JString, required = false,
                                 default = nil)
  if valid_603906 != nil:
    section.add "X-Amz-Credential", valid_603906
  var valid_603907 = header.getOrDefault("X-Amz-Security-Token")
  valid_603907 = validateParameter(valid_603907, JString, required = false,
                                 default = nil)
  if valid_603907 != nil:
    section.add "X-Amz-Security-Token", valid_603907
  var valid_603908 = header.getOrDefault("X-Amz-Algorithm")
  valid_603908 = validateParameter(valid_603908, JString, required = false,
                                 default = nil)
  if valid_603908 != nil:
    section.add "X-Amz-Algorithm", valid_603908
  var valid_603909 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603909 = validateParameter(valid_603909, JString, required = false,
                                 default = nil)
  if valid_603909 != nil:
    section.add "X-Amz-SignedHeaders", valid_603909
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  section = newJObject()
  var valid_603910 = formData.getOrDefault("NodeType")
  valid_603910 = validateParameter(valid_603910, JString, required = false,
                                 default = nil)
  if valid_603910 != nil:
    section.add "NodeType", valid_603910
  var valid_603911 = formData.getOrDefault("MaxRecords")
  valid_603911 = validateParameter(valid_603911, JInt, required = false, default = nil)
  if valid_603911 != nil:
    section.add "MaxRecords", valid_603911
  var valid_603912 = formData.getOrDefault("Marker")
  valid_603912 = validateParameter(valid_603912, JString, required = false,
                                 default = nil)
  if valid_603912 != nil:
    section.add "Marker", valid_603912
  var valid_603913 = formData.getOrDefault("ClusterVersion")
  valid_603913 = validateParameter(valid_603913, JString, required = false,
                                 default = nil)
  if valid_603913 != nil:
    section.add "ClusterVersion", valid_603913
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603914: Call_PostDescribeOrderableClusterOptions_603898;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_603914.validator(path, query, header, formData, body)
  let scheme = call_603914.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603914.url(scheme.get, call_603914.host, call_603914.base,
                         call_603914.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603914, url, valid)

proc call*(call_603915: Call_PostDescribeOrderableClusterOptions_603898;
          NodeType: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeOrderableClusterOptions";
          ClusterVersion: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: string (required)
  var query_603916 = newJObject()
  var formData_603917 = newJObject()
  add(formData_603917, "NodeType", newJString(NodeType))
  add(formData_603917, "MaxRecords", newJInt(MaxRecords))
  add(formData_603917, "Marker", newJString(Marker))
  add(query_603916, "Action", newJString(Action))
  add(formData_603917, "ClusterVersion", newJString(ClusterVersion))
  add(query_603916, "Version", newJString(Version))
  result = call_603915.call(nil, query_603916, nil, formData_603917, nil)

var postDescribeOrderableClusterOptions* = Call_PostDescribeOrderableClusterOptions_603898(
    name: "postDescribeOrderableClusterOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_PostDescribeOrderableClusterOptions_603899, base: "/",
    url: url_PostDescribeOrderableClusterOptions_603900,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeOrderableClusterOptions_603879 = ref object of OpenApiRestCall_601373
proc url_GetDescribeOrderableClusterOptions_603881(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeOrderableClusterOptions_603880(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_603882 = query.getOrDefault("Marker")
  valid_603882 = validateParameter(valid_603882, JString, required = false,
                                 default = nil)
  if valid_603882 != nil:
    section.add "Marker", valid_603882
  var valid_603883 = query.getOrDefault("ClusterVersion")
  valid_603883 = validateParameter(valid_603883, JString, required = false,
                                 default = nil)
  if valid_603883 != nil:
    section.add "ClusterVersion", valid_603883
  var valid_603884 = query.getOrDefault("NodeType")
  valid_603884 = validateParameter(valid_603884, JString, required = false,
                                 default = nil)
  if valid_603884 != nil:
    section.add "NodeType", valid_603884
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603885 = query.getOrDefault("Action")
  valid_603885 = validateParameter(valid_603885, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_603885 != nil:
    section.add "Action", valid_603885
  var valid_603886 = query.getOrDefault("Version")
  valid_603886 = validateParameter(valid_603886, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603886 != nil:
    section.add "Version", valid_603886
  var valid_603887 = query.getOrDefault("MaxRecords")
  valid_603887 = validateParameter(valid_603887, JInt, required = false, default = nil)
  if valid_603887 != nil:
    section.add "MaxRecords", valid_603887
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603888 = header.getOrDefault("X-Amz-Signature")
  valid_603888 = validateParameter(valid_603888, JString, required = false,
                                 default = nil)
  if valid_603888 != nil:
    section.add "X-Amz-Signature", valid_603888
  var valid_603889 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603889 = validateParameter(valid_603889, JString, required = false,
                                 default = nil)
  if valid_603889 != nil:
    section.add "X-Amz-Content-Sha256", valid_603889
  var valid_603890 = header.getOrDefault("X-Amz-Date")
  valid_603890 = validateParameter(valid_603890, JString, required = false,
                                 default = nil)
  if valid_603890 != nil:
    section.add "X-Amz-Date", valid_603890
  var valid_603891 = header.getOrDefault("X-Amz-Credential")
  valid_603891 = validateParameter(valid_603891, JString, required = false,
                                 default = nil)
  if valid_603891 != nil:
    section.add "X-Amz-Credential", valid_603891
  var valid_603892 = header.getOrDefault("X-Amz-Security-Token")
  valid_603892 = validateParameter(valid_603892, JString, required = false,
                                 default = nil)
  if valid_603892 != nil:
    section.add "X-Amz-Security-Token", valid_603892
  var valid_603893 = header.getOrDefault("X-Amz-Algorithm")
  valid_603893 = validateParameter(valid_603893, JString, required = false,
                                 default = nil)
  if valid_603893 != nil:
    section.add "X-Amz-Algorithm", valid_603893
  var valid_603894 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603894 = validateParameter(valid_603894, JString, required = false,
                                 default = nil)
  if valid_603894 != nil:
    section.add "X-Amz-SignedHeaders", valid_603894
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603895: Call_GetDescribeOrderableClusterOptions_603879;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_603895.validator(path, query, header, formData, body)
  let scheme = call_603895.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603895.url(scheme.get, call_603895.host, call_603895.base,
                         call_603895.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603895, url, valid)

proc call*(call_603896: Call_GetDescribeOrderableClusterOptions_603879;
          Marker: string = ""; ClusterVersion: string = ""; NodeType: string = "";
          Action: string = "DescribeOrderableClusterOptions";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_603897 = newJObject()
  add(query_603897, "Marker", newJString(Marker))
  add(query_603897, "ClusterVersion", newJString(ClusterVersion))
  add(query_603897, "NodeType", newJString(NodeType))
  add(query_603897, "Action", newJString(Action))
  add(query_603897, "Version", newJString(Version))
  add(query_603897, "MaxRecords", newJInt(MaxRecords))
  result = call_603896.call(nil, query_603897, nil, nil, nil)

var getDescribeOrderableClusterOptions* = Call_GetDescribeOrderableClusterOptions_603879(
    name: "getDescribeOrderableClusterOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_GetDescribeOrderableClusterOptions_603880, base: "/",
    url: url_GetDescribeOrderableClusterOptions_603881,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodeOfferings_603936 = ref object of OpenApiRestCall_601373
proc url_PostDescribeReservedNodeOfferings_603938(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodeOfferings_603937(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603939 = query.getOrDefault("Action")
  valid_603939 = validateParameter(valid_603939, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_603939 != nil:
    section.add "Action", valid_603939
  var valid_603940 = query.getOrDefault("Version")
  valid_603940 = validateParameter(valid_603940, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603940 != nil:
    section.add "Version", valid_603940
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603941 = header.getOrDefault("X-Amz-Signature")
  valid_603941 = validateParameter(valid_603941, JString, required = false,
                                 default = nil)
  if valid_603941 != nil:
    section.add "X-Amz-Signature", valid_603941
  var valid_603942 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603942 = validateParameter(valid_603942, JString, required = false,
                                 default = nil)
  if valid_603942 != nil:
    section.add "X-Amz-Content-Sha256", valid_603942
  var valid_603943 = header.getOrDefault("X-Amz-Date")
  valid_603943 = validateParameter(valid_603943, JString, required = false,
                                 default = nil)
  if valid_603943 != nil:
    section.add "X-Amz-Date", valid_603943
  var valid_603944 = header.getOrDefault("X-Amz-Credential")
  valid_603944 = validateParameter(valid_603944, JString, required = false,
                                 default = nil)
  if valid_603944 != nil:
    section.add "X-Amz-Credential", valid_603944
  var valid_603945 = header.getOrDefault("X-Amz-Security-Token")
  valid_603945 = validateParameter(valid_603945, JString, required = false,
                                 default = nil)
  if valid_603945 != nil:
    section.add "X-Amz-Security-Token", valid_603945
  var valid_603946 = header.getOrDefault("X-Amz-Algorithm")
  valid_603946 = validateParameter(valid_603946, JString, required = false,
                                 default = nil)
  if valid_603946 != nil:
    section.add "X-Amz-Algorithm", valid_603946
  var valid_603947 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603947 = validateParameter(valid_603947, JString, required = false,
                                 default = nil)
  if valid_603947 != nil:
    section.add "X-Amz-SignedHeaders", valid_603947
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_603948 = formData.getOrDefault("MaxRecords")
  valid_603948 = validateParameter(valid_603948, JInt, required = false, default = nil)
  if valid_603948 != nil:
    section.add "MaxRecords", valid_603948
  var valid_603949 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_603949 = validateParameter(valid_603949, JString, required = false,
                                 default = nil)
  if valid_603949 != nil:
    section.add "ReservedNodeOfferingId", valid_603949
  var valid_603950 = formData.getOrDefault("Marker")
  valid_603950 = validateParameter(valid_603950, JString, required = false,
                                 default = nil)
  if valid_603950 != nil:
    section.add "Marker", valid_603950
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603951: Call_PostDescribeReservedNodeOfferings_603936;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603951.validator(path, query, header, formData, body)
  let scheme = call_603951.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603951.url(scheme.get, call_603951.host, call_603951.base,
                         call_603951.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603951, url, valid)

proc call*(call_603952: Call_PostDescribeReservedNodeOfferings_603936;
          MaxRecords: int = 0; ReservedNodeOfferingId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodeOfferings";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603953 = newJObject()
  var formData_603954 = newJObject()
  add(formData_603954, "MaxRecords", newJInt(MaxRecords))
  add(formData_603954, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_603954, "Marker", newJString(Marker))
  add(query_603953, "Action", newJString(Action))
  add(query_603953, "Version", newJString(Version))
  result = call_603952.call(nil, query_603953, nil, formData_603954, nil)

var postDescribeReservedNodeOfferings* = Call_PostDescribeReservedNodeOfferings_603936(
    name: "postDescribeReservedNodeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_PostDescribeReservedNodeOfferings_603937, base: "/",
    url: url_PostDescribeReservedNodeOfferings_603938,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodeOfferings_603918 = ref object of OpenApiRestCall_601373
proc url_GetDescribeReservedNodeOfferings_603920(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodeOfferings_603919(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_603921 = query.getOrDefault("Marker")
  valid_603921 = validateParameter(valid_603921, JString, required = false,
                                 default = nil)
  if valid_603921 != nil:
    section.add "Marker", valid_603921
  var valid_603922 = query.getOrDefault("ReservedNodeOfferingId")
  valid_603922 = validateParameter(valid_603922, JString, required = false,
                                 default = nil)
  if valid_603922 != nil:
    section.add "ReservedNodeOfferingId", valid_603922
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603923 = query.getOrDefault("Action")
  valid_603923 = validateParameter(valid_603923, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_603923 != nil:
    section.add "Action", valid_603923
  var valid_603924 = query.getOrDefault("Version")
  valid_603924 = validateParameter(valid_603924, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603924 != nil:
    section.add "Version", valid_603924
  var valid_603925 = query.getOrDefault("MaxRecords")
  valid_603925 = validateParameter(valid_603925, JInt, required = false, default = nil)
  if valid_603925 != nil:
    section.add "MaxRecords", valid_603925
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603926 = header.getOrDefault("X-Amz-Signature")
  valid_603926 = validateParameter(valid_603926, JString, required = false,
                                 default = nil)
  if valid_603926 != nil:
    section.add "X-Amz-Signature", valid_603926
  var valid_603927 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603927 = validateParameter(valid_603927, JString, required = false,
                                 default = nil)
  if valid_603927 != nil:
    section.add "X-Amz-Content-Sha256", valid_603927
  var valid_603928 = header.getOrDefault("X-Amz-Date")
  valid_603928 = validateParameter(valid_603928, JString, required = false,
                                 default = nil)
  if valid_603928 != nil:
    section.add "X-Amz-Date", valid_603928
  var valid_603929 = header.getOrDefault("X-Amz-Credential")
  valid_603929 = validateParameter(valid_603929, JString, required = false,
                                 default = nil)
  if valid_603929 != nil:
    section.add "X-Amz-Credential", valid_603929
  var valid_603930 = header.getOrDefault("X-Amz-Security-Token")
  valid_603930 = validateParameter(valid_603930, JString, required = false,
                                 default = nil)
  if valid_603930 != nil:
    section.add "X-Amz-Security-Token", valid_603930
  var valid_603931 = header.getOrDefault("X-Amz-Algorithm")
  valid_603931 = validateParameter(valid_603931, JString, required = false,
                                 default = nil)
  if valid_603931 != nil:
    section.add "X-Amz-Algorithm", valid_603931
  var valid_603932 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603932 = validateParameter(valid_603932, JString, required = false,
                                 default = nil)
  if valid_603932 != nil:
    section.add "X-Amz-SignedHeaders", valid_603932
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603933: Call_GetDescribeReservedNodeOfferings_603918;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603933.validator(path, query, header, formData, body)
  let scheme = call_603933.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603933.url(scheme.get, call_603933.host, call_603933.base,
                         call_603933.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603933, url, valid)

proc call*(call_603934: Call_GetDescribeReservedNodeOfferings_603918;
          Marker: string = ""; ReservedNodeOfferingId: string = "";
          Action: string = "DescribeReservedNodeOfferings";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_603935 = newJObject()
  add(query_603935, "Marker", newJString(Marker))
  add(query_603935, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_603935, "Action", newJString(Action))
  add(query_603935, "Version", newJString(Version))
  add(query_603935, "MaxRecords", newJInt(MaxRecords))
  result = call_603934.call(nil, query_603935, nil, nil, nil)

var getDescribeReservedNodeOfferings* = Call_GetDescribeReservedNodeOfferings_603918(
    name: "getDescribeReservedNodeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_GetDescribeReservedNodeOfferings_603919, base: "/",
    url: url_GetDescribeReservedNodeOfferings_603920,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodes_603973 = ref object of OpenApiRestCall_601373
proc url_PostDescribeReservedNodes_603975(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodes_603974(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603976 = query.getOrDefault("Action")
  valid_603976 = validateParameter(valid_603976, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_603976 != nil:
    section.add "Action", valid_603976
  var valid_603977 = query.getOrDefault("Version")
  valid_603977 = validateParameter(valid_603977, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603977 != nil:
    section.add "Version", valid_603977
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603978 = header.getOrDefault("X-Amz-Signature")
  valid_603978 = validateParameter(valid_603978, JString, required = false,
                                 default = nil)
  if valid_603978 != nil:
    section.add "X-Amz-Signature", valid_603978
  var valid_603979 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603979 = validateParameter(valid_603979, JString, required = false,
                                 default = nil)
  if valid_603979 != nil:
    section.add "X-Amz-Content-Sha256", valid_603979
  var valid_603980 = header.getOrDefault("X-Amz-Date")
  valid_603980 = validateParameter(valid_603980, JString, required = false,
                                 default = nil)
  if valid_603980 != nil:
    section.add "X-Amz-Date", valid_603980
  var valid_603981 = header.getOrDefault("X-Amz-Credential")
  valid_603981 = validateParameter(valid_603981, JString, required = false,
                                 default = nil)
  if valid_603981 != nil:
    section.add "X-Amz-Credential", valid_603981
  var valid_603982 = header.getOrDefault("X-Amz-Security-Token")
  valid_603982 = validateParameter(valid_603982, JString, required = false,
                                 default = nil)
  if valid_603982 != nil:
    section.add "X-Amz-Security-Token", valid_603982
  var valid_603983 = header.getOrDefault("X-Amz-Algorithm")
  valid_603983 = validateParameter(valid_603983, JString, required = false,
                                 default = nil)
  if valid_603983 != nil:
    section.add "X-Amz-Algorithm", valid_603983
  var valid_603984 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603984 = validateParameter(valid_603984, JString, required = false,
                                 default = nil)
  if valid_603984 != nil:
    section.add "X-Amz-SignedHeaders", valid_603984
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_603985 = formData.getOrDefault("ReservedNodeId")
  valid_603985 = validateParameter(valid_603985, JString, required = false,
                                 default = nil)
  if valid_603985 != nil:
    section.add "ReservedNodeId", valid_603985
  var valid_603986 = formData.getOrDefault("MaxRecords")
  valid_603986 = validateParameter(valid_603986, JInt, required = false, default = nil)
  if valid_603986 != nil:
    section.add "MaxRecords", valid_603986
  var valid_603987 = formData.getOrDefault("Marker")
  valid_603987 = validateParameter(valid_603987, JString, required = false,
                                 default = nil)
  if valid_603987 != nil:
    section.add "Marker", valid_603987
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603988: Call_PostDescribeReservedNodes_603973; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_603988.validator(path, query, header, formData, body)
  let scheme = call_603988.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603988.url(scheme.get, call_603988.host, call_603988.base,
                         call_603988.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603988, url, valid)

proc call*(call_603989: Call_PostDescribeReservedNodes_603973;
          ReservedNodeId: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeReservedNodes"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603990 = newJObject()
  var formData_603991 = newJObject()
  add(formData_603991, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_603991, "MaxRecords", newJInt(MaxRecords))
  add(formData_603991, "Marker", newJString(Marker))
  add(query_603990, "Action", newJString(Action))
  add(query_603990, "Version", newJString(Version))
  result = call_603989.call(nil, query_603990, nil, formData_603991, nil)

var postDescribeReservedNodes* = Call_PostDescribeReservedNodes_603973(
    name: "postDescribeReservedNodes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_PostDescribeReservedNodes_603974, base: "/",
    url: url_PostDescribeReservedNodes_603975,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodes_603955 = ref object of OpenApiRestCall_601373
proc url_GetDescribeReservedNodes_603957(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodes_603956(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: JString (required)
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_603958 = query.getOrDefault("Marker")
  valid_603958 = validateParameter(valid_603958, JString, required = false,
                                 default = nil)
  if valid_603958 != nil:
    section.add "Marker", valid_603958
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603959 = query.getOrDefault("Action")
  valid_603959 = validateParameter(valid_603959, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_603959 != nil:
    section.add "Action", valid_603959
  var valid_603960 = query.getOrDefault("ReservedNodeId")
  valid_603960 = validateParameter(valid_603960, JString, required = false,
                                 default = nil)
  if valid_603960 != nil:
    section.add "ReservedNodeId", valid_603960
  var valid_603961 = query.getOrDefault("Version")
  valid_603961 = validateParameter(valid_603961, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603961 != nil:
    section.add "Version", valid_603961
  var valid_603962 = query.getOrDefault("MaxRecords")
  valid_603962 = validateParameter(valid_603962, JInt, required = false, default = nil)
  if valid_603962 != nil:
    section.add "MaxRecords", valid_603962
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603963 = header.getOrDefault("X-Amz-Signature")
  valid_603963 = validateParameter(valid_603963, JString, required = false,
                                 default = nil)
  if valid_603963 != nil:
    section.add "X-Amz-Signature", valid_603963
  var valid_603964 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603964 = validateParameter(valid_603964, JString, required = false,
                                 default = nil)
  if valid_603964 != nil:
    section.add "X-Amz-Content-Sha256", valid_603964
  var valid_603965 = header.getOrDefault("X-Amz-Date")
  valid_603965 = validateParameter(valid_603965, JString, required = false,
                                 default = nil)
  if valid_603965 != nil:
    section.add "X-Amz-Date", valid_603965
  var valid_603966 = header.getOrDefault("X-Amz-Credential")
  valid_603966 = validateParameter(valid_603966, JString, required = false,
                                 default = nil)
  if valid_603966 != nil:
    section.add "X-Amz-Credential", valid_603966
  var valid_603967 = header.getOrDefault("X-Amz-Security-Token")
  valid_603967 = validateParameter(valid_603967, JString, required = false,
                                 default = nil)
  if valid_603967 != nil:
    section.add "X-Amz-Security-Token", valid_603967
  var valid_603968 = header.getOrDefault("X-Amz-Algorithm")
  valid_603968 = validateParameter(valid_603968, JString, required = false,
                                 default = nil)
  if valid_603968 != nil:
    section.add "X-Amz-Algorithm", valid_603968
  var valid_603969 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603969 = validateParameter(valid_603969, JString, required = false,
                                 default = nil)
  if valid_603969 != nil:
    section.add "X-Amz-SignedHeaders", valid_603969
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603970: Call_GetDescribeReservedNodes_603955; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_603970.validator(path, query, header, formData, body)
  let scheme = call_603970.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603970.url(scheme.get, call_603970.host, call_603970.base,
                         call_603970.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603970, url, valid)

proc call*(call_603971: Call_GetDescribeReservedNodes_603955; Marker: string = "";
          Action: string = "DescribeReservedNodes"; ReservedNodeId: string = "";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_603972 = newJObject()
  add(query_603972, "Marker", newJString(Marker))
  add(query_603972, "Action", newJString(Action))
  add(query_603972, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_603972, "Version", newJString(Version))
  add(query_603972, "MaxRecords", newJInt(MaxRecords))
  result = call_603971.call(nil, query_603972, nil, nil, nil)

var getDescribeReservedNodes* = Call_GetDescribeReservedNodes_603955(
    name: "getDescribeReservedNodes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_GetDescribeReservedNodes_603956, base: "/",
    url: url_GetDescribeReservedNodes_603957, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeResize_604008 = ref object of OpenApiRestCall_601373
proc url_PostDescribeResize_604010(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeResize_604009(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604011 = query.getOrDefault("Action")
  valid_604011 = validateParameter(valid_604011, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_604011 != nil:
    section.add "Action", valid_604011
  var valid_604012 = query.getOrDefault("Version")
  valid_604012 = validateParameter(valid_604012, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604012 != nil:
    section.add "Version", valid_604012
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604013 = header.getOrDefault("X-Amz-Signature")
  valid_604013 = validateParameter(valid_604013, JString, required = false,
                                 default = nil)
  if valid_604013 != nil:
    section.add "X-Amz-Signature", valid_604013
  var valid_604014 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604014 = validateParameter(valid_604014, JString, required = false,
                                 default = nil)
  if valid_604014 != nil:
    section.add "X-Amz-Content-Sha256", valid_604014
  var valid_604015 = header.getOrDefault("X-Amz-Date")
  valid_604015 = validateParameter(valid_604015, JString, required = false,
                                 default = nil)
  if valid_604015 != nil:
    section.add "X-Amz-Date", valid_604015
  var valid_604016 = header.getOrDefault("X-Amz-Credential")
  valid_604016 = validateParameter(valid_604016, JString, required = false,
                                 default = nil)
  if valid_604016 != nil:
    section.add "X-Amz-Credential", valid_604016
  var valid_604017 = header.getOrDefault("X-Amz-Security-Token")
  valid_604017 = validateParameter(valid_604017, JString, required = false,
                                 default = nil)
  if valid_604017 != nil:
    section.add "X-Amz-Security-Token", valid_604017
  var valid_604018 = header.getOrDefault("X-Amz-Algorithm")
  valid_604018 = validateParameter(valid_604018, JString, required = false,
                                 default = nil)
  if valid_604018 != nil:
    section.add "X-Amz-Algorithm", valid_604018
  var valid_604019 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604019 = validateParameter(valid_604019, JString, required = false,
                                 default = nil)
  if valid_604019 != nil:
    section.add "X-Amz-SignedHeaders", valid_604019
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604020 = formData.getOrDefault("ClusterIdentifier")
  valid_604020 = validateParameter(valid_604020, JString, required = true,
                                 default = nil)
  if valid_604020 != nil:
    section.add "ClusterIdentifier", valid_604020
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604021: Call_PostDescribeResize_604008; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_604021.validator(path, query, header, formData, body)
  let scheme = call_604021.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604021.url(scheme.get, call_604021.host, call_604021.base,
                         call_604021.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604021, url, valid)

proc call*(call_604022: Call_PostDescribeResize_604008; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604023 = newJObject()
  var formData_604024 = newJObject()
  add(formData_604024, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604023, "Action", newJString(Action))
  add(query_604023, "Version", newJString(Version))
  result = call_604022.call(nil, query_604023, nil, formData_604024, nil)

var postDescribeResize* = Call_PostDescribeResize_604008(
    name: "postDescribeResize", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeResize",
    validator: validate_PostDescribeResize_604009, base: "/",
    url: url_PostDescribeResize_604010, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeResize_603992 = ref object of OpenApiRestCall_601373
proc url_GetDescribeResize_603994(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeResize_603993(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603995 = query.getOrDefault("Action")
  valid_603995 = validateParameter(valid_603995, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_603995 != nil:
    section.add "Action", valid_603995
  var valid_603996 = query.getOrDefault("ClusterIdentifier")
  valid_603996 = validateParameter(valid_603996, JString, required = true,
                                 default = nil)
  if valid_603996 != nil:
    section.add "ClusterIdentifier", valid_603996
  var valid_603997 = query.getOrDefault("Version")
  valid_603997 = validateParameter(valid_603997, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603997 != nil:
    section.add "Version", valid_603997
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_603998 = header.getOrDefault("X-Amz-Signature")
  valid_603998 = validateParameter(valid_603998, JString, required = false,
                                 default = nil)
  if valid_603998 != nil:
    section.add "X-Amz-Signature", valid_603998
  var valid_603999 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603999 = validateParameter(valid_603999, JString, required = false,
                                 default = nil)
  if valid_603999 != nil:
    section.add "X-Amz-Content-Sha256", valid_603999
  var valid_604000 = header.getOrDefault("X-Amz-Date")
  valid_604000 = validateParameter(valid_604000, JString, required = false,
                                 default = nil)
  if valid_604000 != nil:
    section.add "X-Amz-Date", valid_604000
  var valid_604001 = header.getOrDefault("X-Amz-Credential")
  valid_604001 = validateParameter(valid_604001, JString, required = false,
                                 default = nil)
  if valid_604001 != nil:
    section.add "X-Amz-Credential", valid_604001
  var valid_604002 = header.getOrDefault("X-Amz-Security-Token")
  valid_604002 = validateParameter(valid_604002, JString, required = false,
                                 default = nil)
  if valid_604002 != nil:
    section.add "X-Amz-Security-Token", valid_604002
  var valid_604003 = header.getOrDefault("X-Amz-Algorithm")
  valid_604003 = validateParameter(valid_604003, JString, required = false,
                                 default = nil)
  if valid_604003 != nil:
    section.add "X-Amz-Algorithm", valid_604003
  var valid_604004 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604004 = validateParameter(valid_604004, JString, required = false,
                                 default = nil)
  if valid_604004 != nil:
    section.add "X-Amz-SignedHeaders", valid_604004
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604005: Call_GetDescribeResize_603992; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_604005.validator(path, query, header, formData, body)
  let scheme = call_604005.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604005.url(scheme.get, call_604005.host, call_604005.base,
                         call_604005.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604005, url, valid)

proc call*(call_604006: Call_GetDescribeResize_603992; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_604007 = newJObject()
  add(query_604007, "Action", newJString(Action))
  add(query_604007, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604007, "Version", newJString(Version))
  result = call_604006.call(nil, query_604007, nil, nil, nil)

var getDescribeResize* = Call_GetDescribeResize_603992(name: "getDescribeResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeResize", validator: validate_GetDescribeResize_603993,
    base: "/", url: url_GetDescribeResize_603994,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeScheduledActions_604048 = ref object of OpenApiRestCall_601373
proc url_PostDescribeScheduledActions_604050(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeScheduledActions_604049(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604051 = query.getOrDefault("Action")
  valid_604051 = validateParameter(valid_604051, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_604051 != nil:
    section.add "Action", valid_604051
  var valid_604052 = query.getOrDefault("Version")
  valid_604052 = validateParameter(valid_604052, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604052 != nil:
    section.add "Version", valid_604052
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604053 = header.getOrDefault("X-Amz-Signature")
  valid_604053 = validateParameter(valid_604053, JString, required = false,
                                 default = nil)
  if valid_604053 != nil:
    section.add "X-Amz-Signature", valid_604053
  var valid_604054 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604054 = validateParameter(valid_604054, JString, required = false,
                                 default = nil)
  if valid_604054 != nil:
    section.add "X-Amz-Content-Sha256", valid_604054
  var valid_604055 = header.getOrDefault("X-Amz-Date")
  valid_604055 = validateParameter(valid_604055, JString, required = false,
                                 default = nil)
  if valid_604055 != nil:
    section.add "X-Amz-Date", valid_604055
  var valid_604056 = header.getOrDefault("X-Amz-Credential")
  valid_604056 = validateParameter(valid_604056, JString, required = false,
                                 default = nil)
  if valid_604056 != nil:
    section.add "X-Amz-Credential", valid_604056
  var valid_604057 = header.getOrDefault("X-Amz-Security-Token")
  valid_604057 = validateParameter(valid_604057, JString, required = false,
                                 default = nil)
  if valid_604057 != nil:
    section.add "X-Amz-Security-Token", valid_604057
  var valid_604058 = header.getOrDefault("X-Amz-Algorithm")
  valid_604058 = validateParameter(valid_604058, JString, required = false,
                                 default = nil)
  if valid_604058 != nil:
    section.add "X-Amz-Algorithm", valid_604058
  var valid_604059 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604059 = validateParameter(valid_604059, JString, required = false,
                                 default = nil)
  if valid_604059 != nil:
    section.add "X-Amz-SignedHeaders", valid_604059
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  section = newJObject()
  var valid_604060 = formData.getOrDefault("MaxRecords")
  valid_604060 = validateParameter(valid_604060, JInt, required = false, default = nil)
  if valid_604060 != nil:
    section.add "MaxRecords", valid_604060
  var valid_604061 = formData.getOrDefault("ScheduledActionName")
  valid_604061 = validateParameter(valid_604061, JString, required = false,
                                 default = nil)
  if valid_604061 != nil:
    section.add "ScheduledActionName", valid_604061
  var valid_604062 = formData.getOrDefault("Marker")
  valid_604062 = validateParameter(valid_604062, JString, required = false,
                                 default = nil)
  if valid_604062 != nil:
    section.add "Marker", valid_604062
  var valid_604063 = formData.getOrDefault("EndTime")
  valid_604063 = validateParameter(valid_604063, JString, required = false,
                                 default = nil)
  if valid_604063 != nil:
    section.add "EndTime", valid_604063
  var valid_604064 = formData.getOrDefault("StartTime")
  valid_604064 = validateParameter(valid_604064, JString, required = false,
                                 default = nil)
  if valid_604064 != nil:
    section.add "StartTime", valid_604064
  var valid_604065 = formData.getOrDefault("Filters")
  valid_604065 = validateParameter(valid_604065, JArray, required = false,
                                 default = nil)
  if valid_604065 != nil:
    section.add "Filters", valid_604065
  var valid_604066 = formData.getOrDefault("TargetActionType")
  valid_604066 = validateParameter(valid_604066, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_604066 != nil:
    section.add "TargetActionType", valid_604066
  var valid_604067 = formData.getOrDefault("Active")
  valid_604067 = validateParameter(valid_604067, JBool, required = false, default = nil)
  if valid_604067 != nil:
    section.add "Active", valid_604067
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604068: Call_PostDescribeScheduledActions_604048; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_604068.validator(path, query, header, formData, body)
  let scheme = call_604068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604068.url(scheme.get, call_604068.host, call_604068.base,
                         call_604068.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604068, url, valid)

proc call*(call_604069: Call_PostDescribeScheduledActions_604048;
          MaxRecords: int = 0; ScheduledActionName: string = ""; Marker: string = "";
          EndTime: string = ""; StartTime: string = "";
          Action: string = "DescribeScheduledActions"; Filters: JsonNode = nil;
          TargetActionType: string = "ResizeCluster";
          Version: string = "2012-12-01"; Active: bool = false): Recallable =
  ## postDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Action: string (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  ##   Version: string (required)
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  var query_604070 = newJObject()
  var formData_604071 = newJObject()
  add(formData_604071, "MaxRecords", newJInt(MaxRecords))
  add(formData_604071, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_604071, "Marker", newJString(Marker))
  add(formData_604071, "EndTime", newJString(EndTime))
  add(formData_604071, "StartTime", newJString(StartTime))
  add(query_604070, "Action", newJString(Action))
  if Filters != nil:
    formData_604071.add "Filters", Filters
  add(formData_604071, "TargetActionType", newJString(TargetActionType))
  add(query_604070, "Version", newJString(Version))
  add(formData_604071, "Active", newJBool(Active))
  result = call_604069.call(nil, query_604070, nil, formData_604071, nil)

var postDescribeScheduledActions* = Call_PostDescribeScheduledActions_604048(
    name: "postDescribeScheduledActions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_PostDescribeScheduledActions_604049, base: "/",
    url: url_PostDescribeScheduledActions_604050,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeScheduledActions_604025 = ref object of OpenApiRestCall_601373
proc url_GetDescribeScheduledActions_604027(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeScheduledActions_604026(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: JString (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_604028 = query.getOrDefault("Marker")
  valid_604028 = validateParameter(valid_604028, JString, required = false,
                                 default = nil)
  if valid_604028 != nil:
    section.add "Marker", valid_604028
  var valid_604029 = query.getOrDefault("TargetActionType")
  valid_604029 = validateParameter(valid_604029, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_604029 != nil:
    section.add "TargetActionType", valid_604029
  var valid_604030 = query.getOrDefault("ScheduledActionName")
  valid_604030 = validateParameter(valid_604030, JString, required = false,
                                 default = nil)
  if valid_604030 != nil:
    section.add "ScheduledActionName", valid_604030
  var valid_604031 = query.getOrDefault("Active")
  valid_604031 = validateParameter(valid_604031, JBool, required = false, default = nil)
  if valid_604031 != nil:
    section.add "Active", valid_604031
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604032 = query.getOrDefault("Action")
  valid_604032 = validateParameter(valid_604032, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_604032 != nil:
    section.add "Action", valid_604032
  var valid_604033 = query.getOrDefault("StartTime")
  valid_604033 = validateParameter(valid_604033, JString, required = false,
                                 default = nil)
  if valid_604033 != nil:
    section.add "StartTime", valid_604033
  var valid_604034 = query.getOrDefault("EndTime")
  valid_604034 = validateParameter(valid_604034, JString, required = false,
                                 default = nil)
  if valid_604034 != nil:
    section.add "EndTime", valid_604034
  var valid_604035 = query.getOrDefault("Version")
  valid_604035 = validateParameter(valid_604035, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604035 != nil:
    section.add "Version", valid_604035
  var valid_604036 = query.getOrDefault("Filters")
  valid_604036 = validateParameter(valid_604036, JArray, required = false,
                                 default = nil)
  if valid_604036 != nil:
    section.add "Filters", valid_604036
  var valid_604037 = query.getOrDefault("MaxRecords")
  valid_604037 = validateParameter(valid_604037, JInt, required = false, default = nil)
  if valid_604037 != nil:
    section.add "MaxRecords", valid_604037
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604038 = header.getOrDefault("X-Amz-Signature")
  valid_604038 = validateParameter(valid_604038, JString, required = false,
                                 default = nil)
  if valid_604038 != nil:
    section.add "X-Amz-Signature", valid_604038
  var valid_604039 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604039 = validateParameter(valid_604039, JString, required = false,
                                 default = nil)
  if valid_604039 != nil:
    section.add "X-Amz-Content-Sha256", valid_604039
  var valid_604040 = header.getOrDefault("X-Amz-Date")
  valid_604040 = validateParameter(valid_604040, JString, required = false,
                                 default = nil)
  if valid_604040 != nil:
    section.add "X-Amz-Date", valid_604040
  var valid_604041 = header.getOrDefault("X-Amz-Credential")
  valid_604041 = validateParameter(valid_604041, JString, required = false,
                                 default = nil)
  if valid_604041 != nil:
    section.add "X-Amz-Credential", valid_604041
  var valid_604042 = header.getOrDefault("X-Amz-Security-Token")
  valid_604042 = validateParameter(valid_604042, JString, required = false,
                                 default = nil)
  if valid_604042 != nil:
    section.add "X-Amz-Security-Token", valid_604042
  var valid_604043 = header.getOrDefault("X-Amz-Algorithm")
  valid_604043 = validateParameter(valid_604043, JString, required = false,
                                 default = nil)
  if valid_604043 != nil:
    section.add "X-Amz-Algorithm", valid_604043
  var valid_604044 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604044 = validateParameter(valid_604044, JString, required = false,
                                 default = nil)
  if valid_604044 != nil:
    section.add "X-Amz-SignedHeaders", valid_604044
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604045: Call_GetDescribeScheduledActions_604025; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_604045.validator(path, query, header, formData, body)
  let scheme = call_604045.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604045.url(scheme.get, call_604045.host, call_604045.base,
                         call_604045.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604045, url, valid)

proc call*(call_604046: Call_GetDescribeScheduledActions_604025;
          Marker: string = ""; TargetActionType: string = "ResizeCluster";
          ScheduledActionName: string = ""; Active: bool = false;
          Action: string = "DescribeScheduledActions"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"; Filters: JsonNode = nil;
          MaxRecords: int = 0): Recallable =
  ## getDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: string (required)
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_604047 = newJObject()
  add(query_604047, "Marker", newJString(Marker))
  add(query_604047, "TargetActionType", newJString(TargetActionType))
  add(query_604047, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_604047, "Active", newJBool(Active))
  add(query_604047, "Action", newJString(Action))
  add(query_604047, "StartTime", newJString(StartTime))
  add(query_604047, "EndTime", newJString(EndTime))
  add(query_604047, "Version", newJString(Version))
  if Filters != nil:
    query_604047.add "Filters", Filters
  add(query_604047, "MaxRecords", newJInt(MaxRecords))
  result = call_604046.call(nil, query_604047, nil, nil, nil)

var getDescribeScheduledActions* = Call_GetDescribeScheduledActions_604025(
    name: "getDescribeScheduledActions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_GetDescribeScheduledActions_604026, base: "/",
    url: url_GetDescribeScheduledActions_604027,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotCopyGrants_604092 = ref object of OpenApiRestCall_601373
proc url_PostDescribeSnapshotCopyGrants_604094(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotCopyGrants_604093(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604095 = query.getOrDefault("Action")
  valid_604095 = validateParameter(valid_604095, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_604095 != nil:
    section.add "Action", valid_604095
  var valid_604096 = query.getOrDefault("Version")
  valid_604096 = validateParameter(valid_604096, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604096 != nil:
    section.add "Version", valid_604096
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604097 = header.getOrDefault("X-Amz-Signature")
  valid_604097 = validateParameter(valid_604097, JString, required = false,
                                 default = nil)
  if valid_604097 != nil:
    section.add "X-Amz-Signature", valid_604097
  var valid_604098 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604098 = validateParameter(valid_604098, JString, required = false,
                                 default = nil)
  if valid_604098 != nil:
    section.add "X-Amz-Content-Sha256", valid_604098
  var valid_604099 = header.getOrDefault("X-Amz-Date")
  valid_604099 = validateParameter(valid_604099, JString, required = false,
                                 default = nil)
  if valid_604099 != nil:
    section.add "X-Amz-Date", valid_604099
  var valid_604100 = header.getOrDefault("X-Amz-Credential")
  valid_604100 = validateParameter(valid_604100, JString, required = false,
                                 default = nil)
  if valid_604100 != nil:
    section.add "X-Amz-Credential", valid_604100
  var valid_604101 = header.getOrDefault("X-Amz-Security-Token")
  valid_604101 = validateParameter(valid_604101, JString, required = false,
                                 default = nil)
  if valid_604101 != nil:
    section.add "X-Amz-Security-Token", valid_604101
  var valid_604102 = header.getOrDefault("X-Amz-Algorithm")
  valid_604102 = validateParameter(valid_604102, JString, required = false,
                                 default = nil)
  if valid_604102 != nil:
    section.add "X-Amz-Algorithm", valid_604102
  var valid_604103 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604103 = validateParameter(valid_604103, JString, required = false,
                                 default = nil)
  if valid_604103 != nil:
    section.add "X-Amz-SignedHeaders", valid_604103
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  section = newJObject()
  var valid_604104 = formData.getOrDefault("TagKeys")
  valid_604104 = validateParameter(valid_604104, JArray, required = false,
                                 default = nil)
  if valid_604104 != nil:
    section.add "TagKeys", valid_604104
  var valid_604105 = formData.getOrDefault("MaxRecords")
  valid_604105 = validateParameter(valid_604105, JInt, required = false, default = nil)
  if valid_604105 != nil:
    section.add "MaxRecords", valid_604105
  var valid_604106 = formData.getOrDefault("Marker")
  valid_604106 = validateParameter(valid_604106, JString, required = false,
                                 default = nil)
  if valid_604106 != nil:
    section.add "Marker", valid_604106
  var valid_604107 = formData.getOrDefault("TagValues")
  valid_604107 = validateParameter(valid_604107, JArray, required = false,
                                 default = nil)
  if valid_604107 != nil:
    section.add "TagValues", valid_604107
  var valid_604108 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_604108 = validateParameter(valid_604108, JString, required = false,
                                 default = nil)
  if valid_604108 != nil:
    section.add "SnapshotCopyGrantName", valid_604108
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604109: Call_PostDescribeSnapshotCopyGrants_604092; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_604109.validator(path, query, header, formData, body)
  let scheme = call_604109.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604109.url(scheme.get, call_604109.host, call_604109.base,
                         call_604109.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604109, url, valid)

proc call*(call_604110: Call_PostDescribeSnapshotCopyGrants_604092;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeSnapshotCopyGrants";
          SnapshotCopyGrantName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   Version: string (required)
  var query_604111 = newJObject()
  var formData_604112 = newJObject()
  if TagKeys != nil:
    formData_604112.add "TagKeys", TagKeys
  add(formData_604112, "MaxRecords", newJInt(MaxRecords))
  add(formData_604112, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_604112.add "TagValues", TagValues
  add(query_604111, "Action", newJString(Action))
  add(formData_604112, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_604111, "Version", newJString(Version))
  result = call_604110.call(nil, query_604111, nil, formData_604112, nil)

var postDescribeSnapshotCopyGrants* = Call_PostDescribeSnapshotCopyGrants_604092(
    name: "postDescribeSnapshotCopyGrants", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_PostDescribeSnapshotCopyGrants_604093, base: "/",
    url: url_PostDescribeSnapshotCopyGrants_604094,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotCopyGrants_604072 = ref object of OpenApiRestCall_601373
proc url_GetDescribeSnapshotCopyGrants_604074(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotCopyGrants_604073(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_604075 = query.getOrDefault("Marker")
  valid_604075 = validateParameter(valid_604075, JString, required = false,
                                 default = nil)
  if valid_604075 != nil:
    section.add "Marker", valid_604075
  var valid_604076 = query.getOrDefault("TagKeys")
  valid_604076 = validateParameter(valid_604076, JArray, required = false,
                                 default = nil)
  if valid_604076 != nil:
    section.add "TagKeys", valid_604076
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604077 = query.getOrDefault("Action")
  valid_604077 = validateParameter(valid_604077, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_604077 != nil:
    section.add "Action", valid_604077
  var valid_604078 = query.getOrDefault("Version")
  valid_604078 = validateParameter(valid_604078, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604078 != nil:
    section.add "Version", valid_604078
  var valid_604079 = query.getOrDefault("SnapshotCopyGrantName")
  valid_604079 = validateParameter(valid_604079, JString, required = false,
                                 default = nil)
  if valid_604079 != nil:
    section.add "SnapshotCopyGrantName", valid_604079
  var valid_604080 = query.getOrDefault("MaxRecords")
  valid_604080 = validateParameter(valid_604080, JInt, required = false, default = nil)
  if valid_604080 != nil:
    section.add "MaxRecords", valid_604080
  var valid_604081 = query.getOrDefault("TagValues")
  valid_604081 = validateParameter(valid_604081, JArray, required = false,
                                 default = nil)
  if valid_604081 != nil:
    section.add "TagValues", valid_604081
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604082 = header.getOrDefault("X-Amz-Signature")
  valid_604082 = validateParameter(valid_604082, JString, required = false,
                                 default = nil)
  if valid_604082 != nil:
    section.add "X-Amz-Signature", valid_604082
  var valid_604083 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604083 = validateParameter(valid_604083, JString, required = false,
                                 default = nil)
  if valid_604083 != nil:
    section.add "X-Amz-Content-Sha256", valid_604083
  var valid_604084 = header.getOrDefault("X-Amz-Date")
  valid_604084 = validateParameter(valid_604084, JString, required = false,
                                 default = nil)
  if valid_604084 != nil:
    section.add "X-Amz-Date", valid_604084
  var valid_604085 = header.getOrDefault("X-Amz-Credential")
  valid_604085 = validateParameter(valid_604085, JString, required = false,
                                 default = nil)
  if valid_604085 != nil:
    section.add "X-Amz-Credential", valid_604085
  var valid_604086 = header.getOrDefault("X-Amz-Security-Token")
  valid_604086 = validateParameter(valid_604086, JString, required = false,
                                 default = nil)
  if valid_604086 != nil:
    section.add "X-Amz-Security-Token", valid_604086
  var valid_604087 = header.getOrDefault("X-Amz-Algorithm")
  valid_604087 = validateParameter(valid_604087, JString, required = false,
                                 default = nil)
  if valid_604087 != nil:
    section.add "X-Amz-Algorithm", valid_604087
  var valid_604088 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604088 = validateParameter(valid_604088, JString, required = false,
                                 default = nil)
  if valid_604088 != nil:
    section.add "X-Amz-SignedHeaders", valid_604088
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604089: Call_GetDescribeSnapshotCopyGrants_604072; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_604089.validator(path, query, header, formData, body)
  let scheme = call_604089.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604089.url(scheme.get, call_604089.host, call_604089.base,
                         call_604089.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604089, url, valid)

proc call*(call_604090: Call_GetDescribeSnapshotCopyGrants_604072;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeSnapshotCopyGrants";
          Version: string = "2012-12-01"; SnapshotCopyGrantName: string = "";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  var query_604091 = newJObject()
  add(query_604091, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_604091.add "TagKeys", TagKeys
  add(query_604091, "Action", newJString(Action))
  add(query_604091, "Version", newJString(Version))
  add(query_604091, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_604091, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_604091.add "TagValues", TagValues
  result = call_604090.call(nil, query_604091, nil, nil, nil)

var getDescribeSnapshotCopyGrants* = Call_GetDescribeSnapshotCopyGrants_604072(
    name: "getDescribeSnapshotCopyGrants", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_GetDescribeSnapshotCopyGrants_604073, base: "/",
    url: url_GetDescribeSnapshotCopyGrants_604074,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotSchedules_604134 = ref object of OpenApiRestCall_601373
proc url_PostDescribeSnapshotSchedules_604136(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotSchedules_604135(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604137 = query.getOrDefault("Action")
  valid_604137 = validateParameter(valid_604137, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_604137 != nil:
    section.add "Action", valid_604137
  var valid_604138 = query.getOrDefault("Version")
  valid_604138 = validateParameter(valid_604138, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604138 != nil:
    section.add "Version", valid_604138
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604139 = header.getOrDefault("X-Amz-Signature")
  valid_604139 = validateParameter(valid_604139, JString, required = false,
                                 default = nil)
  if valid_604139 != nil:
    section.add "X-Amz-Signature", valid_604139
  var valid_604140 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604140 = validateParameter(valid_604140, JString, required = false,
                                 default = nil)
  if valid_604140 != nil:
    section.add "X-Amz-Content-Sha256", valid_604140
  var valid_604141 = header.getOrDefault("X-Amz-Date")
  valid_604141 = validateParameter(valid_604141, JString, required = false,
                                 default = nil)
  if valid_604141 != nil:
    section.add "X-Amz-Date", valid_604141
  var valid_604142 = header.getOrDefault("X-Amz-Credential")
  valid_604142 = validateParameter(valid_604142, JString, required = false,
                                 default = nil)
  if valid_604142 != nil:
    section.add "X-Amz-Credential", valid_604142
  var valid_604143 = header.getOrDefault("X-Amz-Security-Token")
  valid_604143 = validateParameter(valid_604143, JString, required = false,
                                 default = nil)
  if valid_604143 != nil:
    section.add "X-Amz-Security-Token", valid_604143
  var valid_604144 = header.getOrDefault("X-Amz-Algorithm")
  valid_604144 = validateParameter(valid_604144, JString, required = false,
                                 default = nil)
  if valid_604144 != nil:
    section.add "X-Amz-Algorithm", valid_604144
  var valid_604145 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604145 = validateParameter(valid_604145, JString, required = false,
                                 default = nil)
  if valid_604145 != nil:
    section.add "X-Amz-SignedHeaders", valid_604145
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  section = newJObject()
  var valid_604146 = formData.getOrDefault("TagKeys")
  valid_604146 = validateParameter(valid_604146, JArray, required = false,
                                 default = nil)
  if valid_604146 != nil:
    section.add "TagKeys", valid_604146
  var valid_604147 = formData.getOrDefault("ClusterIdentifier")
  valid_604147 = validateParameter(valid_604147, JString, required = false,
                                 default = nil)
  if valid_604147 != nil:
    section.add "ClusterIdentifier", valid_604147
  var valid_604148 = formData.getOrDefault("MaxRecords")
  valid_604148 = validateParameter(valid_604148, JInt, required = false, default = nil)
  if valid_604148 != nil:
    section.add "MaxRecords", valid_604148
  var valid_604149 = formData.getOrDefault("Marker")
  valid_604149 = validateParameter(valid_604149, JString, required = false,
                                 default = nil)
  if valid_604149 != nil:
    section.add "Marker", valid_604149
  var valid_604150 = formData.getOrDefault("TagValues")
  valid_604150 = validateParameter(valid_604150, JArray, required = false,
                                 default = nil)
  if valid_604150 != nil:
    section.add "TagValues", valid_604150
  var valid_604151 = formData.getOrDefault("ScheduleIdentifier")
  valid_604151 = validateParameter(valid_604151, JString, required = false,
                                 default = nil)
  if valid_604151 != nil:
    section.add "ScheduleIdentifier", valid_604151
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604152: Call_PostDescribeSnapshotSchedules_604134; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_604152.validator(path, query, header, formData, body)
  let scheme = call_604152.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604152.url(scheme.get, call_604152.host, call_604152.base,
                         call_604152.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604152, url, valid)

proc call*(call_604153: Call_PostDescribeSnapshotSchedules_604134;
          TagKeys: JsonNode = nil; ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Marker: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeSnapshotSchedules";
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   Version: string (required)
  var query_604154 = newJObject()
  var formData_604155 = newJObject()
  if TagKeys != nil:
    formData_604155.add "TagKeys", TagKeys
  add(formData_604155, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_604155, "MaxRecords", newJInt(MaxRecords))
  add(formData_604155, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_604155.add "TagValues", TagValues
  add(query_604154, "Action", newJString(Action))
  add(formData_604155, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_604154, "Version", newJString(Version))
  result = call_604153.call(nil, query_604154, nil, formData_604155, nil)

var postDescribeSnapshotSchedules* = Call_PostDescribeSnapshotSchedules_604134(
    name: "postDescribeSnapshotSchedules", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_PostDescribeSnapshotSchedules_604135, base: "/",
    url: url_PostDescribeSnapshotSchedules_604136,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotSchedules_604113 = ref object of OpenApiRestCall_601373
proc url_GetDescribeSnapshotSchedules_604115(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotSchedules_604114(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  section = newJObject()
  var valid_604116 = query.getOrDefault("Marker")
  valid_604116 = validateParameter(valid_604116, JString, required = false,
                                 default = nil)
  if valid_604116 != nil:
    section.add "Marker", valid_604116
  var valid_604117 = query.getOrDefault("ScheduleIdentifier")
  valid_604117 = validateParameter(valid_604117, JString, required = false,
                                 default = nil)
  if valid_604117 != nil:
    section.add "ScheduleIdentifier", valid_604117
  var valid_604118 = query.getOrDefault("TagKeys")
  valid_604118 = validateParameter(valid_604118, JArray, required = false,
                                 default = nil)
  if valid_604118 != nil:
    section.add "TagKeys", valid_604118
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604119 = query.getOrDefault("Action")
  valid_604119 = validateParameter(valid_604119, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_604119 != nil:
    section.add "Action", valid_604119
  var valid_604120 = query.getOrDefault("ClusterIdentifier")
  valid_604120 = validateParameter(valid_604120, JString, required = false,
                                 default = nil)
  if valid_604120 != nil:
    section.add "ClusterIdentifier", valid_604120
  var valid_604121 = query.getOrDefault("Version")
  valid_604121 = validateParameter(valid_604121, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604121 != nil:
    section.add "Version", valid_604121
  var valid_604122 = query.getOrDefault("MaxRecords")
  valid_604122 = validateParameter(valid_604122, JInt, required = false, default = nil)
  if valid_604122 != nil:
    section.add "MaxRecords", valid_604122
  var valid_604123 = query.getOrDefault("TagValues")
  valid_604123 = validateParameter(valid_604123, JArray, required = false,
                                 default = nil)
  if valid_604123 != nil:
    section.add "TagValues", valid_604123
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604124 = header.getOrDefault("X-Amz-Signature")
  valid_604124 = validateParameter(valid_604124, JString, required = false,
                                 default = nil)
  if valid_604124 != nil:
    section.add "X-Amz-Signature", valid_604124
  var valid_604125 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604125 = validateParameter(valid_604125, JString, required = false,
                                 default = nil)
  if valid_604125 != nil:
    section.add "X-Amz-Content-Sha256", valid_604125
  var valid_604126 = header.getOrDefault("X-Amz-Date")
  valid_604126 = validateParameter(valid_604126, JString, required = false,
                                 default = nil)
  if valid_604126 != nil:
    section.add "X-Amz-Date", valid_604126
  var valid_604127 = header.getOrDefault("X-Amz-Credential")
  valid_604127 = validateParameter(valid_604127, JString, required = false,
                                 default = nil)
  if valid_604127 != nil:
    section.add "X-Amz-Credential", valid_604127
  var valid_604128 = header.getOrDefault("X-Amz-Security-Token")
  valid_604128 = validateParameter(valid_604128, JString, required = false,
                                 default = nil)
  if valid_604128 != nil:
    section.add "X-Amz-Security-Token", valid_604128
  var valid_604129 = header.getOrDefault("X-Amz-Algorithm")
  valid_604129 = validateParameter(valid_604129, JString, required = false,
                                 default = nil)
  if valid_604129 != nil:
    section.add "X-Amz-Algorithm", valid_604129
  var valid_604130 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604130 = validateParameter(valid_604130, JString, required = false,
                                 default = nil)
  if valid_604130 != nil:
    section.add "X-Amz-SignedHeaders", valid_604130
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604131: Call_GetDescribeSnapshotSchedules_604113; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_604131.validator(path, query, header, formData, body)
  let scheme = call_604131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604131.url(scheme.get, call_604131.host, call_604131.base,
                         call_604131.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604131, url, valid)

proc call*(call_604132: Call_GetDescribeSnapshotSchedules_604113;
          Marker: string = ""; ScheduleIdentifier: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  var query_604133 = newJObject()
  add(query_604133, "Marker", newJString(Marker))
  add(query_604133, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if TagKeys != nil:
    query_604133.add "TagKeys", TagKeys
  add(query_604133, "Action", newJString(Action))
  add(query_604133, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604133, "Version", newJString(Version))
  add(query_604133, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_604133.add "TagValues", TagValues
  result = call_604132.call(nil, query_604133, nil, nil, nil)

var getDescribeSnapshotSchedules* = Call_GetDescribeSnapshotSchedules_604113(
    name: "getDescribeSnapshotSchedules", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_GetDescribeSnapshotSchedules_604114, base: "/",
    url: url_GetDescribeSnapshotSchedules_604115,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeStorage_604171 = ref object of OpenApiRestCall_601373
proc url_PostDescribeStorage_604173(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeStorage_604172(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604174 = query.getOrDefault("Action")
  valid_604174 = validateParameter(valid_604174, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_604174 != nil:
    section.add "Action", valid_604174
  var valid_604175 = query.getOrDefault("Version")
  valid_604175 = validateParameter(valid_604175, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604175 != nil:
    section.add "Version", valid_604175
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604176 = header.getOrDefault("X-Amz-Signature")
  valid_604176 = validateParameter(valid_604176, JString, required = false,
                                 default = nil)
  if valid_604176 != nil:
    section.add "X-Amz-Signature", valid_604176
  var valid_604177 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604177 = validateParameter(valid_604177, JString, required = false,
                                 default = nil)
  if valid_604177 != nil:
    section.add "X-Amz-Content-Sha256", valid_604177
  var valid_604178 = header.getOrDefault("X-Amz-Date")
  valid_604178 = validateParameter(valid_604178, JString, required = false,
                                 default = nil)
  if valid_604178 != nil:
    section.add "X-Amz-Date", valid_604178
  var valid_604179 = header.getOrDefault("X-Amz-Credential")
  valid_604179 = validateParameter(valid_604179, JString, required = false,
                                 default = nil)
  if valid_604179 != nil:
    section.add "X-Amz-Credential", valid_604179
  var valid_604180 = header.getOrDefault("X-Amz-Security-Token")
  valid_604180 = validateParameter(valid_604180, JString, required = false,
                                 default = nil)
  if valid_604180 != nil:
    section.add "X-Amz-Security-Token", valid_604180
  var valid_604181 = header.getOrDefault("X-Amz-Algorithm")
  valid_604181 = validateParameter(valid_604181, JString, required = false,
                                 default = nil)
  if valid_604181 != nil:
    section.add "X-Amz-Algorithm", valid_604181
  var valid_604182 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604182 = validateParameter(valid_604182, JString, required = false,
                                 default = nil)
  if valid_604182 != nil:
    section.add "X-Amz-SignedHeaders", valid_604182
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604183: Call_PostDescribeStorage_604171; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_604183.validator(path, query, header, formData, body)
  let scheme = call_604183.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604183.url(scheme.get, call_604183.host, call_604183.base,
                         call_604183.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604183, url, valid)

proc call*(call_604184: Call_PostDescribeStorage_604171;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604185 = newJObject()
  add(query_604185, "Action", newJString(Action))
  add(query_604185, "Version", newJString(Version))
  result = call_604184.call(nil, query_604185, nil, nil, nil)

var postDescribeStorage* = Call_PostDescribeStorage_604171(
    name: "postDescribeStorage", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_PostDescribeStorage_604172, base: "/",
    url: url_PostDescribeStorage_604173, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeStorage_604156 = ref object of OpenApiRestCall_601373
proc url_GetDescribeStorage_604158(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeStorage_604157(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604159 = query.getOrDefault("Action")
  valid_604159 = validateParameter(valid_604159, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_604159 != nil:
    section.add "Action", valid_604159
  var valid_604160 = query.getOrDefault("Version")
  valid_604160 = validateParameter(valid_604160, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604160 != nil:
    section.add "Version", valid_604160
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604161 = header.getOrDefault("X-Amz-Signature")
  valid_604161 = validateParameter(valid_604161, JString, required = false,
                                 default = nil)
  if valid_604161 != nil:
    section.add "X-Amz-Signature", valid_604161
  var valid_604162 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604162 = validateParameter(valid_604162, JString, required = false,
                                 default = nil)
  if valid_604162 != nil:
    section.add "X-Amz-Content-Sha256", valid_604162
  var valid_604163 = header.getOrDefault("X-Amz-Date")
  valid_604163 = validateParameter(valid_604163, JString, required = false,
                                 default = nil)
  if valid_604163 != nil:
    section.add "X-Amz-Date", valid_604163
  var valid_604164 = header.getOrDefault("X-Amz-Credential")
  valid_604164 = validateParameter(valid_604164, JString, required = false,
                                 default = nil)
  if valid_604164 != nil:
    section.add "X-Amz-Credential", valid_604164
  var valid_604165 = header.getOrDefault("X-Amz-Security-Token")
  valid_604165 = validateParameter(valid_604165, JString, required = false,
                                 default = nil)
  if valid_604165 != nil:
    section.add "X-Amz-Security-Token", valid_604165
  var valid_604166 = header.getOrDefault("X-Amz-Algorithm")
  valid_604166 = validateParameter(valid_604166, JString, required = false,
                                 default = nil)
  if valid_604166 != nil:
    section.add "X-Amz-Algorithm", valid_604166
  var valid_604167 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604167 = validateParameter(valid_604167, JString, required = false,
                                 default = nil)
  if valid_604167 != nil:
    section.add "X-Amz-SignedHeaders", valid_604167
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604168: Call_GetDescribeStorage_604156; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_604168.validator(path, query, header, formData, body)
  let scheme = call_604168.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604168.url(scheme.get, call_604168.host, call_604168.base,
                         call_604168.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604168, url, valid)

proc call*(call_604169: Call_GetDescribeStorage_604156;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604170 = newJObject()
  add(query_604170, "Action", newJString(Action))
  add(query_604170, "Version", newJString(Version))
  result = call_604169.call(nil, query_604170, nil, nil, nil)

var getDescribeStorage* = Call_GetDescribeStorage_604156(
    name: "getDescribeStorage", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_GetDescribeStorage_604157, base: "/",
    url: url_GetDescribeStorage_604158, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTableRestoreStatus_604205 = ref object of OpenApiRestCall_601373
proc url_PostDescribeTableRestoreStatus_604207(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTableRestoreStatus_604206(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604208 = query.getOrDefault("Action")
  valid_604208 = validateParameter(valid_604208, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_604208 != nil:
    section.add "Action", valid_604208
  var valid_604209 = query.getOrDefault("Version")
  valid_604209 = validateParameter(valid_604209, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604209 != nil:
    section.add "Version", valid_604209
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604210 = header.getOrDefault("X-Amz-Signature")
  valid_604210 = validateParameter(valid_604210, JString, required = false,
                                 default = nil)
  if valid_604210 != nil:
    section.add "X-Amz-Signature", valid_604210
  var valid_604211 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604211 = validateParameter(valid_604211, JString, required = false,
                                 default = nil)
  if valid_604211 != nil:
    section.add "X-Amz-Content-Sha256", valid_604211
  var valid_604212 = header.getOrDefault("X-Amz-Date")
  valid_604212 = validateParameter(valid_604212, JString, required = false,
                                 default = nil)
  if valid_604212 != nil:
    section.add "X-Amz-Date", valid_604212
  var valid_604213 = header.getOrDefault("X-Amz-Credential")
  valid_604213 = validateParameter(valid_604213, JString, required = false,
                                 default = nil)
  if valid_604213 != nil:
    section.add "X-Amz-Credential", valid_604213
  var valid_604214 = header.getOrDefault("X-Amz-Security-Token")
  valid_604214 = validateParameter(valid_604214, JString, required = false,
                                 default = nil)
  if valid_604214 != nil:
    section.add "X-Amz-Security-Token", valid_604214
  var valid_604215 = header.getOrDefault("X-Amz-Algorithm")
  valid_604215 = validateParameter(valid_604215, JString, required = false,
                                 default = nil)
  if valid_604215 != nil:
    section.add "X-Amz-Algorithm", valid_604215
  var valid_604216 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604216 = validateParameter(valid_604216, JString, required = false,
                                 default = nil)
  if valid_604216 != nil:
    section.add "X-Amz-SignedHeaders", valid_604216
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  section = newJObject()
  var valid_604217 = formData.getOrDefault("ClusterIdentifier")
  valid_604217 = validateParameter(valid_604217, JString, required = false,
                                 default = nil)
  if valid_604217 != nil:
    section.add "ClusterIdentifier", valid_604217
  var valid_604218 = formData.getOrDefault("TableRestoreRequestId")
  valid_604218 = validateParameter(valid_604218, JString, required = false,
                                 default = nil)
  if valid_604218 != nil:
    section.add "TableRestoreRequestId", valid_604218
  var valid_604219 = formData.getOrDefault("MaxRecords")
  valid_604219 = validateParameter(valid_604219, JInt, required = false, default = nil)
  if valid_604219 != nil:
    section.add "MaxRecords", valid_604219
  var valid_604220 = formData.getOrDefault("Marker")
  valid_604220 = validateParameter(valid_604220, JString, required = false,
                                 default = nil)
  if valid_604220 != nil:
    section.add "Marker", valid_604220
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604221: Call_PostDescribeTableRestoreStatus_604205; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_604221.validator(path, query, header, formData, body)
  let scheme = call_604221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604221.url(scheme.get, call_604221.host, call_604221.base,
                         call_604221.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604221, url, valid)

proc call*(call_604222: Call_PostDescribeTableRestoreStatus_604205;
          ClusterIdentifier: string = ""; TableRestoreRequestId: string = "";
          MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeTableRestoreStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604223 = newJObject()
  var formData_604224 = newJObject()
  add(formData_604224, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_604224, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(formData_604224, "MaxRecords", newJInt(MaxRecords))
  add(formData_604224, "Marker", newJString(Marker))
  add(query_604223, "Action", newJString(Action))
  add(query_604223, "Version", newJString(Version))
  result = call_604222.call(nil, query_604223, nil, formData_604224, nil)

var postDescribeTableRestoreStatus* = Call_PostDescribeTableRestoreStatus_604205(
    name: "postDescribeTableRestoreStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_PostDescribeTableRestoreStatus_604206, base: "/",
    url: url_PostDescribeTableRestoreStatus_604207,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTableRestoreStatus_604186 = ref object of OpenApiRestCall_601373
proc url_GetDescribeTableRestoreStatus_604188(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTableRestoreStatus_604187(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Version: JString (required)
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  section = newJObject()
  var valid_604189 = query.getOrDefault("Marker")
  valid_604189 = validateParameter(valid_604189, JString, required = false,
                                 default = nil)
  if valid_604189 != nil:
    section.add "Marker", valid_604189
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604190 = query.getOrDefault("Action")
  valid_604190 = validateParameter(valid_604190, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_604190 != nil:
    section.add "Action", valid_604190
  var valid_604191 = query.getOrDefault("ClusterIdentifier")
  valid_604191 = validateParameter(valid_604191, JString, required = false,
                                 default = nil)
  if valid_604191 != nil:
    section.add "ClusterIdentifier", valid_604191
  var valid_604192 = query.getOrDefault("Version")
  valid_604192 = validateParameter(valid_604192, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604192 != nil:
    section.add "Version", valid_604192
  var valid_604193 = query.getOrDefault("TableRestoreRequestId")
  valid_604193 = validateParameter(valid_604193, JString, required = false,
                                 default = nil)
  if valid_604193 != nil:
    section.add "TableRestoreRequestId", valid_604193
  var valid_604194 = query.getOrDefault("MaxRecords")
  valid_604194 = validateParameter(valid_604194, JInt, required = false, default = nil)
  if valid_604194 != nil:
    section.add "MaxRecords", valid_604194
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604195 = header.getOrDefault("X-Amz-Signature")
  valid_604195 = validateParameter(valid_604195, JString, required = false,
                                 default = nil)
  if valid_604195 != nil:
    section.add "X-Amz-Signature", valid_604195
  var valid_604196 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604196 = validateParameter(valid_604196, JString, required = false,
                                 default = nil)
  if valid_604196 != nil:
    section.add "X-Amz-Content-Sha256", valid_604196
  var valid_604197 = header.getOrDefault("X-Amz-Date")
  valid_604197 = validateParameter(valid_604197, JString, required = false,
                                 default = nil)
  if valid_604197 != nil:
    section.add "X-Amz-Date", valid_604197
  var valid_604198 = header.getOrDefault("X-Amz-Credential")
  valid_604198 = validateParameter(valid_604198, JString, required = false,
                                 default = nil)
  if valid_604198 != nil:
    section.add "X-Amz-Credential", valid_604198
  var valid_604199 = header.getOrDefault("X-Amz-Security-Token")
  valid_604199 = validateParameter(valid_604199, JString, required = false,
                                 default = nil)
  if valid_604199 != nil:
    section.add "X-Amz-Security-Token", valid_604199
  var valid_604200 = header.getOrDefault("X-Amz-Algorithm")
  valid_604200 = validateParameter(valid_604200, JString, required = false,
                                 default = nil)
  if valid_604200 != nil:
    section.add "X-Amz-Algorithm", valid_604200
  var valid_604201 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604201 = validateParameter(valid_604201, JString, required = false,
                                 default = nil)
  if valid_604201 != nil:
    section.add "X-Amz-SignedHeaders", valid_604201
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604202: Call_GetDescribeTableRestoreStatus_604186; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_604202.validator(path, query, header, formData, body)
  let scheme = call_604202.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604202.url(scheme.get, call_604202.host, call_604202.base,
                         call_604202.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604202, url, valid)

proc call*(call_604203: Call_GetDescribeTableRestoreStatus_604186;
          Marker: string = ""; Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          TableRestoreRequestId: string = ""; MaxRecords: int = 0): Recallable =
  ## getDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Version: string (required)
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  var query_604204 = newJObject()
  add(query_604204, "Marker", newJString(Marker))
  add(query_604204, "Action", newJString(Action))
  add(query_604204, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604204, "Version", newJString(Version))
  add(query_604204, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(query_604204, "MaxRecords", newJInt(MaxRecords))
  result = call_604203.call(nil, query_604204, nil, nil, nil)

var getDescribeTableRestoreStatus* = Call_GetDescribeTableRestoreStatus_604186(
    name: "getDescribeTableRestoreStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_GetDescribeTableRestoreStatus_604187, base: "/",
    url: url_GetDescribeTableRestoreStatus_604188,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTags_604246 = ref object of OpenApiRestCall_601373
proc url_PostDescribeTags_604248(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTags_604247(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604249 = query.getOrDefault("Action")
  valid_604249 = validateParameter(valid_604249, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_604249 != nil:
    section.add "Action", valid_604249
  var valid_604250 = query.getOrDefault("Version")
  valid_604250 = validateParameter(valid_604250, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604250 != nil:
    section.add "Version", valid_604250
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604251 = header.getOrDefault("X-Amz-Signature")
  valid_604251 = validateParameter(valid_604251, JString, required = false,
                                 default = nil)
  if valid_604251 != nil:
    section.add "X-Amz-Signature", valid_604251
  var valid_604252 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604252 = validateParameter(valid_604252, JString, required = false,
                                 default = nil)
  if valid_604252 != nil:
    section.add "X-Amz-Content-Sha256", valid_604252
  var valid_604253 = header.getOrDefault("X-Amz-Date")
  valid_604253 = validateParameter(valid_604253, JString, required = false,
                                 default = nil)
  if valid_604253 != nil:
    section.add "X-Amz-Date", valid_604253
  var valid_604254 = header.getOrDefault("X-Amz-Credential")
  valid_604254 = validateParameter(valid_604254, JString, required = false,
                                 default = nil)
  if valid_604254 != nil:
    section.add "X-Amz-Credential", valid_604254
  var valid_604255 = header.getOrDefault("X-Amz-Security-Token")
  valid_604255 = validateParameter(valid_604255, JString, required = false,
                                 default = nil)
  if valid_604255 != nil:
    section.add "X-Amz-Security-Token", valid_604255
  var valid_604256 = header.getOrDefault("X-Amz-Algorithm")
  valid_604256 = validateParameter(valid_604256, JString, required = false,
                                 default = nil)
  if valid_604256 != nil:
    section.add "X-Amz-Algorithm", valid_604256
  var valid_604257 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604257 = validateParameter(valid_604257, JString, required = false,
                                 default = nil)
  if valid_604257 != nil:
    section.add "X-Amz-SignedHeaders", valid_604257
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  var valid_604258 = formData.getOrDefault("TagKeys")
  valid_604258 = validateParameter(valid_604258, JArray, required = false,
                                 default = nil)
  if valid_604258 != nil:
    section.add "TagKeys", valid_604258
  var valid_604259 = formData.getOrDefault("MaxRecords")
  valid_604259 = validateParameter(valid_604259, JInt, required = false, default = nil)
  if valid_604259 != nil:
    section.add "MaxRecords", valid_604259
  var valid_604260 = formData.getOrDefault("ResourceType")
  valid_604260 = validateParameter(valid_604260, JString, required = false,
                                 default = nil)
  if valid_604260 != nil:
    section.add "ResourceType", valid_604260
  var valid_604261 = formData.getOrDefault("Marker")
  valid_604261 = validateParameter(valid_604261, JString, required = false,
                                 default = nil)
  if valid_604261 != nil:
    section.add "Marker", valid_604261
  var valid_604262 = formData.getOrDefault("TagValues")
  valid_604262 = validateParameter(valid_604262, JArray, required = false,
                                 default = nil)
  if valid_604262 != nil:
    section.add "TagValues", valid_604262
  var valid_604263 = formData.getOrDefault("ResourceName")
  valid_604263 = validateParameter(valid_604263, JString, required = false,
                                 default = nil)
  if valid_604263 != nil:
    section.add "ResourceName", valid_604263
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604264: Call_PostDescribeTags_604246; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604264.validator(path, query, header, formData, body)
  let scheme = call_604264.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604264.url(scheme.get, call_604264.host, call_604264.base,
                         call_604264.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604264, url, valid)

proc call*(call_604265: Call_PostDescribeTags_604246; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; ResourceType: string = ""; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeTags";
          Version: string = "2012-12-01"; ResourceName: string = ""): Recallable =
  ## postDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  var query_604266 = newJObject()
  var formData_604267 = newJObject()
  if TagKeys != nil:
    formData_604267.add "TagKeys", TagKeys
  add(formData_604267, "MaxRecords", newJInt(MaxRecords))
  add(formData_604267, "ResourceType", newJString(ResourceType))
  add(formData_604267, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_604267.add "TagValues", TagValues
  add(query_604266, "Action", newJString(Action))
  add(query_604266, "Version", newJString(Version))
  add(formData_604267, "ResourceName", newJString(ResourceName))
  result = call_604265.call(nil, query_604266, nil, formData_604267, nil)

var postDescribeTags* = Call_PostDescribeTags_604246(name: "postDescribeTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_PostDescribeTags_604247,
    base: "/", url: url_PostDescribeTags_604248,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTags_604225 = ref object of OpenApiRestCall_601373
proc url_GetDescribeTags_604227(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTags_604226(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_604228 = query.getOrDefault("Marker")
  valid_604228 = validateParameter(valid_604228, JString, required = false,
                                 default = nil)
  if valid_604228 != nil:
    section.add "Marker", valid_604228
  var valid_604229 = query.getOrDefault("ResourceName")
  valid_604229 = validateParameter(valid_604229, JString, required = false,
                                 default = nil)
  if valid_604229 != nil:
    section.add "ResourceName", valid_604229
  var valid_604230 = query.getOrDefault("ResourceType")
  valid_604230 = validateParameter(valid_604230, JString, required = false,
                                 default = nil)
  if valid_604230 != nil:
    section.add "ResourceType", valid_604230
  var valid_604231 = query.getOrDefault("TagKeys")
  valid_604231 = validateParameter(valid_604231, JArray, required = false,
                                 default = nil)
  if valid_604231 != nil:
    section.add "TagKeys", valid_604231
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604232 = query.getOrDefault("Action")
  valid_604232 = validateParameter(valid_604232, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_604232 != nil:
    section.add "Action", valid_604232
  var valid_604233 = query.getOrDefault("Version")
  valid_604233 = validateParameter(valid_604233, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604233 != nil:
    section.add "Version", valid_604233
  var valid_604234 = query.getOrDefault("MaxRecords")
  valid_604234 = validateParameter(valid_604234, JInt, required = false, default = nil)
  if valid_604234 != nil:
    section.add "MaxRecords", valid_604234
  var valid_604235 = query.getOrDefault("TagValues")
  valid_604235 = validateParameter(valid_604235, JArray, required = false,
                                 default = nil)
  if valid_604235 != nil:
    section.add "TagValues", valid_604235
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604236 = header.getOrDefault("X-Amz-Signature")
  valid_604236 = validateParameter(valid_604236, JString, required = false,
                                 default = nil)
  if valid_604236 != nil:
    section.add "X-Amz-Signature", valid_604236
  var valid_604237 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604237 = validateParameter(valid_604237, JString, required = false,
                                 default = nil)
  if valid_604237 != nil:
    section.add "X-Amz-Content-Sha256", valid_604237
  var valid_604238 = header.getOrDefault("X-Amz-Date")
  valid_604238 = validateParameter(valid_604238, JString, required = false,
                                 default = nil)
  if valid_604238 != nil:
    section.add "X-Amz-Date", valid_604238
  var valid_604239 = header.getOrDefault("X-Amz-Credential")
  valid_604239 = validateParameter(valid_604239, JString, required = false,
                                 default = nil)
  if valid_604239 != nil:
    section.add "X-Amz-Credential", valid_604239
  var valid_604240 = header.getOrDefault("X-Amz-Security-Token")
  valid_604240 = validateParameter(valid_604240, JString, required = false,
                                 default = nil)
  if valid_604240 != nil:
    section.add "X-Amz-Security-Token", valid_604240
  var valid_604241 = header.getOrDefault("X-Amz-Algorithm")
  valid_604241 = validateParameter(valid_604241, JString, required = false,
                                 default = nil)
  if valid_604241 != nil:
    section.add "X-Amz-Algorithm", valid_604241
  var valid_604242 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604242 = validateParameter(valid_604242, JString, required = false,
                                 default = nil)
  if valid_604242 != nil:
    section.add "X-Amz-SignedHeaders", valid_604242
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604243: Call_GetDescribeTags_604225; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_604243.validator(path, query, header, formData, body)
  let scheme = call_604243.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604243.url(scheme.get, call_604243.host, call_604243.base,
                         call_604243.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604243, url, valid)

proc call*(call_604244: Call_GetDescribeTags_604225; Marker: string = "";
          ResourceName: string = ""; ResourceType: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeTags"; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  var query_604245 = newJObject()
  add(query_604245, "Marker", newJString(Marker))
  add(query_604245, "ResourceName", newJString(ResourceName))
  add(query_604245, "ResourceType", newJString(ResourceType))
  if TagKeys != nil:
    query_604245.add "TagKeys", TagKeys
  add(query_604245, "Action", newJString(Action))
  add(query_604245, "Version", newJString(Version))
  add(query_604245, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_604245.add "TagValues", TagValues
  result = call_604244.call(nil, query_604245, nil, nil, nil)

var getDescribeTags* = Call_GetDescribeTags_604225(name: "getDescribeTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_GetDescribeTags_604226,
    base: "/", url: url_GetDescribeTags_604227, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableLogging_604284 = ref object of OpenApiRestCall_601373
proc url_PostDisableLogging_604286(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableLogging_604285(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604287 = query.getOrDefault("Action")
  valid_604287 = validateParameter(valid_604287, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_604287 != nil:
    section.add "Action", valid_604287
  var valid_604288 = query.getOrDefault("Version")
  valid_604288 = validateParameter(valid_604288, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604288 != nil:
    section.add "Version", valid_604288
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604289 = header.getOrDefault("X-Amz-Signature")
  valid_604289 = validateParameter(valid_604289, JString, required = false,
                                 default = nil)
  if valid_604289 != nil:
    section.add "X-Amz-Signature", valid_604289
  var valid_604290 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604290 = validateParameter(valid_604290, JString, required = false,
                                 default = nil)
  if valid_604290 != nil:
    section.add "X-Amz-Content-Sha256", valid_604290
  var valid_604291 = header.getOrDefault("X-Amz-Date")
  valid_604291 = validateParameter(valid_604291, JString, required = false,
                                 default = nil)
  if valid_604291 != nil:
    section.add "X-Amz-Date", valid_604291
  var valid_604292 = header.getOrDefault("X-Amz-Credential")
  valid_604292 = validateParameter(valid_604292, JString, required = false,
                                 default = nil)
  if valid_604292 != nil:
    section.add "X-Amz-Credential", valid_604292
  var valid_604293 = header.getOrDefault("X-Amz-Security-Token")
  valid_604293 = validateParameter(valid_604293, JString, required = false,
                                 default = nil)
  if valid_604293 != nil:
    section.add "X-Amz-Security-Token", valid_604293
  var valid_604294 = header.getOrDefault("X-Amz-Algorithm")
  valid_604294 = validateParameter(valid_604294, JString, required = false,
                                 default = nil)
  if valid_604294 != nil:
    section.add "X-Amz-Algorithm", valid_604294
  var valid_604295 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604295 = validateParameter(valid_604295, JString, required = false,
                                 default = nil)
  if valid_604295 != nil:
    section.add "X-Amz-SignedHeaders", valid_604295
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604296 = formData.getOrDefault("ClusterIdentifier")
  valid_604296 = validateParameter(valid_604296, JString, required = true,
                                 default = nil)
  if valid_604296 != nil:
    section.add "ClusterIdentifier", valid_604296
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604297: Call_PostDisableLogging_604284; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_604297.validator(path, query, header, formData, body)
  let scheme = call_604297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604297.url(scheme.get, call_604297.host, call_604297.base,
                         call_604297.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604297, url, valid)

proc call*(call_604298: Call_PostDisableLogging_604284; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604299 = newJObject()
  var formData_604300 = newJObject()
  add(formData_604300, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604299, "Action", newJString(Action))
  add(query_604299, "Version", newJString(Version))
  result = call_604298.call(nil, query_604299, nil, formData_604300, nil)

var postDisableLogging* = Call_PostDisableLogging_604284(
    name: "postDisableLogging", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableLogging",
    validator: validate_PostDisableLogging_604285, base: "/",
    url: url_PostDisableLogging_604286, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableLogging_604268 = ref object of OpenApiRestCall_601373
proc url_GetDisableLogging_604270(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableLogging_604269(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604271 = query.getOrDefault("Action")
  valid_604271 = validateParameter(valid_604271, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_604271 != nil:
    section.add "Action", valid_604271
  var valid_604272 = query.getOrDefault("ClusterIdentifier")
  valid_604272 = validateParameter(valid_604272, JString, required = true,
                                 default = nil)
  if valid_604272 != nil:
    section.add "ClusterIdentifier", valid_604272
  var valid_604273 = query.getOrDefault("Version")
  valid_604273 = validateParameter(valid_604273, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604273 != nil:
    section.add "Version", valid_604273
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604274 = header.getOrDefault("X-Amz-Signature")
  valid_604274 = validateParameter(valid_604274, JString, required = false,
                                 default = nil)
  if valid_604274 != nil:
    section.add "X-Amz-Signature", valid_604274
  var valid_604275 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604275 = validateParameter(valid_604275, JString, required = false,
                                 default = nil)
  if valid_604275 != nil:
    section.add "X-Amz-Content-Sha256", valid_604275
  var valid_604276 = header.getOrDefault("X-Amz-Date")
  valid_604276 = validateParameter(valid_604276, JString, required = false,
                                 default = nil)
  if valid_604276 != nil:
    section.add "X-Amz-Date", valid_604276
  var valid_604277 = header.getOrDefault("X-Amz-Credential")
  valid_604277 = validateParameter(valid_604277, JString, required = false,
                                 default = nil)
  if valid_604277 != nil:
    section.add "X-Amz-Credential", valid_604277
  var valid_604278 = header.getOrDefault("X-Amz-Security-Token")
  valid_604278 = validateParameter(valid_604278, JString, required = false,
                                 default = nil)
  if valid_604278 != nil:
    section.add "X-Amz-Security-Token", valid_604278
  var valid_604279 = header.getOrDefault("X-Amz-Algorithm")
  valid_604279 = validateParameter(valid_604279, JString, required = false,
                                 default = nil)
  if valid_604279 != nil:
    section.add "X-Amz-Algorithm", valid_604279
  var valid_604280 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604280 = validateParameter(valid_604280, JString, required = false,
                                 default = nil)
  if valid_604280 != nil:
    section.add "X-Amz-SignedHeaders", valid_604280
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604281: Call_GetDisableLogging_604268; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_604281.validator(path, query, header, formData, body)
  let scheme = call_604281.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604281.url(scheme.get, call_604281.host, call_604281.base,
                         call_604281.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604281, url, valid)

proc call*(call_604282: Call_GetDisableLogging_604268; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_604283 = newJObject()
  add(query_604283, "Action", newJString(Action))
  add(query_604283, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604283, "Version", newJString(Version))
  result = call_604282.call(nil, query_604283, nil, nil, nil)

var getDisableLogging* = Call_GetDisableLogging_604268(name: "getDisableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DisableLogging", validator: validate_GetDisableLogging_604269,
    base: "/", url: url_GetDisableLogging_604270,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableSnapshotCopy_604317 = ref object of OpenApiRestCall_601373
proc url_PostDisableSnapshotCopy_604319(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableSnapshotCopy_604318(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604320 = query.getOrDefault("Action")
  valid_604320 = validateParameter(valid_604320, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_604320 != nil:
    section.add "Action", valid_604320
  var valid_604321 = query.getOrDefault("Version")
  valid_604321 = validateParameter(valid_604321, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604321 != nil:
    section.add "Version", valid_604321
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604322 = header.getOrDefault("X-Amz-Signature")
  valid_604322 = validateParameter(valid_604322, JString, required = false,
                                 default = nil)
  if valid_604322 != nil:
    section.add "X-Amz-Signature", valid_604322
  var valid_604323 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604323 = validateParameter(valid_604323, JString, required = false,
                                 default = nil)
  if valid_604323 != nil:
    section.add "X-Amz-Content-Sha256", valid_604323
  var valid_604324 = header.getOrDefault("X-Amz-Date")
  valid_604324 = validateParameter(valid_604324, JString, required = false,
                                 default = nil)
  if valid_604324 != nil:
    section.add "X-Amz-Date", valid_604324
  var valid_604325 = header.getOrDefault("X-Amz-Credential")
  valid_604325 = validateParameter(valid_604325, JString, required = false,
                                 default = nil)
  if valid_604325 != nil:
    section.add "X-Amz-Credential", valid_604325
  var valid_604326 = header.getOrDefault("X-Amz-Security-Token")
  valid_604326 = validateParameter(valid_604326, JString, required = false,
                                 default = nil)
  if valid_604326 != nil:
    section.add "X-Amz-Security-Token", valid_604326
  var valid_604327 = header.getOrDefault("X-Amz-Algorithm")
  valid_604327 = validateParameter(valid_604327, JString, required = false,
                                 default = nil)
  if valid_604327 != nil:
    section.add "X-Amz-Algorithm", valid_604327
  var valid_604328 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604328 = validateParameter(valid_604328, JString, required = false,
                                 default = nil)
  if valid_604328 != nil:
    section.add "X-Amz-SignedHeaders", valid_604328
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604329 = formData.getOrDefault("ClusterIdentifier")
  valid_604329 = validateParameter(valid_604329, JString, required = true,
                                 default = nil)
  if valid_604329 != nil:
    section.add "ClusterIdentifier", valid_604329
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604330: Call_PostDisableSnapshotCopy_604317; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_604330.validator(path, query, header, formData, body)
  let scheme = call_604330.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604330.url(scheme.get, call_604330.host, call_604330.base,
                         call_604330.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604330, url, valid)

proc call*(call_604331: Call_PostDisableSnapshotCopy_604317;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## postDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604332 = newJObject()
  var formData_604333 = newJObject()
  add(formData_604333, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604332, "Action", newJString(Action))
  add(query_604332, "Version", newJString(Version))
  result = call_604331.call(nil, query_604332, nil, formData_604333, nil)

var postDisableSnapshotCopy* = Call_PostDisableSnapshotCopy_604317(
    name: "postDisableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_PostDisableSnapshotCopy_604318, base: "/",
    url: url_PostDisableSnapshotCopy_604319, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableSnapshotCopy_604301 = ref object of OpenApiRestCall_601373
proc url_GetDisableSnapshotCopy_604303(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableSnapshotCopy_604302(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604304 = query.getOrDefault("Action")
  valid_604304 = validateParameter(valid_604304, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_604304 != nil:
    section.add "Action", valid_604304
  var valid_604305 = query.getOrDefault("ClusterIdentifier")
  valid_604305 = validateParameter(valid_604305, JString, required = true,
                                 default = nil)
  if valid_604305 != nil:
    section.add "ClusterIdentifier", valid_604305
  var valid_604306 = query.getOrDefault("Version")
  valid_604306 = validateParameter(valid_604306, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604306 != nil:
    section.add "Version", valid_604306
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604307 = header.getOrDefault("X-Amz-Signature")
  valid_604307 = validateParameter(valid_604307, JString, required = false,
                                 default = nil)
  if valid_604307 != nil:
    section.add "X-Amz-Signature", valid_604307
  var valid_604308 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604308 = validateParameter(valid_604308, JString, required = false,
                                 default = nil)
  if valid_604308 != nil:
    section.add "X-Amz-Content-Sha256", valid_604308
  var valid_604309 = header.getOrDefault("X-Amz-Date")
  valid_604309 = validateParameter(valid_604309, JString, required = false,
                                 default = nil)
  if valid_604309 != nil:
    section.add "X-Amz-Date", valid_604309
  var valid_604310 = header.getOrDefault("X-Amz-Credential")
  valid_604310 = validateParameter(valid_604310, JString, required = false,
                                 default = nil)
  if valid_604310 != nil:
    section.add "X-Amz-Credential", valid_604310
  var valid_604311 = header.getOrDefault("X-Amz-Security-Token")
  valid_604311 = validateParameter(valid_604311, JString, required = false,
                                 default = nil)
  if valid_604311 != nil:
    section.add "X-Amz-Security-Token", valid_604311
  var valid_604312 = header.getOrDefault("X-Amz-Algorithm")
  valid_604312 = validateParameter(valid_604312, JString, required = false,
                                 default = nil)
  if valid_604312 != nil:
    section.add "X-Amz-Algorithm", valid_604312
  var valid_604313 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604313 = validateParameter(valid_604313, JString, required = false,
                                 default = nil)
  if valid_604313 != nil:
    section.add "X-Amz-SignedHeaders", valid_604313
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604314: Call_GetDisableSnapshotCopy_604301; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_604314.validator(path, query, header, formData, body)
  let scheme = call_604314.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604314.url(scheme.get, call_604314.host, call_604314.base,
                         call_604314.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604314, url, valid)

proc call*(call_604315: Call_GetDisableSnapshotCopy_604301;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## getDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_604316 = newJObject()
  add(query_604316, "Action", newJString(Action))
  add(query_604316, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604316, "Version", newJString(Version))
  result = call_604315.call(nil, query_604316, nil, nil, nil)

var getDisableSnapshotCopy* = Call_GetDisableSnapshotCopy_604301(
    name: "getDisableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_GetDisableSnapshotCopy_604302, base: "/",
    url: url_GetDisableSnapshotCopy_604303, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableLogging_604352 = ref object of OpenApiRestCall_601373
proc url_PostEnableLogging_604354(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableLogging_604353(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604355 = query.getOrDefault("Action")
  valid_604355 = validateParameter(valid_604355, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_604355 != nil:
    section.add "Action", valid_604355
  var valid_604356 = query.getOrDefault("Version")
  valid_604356 = validateParameter(valid_604356, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604356 != nil:
    section.add "Version", valid_604356
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604357 = header.getOrDefault("X-Amz-Signature")
  valid_604357 = validateParameter(valid_604357, JString, required = false,
                                 default = nil)
  if valid_604357 != nil:
    section.add "X-Amz-Signature", valid_604357
  var valid_604358 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604358 = validateParameter(valid_604358, JString, required = false,
                                 default = nil)
  if valid_604358 != nil:
    section.add "X-Amz-Content-Sha256", valid_604358
  var valid_604359 = header.getOrDefault("X-Amz-Date")
  valid_604359 = validateParameter(valid_604359, JString, required = false,
                                 default = nil)
  if valid_604359 != nil:
    section.add "X-Amz-Date", valid_604359
  var valid_604360 = header.getOrDefault("X-Amz-Credential")
  valid_604360 = validateParameter(valid_604360, JString, required = false,
                                 default = nil)
  if valid_604360 != nil:
    section.add "X-Amz-Credential", valid_604360
  var valid_604361 = header.getOrDefault("X-Amz-Security-Token")
  valid_604361 = validateParameter(valid_604361, JString, required = false,
                                 default = nil)
  if valid_604361 != nil:
    section.add "X-Amz-Security-Token", valid_604361
  var valid_604362 = header.getOrDefault("X-Amz-Algorithm")
  valid_604362 = validateParameter(valid_604362, JString, required = false,
                                 default = nil)
  if valid_604362 != nil:
    section.add "X-Amz-Algorithm", valid_604362
  var valid_604363 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604363 = validateParameter(valid_604363, JString, required = false,
                                 default = nil)
  if valid_604363 != nil:
    section.add "X-Amz-SignedHeaders", valid_604363
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604364 = formData.getOrDefault("ClusterIdentifier")
  valid_604364 = validateParameter(valid_604364, JString, required = true,
                                 default = nil)
  if valid_604364 != nil:
    section.add "ClusterIdentifier", valid_604364
  var valid_604365 = formData.getOrDefault("BucketName")
  valid_604365 = validateParameter(valid_604365, JString, required = true,
                                 default = nil)
  if valid_604365 != nil:
    section.add "BucketName", valid_604365
  var valid_604366 = formData.getOrDefault("S3KeyPrefix")
  valid_604366 = validateParameter(valid_604366, JString, required = false,
                                 default = nil)
  if valid_604366 != nil:
    section.add "S3KeyPrefix", valid_604366
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604367: Call_PostEnableLogging_604352; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_604367.validator(path, query, header, formData, body)
  let scheme = call_604367.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604367.url(scheme.get, call_604367.host, call_604367.base,
                         call_604367.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604367, url, valid)

proc call*(call_604368: Call_PostEnableLogging_604352; ClusterIdentifier: string;
          BucketName: string; Action: string = "EnableLogging";
          Version: string = "2012-12-01"; S3KeyPrefix: string = ""): Recallable =
  ## postEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Version: string (required)
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  var query_604369 = newJObject()
  var formData_604370 = newJObject()
  add(formData_604370, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604369, "Action", newJString(Action))
  add(formData_604370, "BucketName", newJString(BucketName))
  add(query_604369, "Version", newJString(Version))
  add(formData_604370, "S3KeyPrefix", newJString(S3KeyPrefix))
  result = call_604368.call(nil, query_604369, nil, formData_604370, nil)

var postEnableLogging* = Call_PostEnableLogging_604352(name: "postEnableLogging",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_PostEnableLogging_604353,
    base: "/", url: url_PostEnableLogging_604354,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableLogging_604334 = ref object of OpenApiRestCall_601373
proc url_GetEnableLogging_604336(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableLogging_604335(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `BucketName` field"
  var valid_604337 = query.getOrDefault("BucketName")
  valid_604337 = validateParameter(valid_604337, JString, required = true,
                                 default = nil)
  if valid_604337 != nil:
    section.add "BucketName", valid_604337
  var valid_604338 = query.getOrDefault("S3KeyPrefix")
  valid_604338 = validateParameter(valid_604338, JString, required = false,
                                 default = nil)
  if valid_604338 != nil:
    section.add "S3KeyPrefix", valid_604338
  var valid_604339 = query.getOrDefault("Action")
  valid_604339 = validateParameter(valid_604339, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_604339 != nil:
    section.add "Action", valid_604339
  var valid_604340 = query.getOrDefault("ClusterIdentifier")
  valid_604340 = validateParameter(valid_604340, JString, required = true,
                                 default = nil)
  if valid_604340 != nil:
    section.add "ClusterIdentifier", valid_604340
  var valid_604341 = query.getOrDefault("Version")
  valid_604341 = validateParameter(valid_604341, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604341 != nil:
    section.add "Version", valid_604341
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604342 = header.getOrDefault("X-Amz-Signature")
  valid_604342 = validateParameter(valid_604342, JString, required = false,
                                 default = nil)
  if valid_604342 != nil:
    section.add "X-Amz-Signature", valid_604342
  var valid_604343 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604343 = validateParameter(valid_604343, JString, required = false,
                                 default = nil)
  if valid_604343 != nil:
    section.add "X-Amz-Content-Sha256", valid_604343
  var valid_604344 = header.getOrDefault("X-Amz-Date")
  valid_604344 = validateParameter(valid_604344, JString, required = false,
                                 default = nil)
  if valid_604344 != nil:
    section.add "X-Amz-Date", valid_604344
  var valid_604345 = header.getOrDefault("X-Amz-Credential")
  valid_604345 = validateParameter(valid_604345, JString, required = false,
                                 default = nil)
  if valid_604345 != nil:
    section.add "X-Amz-Credential", valid_604345
  var valid_604346 = header.getOrDefault("X-Amz-Security-Token")
  valid_604346 = validateParameter(valid_604346, JString, required = false,
                                 default = nil)
  if valid_604346 != nil:
    section.add "X-Amz-Security-Token", valid_604346
  var valid_604347 = header.getOrDefault("X-Amz-Algorithm")
  valid_604347 = validateParameter(valid_604347, JString, required = false,
                                 default = nil)
  if valid_604347 != nil:
    section.add "X-Amz-Algorithm", valid_604347
  var valid_604348 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604348 = validateParameter(valid_604348, JString, required = false,
                                 default = nil)
  if valid_604348 != nil:
    section.add "X-Amz-SignedHeaders", valid_604348
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604349: Call_GetEnableLogging_604334; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_604349.validator(path, query, header, formData, body)
  let scheme = call_604349.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604349.url(scheme.get, call_604349.host, call_604349.base,
                         call_604349.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604349, url, valid)

proc call*(call_604350: Call_GetEnableLogging_604334; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_604351 = newJObject()
  add(query_604351, "BucketName", newJString(BucketName))
  add(query_604351, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(query_604351, "Action", newJString(Action))
  add(query_604351, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604351, "Version", newJString(Version))
  result = call_604350.call(nil, query_604351, nil, nil, nil)

var getEnableLogging* = Call_GetEnableLogging_604334(name: "getEnableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_GetEnableLogging_604335,
    base: "/", url: url_GetEnableLogging_604336,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableSnapshotCopy_604391 = ref object of OpenApiRestCall_601373
proc url_PostEnableSnapshotCopy_604393(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableSnapshotCopy_604392(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604394 = query.getOrDefault("Action")
  valid_604394 = validateParameter(valid_604394, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_604394 != nil:
    section.add "Action", valid_604394
  var valid_604395 = query.getOrDefault("Version")
  valid_604395 = validateParameter(valid_604395, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604395 != nil:
    section.add "Version", valid_604395
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604396 = header.getOrDefault("X-Amz-Signature")
  valid_604396 = validateParameter(valid_604396, JString, required = false,
                                 default = nil)
  if valid_604396 != nil:
    section.add "X-Amz-Signature", valid_604396
  var valid_604397 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604397 = validateParameter(valid_604397, JString, required = false,
                                 default = nil)
  if valid_604397 != nil:
    section.add "X-Amz-Content-Sha256", valid_604397
  var valid_604398 = header.getOrDefault("X-Amz-Date")
  valid_604398 = validateParameter(valid_604398, JString, required = false,
                                 default = nil)
  if valid_604398 != nil:
    section.add "X-Amz-Date", valid_604398
  var valid_604399 = header.getOrDefault("X-Amz-Credential")
  valid_604399 = validateParameter(valid_604399, JString, required = false,
                                 default = nil)
  if valid_604399 != nil:
    section.add "X-Amz-Credential", valid_604399
  var valid_604400 = header.getOrDefault("X-Amz-Security-Token")
  valid_604400 = validateParameter(valid_604400, JString, required = false,
                                 default = nil)
  if valid_604400 != nil:
    section.add "X-Amz-Security-Token", valid_604400
  var valid_604401 = header.getOrDefault("X-Amz-Algorithm")
  valid_604401 = validateParameter(valid_604401, JString, required = false,
                                 default = nil)
  if valid_604401 != nil:
    section.add "X-Amz-Algorithm", valid_604401
  var valid_604402 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604402 = validateParameter(valid_604402, JString, required = false,
                                 default = nil)
  if valid_604402 != nil:
    section.add "X-Amz-SignedHeaders", valid_604402
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604403 = formData.getOrDefault("ClusterIdentifier")
  valid_604403 = validateParameter(valid_604403, JString, required = true,
                                 default = nil)
  if valid_604403 != nil:
    section.add "ClusterIdentifier", valid_604403
  var valid_604404 = formData.getOrDefault("RetentionPeriod")
  valid_604404 = validateParameter(valid_604404, JInt, required = false, default = nil)
  if valid_604404 != nil:
    section.add "RetentionPeriod", valid_604404
  var valid_604405 = formData.getOrDefault("DestinationRegion")
  valid_604405 = validateParameter(valid_604405, JString, required = true,
                                 default = nil)
  if valid_604405 != nil:
    section.add "DestinationRegion", valid_604405
  var valid_604406 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_604406 = validateParameter(valid_604406, JString, required = false,
                                 default = nil)
  if valid_604406 != nil:
    section.add "SnapshotCopyGrantName", valid_604406
  var valid_604407 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_604407 = validateParameter(valid_604407, JInt, required = false, default = nil)
  if valid_604407 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_604407
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604408: Call_PostEnableSnapshotCopy_604391; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_604408.validator(path, query, header, formData, body)
  let scheme = call_604408.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604408.url(scheme.get, call_604408.host, call_604408.base,
                         call_604408.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604408, url, valid)

proc call*(call_604409: Call_PostEnableSnapshotCopy_604391;
          ClusterIdentifier: string; DestinationRegion: string;
          RetentionPeriod: int = 0; Action: string = "EnableSnapshotCopy";
          SnapshotCopyGrantName: string = ""; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_604410 = newJObject()
  var formData_604411 = newJObject()
  add(formData_604411, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_604411, "RetentionPeriod", newJInt(RetentionPeriod))
  add(formData_604411, "DestinationRegion", newJString(DestinationRegion))
  add(query_604410, "Action", newJString(Action))
  add(formData_604411, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_604410, "Version", newJString(Version))
  add(formData_604411, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_604409.call(nil, query_604410, nil, formData_604411, nil)

var postEnableSnapshotCopy* = Call_PostEnableSnapshotCopy_604391(
    name: "postEnableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_PostEnableSnapshotCopy_604392, base: "/",
    url: url_PostEnableSnapshotCopy_604393, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableSnapshotCopy_604371 = ref object of OpenApiRestCall_601373
proc url_GetEnableSnapshotCopy_604373(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableSnapshotCopy_604372(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  section = newJObject()
  var valid_604374 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_604374 = validateParameter(valid_604374, JInt, required = false, default = nil)
  if valid_604374 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_604374
  assert query != nil,
        "query argument is necessary due to required `DestinationRegion` field"
  var valid_604375 = query.getOrDefault("DestinationRegion")
  valid_604375 = validateParameter(valid_604375, JString, required = true,
                                 default = nil)
  if valid_604375 != nil:
    section.add "DestinationRegion", valid_604375
  var valid_604376 = query.getOrDefault("Action")
  valid_604376 = validateParameter(valid_604376, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_604376 != nil:
    section.add "Action", valid_604376
  var valid_604377 = query.getOrDefault("ClusterIdentifier")
  valid_604377 = validateParameter(valid_604377, JString, required = true,
                                 default = nil)
  if valid_604377 != nil:
    section.add "ClusterIdentifier", valid_604377
  var valid_604378 = query.getOrDefault("Version")
  valid_604378 = validateParameter(valid_604378, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604378 != nil:
    section.add "Version", valid_604378
  var valid_604379 = query.getOrDefault("RetentionPeriod")
  valid_604379 = validateParameter(valid_604379, JInt, required = false, default = nil)
  if valid_604379 != nil:
    section.add "RetentionPeriod", valid_604379
  var valid_604380 = query.getOrDefault("SnapshotCopyGrantName")
  valid_604380 = validateParameter(valid_604380, JString, required = false,
                                 default = nil)
  if valid_604380 != nil:
    section.add "SnapshotCopyGrantName", valid_604380
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604381 = header.getOrDefault("X-Amz-Signature")
  valid_604381 = validateParameter(valid_604381, JString, required = false,
                                 default = nil)
  if valid_604381 != nil:
    section.add "X-Amz-Signature", valid_604381
  var valid_604382 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604382 = validateParameter(valid_604382, JString, required = false,
                                 default = nil)
  if valid_604382 != nil:
    section.add "X-Amz-Content-Sha256", valid_604382
  var valid_604383 = header.getOrDefault("X-Amz-Date")
  valid_604383 = validateParameter(valid_604383, JString, required = false,
                                 default = nil)
  if valid_604383 != nil:
    section.add "X-Amz-Date", valid_604383
  var valid_604384 = header.getOrDefault("X-Amz-Credential")
  valid_604384 = validateParameter(valid_604384, JString, required = false,
                                 default = nil)
  if valid_604384 != nil:
    section.add "X-Amz-Credential", valid_604384
  var valid_604385 = header.getOrDefault("X-Amz-Security-Token")
  valid_604385 = validateParameter(valid_604385, JString, required = false,
                                 default = nil)
  if valid_604385 != nil:
    section.add "X-Amz-Security-Token", valid_604385
  var valid_604386 = header.getOrDefault("X-Amz-Algorithm")
  valid_604386 = validateParameter(valid_604386, JString, required = false,
                                 default = nil)
  if valid_604386 != nil:
    section.add "X-Amz-Algorithm", valid_604386
  var valid_604387 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604387 = validateParameter(valid_604387, JString, required = false,
                                 default = nil)
  if valid_604387 != nil:
    section.add "X-Amz-SignedHeaders", valid_604387
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604388: Call_GetEnableSnapshotCopy_604371; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_604388.validator(path, query, header, formData, body)
  let scheme = call_604388.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604388.url(scheme.get, call_604388.host, call_604388.base,
                         call_604388.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604388, url, valid)

proc call*(call_604389: Call_GetEnableSnapshotCopy_604371;
          DestinationRegion: string; ClusterIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0;
          Action: string = "EnableSnapshotCopy"; Version: string = "2012-12-01";
          RetentionPeriod: int = 0; SnapshotCopyGrantName: string = ""): Recallable =
  ## getEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  var query_604390 = newJObject()
  add(query_604390, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_604390, "DestinationRegion", newJString(DestinationRegion))
  add(query_604390, "Action", newJString(Action))
  add(query_604390, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604390, "Version", newJString(Version))
  add(query_604390, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_604390, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_604389.call(nil, query_604390, nil, nil, nil)

var getEnableSnapshotCopy* = Call_GetEnableSnapshotCopy_604371(
    name: "getEnableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_GetEnableSnapshotCopy_604372, base: "/",
    url: url_GetEnableSnapshotCopy_604373, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetClusterCredentials_604433 = ref object of OpenApiRestCall_601373
proc url_PostGetClusterCredentials_604435(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetClusterCredentials_604434(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604436 = query.getOrDefault("Action")
  valid_604436 = validateParameter(valid_604436, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_604436 != nil:
    section.add "Action", valid_604436
  var valid_604437 = query.getOrDefault("Version")
  valid_604437 = validateParameter(valid_604437, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604437 != nil:
    section.add "Version", valid_604437
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604438 = header.getOrDefault("X-Amz-Signature")
  valid_604438 = validateParameter(valid_604438, JString, required = false,
                                 default = nil)
  if valid_604438 != nil:
    section.add "X-Amz-Signature", valid_604438
  var valid_604439 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604439 = validateParameter(valid_604439, JString, required = false,
                                 default = nil)
  if valid_604439 != nil:
    section.add "X-Amz-Content-Sha256", valid_604439
  var valid_604440 = header.getOrDefault("X-Amz-Date")
  valid_604440 = validateParameter(valid_604440, JString, required = false,
                                 default = nil)
  if valid_604440 != nil:
    section.add "X-Amz-Date", valid_604440
  var valid_604441 = header.getOrDefault("X-Amz-Credential")
  valid_604441 = validateParameter(valid_604441, JString, required = false,
                                 default = nil)
  if valid_604441 != nil:
    section.add "X-Amz-Credential", valid_604441
  var valid_604442 = header.getOrDefault("X-Amz-Security-Token")
  valid_604442 = validateParameter(valid_604442, JString, required = false,
                                 default = nil)
  if valid_604442 != nil:
    section.add "X-Amz-Security-Token", valid_604442
  var valid_604443 = header.getOrDefault("X-Amz-Algorithm")
  valid_604443 = validateParameter(valid_604443, JString, required = false,
                                 default = nil)
  if valid_604443 != nil:
    section.add "X-Amz-Algorithm", valid_604443
  var valid_604444 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604444 = validateParameter(valid_604444, JString, required = false,
                                 default = nil)
  if valid_604444 != nil:
    section.add "X-Amz-SignedHeaders", valid_604444
  result.add "header", section
  ## parameters in `formData` object:
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `DbUser` field"
  var valid_604445 = formData.getOrDefault("DbUser")
  valid_604445 = validateParameter(valid_604445, JString, required = true,
                                 default = nil)
  if valid_604445 != nil:
    section.add "DbUser", valid_604445
  var valid_604446 = formData.getOrDefault("ClusterIdentifier")
  valid_604446 = validateParameter(valid_604446, JString, required = true,
                                 default = nil)
  if valid_604446 != nil:
    section.add "ClusterIdentifier", valid_604446
  var valid_604447 = formData.getOrDefault("DurationSeconds")
  valid_604447 = validateParameter(valid_604447, JInt, required = false, default = nil)
  if valid_604447 != nil:
    section.add "DurationSeconds", valid_604447
  var valid_604448 = formData.getOrDefault("DbGroups")
  valid_604448 = validateParameter(valid_604448, JArray, required = false,
                                 default = nil)
  if valid_604448 != nil:
    section.add "DbGroups", valid_604448
  var valid_604449 = formData.getOrDefault("DbName")
  valid_604449 = validateParameter(valid_604449, JString, required = false,
                                 default = nil)
  if valid_604449 != nil:
    section.add "DbName", valid_604449
  var valid_604450 = formData.getOrDefault("AutoCreate")
  valid_604450 = validateParameter(valid_604450, JBool, required = false, default = nil)
  if valid_604450 != nil:
    section.add "AutoCreate", valid_604450
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604451: Call_PostGetClusterCredentials_604433; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_604451.validator(path, query, header, formData, body)
  let scheme = call_604451.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604451.url(scheme.get, call_604451.host, call_604451.base,
                         call_604451.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604451, url, valid)

proc call*(call_604452: Call_PostGetClusterCredentials_604433; DbUser: string;
          ClusterIdentifier: string; DurationSeconds: int = 0;
          DbGroups: JsonNode = nil; Action: string = "GetClusterCredentials";
          DbName: string = ""; AutoCreate: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Version: string (required)
  var query_604453 = newJObject()
  var formData_604454 = newJObject()
  add(formData_604454, "DbUser", newJString(DbUser))
  add(formData_604454, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_604454, "DurationSeconds", newJInt(DurationSeconds))
  if DbGroups != nil:
    formData_604454.add "DbGroups", DbGroups
  add(query_604453, "Action", newJString(Action))
  add(formData_604454, "DbName", newJString(DbName))
  add(formData_604454, "AutoCreate", newJBool(AutoCreate))
  add(query_604453, "Version", newJString(Version))
  result = call_604452.call(nil, query_604453, nil, formData_604454, nil)

var postGetClusterCredentials* = Call_PostGetClusterCredentials_604433(
    name: "postGetClusterCredentials", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_PostGetClusterCredentials_604434, base: "/",
    url: url_PostGetClusterCredentials_604435,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetClusterCredentials_604412 = ref object of OpenApiRestCall_601373
proc url_GetGetClusterCredentials_604414(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetClusterCredentials_604413(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   Version: JString (required)
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  section = newJObject()
  var valid_604415 = query.getOrDefault("DbName")
  valid_604415 = validateParameter(valid_604415, JString, required = false,
                                 default = nil)
  if valid_604415 != nil:
    section.add "DbName", valid_604415
  assert query != nil, "query argument is necessary due to required `DbUser` field"
  var valid_604416 = query.getOrDefault("DbUser")
  valid_604416 = validateParameter(valid_604416, JString, required = true,
                                 default = nil)
  if valid_604416 != nil:
    section.add "DbUser", valid_604416
  var valid_604417 = query.getOrDefault("AutoCreate")
  valid_604417 = validateParameter(valid_604417, JBool, required = false, default = nil)
  if valid_604417 != nil:
    section.add "AutoCreate", valid_604417
  var valid_604418 = query.getOrDefault("Action")
  valid_604418 = validateParameter(valid_604418, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_604418 != nil:
    section.add "Action", valid_604418
  var valid_604419 = query.getOrDefault("ClusterIdentifier")
  valid_604419 = validateParameter(valid_604419, JString, required = true,
                                 default = nil)
  if valid_604419 != nil:
    section.add "ClusterIdentifier", valid_604419
  var valid_604420 = query.getOrDefault("Version")
  valid_604420 = validateParameter(valid_604420, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604420 != nil:
    section.add "Version", valid_604420
  var valid_604421 = query.getOrDefault("DbGroups")
  valid_604421 = validateParameter(valid_604421, JArray, required = false,
                                 default = nil)
  if valid_604421 != nil:
    section.add "DbGroups", valid_604421
  var valid_604422 = query.getOrDefault("DurationSeconds")
  valid_604422 = validateParameter(valid_604422, JInt, required = false, default = nil)
  if valid_604422 != nil:
    section.add "DurationSeconds", valid_604422
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604423 = header.getOrDefault("X-Amz-Signature")
  valid_604423 = validateParameter(valid_604423, JString, required = false,
                                 default = nil)
  if valid_604423 != nil:
    section.add "X-Amz-Signature", valid_604423
  var valid_604424 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604424 = validateParameter(valid_604424, JString, required = false,
                                 default = nil)
  if valid_604424 != nil:
    section.add "X-Amz-Content-Sha256", valid_604424
  var valid_604425 = header.getOrDefault("X-Amz-Date")
  valid_604425 = validateParameter(valid_604425, JString, required = false,
                                 default = nil)
  if valid_604425 != nil:
    section.add "X-Amz-Date", valid_604425
  var valid_604426 = header.getOrDefault("X-Amz-Credential")
  valid_604426 = validateParameter(valid_604426, JString, required = false,
                                 default = nil)
  if valid_604426 != nil:
    section.add "X-Amz-Credential", valid_604426
  var valid_604427 = header.getOrDefault("X-Amz-Security-Token")
  valid_604427 = validateParameter(valid_604427, JString, required = false,
                                 default = nil)
  if valid_604427 != nil:
    section.add "X-Amz-Security-Token", valid_604427
  var valid_604428 = header.getOrDefault("X-Amz-Algorithm")
  valid_604428 = validateParameter(valid_604428, JString, required = false,
                                 default = nil)
  if valid_604428 != nil:
    section.add "X-Amz-Algorithm", valid_604428
  var valid_604429 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604429 = validateParameter(valid_604429, JString, required = false,
                                 default = nil)
  if valid_604429 != nil:
    section.add "X-Amz-SignedHeaders", valid_604429
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604430: Call_GetGetClusterCredentials_604412; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_604430.validator(path, query, header, formData, body)
  let scheme = call_604430.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604430.url(scheme.get, call_604430.host, call_604430.base,
                         call_604430.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604430, url, valid)

proc call*(call_604431: Call_GetGetClusterCredentials_604412; DbUser: string;
          ClusterIdentifier: string; DbName: string = ""; AutoCreate: bool = false;
          Action: string = "GetClusterCredentials"; Version: string = "2012-12-01";
          DbGroups: JsonNode = nil; DurationSeconds: int = 0): Recallable =
  ## getGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   Version: string (required)
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  var query_604432 = newJObject()
  add(query_604432, "DbName", newJString(DbName))
  add(query_604432, "DbUser", newJString(DbUser))
  add(query_604432, "AutoCreate", newJBool(AutoCreate))
  add(query_604432, "Action", newJString(Action))
  add(query_604432, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604432, "Version", newJString(Version))
  if DbGroups != nil:
    query_604432.add "DbGroups", DbGroups
  add(query_604432, "DurationSeconds", newJInt(DurationSeconds))
  result = call_604431.call(nil, query_604432, nil, nil, nil)

var getGetClusterCredentials* = Call_GetGetClusterCredentials_604412(
    name: "getGetClusterCredentials", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_GetGetClusterCredentials_604413, base: "/",
    url: url_GetGetClusterCredentials_604414, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetReservedNodeExchangeOfferings_604473 = ref object of OpenApiRestCall_601373
proc url_PostGetReservedNodeExchangeOfferings_604475(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetReservedNodeExchangeOfferings_604474(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604476 = query.getOrDefault("Action")
  valid_604476 = validateParameter(valid_604476, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_604476 != nil:
    section.add "Action", valid_604476
  var valid_604477 = query.getOrDefault("Version")
  valid_604477 = validateParameter(valid_604477, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604477 != nil:
    section.add "Version", valid_604477
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604478 = header.getOrDefault("X-Amz-Signature")
  valid_604478 = validateParameter(valid_604478, JString, required = false,
                                 default = nil)
  if valid_604478 != nil:
    section.add "X-Amz-Signature", valid_604478
  var valid_604479 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604479 = validateParameter(valid_604479, JString, required = false,
                                 default = nil)
  if valid_604479 != nil:
    section.add "X-Amz-Content-Sha256", valid_604479
  var valid_604480 = header.getOrDefault("X-Amz-Date")
  valid_604480 = validateParameter(valid_604480, JString, required = false,
                                 default = nil)
  if valid_604480 != nil:
    section.add "X-Amz-Date", valid_604480
  var valid_604481 = header.getOrDefault("X-Amz-Credential")
  valid_604481 = validateParameter(valid_604481, JString, required = false,
                                 default = nil)
  if valid_604481 != nil:
    section.add "X-Amz-Credential", valid_604481
  var valid_604482 = header.getOrDefault("X-Amz-Security-Token")
  valid_604482 = validateParameter(valid_604482, JString, required = false,
                                 default = nil)
  if valid_604482 != nil:
    section.add "X-Amz-Security-Token", valid_604482
  var valid_604483 = header.getOrDefault("X-Amz-Algorithm")
  valid_604483 = validateParameter(valid_604483, JString, required = false,
                                 default = nil)
  if valid_604483 != nil:
    section.add "X-Amz-Algorithm", valid_604483
  var valid_604484 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604484 = validateParameter(valid_604484, JString, required = false,
                                 default = nil)
  if valid_604484 != nil:
    section.add "X-Amz-SignedHeaders", valid_604484
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_604485 = formData.getOrDefault("ReservedNodeId")
  valid_604485 = validateParameter(valid_604485, JString, required = true,
                                 default = nil)
  if valid_604485 != nil:
    section.add "ReservedNodeId", valid_604485
  var valid_604486 = formData.getOrDefault("MaxRecords")
  valid_604486 = validateParameter(valid_604486, JInt, required = false, default = nil)
  if valid_604486 != nil:
    section.add "MaxRecords", valid_604486
  var valid_604487 = formData.getOrDefault("Marker")
  valid_604487 = validateParameter(valid_604487, JString, required = false,
                                 default = nil)
  if valid_604487 != nil:
    section.add "Marker", valid_604487
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604488: Call_PostGetReservedNodeExchangeOfferings_604473;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_604488.validator(path, query, header, formData, body)
  let scheme = call_604488.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604488.url(scheme.get, call_604488.host, call_604488.base,
                         call_604488.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604488, url, valid)

proc call*(call_604489: Call_PostGetReservedNodeExchangeOfferings_604473;
          ReservedNodeId: string; MaxRecords: int = 0; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings";
          Version: string = "2012-12-01"): Recallable =
  ## postGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604490 = newJObject()
  var formData_604491 = newJObject()
  add(formData_604491, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_604491, "MaxRecords", newJInt(MaxRecords))
  add(formData_604491, "Marker", newJString(Marker))
  add(query_604490, "Action", newJString(Action))
  add(query_604490, "Version", newJString(Version))
  result = call_604489.call(nil, query_604490, nil, formData_604491, nil)

var postGetReservedNodeExchangeOfferings* = Call_PostGetReservedNodeExchangeOfferings_604473(
    name: "postGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_PostGetReservedNodeExchangeOfferings_604474, base: "/",
    url: url_PostGetReservedNodeExchangeOfferings_604475,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetReservedNodeExchangeOfferings_604455 = ref object of OpenApiRestCall_601373
proc url_GetGetReservedNodeExchangeOfferings_604457(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetReservedNodeExchangeOfferings_604456(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  section = newJObject()
  var valid_604458 = query.getOrDefault("Marker")
  valid_604458 = validateParameter(valid_604458, JString, required = false,
                                 default = nil)
  if valid_604458 != nil:
    section.add "Marker", valid_604458
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604459 = query.getOrDefault("Action")
  valid_604459 = validateParameter(valid_604459, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_604459 != nil:
    section.add "Action", valid_604459
  var valid_604460 = query.getOrDefault("ReservedNodeId")
  valid_604460 = validateParameter(valid_604460, JString, required = true,
                                 default = nil)
  if valid_604460 != nil:
    section.add "ReservedNodeId", valid_604460
  var valid_604461 = query.getOrDefault("Version")
  valid_604461 = validateParameter(valid_604461, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604461 != nil:
    section.add "Version", valid_604461
  var valid_604462 = query.getOrDefault("MaxRecords")
  valid_604462 = validateParameter(valid_604462, JInt, required = false, default = nil)
  if valid_604462 != nil:
    section.add "MaxRecords", valid_604462
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604463 = header.getOrDefault("X-Amz-Signature")
  valid_604463 = validateParameter(valid_604463, JString, required = false,
                                 default = nil)
  if valid_604463 != nil:
    section.add "X-Amz-Signature", valid_604463
  var valid_604464 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604464 = validateParameter(valid_604464, JString, required = false,
                                 default = nil)
  if valid_604464 != nil:
    section.add "X-Amz-Content-Sha256", valid_604464
  var valid_604465 = header.getOrDefault("X-Amz-Date")
  valid_604465 = validateParameter(valid_604465, JString, required = false,
                                 default = nil)
  if valid_604465 != nil:
    section.add "X-Amz-Date", valid_604465
  var valid_604466 = header.getOrDefault("X-Amz-Credential")
  valid_604466 = validateParameter(valid_604466, JString, required = false,
                                 default = nil)
  if valid_604466 != nil:
    section.add "X-Amz-Credential", valid_604466
  var valid_604467 = header.getOrDefault("X-Amz-Security-Token")
  valid_604467 = validateParameter(valid_604467, JString, required = false,
                                 default = nil)
  if valid_604467 != nil:
    section.add "X-Amz-Security-Token", valid_604467
  var valid_604468 = header.getOrDefault("X-Amz-Algorithm")
  valid_604468 = validateParameter(valid_604468, JString, required = false,
                                 default = nil)
  if valid_604468 != nil:
    section.add "X-Amz-Algorithm", valid_604468
  var valid_604469 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604469 = validateParameter(valid_604469, JString, required = false,
                                 default = nil)
  if valid_604469 != nil:
    section.add "X-Amz-SignedHeaders", valid_604469
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604470: Call_GetGetReservedNodeExchangeOfferings_604455;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_604470.validator(path, query, header, formData, body)
  let scheme = call_604470.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604470.url(scheme.get, call_604470.host, call_604470.base,
                         call_604470.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604470, url, valid)

proc call*(call_604471: Call_GetGetReservedNodeExchangeOfferings_604455;
          ReservedNodeId: string; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  var query_604472 = newJObject()
  add(query_604472, "Marker", newJString(Marker))
  add(query_604472, "Action", newJString(Action))
  add(query_604472, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_604472, "Version", newJString(Version))
  add(query_604472, "MaxRecords", newJInt(MaxRecords))
  result = call_604471.call(nil, query_604472, nil, nil, nil)

var getGetReservedNodeExchangeOfferings* = Call_GetGetReservedNodeExchangeOfferings_604455(
    name: "getGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_GetGetReservedNodeExchangeOfferings_604456, base: "/",
    url: url_GetGetReservedNodeExchangeOfferings_604457,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyCluster_604529 = ref object of OpenApiRestCall_601373
proc url_PostModifyCluster_604531(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyCluster_604530(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604532 = query.getOrDefault("Action")
  valid_604532 = validateParameter(valid_604532, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_604532 != nil:
    section.add "Action", valid_604532
  var valid_604533 = query.getOrDefault("Version")
  valid_604533 = validateParameter(valid_604533, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604533 != nil:
    section.add "Version", valid_604533
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604534 = header.getOrDefault("X-Amz-Signature")
  valid_604534 = validateParameter(valid_604534, JString, required = false,
                                 default = nil)
  if valid_604534 != nil:
    section.add "X-Amz-Signature", valid_604534
  var valid_604535 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604535 = validateParameter(valid_604535, JString, required = false,
                                 default = nil)
  if valid_604535 != nil:
    section.add "X-Amz-Content-Sha256", valid_604535
  var valid_604536 = header.getOrDefault("X-Amz-Date")
  valid_604536 = validateParameter(valid_604536, JString, required = false,
                                 default = nil)
  if valid_604536 != nil:
    section.add "X-Amz-Date", valid_604536
  var valid_604537 = header.getOrDefault("X-Amz-Credential")
  valid_604537 = validateParameter(valid_604537, JString, required = false,
                                 default = nil)
  if valid_604537 != nil:
    section.add "X-Amz-Credential", valid_604537
  var valid_604538 = header.getOrDefault("X-Amz-Security-Token")
  valid_604538 = validateParameter(valid_604538, JString, required = false,
                                 default = nil)
  if valid_604538 != nil:
    section.add "X-Amz-Security-Token", valid_604538
  var valid_604539 = header.getOrDefault("X-Amz-Algorithm")
  valid_604539 = validateParameter(valid_604539, JString, required = false,
                                 default = nil)
  if valid_604539 != nil:
    section.add "X-Amz-Algorithm", valid_604539
  var valid_604540 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604540 = validateParameter(valid_604540, JString, required = false,
                                 default = nil)
  if valid_604540 != nil:
    section.add "X-Amz-SignedHeaders", valid_604540
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_604541 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_604541 = validateParameter(valid_604541, JString, required = false,
                                 default = nil)
  if valid_604541 != nil:
    section.add "PreferredMaintenanceWindow", valid_604541
  var valid_604542 = formData.getOrDefault("NodeType")
  valid_604542 = validateParameter(valid_604542, JString, required = false,
                                 default = nil)
  if valid_604542 != nil:
    section.add "NodeType", valid_604542
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604543 = formData.getOrDefault("ClusterIdentifier")
  valid_604543 = validateParameter(valid_604543, JString, required = true,
                                 default = nil)
  if valid_604543 != nil:
    section.add "ClusterIdentifier", valid_604543
  var valid_604544 = formData.getOrDefault("MasterUserPassword")
  valid_604544 = validateParameter(valid_604544, JString, required = false,
                                 default = nil)
  if valid_604544 != nil:
    section.add "MasterUserPassword", valid_604544
  var valid_604545 = formData.getOrDefault("MaintenanceTrackName")
  valid_604545 = validateParameter(valid_604545, JString, required = false,
                                 default = nil)
  if valid_604545 != nil:
    section.add "MaintenanceTrackName", valid_604545
  var valid_604546 = formData.getOrDefault("ClusterSecurityGroups")
  valid_604546 = validateParameter(valid_604546, JArray, required = false,
                                 default = nil)
  if valid_604546 != nil:
    section.add "ClusterSecurityGroups", valid_604546
  var valid_604547 = formData.getOrDefault("NumberOfNodes")
  valid_604547 = validateParameter(valid_604547, JInt, required = false, default = nil)
  if valid_604547 != nil:
    section.add "NumberOfNodes", valid_604547
  var valid_604548 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_604548 = validateParameter(valid_604548, JArray, required = false,
                                 default = nil)
  if valid_604548 != nil:
    section.add "VpcSecurityGroupIds", valid_604548
  var valid_604549 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_604549 = validateParameter(valid_604549, JInt, required = false, default = nil)
  if valid_604549 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_604549
  var valid_604550 = formData.getOrDefault("NewClusterIdentifier")
  valid_604550 = validateParameter(valid_604550, JString, required = false,
                                 default = nil)
  if valid_604550 != nil:
    section.add "NewClusterIdentifier", valid_604550
  var valid_604551 = formData.getOrDefault("EnhancedVpcRouting")
  valid_604551 = validateParameter(valid_604551, JBool, required = false, default = nil)
  if valid_604551 != nil:
    section.add "EnhancedVpcRouting", valid_604551
  var valid_604552 = formData.getOrDefault("KmsKeyId")
  valid_604552 = validateParameter(valid_604552, JString, required = false,
                                 default = nil)
  if valid_604552 != nil:
    section.add "KmsKeyId", valid_604552
  var valid_604553 = formData.getOrDefault("AllowVersionUpgrade")
  valid_604553 = validateParameter(valid_604553, JBool, required = false, default = nil)
  if valid_604553 != nil:
    section.add "AllowVersionUpgrade", valid_604553
  var valid_604554 = formData.getOrDefault("PubliclyAccessible")
  valid_604554 = validateParameter(valid_604554, JBool, required = false, default = nil)
  if valid_604554 != nil:
    section.add "PubliclyAccessible", valid_604554
  var valid_604555 = formData.getOrDefault("ClusterParameterGroupName")
  valid_604555 = validateParameter(valid_604555, JString, required = false,
                                 default = nil)
  if valid_604555 != nil:
    section.add "ClusterParameterGroupName", valid_604555
  var valid_604556 = formData.getOrDefault("ClusterVersion")
  valid_604556 = validateParameter(valid_604556, JString, required = false,
                                 default = nil)
  if valid_604556 != nil:
    section.add "ClusterVersion", valid_604556
  var valid_604557 = formData.getOrDefault("ClusterType")
  valid_604557 = validateParameter(valid_604557, JString, required = false,
                                 default = nil)
  if valid_604557 != nil:
    section.add "ClusterType", valid_604557
  var valid_604558 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_604558 = validateParameter(valid_604558, JString, required = false,
                                 default = nil)
  if valid_604558 != nil:
    section.add "HsmClientCertificateIdentifier", valid_604558
  var valid_604559 = formData.getOrDefault("Encrypted")
  valid_604559 = validateParameter(valid_604559, JBool, required = false, default = nil)
  if valid_604559 != nil:
    section.add "Encrypted", valid_604559
  var valid_604560 = formData.getOrDefault("ElasticIp")
  valid_604560 = validateParameter(valid_604560, JString, required = false,
                                 default = nil)
  if valid_604560 != nil:
    section.add "ElasticIp", valid_604560
  var valid_604561 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_604561 = validateParameter(valid_604561, JString, required = false,
                                 default = nil)
  if valid_604561 != nil:
    section.add "HsmConfigurationIdentifier", valid_604561
  var valid_604562 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_604562 = validateParameter(valid_604562, JInt, required = false, default = nil)
  if valid_604562 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_604562
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604563: Call_PostModifyCluster_604529; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_604563.validator(path, query, header, formData, body)
  let scheme = call_604563.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604563.url(scheme.get, call_604563.host, call_604563.base,
                         call_604563.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604563, url, valid)

proc call*(call_604564: Call_PostModifyCluster_604529; ClusterIdentifier: string;
          PreferredMaintenanceWindow: string = ""; NodeType: string = "";
          MasterUserPassword: string = ""; MaintenanceTrackName: string = "";
          ClusterSecurityGroups: JsonNode = nil; NumberOfNodes: int = 0;
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0;
          NewClusterIdentifier: string = ""; EnhancedVpcRouting: bool = false;
          KmsKeyId: string = ""; AllowVersionUpgrade: bool = false;
          PubliclyAccessible: bool = false; Action: string = "ModifyCluster";
          ClusterParameterGroupName: string = ""; ClusterVersion: string = "";
          ClusterType: string = ""; HsmClientCertificateIdentifier: string = "";
          Encrypted: bool = false; Version: string = "2012-12-01";
          ElasticIp: string = ""; HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_604565 = newJObject()
  var formData_604566 = newJObject()
  add(formData_604566, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_604566, "NodeType", newJString(NodeType))
  add(formData_604566, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_604566, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_604566, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if ClusterSecurityGroups != nil:
    formData_604566.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_604566, "NumberOfNodes", newJInt(NumberOfNodes))
  if VpcSecurityGroupIds != nil:
    formData_604566.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_604566, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_604566, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(formData_604566, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_604566, "KmsKeyId", newJString(KmsKeyId))
  add(formData_604566, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_604566, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_604565, "Action", newJString(Action))
  add(formData_604566, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_604566, "ClusterVersion", newJString(ClusterVersion))
  add(formData_604566, "ClusterType", newJString(ClusterType))
  add(formData_604566, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_604566, "Encrypted", newJBool(Encrypted))
  add(query_604565, "Version", newJString(Version))
  add(formData_604566, "ElasticIp", newJString(ElasticIp))
  add(formData_604566, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_604566, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_604564.call(nil, query_604565, nil, formData_604566, nil)

var postModifyCluster* = Call_PostModifyCluster_604529(name: "postModifyCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_PostModifyCluster_604530,
    base: "/", url: url_PostModifyCluster_604531,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyCluster_604492 = ref object of OpenApiRestCall_601373
proc url_GetModifyCluster_604494(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyCluster_604493(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  section = newJObject()
  var valid_604495 = query.getOrDefault("MaintenanceTrackName")
  valid_604495 = validateParameter(valid_604495, JString, required = false,
                                 default = nil)
  if valid_604495 != nil:
    section.add "MaintenanceTrackName", valid_604495
  var valid_604496 = query.getOrDefault("Encrypted")
  valid_604496 = validateParameter(valid_604496, JBool, required = false, default = nil)
  if valid_604496 != nil:
    section.add "Encrypted", valid_604496
  var valid_604497 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_604497 = validateParameter(valid_604497, JInt, required = false, default = nil)
  if valid_604497 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_604497
  var valid_604498 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_604498 = validateParameter(valid_604498, JString, required = false,
                                 default = nil)
  if valid_604498 != nil:
    section.add "HsmClientCertificateIdentifier", valid_604498
  var valid_604499 = query.getOrDefault("ClusterSecurityGroups")
  valid_604499 = validateParameter(valid_604499, JArray, required = false,
                                 default = nil)
  if valid_604499 != nil:
    section.add "ClusterSecurityGroups", valid_604499
  var valid_604500 = query.getOrDefault("KmsKeyId")
  valid_604500 = validateParameter(valid_604500, JString, required = false,
                                 default = nil)
  if valid_604500 != nil:
    section.add "KmsKeyId", valid_604500
  var valid_604501 = query.getOrDefault("ClusterParameterGroupName")
  valid_604501 = validateParameter(valid_604501, JString, required = false,
                                 default = nil)
  if valid_604501 != nil:
    section.add "ClusterParameterGroupName", valid_604501
  var valid_604502 = query.getOrDefault("NodeType")
  valid_604502 = validateParameter(valid_604502, JString, required = false,
                                 default = nil)
  if valid_604502 != nil:
    section.add "NodeType", valid_604502
  var valid_604503 = query.getOrDefault("ClusterVersion")
  valid_604503 = validateParameter(valid_604503, JString, required = false,
                                 default = nil)
  if valid_604503 != nil:
    section.add "ClusterVersion", valid_604503
  var valid_604504 = query.getOrDefault("ClusterType")
  valid_604504 = validateParameter(valid_604504, JString, required = false,
                                 default = nil)
  if valid_604504 != nil:
    section.add "ClusterType", valid_604504
  var valid_604505 = query.getOrDefault("NumberOfNodes")
  valid_604505 = validateParameter(valid_604505, JInt, required = false, default = nil)
  if valid_604505 != nil:
    section.add "NumberOfNodes", valid_604505
  var valid_604506 = query.getOrDefault("AllowVersionUpgrade")
  valid_604506 = validateParameter(valid_604506, JBool, required = false, default = nil)
  if valid_604506 != nil:
    section.add "AllowVersionUpgrade", valid_604506
  var valid_604507 = query.getOrDefault("ElasticIp")
  valid_604507 = validateParameter(valid_604507, JString, required = false,
                                 default = nil)
  if valid_604507 != nil:
    section.add "ElasticIp", valid_604507
  var valid_604508 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_604508 = validateParameter(valid_604508, JInt, required = false, default = nil)
  if valid_604508 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_604508
  var valid_604509 = query.getOrDefault("EnhancedVpcRouting")
  valid_604509 = validateParameter(valid_604509, JBool, required = false, default = nil)
  if valid_604509 != nil:
    section.add "EnhancedVpcRouting", valid_604509
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604510 = query.getOrDefault("Action")
  valid_604510 = validateParameter(valid_604510, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_604510 != nil:
    section.add "Action", valid_604510
  var valid_604511 = query.getOrDefault("ClusterIdentifier")
  valid_604511 = validateParameter(valid_604511, JString, required = true,
                                 default = nil)
  if valid_604511 != nil:
    section.add "ClusterIdentifier", valid_604511
  var valid_604512 = query.getOrDefault("VpcSecurityGroupIds")
  valid_604512 = validateParameter(valid_604512, JArray, required = false,
                                 default = nil)
  if valid_604512 != nil:
    section.add "VpcSecurityGroupIds", valid_604512
  var valid_604513 = query.getOrDefault("NewClusterIdentifier")
  valid_604513 = validateParameter(valid_604513, JString, required = false,
                                 default = nil)
  if valid_604513 != nil:
    section.add "NewClusterIdentifier", valid_604513
  var valid_604514 = query.getOrDefault("MasterUserPassword")
  valid_604514 = validateParameter(valid_604514, JString, required = false,
                                 default = nil)
  if valid_604514 != nil:
    section.add "MasterUserPassword", valid_604514
  var valid_604515 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_604515 = validateParameter(valid_604515, JString, required = false,
                                 default = nil)
  if valid_604515 != nil:
    section.add "HsmConfigurationIdentifier", valid_604515
  var valid_604516 = query.getOrDefault("Version")
  valid_604516 = validateParameter(valid_604516, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604516 != nil:
    section.add "Version", valid_604516
  var valid_604517 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_604517 = validateParameter(valid_604517, JString, required = false,
                                 default = nil)
  if valid_604517 != nil:
    section.add "PreferredMaintenanceWindow", valid_604517
  var valid_604518 = query.getOrDefault("PubliclyAccessible")
  valid_604518 = validateParameter(valid_604518, JBool, required = false, default = nil)
  if valid_604518 != nil:
    section.add "PubliclyAccessible", valid_604518
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604519 = header.getOrDefault("X-Amz-Signature")
  valid_604519 = validateParameter(valid_604519, JString, required = false,
                                 default = nil)
  if valid_604519 != nil:
    section.add "X-Amz-Signature", valid_604519
  var valid_604520 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604520 = validateParameter(valid_604520, JString, required = false,
                                 default = nil)
  if valid_604520 != nil:
    section.add "X-Amz-Content-Sha256", valid_604520
  var valid_604521 = header.getOrDefault("X-Amz-Date")
  valid_604521 = validateParameter(valid_604521, JString, required = false,
                                 default = nil)
  if valid_604521 != nil:
    section.add "X-Amz-Date", valid_604521
  var valid_604522 = header.getOrDefault("X-Amz-Credential")
  valid_604522 = validateParameter(valid_604522, JString, required = false,
                                 default = nil)
  if valid_604522 != nil:
    section.add "X-Amz-Credential", valid_604522
  var valid_604523 = header.getOrDefault("X-Amz-Security-Token")
  valid_604523 = validateParameter(valid_604523, JString, required = false,
                                 default = nil)
  if valid_604523 != nil:
    section.add "X-Amz-Security-Token", valid_604523
  var valid_604524 = header.getOrDefault("X-Amz-Algorithm")
  valid_604524 = validateParameter(valid_604524, JString, required = false,
                                 default = nil)
  if valid_604524 != nil:
    section.add "X-Amz-Algorithm", valid_604524
  var valid_604525 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604525 = validateParameter(valid_604525, JString, required = false,
                                 default = nil)
  if valid_604525 != nil:
    section.add "X-Amz-SignedHeaders", valid_604525
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604526: Call_GetModifyCluster_604492; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_604526.validator(path, query, header, formData, body)
  let scheme = call_604526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604526.url(scheme.get, call_604526.host, call_604526.base,
                         call_604526.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604526, url, valid)

proc call*(call_604527: Call_GetModifyCluster_604492; ClusterIdentifier: string;
          MaintenanceTrackName: string = ""; Encrypted: bool = false;
          ManualSnapshotRetentionPeriod: int = 0;
          HsmClientCertificateIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil; KmsKeyId: string = "";
          ClusterParameterGroupName: string = ""; NodeType: string = "";
          ClusterVersion: string = ""; ClusterType: string = ""; NumberOfNodes: int = 0;
          AllowVersionUpgrade: bool = false; ElasticIp: string = "";
          AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false; Action: string = "ModifyCluster";
          VpcSecurityGroupIds: JsonNode = nil; NewClusterIdentifier: string = "";
          MasterUserPassword: string = ""; HsmConfigurationIdentifier: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  var query_604528 = newJObject()
  add(query_604528, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_604528, "Encrypted", newJBool(Encrypted))
  add(query_604528, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_604528, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if ClusterSecurityGroups != nil:
    query_604528.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_604528, "KmsKeyId", newJString(KmsKeyId))
  add(query_604528, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_604528, "NodeType", newJString(NodeType))
  add(query_604528, "ClusterVersion", newJString(ClusterVersion))
  add(query_604528, "ClusterType", newJString(ClusterType))
  add(query_604528, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_604528, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_604528, "ElasticIp", newJString(ElasticIp))
  add(query_604528, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_604528, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_604528, "Action", newJString(Action))
  add(query_604528, "ClusterIdentifier", newJString(ClusterIdentifier))
  if VpcSecurityGroupIds != nil:
    query_604528.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_604528, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(query_604528, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_604528, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_604528, "Version", newJString(Version))
  add(query_604528, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_604528, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_604527.call(nil, query_604528, nil, nil, nil)

var getModifyCluster* = Call_GetModifyCluster_604492(name: "getModifyCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_GetModifyCluster_604493,
    base: "/", url: url_GetModifyCluster_604494,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterDbRevision_604584 = ref object of OpenApiRestCall_601373
proc url_PostModifyClusterDbRevision_604586(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterDbRevision_604585(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604587 = query.getOrDefault("Action")
  valid_604587 = validateParameter(valid_604587, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_604587 != nil:
    section.add "Action", valid_604587
  var valid_604588 = query.getOrDefault("Version")
  valid_604588 = validateParameter(valid_604588, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604588 != nil:
    section.add "Version", valid_604588
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604589 = header.getOrDefault("X-Amz-Signature")
  valid_604589 = validateParameter(valid_604589, JString, required = false,
                                 default = nil)
  if valid_604589 != nil:
    section.add "X-Amz-Signature", valid_604589
  var valid_604590 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604590 = validateParameter(valid_604590, JString, required = false,
                                 default = nil)
  if valid_604590 != nil:
    section.add "X-Amz-Content-Sha256", valid_604590
  var valid_604591 = header.getOrDefault("X-Amz-Date")
  valid_604591 = validateParameter(valid_604591, JString, required = false,
                                 default = nil)
  if valid_604591 != nil:
    section.add "X-Amz-Date", valid_604591
  var valid_604592 = header.getOrDefault("X-Amz-Credential")
  valid_604592 = validateParameter(valid_604592, JString, required = false,
                                 default = nil)
  if valid_604592 != nil:
    section.add "X-Amz-Credential", valid_604592
  var valid_604593 = header.getOrDefault("X-Amz-Security-Token")
  valid_604593 = validateParameter(valid_604593, JString, required = false,
                                 default = nil)
  if valid_604593 != nil:
    section.add "X-Amz-Security-Token", valid_604593
  var valid_604594 = header.getOrDefault("X-Amz-Algorithm")
  valid_604594 = validateParameter(valid_604594, JString, required = false,
                                 default = nil)
  if valid_604594 != nil:
    section.add "X-Amz-Algorithm", valid_604594
  var valid_604595 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604595 = validateParameter(valid_604595, JString, required = false,
                                 default = nil)
  if valid_604595 != nil:
    section.add "X-Amz-SignedHeaders", valid_604595
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604596 = formData.getOrDefault("ClusterIdentifier")
  valid_604596 = validateParameter(valid_604596, JString, required = true,
                                 default = nil)
  if valid_604596 != nil:
    section.add "ClusterIdentifier", valid_604596
  var valid_604597 = formData.getOrDefault("RevisionTarget")
  valid_604597 = validateParameter(valid_604597, JString, required = true,
                                 default = nil)
  if valid_604597 != nil:
    section.add "RevisionTarget", valid_604597
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604598: Call_PostModifyClusterDbRevision_604584; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_604598.validator(path, query, header, formData, body)
  let scheme = call_604598.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604598.url(scheme.get, call_604598.host, call_604598.base,
                         call_604598.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604598, url, valid)

proc call*(call_604599: Call_PostModifyClusterDbRevision_604584;
          ClusterIdentifier: string; RevisionTarget: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Version: string (required)
  var query_604600 = newJObject()
  var formData_604601 = newJObject()
  add(formData_604601, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604600, "Action", newJString(Action))
  add(formData_604601, "RevisionTarget", newJString(RevisionTarget))
  add(query_604600, "Version", newJString(Version))
  result = call_604599.call(nil, query_604600, nil, formData_604601, nil)

var postModifyClusterDbRevision* = Call_PostModifyClusterDbRevision_604584(
    name: "postModifyClusterDbRevision", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_PostModifyClusterDbRevision_604585, base: "/",
    url: url_PostModifyClusterDbRevision_604586,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterDbRevision_604567 = ref object of OpenApiRestCall_601373
proc url_GetModifyClusterDbRevision_604569(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterDbRevision_604568(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `RevisionTarget` field"
  var valid_604570 = query.getOrDefault("RevisionTarget")
  valid_604570 = validateParameter(valid_604570, JString, required = true,
                                 default = nil)
  if valid_604570 != nil:
    section.add "RevisionTarget", valid_604570
  var valid_604571 = query.getOrDefault("Action")
  valid_604571 = validateParameter(valid_604571, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_604571 != nil:
    section.add "Action", valid_604571
  var valid_604572 = query.getOrDefault("ClusterIdentifier")
  valid_604572 = validateParameter(valid_604572, JString, required = true,
                                 default = nil)
  if valid_604572 != nil:
    section.add "ClusterIdentifier", valid_604572
  var valid_604573 = query.getOrDefault("Version")
  valid_604573 = validateParameter(valid_604573, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604573 != nil:
    section.add "Version", valid_604573
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604574 = header.getOrDefault("X-Amz-Signature")
  valid_604574 = validateParameter(valid_604574, JString, required = false,
                                 default = nil)
  if valid_604574 != nil:
    section.add "X-Amz-Signature", valid_604574
  var valid_604575 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604575 = validateParameter(valid_604575, JString, required = false,
                                 default = nil)
  if valid_604575 != nil:
    section.add "X-Amz-Content-Sha256", valid_604575
  var valid_604576 = header.getOrDefault("X-Amz-Date")
  valid_604576 = validateParameter(valid_604576, JString, required = false,
                                 default = nil)
  if valid_604576 != nil:
    section.add "X-Amz-Date", valid_604576
  var valid_604577 = header.getOrDefault("X-Amz-Credential")
  valid_604577 = validateParameter(valid_604577, JString, required = false,
                                 default = nil)
  if valid_604577 != nil:
    section.add "X-Amz-Credential", valid_604577
  var valid_604578 = header.getOrDefault("X-Amz-Security-Token")
  valid_604578 = validateParameter(valid_604578, JString, required = false,
                                 default = nil)
  if valid_604578 != nil:
    section.add "X-Amz-Security-Token", valid_604578
  var valid_604579 = header.getOrDefault("X-Amz-Algorithm")
  valid_604579 = validateParameter(valid_604579, JString, required = false,
                                 default = nil)
  if valid_604579 != nil:
    section.add "X-Amz-Algorithm", valid_604579
  var valid_604580 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604580 = validateParameter(valid_604580, JString, required = false,
                                 default = nil)
  if valid_604580 != nil:
    section.add "X-Amz-SignedHeaders", valid_604580
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604581: Call_GetModifyClusterDbRevision_604567; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_604581.validator(path, query, header, formData, body)
  let scheme = call_604581.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604581.url(scheme.get, call_604581.host, call_604581.base,
                         call_604581.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604581, url, valid)

proc call*(call_604582: Call_GetModifyClusterDbRevision_604567;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_604583 = newJObject()
  add(query_604583, "RevisionTarget", newJString(RevisionTarget))
  add(query_604583, "Action", newJString(Action))
  add(query_604583, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604583, "Version", newJString(Version))
  result = call_604582.call(nil, query_604583, nil, nil, nil)

var getModifyClusterDbRevision* = Call_GetModifyClusterDbRevision_604567(
    name: "getModifyClusterDbRevision", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_GetModifyClusterDbRevision_604568, base: "/",
    url: url_GetModifyClusterDbRevision_604569,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterIamRoles_604620 = ref object of OpenApiRestCall_601373
proc url_PostModifyClusterIamRoles_604622(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterIamRoles_604621(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604623 = query.getOrDefault("Action")
  valid_604623 = validateParameter(valid_604623, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_604623 != nil:
    section.add "Action", valid_604623
  var valid_604624 = query.getOrDefault("Version")
  valid_604624 = validateParameter(valid_604624, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604624 != nil:
    section.add "Version", valid_604624
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604625 = header.getOrDefault("X-Amz-Signature")
  valid_604625 = validateParameter(valid_604625, JString, required = false,
                                 default = nil)
  if valid_604625 != nil:
    section.add "X-Amz-Signature", valid_604625
  var valid_604626 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604626 = validateParameter(valid_604626, JString, required = false,
                                 default = nil)
  if valid_604626 != nil:
    section.add "X-Amz-Content-Sha256", valid_604626
  var valid_604627 = header.getOrDefault("X-Amz-Date")
  valid_604627 = validateParameter(valid_604627, JString, required = false,
                                 default = nil)
  if valid_604627 != nil:
    section.add "X-Amz-Date", valid_604627
  var valid_604628 = header.getOrDefault("X-Amz-Credential")
  valid_604628 = validateParameter(valid_604628, JString, required = false,
                                 default = nil)
  if valid_604628 != nil:
    section.add "X-Amz-Credential", valid_604628
  var valid_604629 = header.getOrDefault("X-Amz-Security-Token")
  valid_604629 = validateParameter(valid_604629, JString, required = false,
                                 default = nil)
  if valid_604629 != nil:
    section.add "X-Amz-Security-Token", valid_604629
  var valid_604630 = header.getOrDefault("X-Amz-Algorithm")
  valid_604630 = validateParameter(valid_604630, JString, required = false,
                                 default = nil)
  if valid_604630 != nil:
    section.add "X-Amz-Algorithm", valid_604630
  var valid_604631 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604631 = validateParameter(valid_604631, JString, required = false,
                                 default = nil)
  if valid_604631 != nil:
    section.add "X-Amz-SignedHeaders", valid_604631
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604632 = formData.getOrDefault("ClusterIdentifier")
  valid_604632 = validateParameter(valid_604632, JString, required = true,
                                 default = nil)
  if valid_604632 != nil:
    section.add "ClusterIdentifier", valid_604632
  var valid_604633 = formData.getOrDefault("RemoveIamRoles")
  valid_604633 = validateParameter(valid_604633, JArray, required = false,
                                 default = nil)
  if valid_604633 != nil:
    section.add "RemoveIamRoles", valid_604633
  var valid_604634 = formData.getOrDefault("AddIamRoles")
  valid_604634 = validateParameter(valid_604634, JArray, required = false,
                                 default = nil)
  if valid_604634 != nil:
    section.add "AddIamRoles", valid_604634
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604635: Call_PostModifyClusterIamRoles_604620; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_604635.validator(path, query, header, formData, body)
  let scheme = call_604635.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604635.url(scheme.get, call_604635.host, call_604635.base,
                         call_604635.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604635, url, valid)

proc call*(call_604636: Call_PostModifyClusterIamRoles_604620;
          ClusterIdentifier: string; RemoveIamRoles: JsonNode = nil;
          Action: string = "ModifyClusterIamRoles"; AddIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: string (required)
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Version: string (required)
  var query_604637 = newJObject()
  var formData_604638 = newJObject()
  add(formData_604638, "ClusterIdentifier", newJString(ClusterIdentifier))
  if RemoveIamRoles != nil:
    formData_604638.add "RemoveIamRoles", RemoveIamRoles
  add(query_604637, "Action", newJString(Action))
  if AddIamRoles != nil:
    formData_604638.add "AddIamRoles", AddIamRoles
  add(query_604637, "Version", newJString(Version))
  result = call_604636.call(nil, query_604637, nil, formData_604638, nil)

var postModifyClusterIamRoles* = Call_PostModifyClusterIamRoles_604620(
    name: "postModifyClusterIamRoles", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_PostModifyClusterIamRoles_604621, base: "/",
    url: url_PostModifyClusterIamRoles_604622,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterIamRoles_604602 = ref object of OpenApiRestCall_601373
proc url_GetModifyClusterIamRoles_604604(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterIamRoles_604603(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: JString (required)
  section = newJObject()
  var valid_604605 = query.getOrDefault("AddIamRoles")
  valid_604605 = validateParameter(valid_604605, JArray, required = false,
                                 default = nil)
  if valid_604605 != nil:
    section.add "AddIamRoles", valid_604605
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604606 = query.getOrDefault("Action")
  valid_604606 = validateParameter(valid_604606, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_604606 != nil:
    section.add "Action", valid_604606
  var valid_604607 = query.getOrDefault("ClusterIdentifier")
  valid_604607 = validateParameter(valid_604607, JString, required = true,
                                 default = nil)
  if valid_604607 != nil:
    section.add "ClusterIdentifier", valid_604607
  var valid_604608 = query.getOrDefault("RemoveIamRoles")
  valid_604608 = validateParameter(valid_604608, JArray, required = false,
                                 default = nil)
  if valid_604608 != nil:
    section.add "RemoveIamRoles", valid_604608
  var valid_604609 = query.getOrDefault("Version")
  valid_604609 = validateParameter(valid_604609, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604609 != nil:
    section.add "Version", valid_604609
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604610 = header.getOrDefault("X-Amz-Signature")
  valid_604610 = validateParameter(valid_604610, JString, required = false,
                                 default = nil)
  if valid_604610 != nil:
    section.add "X-Amz-Signature", valid_604610
  var valid_604611 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604611 = validateParameter(valid_604611, JString, required = false,
                                 default = nil)
  if valid_604611 != nil:
    section.add "X-Amz-Content-Sha256", valid_604611
  var valid_604612 = header.getOrDefault("X-Amz-Date")
  valid_604612 = validateParameter(valid_604612, JString, required = false,
                                 default = nil)
  if valid_604612 != nil:
    section.add "X-Amz-Date", valid_604612
  var valid_604613 = header.getOrDefault("X-Amz-Credential")
  valid_604613 = validateParameter(valid_604613, JString, required = false,
                                 default = nil)
  if valid_604613 != nil:
    section.add "X-Amz-Credential", valid_604613
  var valid_604614 = header.getOrDefault("X-Amz-Security-Token")
  valid_604614 = validateParameter(valid_604614, JString, required = false,
                                 default = nil)
  if valid_604614 != nil:
    section.add "X-Amz-Security-Token", valid_604614
  var valid_604615 = header.getOrDefault("X-Amz-Algorithm")
  valid_604615 = validateParameter(valid_604615, JString, required = false,
                                 default = nil)
  if valid_604615 != nil:
    section.add "X-Amz-Algorithm", valid_604615
  var valid_604616 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604616 = validateParameter(valid_604616, JString, required = false,
                                 default = nil)
  if valid_604616 != nil:
    section.add "X-Amz-SignedHeaders", valid_604616
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604617: Call_GetModifyClusterIamRoles_604602; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_604617.validator(path, query, header, formData, body)
  let scheme = call_604617.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604617.url(scheme.get, call_604617.host, call_604617.base,
                         call_604617.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604617, url, valid)

proc call*(call_604618: Call_GetModifyClusterIamRoles_604602;
          ClusterIdentifier: string; AddIamRoles: JsonNode = nil;
          Action: string = "ModifyClusterIamRoles"; RemoveIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: string (required)
  var query_604619 = newJObject()
  if AddIamRoles != nil:
    query_604619.add "AddIamRoles", AddIamRoles
  add(query_604619, "Action", newJString(Action))
  add(query_604619, "ClusterIdentifier", newJString(ClusterIdentifier))
  if RemoveIamRoles != nil:
    query_604619.add "RemoveIamRoles", RemoveIamRoles
  add(query_604619, "Version", newJString(Version))
  result = call_604618.call(nil, query_604619, nil, nil, nil)

var getModifyClusterIamRoles* = Call_GetModifyClusterIamRoles_604602(
    name: "getModifyClusterIamRoles", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_GetModifyClusterIamRoles_604603, base: "/",
    url: url_GetModifyClusterIamRoles_604604, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterMaintenance_604660 = ref object of OpenApiRestCall_601373
proc url_PostModifyClusterMaintenance_604662(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterMaintenance_604661(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604663 = query.getOrDefault("Action")
  valid_604663 = validateParameter(valid_604663, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_604663 != nil:
    section.add "Action", valid_604663
  var valid_604664 = query.getOrDefault("Version")
  valid_604664 = validateParameter(valid_604664, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604664 != nil:
    section.add "Version", valid_604664
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604665 = header.getOrDefault("X-Amz-Signature")
  valid_604665 = validateParameter(valid_604665, JString, required = false,
                                 default = nil)
  if valid_604665 != nil:
    section.add "X-Amz-Signature", valid_604665
  var valid_604666 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604666 = validateParameter(valid_604666, JString, required = false,
                                 default = nil)
  if valid_604666 != nil:
    section.add "X-Amz-Content-Sha256", valid_604666
  var valid_604667 = header.getOrDefault("X-Amz-Date")
  valid_604667 = validateParameter(valid_604667, JString, required = false,
                                 default = nil)
  if valid_604667 != nil:
    section.add "X-Amz-Date", valid_604667
  var valid_604668 = header.getOrDefault("X-Amz-Credential")
  valid_604668 = validateParameter(valid_604668, JString, required = false,
                                 default = nil)
  if valid_604668 != nil:
    section.add "X-Amz-Credential", valid_604668
  var valid_604669 = header.getOrDefault("X-Amz-Security-Token")
  valid_604669 = validateParameter(valid_604669, JString, required = false,
                                 default = nil)
  if valid_604669 != nil:
    section.add "X-Amz-Security-Token", valid_604669
  var valid_604670 = header.getOrDefault("X-Amz-Algorithm")
  valid_604670 = validateParameter(valid_604670, JString, required = false,
                                 default = nil)
  if valid_604670 != nil:
    section.add "X-Amz-Algorithm", valid_604670
  var valid_604671 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604671 = validateParameter(valid_604671, JString, required = false,
                                 default = nil)
  if valid_604671 != nil:
    section.add "X-Amz-SignedHeaders", valid_604671
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604672 = formData.getOrDefault("ClusterIdentifier")
  valid_604672 = validateParameter(valid_604672, JString, required = true,
                                 default = nil)
  if valid_604672 != nil:
    section.add "ClusterIdentifier", valid_604672
  var valid_604673 = formData.getOrDefault("DeferMaintenanceStartTime")
  valid_604673 = validateParameter(valid_604673, JString, required = false,
                                 default = nil)
  if valid_604673 != nil:
    section.add "DeferMaintenanceStartTime", valid_604673
  var valid_604674 = formData.getOrDefault("DeferMaintenance")
  valid_604674 = validateParameter(valid_604674, JBool, required = false, default = nil)
  if valid_604674 != nil:
    section.add "DeferMaintenance", valid_604674
  var valid_604675 = formData.getOrDefault("DeferMaintenanceDuration")
  valid_604675 = validateParameter(valid_604675, JInt, required = false, default = nil)
  if valid_604675 != nil:
    section.add "DeferMaintenanceDuration", valid_604675
  var valid_604676 = formData.getOrDefault("DeferMaintenanceEndTime")
  valid_604676 = validateParameter(valid_604676, JString, required = false,
                                 default = nil)
  if valid_604676 != nil:
    section.add "DeferMaintenanceEndTime", valid_604676
  var valid_604677 = formData.getOrDefault("DeferMaintenanceIdentifier")
  valid_604677 = validateParameter(valid_604677, JString, required = false,
                                 default = nil)
  if valid_604677 != nil:
    section.add "DeferMaintenanceIdentifier", valid_604677
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604678: Call_PostModifyClusterMaintenance_604660; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_604678.validator(path, query, header, formData, body)
  let scheme = call_604678.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604678.url(scheme.get, call_604678.host, call_604678.base,
                         call_604678.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604678, url, valid)

proc call*(call_604679: Call_PostModifyClusterMaintenance_604660;
          ClusterIdentifier: string; DeferMaintenanceStartTime: string = "";
          DeferMaintenance: bool = false; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceEndTime: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenanceIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: string (required)
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   Version: string (required)
  var query_604680 = newJObject()
  var formData_604681 = newJObject()
  add(formData_604681, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_604681, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(formData_604681, "DeferMaintenance", newJBool(DeferMaintenance))
  add(formData_604681, "DeferMaintenanceDuration",
      newJInt(DeferMaintenanceDuration))
  add(formData_604681, "DeferMaintenanceEndTime",
      newJString(DeferMaintenanceEndTime))
  add(query_604680, "Action", newJString(Action))
  add(formData_604681, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_604680, "Version", newJString(Version))
  result = call_604679.call(nil, query_604680, nil, formData_604681, nil)

var postModifyClusterMaintenance* = Call_PostModifyClusterMaintenance_604660(
    name: "postModifyClusterMaintenance", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_PostModifyClusterMaintenance_604661, base: "/",
    url: url_PostModifyClusterMaintenance_604662,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterMaintenance_604639 = ref object of OpenApiRestCall_601373
proc url_GetModifyClusterMaintenance_604641(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterMaintenance_604640(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: JString (required)
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: JString (required)
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  section = newJObject()
  var valid_604642 = query.getOrDefault("DeferMaintenanceDuration")
  valid_604642 = validateParameter(valid_604642, JInt, required = false, default = nil)
  if valid_604642 != nil:
    section.add "DeferMaintenanceDuration", valid_604642
  var valid_604643 = query.getOrDefault("DeferMaintenanceIdentifier")
  valid_604643 = validateParameter(valid_604643, JString, required = false,
                                 default = nil)
  if valid_604643 != nil:
    section.add "DeferMaintenanceIdentifier", valid_604643
  var valid_604644 = query.getOrDefault("DeferMaintenanceEndTime")
  valid_604644 = validateParameter(valid_604644, JString, required = false,
                                 default = nil)
  if valid_604644 != nil:
    section.add "DeferMaintenanceEndTime", valid_604644
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604645 = query.getOrDefault("Action")
  valid_604645 = validateParameter(valid_604645, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_604645 != nil:
    section.add "Action", valid_604645
  var valid_604646 = query.getOrDefault("DeferMaintenance")
  valid_604646 = validateParameter(valid_604646, JBool, required = false, default = nil)
  if valid_604646 != nil:
    section.add "DeferMaintenance", valid_604646
  var valid_604647 = query.getOrDefault("ClusterIdentifier")
  valid_604647 = validateParameter(valid_604647, JString, required = true,
                                 default = nil)
  if valid_604647 != nil:
    section.add "ClusterIdentifier", valid_604647
  var valid_604648 = query.getOrDefault("Version")
  valid_604648 = validateParameter(valid_604648, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604648 != nil:
    section.add "Version", valid_604648
  var valid_604649 = query.getOrDefault("DeferMaintenanceStartTime")
  valid_604649 = validateParameter(valid_604649, JString, required = false,
                                 default = nil)
  if valid_604649 != nil:
    section.add "DeferMaintenanceStartTime", valid_604649
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604650 = header.getOrDefault("X-Amz-Signature")
  valid_604650 = validateParameter(valid_604650, JString, required = false,
                                 default = nil)
  if valid_604650 != nil:
    section.add "X-Amz-Signature", valid_604650
  var valid_604651 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604651 = validateParameter(valid_604651, JString, required = false,
                                 default = nil)
  if valid_604651 != nil:
    section.add "X-Amz-Content-Sha256", valid_604651
  var valid_604652 = header.getOrDefault("X-Amz-Date")
  valid_604652 = validateParameter(valid_604652, JString, required = false,
                                 default = nil)
  if valid_604652 != nil:
    section.add "X-Amz-Date", valid_604652
  var valid_604653 = header.getOrDefault("X-Amz-Credential")
  valid_604653 = validateParameter(valid_604653, JString, required = false,
                                 default = nil)
  if valid_604653 != nil:
    section.add "X-Amz-Credential", valid_604653
  var valid_604654 = header.getOrDefault("X-Amz-Security-Token")
  valid_604654 = validateParameter(valid_604654, JString, required = false,
                                 default = nil)
  if valid_604654 != nil:
    section.add "X-Amz-Security-Token", valid_604654
  var valid_604655 = header.getOrDefault("X-Amz-Algorithm")
  valid_604655 = validateParameter(valid_604655, JString, required = false,
                                 default = nil)
  if valid_604655 != nil:
    section.add "X-Amz-Algorithm", valid_604655
  var valid_604656 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604656 = validateParameter(valid_604656, JString, required = false,
                                 default = nil)
  if valid_604656 != nil:
    section.add "X-Amz-SignedHeaders", valid_604656
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604657: Call_GetModifyClusterMaintenance_604639; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_604657.validator(path, query, header, formData, body)
  let scheme = call_604657.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604657.url(scheme.get, call_604657.host, call_604657.base,
                         call_604657.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604657, url, valid)

proc call*(call_604658: Call_GetModifyClusterMaintenance_604639;
          ClusterIdentifier: string; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceIdentifier: string = "";
          DeferMaintenanceEndTime: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenance: bool = false; Version: string = "2012-12-01";
          DeferMaintenanceStartTime: string = ""): Recallable =
  ## getModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: string (required)
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: string (required)
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  var query_604659 = newJObject()
  add(query_604659, "DeferMaintenanceDuration", newJInt(DeferMaintenanceDuration))
  add(query_604659, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_604659, "DeferMaintenanceEndTime", newJString(DeferMaintenanceEndTime))
  add(query_604659, "Action", newJString(Action))
  add(query_604659, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_604659, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604659, "Version", newJString(Version))
  add(query_604659, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  result = call_604658.call(nil, query_604659, nil, nil, nil)

var getModifyClusterMaintenance* = Call_GetModifyClusterMaintenance_604639(
    name: "getModifyClusterMaintenance", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_GetModifyClusterMaintenance_604640, base: "/",
    url: url_GetModifyClusterMaintenance_604641,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterParameterGroup_604699 = ref object of OpenApiRestCall_601373
proc url_PostModifyClusterParameterGroup_604701(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterParameterGroup_604700(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604702 = query.getOrDefault("Action")
  valid_604702 = validateParameter(valid_604702, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_604702 != nil:
    section.add "Action", valid_604702
  var valid_604703 = query.getOrDefault("Version")
  valid_604703 = validateParameter(valid_604703, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604703 != nil:
    section.add "Version", valid_604703
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604704 = header.getOrDefault("X-Amz-Signature")
  valid_604704 = validateParameter(valid_604704, JString, required = false,
                                 default = nil)
  if valid_604704 != nil:
    section.add "X-Amz-Signature", valid_604704
  var valid_604705 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604705 = validateParameter(valid_604705, JString, required = false,
                                 default = nil)
  if valid_604705 != nil:
    section.add "X-Amz-Content-Sha256", valid_604705
  var valid_604706 = header.getOrDefault("X-Amz-Date")
  valid_604706 = validateParameter(valid_604706, JString, required = false,
                                 default = nil)
  if valid_604706 != nil:
    section.add "X-Amz-Date", valid_604706
  var valid_604707 = header.getOrDefault("X-Amz-Credential")
  valid_604707 = validateParameter(valid_604707, JString, required = false,
                                 default = nil)
  if valid_604707 != nil:
    section.add "X-Amz-Credential", valid_604707
  var valid_604708 = header.getOrDefault("X-Amz-Security-Token")
  valid_604708 = validateParameter(valid_604708, JString, required = false,
                                 default = nil)
  if valid_604708 != nil:
    section.add "X-Amz-Security-Token", valid_604708
  var valid_604709 = header.getOrDefault("X-Amz-Algorithm")
  valid_604709 = validateParameter(valid_604709, JString, required = false,
                                 default = nil)
  if valid_604709 != nil:
    section.add "X-Amz-Algorithm", valid_604709
  var valid_604710 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604710 = validateParameter(valid_604710, JString, required = false,
                                 default = nil)
  if valid_604710 != nil:
    section.add "X-Amz-SignedHeaders", valid_604710
  result.add "header", section
  ## parameters in `formData` object:
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Parameters` field"
  var valid_604711 = formData.getOrDefault("Parameters")
  valid_604711 = validateParameter(valid_604711, JArray, required = true, default = nil)
  if valid_604711 != nil:
    section.add "Parameters", valid_604711
  var valid_604712 = formData.getOrDefault("ParameterGroupName")
  valid_604712 = validateParameter(valid_604712, JString, required = true,
                                 default = nil)
  if valid_604712 != nil:
    section.add "ParameterGroupName", valid_604712
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604713: Call_PostModifyClusterParameterGroup_604699;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_604713.validator(path, query, header, formData, body)
  let scheme = call_604713.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604713.url(scheme.get, call_604713.host, call_604713.base,
                         call_604713.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604713, url, valid)

proc call*(call_604714: Call_PostModifyClusterParameterGroup_604699;
          Parameters: JsonNode; ParameterGroupName: string;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: string (required)
  var query_604715 = newJObject()
  var formData_604716 = newJObject()
  add(query_604715, "Action", newJString(Action))
  if Parameters != nil:
    formData_604716.add "Parameters", Parameters
  add(formData_604716, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_604715, "Version", newJString(Version))
  result = call_604714.call(nil, query_604715, nil, formData_604716, nil)

var postModifyClusterParameterGroup* = Call_PostModifyClusterParameterGroup_604699(
    name: "postModifyClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_PostModifyClusterParameterGroup_604700, base: "/",
    url: url_PostModifyClusterParameterGroup_604701,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterParameterGroup_604682 = ref object of OpenApiRestCall_601373
proc url_GetModifyClusterParameterGroup_604684(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterParameterGroup_604683(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Parameters` field"
  var valid_604685 = query.getOrDefault("Parameters")
  valid_604685 = validateParameter(valid_604685, JArray, required = true, default = nil)
  if valid_604685 != nil:
    section.add "Parameters", valid_604685
  var valid_604686 = query.getOrDefault("Action")
  valid_604686 = validateParameter(valid_604686, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_604686 != nil:
    section.add "Action", valid_604686
  var valid_604687 = query.getOrDefault("ParameterGroupName")
  valid_604687 = validateParameter(valid_604687, JString, required = true,
                                 default = nil)
  if valid_604687 != nil:
    section.add "ParameterGroupName", valid_604687
  var valid_604688 = query.getOrDefault("Version")
  valid_604688 = validateParameter(valid_604688, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604688 != nil:
    section.add "Version", valid_604688
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604689 = header.getOrDefault("X-Amz-Signature")
  valid_604689 = validateParameter(valid_604689, JString, required = false,
                                 default = nil)
  if valid_604689 != nil:
    section.add "X-Amz-Signature", valid_604689
  var valid_604690 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604690 = validateParameter(valid_604690, JString, required = false,
                                 default = nil)
  if valid_604690 != nil:
    section.add "X-Amz-Content-Sha256", valid_604690
  var valid_604691 = header.getOrDefault("X-Amz-Date")
  valid_604691 = validateParameter(valid_604691, JString, required = false,
                                 default = nil)
  if valid_604691 != nil:
    section.add "X-Amz-Date", valid_604691
  var valid_604692 = header.getOrDefault("X-Amz-Credential")
  valid_604692 = validateParameter(valid_604692, JString, required = false,
                                 default = nil)
  if valid_604692 != nil:
    section.add "X-Amz-Credential", valid_604692
  var valid_604693 = header.getOrDefault("X-Amz-Security-Token")
  valid_604693 = validateParameter(valid_604693, JString, required = false,
                                 default = nil)
  if valid_604693 != nil:
    section.add "X-Amz-Security-Token", valid_604693
  var valid_604694 = header.getOrDefault("X-Amz-Algorithm")
  valid_604694 = validateParameter(valid_604694, JString, required = false,
                                 default = nil)
  if valid_604694 != nil:
    section.add "X-Amz-Algorithm", valid_604694
  var valid_604695 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604695 = validateParameter(valid_604695, JString, required = false,
                                 default = nil)
  if valid_604695 != nil:
    section.add "X-Amz-SignedHeaders", valid_604695
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604696: Call_GetModifyClusterParameterGroup_604682; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_604696.validator(path, query, header, formData, body)
  let scheme = call_604696.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604696.url(scheme.get, call_604696.host, call_604696.base,
                         call_604696.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604696, url, valid)

proc call*(call_604697: Call_GetModifyClusterParameterGroup_604682;
          Parameters: JsonNode; ParameterGroupName: string;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: string (required)
  var query_604698 = newJObject()
  if Parameters != nil:
    query_604698.add "Parameters", Parameters
  add(query_604698, "Action", newJString(Action))
  add(query_604698, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_604698, "Version", newJString(Version))
  result = call_604697.call(nil, query_604698, nil, nil, nil)

var getModifyClusterParameterGroup* = Call_GetModifyClusterParameterGroup_604682(
    name: "getModifyClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_GetModifyClusterParameterGroup_604683, base: "/",
    url: url_GetModifyClusterParameterGroup_604684,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshot_604735 = ref object of OpenApiRestCall_601373
proc url_PostModifyClusterSnapshot_604737(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshot_604736(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604738 = query.getOrDefault("Action")
  valid_604738 = validateParameter(valid_604738, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_604738 != nil:
    section.add "Action", valid_604738
  var valid_604739 = query.getOrDefault("Version")
  valid_604739 = validateParameter(valid_604739, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604739 != nil:
    section.add "Version", valid_604739
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604740 = header.getOrDefault("X-Amz-Signature")
  valid_604740 = validateParameter(valid_604740, JString, required = false,
                                 default = nil)
  if valid_604740 != nil:
    section.add "X-Amz-Signature", valid_604740
  var valid_604741 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604741 = validateParameter(valid_604741, JString, required = false,
                                 default = nil)
  if valid_604741 != nil:
    section.add "X-Amz-Content-Sha256", valid_604741
  var valid_604742 = header.getOrDefault("X-Amz-Date")
  valid_604742 = validateParameter(valid_604742, JString, required = false,
                                 default = nil)
  if valid_604742 != nil:
    section.add "X-Amz-Date", valid_604742
  var valid_604743 = header.getOrDefault("X-Amz-Credential")
  valid_604743 = validateParameter(valid_604743, JString, required = false,
                                 default = nil)
  if valid_604743 != nil:
    section.add "X-Amz-Credential", valid_604743
  var valid_604744 = header.getOrDefault("X-Amz-Security-Token")
  valid_604744 = validateParameter(valid_604744, JString, required = false,
                                 default = nil)
  if valid_604744 != nil:
    section.add "X-Amz-Security-Token", valid_604744
  var valid_604745 = header.getOrDefault("X-Amz-Algorithm")
  valid_604745 = validateParameter(valid_604745, JString, required = false,
                                 default = nil)
  if valid_604745 != nil:
    section.add "X-Amz-Algorithm", valid_604745
  var valid_604746 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604746 = validateParameter(valid_604746, JString, required = false,
                                 default = nil)
  if valid_604746 != nil:
    section.add "X-Amz-SignedHeaders", valid_604746
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_604747 = formData.getOrDefault("Force")
  valid_604747 = validateParameter(valid_604747, JBool, required = false, default = nil)
  if valid_604747 != nil:
    section.add "Force", valid_604747
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_604748 = formData.getOrDefault("SnapshotIdentifier")
  valid_604748 = validateParameter(valid_604748, JString, required = true,
                                 default = nil)
  if valid_604748 != nil:
    section.add "SnapshotIdentifier", valid_604748
  var valid_604749 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_604749 = validateParameter(valid_604749, JInt, required = false, default = nil)
  if valid_604749 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_604749
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604750: Call_PostModifyClusterSnapshot_604735; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_604750.validator(path, query, header, formData, body)
  let scheme = call_604750.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604750.url(scheme.get, call_604750.host, call_604750.base,
                         call_604750.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604750, url, valid)

proc call*(call_604751: Call_PostModifyClusterSnapshot_604735;
          SnapshotIdentifier: string; Force: bool = false;
          Action: string = "ModifyClusterSnapshot"; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_604752 = newJObject()
  var formData_604753 = newJObject()
  add(formData_604753, "Force", newJBool(Force))
  add(formData_604753, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_604752, "Action", newJString(Action))
  add(query_604752, "Version", newJString(Version))
  add(formData_604753, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_604751.call(nil, query_604752, nil, formData_604753, nil)

var postModifyClusterSnapshot* = Call_PostModifyClusterSnapshot_604735(
    name: "postModifyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_PostModifyClusterSnapshot_604736, base: "/",
    url: url_PostModifyClusterSnapshot_604737,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshot_604717 = ref object of OpenApiRestCall_601373
proc url_GetModifyClusterSnapshot_604719(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshot_604718(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_604720 = query.getOrDefault("SnapshotIdentifier")
  valid_604720 = validateParameter(valid_604720, JString, required = true,
                                 default = nil)
  if valid_604720 != nil:
    section.add "SnapshotIdentifier", valid_604720
  var valid_604721 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_604721 = validateParameter(valid_604721, JInt, required = false, default = nil)
  if valid_604721 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_604721
  var valid_604722 = query.getOrDefault("Force")
  valid_604722 = validateParameter(valid_604722, JBool, required = false, default = nil)
  if valid_604722 != nil:
    section.add "Force", valid_604722
  var valid_604723 = query.getOrDefault("Action")
  valid_604723 = validateParameter(valid_604723, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_604723 != nil:
    section.add "Action", valid_604723
  var valid_604724 = query.getOrDefault("Version")
  valid_604724 = validateParameter(valid_604724, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604724 != nil:
    section.add "Version", valid_604724
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604725 = header.getOrDefault("X-Amz-Signature")
  valid_604725 = validateParameter(valid_604725, JString, required = false,
                                 default = nil)
  if valid_604725 != nil:
    section.add "X-Amz-Signature", valid_604725
  var valid_604726 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604726 = validateParameter(valid_604726, JString, required = false,
                                 default = nil)
  if valid_604726 != nil:
    section.add "X-Amz-Content-Sha256", valid_604726
  var valid_604727 = header.getOrDefault("X-Amz-Date")
  valid_604727 = validateParameter(valid_604727, JString, required = false,
                                 default = nil)
  if valid_604727 != nil:
    section.add "X-Amz-Date", valid_604727
  var valid_604728 = header.getOrDefault("X-Amz-Credential")
  valid_604728 = validateParameter(valid_604728, JString, required = false,
                                 default = nil)
  if valid_604728 != nil:
    section.add "X-Amz-Credential", valid_604728
  var valid_604729 = header.getOrDefault("X-Amz-Security-Token")
  valid_604729 = validateParameter(valid_604729, JString, required = false,
                                 default = nil)
  if valid_604729 != nil:
    section.add "X-Amz-Security-Token", valid_604729
  var valid_604730 = header.getOrDefault("X-Amz-Algorithm")
  valid_604730 = validateParameter(valid_604730, JString, required = false,
                                 default = nil)
  if valid_604730 != nil:
    section.add "X-Amz-Algorithm", valid_604730
  var valid_604731 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604731 = validateParameter(valid_604731, JString, required = false,
                                 default = nil)
  if valid_604731 != nil:
    section.add "X-Amz-SignedHeaders", valid_604731
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604732: Call_GetModifyClusterSnapshot_604717; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_604732.validator(path, query, header, formData, body)
  let scheme = call_604732.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604732.url(scheme.get, call_604732.host, call_604732.base,
                         call_604732.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604732, url, valid)

proc call*(call_604733: Call_GetModifyClusterSnapshot_604717;
          SnapshotIdentifier: string; ManualSnapshotRetentionPeriod: int = 0;
          Force: bool = false; Action: string = "ModifyClusterSnapshot";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604734 = newJObject()
  add(query_604734, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_604734, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_604734, "Force", newJBool(Force))
  add(query_604734, "Action", newJString(Action))
  add(query_604734, "Version", newJString(Version))
  result = call_604733.call(nil, query_604734, nil, nil, nil)

var getModifyClusterSnapshot* = Call_GetModifyClusterSnapshot_604717(
    name: "getModifyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_GetModifyClusterSnapshot_604718, base: "/",
    url: url_GetModifyClusterSnapshot_604719, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshotSchedule_604772 = ref object of OpenApiRestCall_601373
proc url_PostModifyClusterSnapshotSchedule_604774(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshotSchedule_604773(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604775 = query.getOrDefault("Action")
  valid_604775 = validateParameter(valid_604775, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_604775 != nil:
    section.add "Action", valid_604775
  var valid_604776 = query.getOrDefault("Version")
  valid_604776 = validateParameter(valid_604776, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604776 != nil:
    section.add "Version", valid_604776
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604777 = header.getOrDefault("X-Amz-Signature")
  valid_604777 = validateParameter(valid_604777, JString, required = false,
                                 default = nil)
  if valid_604777 != nil:
    section.add "X-Amz-Signature", valid_604777
  var valid_604778 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604778 = validateParameter(valid_604778, JString, required = false,
                                 default = nil)
  if valid_604778 != nil:
    section.add "X-Amz-Content-Sha256", valid_604778
  var valid_604779 = header.getOrDefault("X-Amz-Date")
  valid_604779 = validateParameter(valid_604779, JString, required = false,
                                 default = nil)
  if valid_604779 != nil:
    section.add "X-Amz-Date", valid_604779
  var valid_604780 = header.getOrDefault("X-Amz-Credential")
  valid_604780 = validateParameter(valid_604780, JString, required = false,
                                 default = nil)
  if valid_604780 != nil:
    section.add "X-Amz-Credential", valid_604780
  var valid_604781 = header.getOrDefault("X-Amz-Security-Token")
  valid_604781 = validateParameter(valid_604781, JString, required = false,
                                 default = nil)
  if valid_604781 != nil:
    section.add "X-Amz-Security-Token", valid_604781
  var valid_604782 = header.getOrDefault("X-Amz-Algorithm")
  valid_604782 = validateParameter(valid_604782, JString, required = false,
                                 default = nil)
  if valid_604782 != nil:
    section.add "X-Amz-Algorithm", valid_604782
  var valid_604783 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604783 = validateParameter(valid_604783, JString, required = false,
                                 default = nil)
  if valid_604783 != nil:
    section.add "X-Amz-SignedHeaders", valid_604783
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604784 = formData.getOrDefault("ClusterIdentifier")
  valid_604784 = validateParameter(valid_604784, JString, required = true,
                                 default = nil)
  if valid_604784 != nil:
    section.add "ClusterIdentifier", valid_604784
  var valid_604785 = formData.getOrDefault("ScheduleIdentifier")
  valid_604785 = validateParameter(valid_604785, JString, required = false,
                                 default = nil)
  if valid_604785 != nil:
    section.add "ScheduleIdentifier", valid_604785
  var valid_604786 = formData.getOrDefault("DisassociateSchedule")
  valid_604786 = validateParameter(valid_604786, JBool, required = false, default = nil)
  if valid_604786 != nil:
    section.add "DisassociateSchedule", valid_604786
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604787: Call_PostModifyClusterSnapshotSchedule_604772;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_604787.validator(path, query, header, formData, body)
  let scheme = call_604787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604787.url(scheme.get, call_604787.host, call_604787.base,
                         call_604787.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604787, url, valid)

proc call*(call_604788: Call_PostModifyClusterSnapshotSchedule_604772;
          ClusterIdentifier: string;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; DisassociateSchedule: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: string (required)
  var query_604789 = newJObject()
  var formData_604790 = newJObject()
  add(formData_604790, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604789, "Action", newJString(Action))
  add(formData_604790, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(formData_604790, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_604789, "Version", newJString(Version))
  result = call_604788.call(nil, query_604789, nil, formData_604790, nil)

var postModifyClusterSnapshotSchedule* = Call_PostModifyClusterSnapshotSchedule_604772(
    name: "postModifyClusterSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_PostModifyClusterSnapshotSchedule_604773, base: "/",
    url: url_PostModifyClusterSnapshotSchedule_604774,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshotSchedule_604754 = ref object of OpenApiRestCall_601373
proc url_GetModifyClusterSnapshotSchedule_604756(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshotSchedule_604755(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Action: JString (required)
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_604757 = query.getOrDefault("ScheduleIdentifier")
  valid_604757 = validateParameter(valid_604757, JString, required = false,
                                 default = nil)
  if valid_604757 != nil:
    section.add "ScheduleIdentifier", valid_604757
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604758 = query.getOrDefault("Action")
  valid_604758 = validateParameter(valid_604758, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_604758 != nil:
    section.add "Action", valid_604758
  var valid_604759 = query.getOrDefault("DisassociateSchedule")
  valid_604759 = validateParameter(valid_604759, JBool, required = false, default = nil)
  if valid_604759 != nil:
    section.add "DisassociateSchedule", valid_604759
  var valid_604760 = query.getOrDefault("ClusterIdentifier")
  valid_604760 = validateParameter(valid_604760, JString, required = true,
                                 default = nil)
  if valid_604760 != nil:
    section.add "ClusterIdentifier", valid_604760
  var valid_604761 = query.getOrDefault("Version")
  valid_604761 = validateParameter(valid_604761, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604761 != nil:
    section.add "Version", valid_604761
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604762 = header.getOrDefault("X-Amz-Signature")
  valid_604762 = validateParameter(valid_604762, JString, required = false,
                                 default = nil)
  if valid_604762 != nil:
    section.add "X-Amz-Signature", valid_604762
  var valid_604763 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604763 = validateParameter(valid_604763, JString, required = false,
                                 default = nil)
  if valid_604763 != nil:
    section.add "X-Amz-Content-Sha256", valid_604763
  var valid_604764 = header.getOrDefault("X-Amz-Date")
  valid_604764 = validateParameter(valid_604764, JString, required = false,
                                 default = nil)
  if valid_604764 != nil:
    section.add "X-Amz-Date", valid_604764
  var valid_604765 = header.getOrDefault("X-Amz-Credential")
  valid_604765 = validateParameter(valid_604765, JString, required = false,
                                 default = nil)
  if valid_604765 != nil:
    section.add "X-Amz-Credential", valid_604765
  var valid_604766 = header.getOrDefault("X-Amz-Security-Token")
  valid_604766 = validateParameter(valid_604766, JString, required = false,
                                 default = nil)
  if valid_604766 != nil:
    section.add "X-Amz-Security-Token", valid_604766
  var valid_604767 = header.getOrDefault("X-Amz-Algorithm")
  valid_604767 = validateParameter(valid_604767, JString, required = false,
                                 default = nil)
  if valid_604767 != nil:
    section.add "X-Amz-Algorithm", valid_604767
  var valid_604768 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604768 = validateParameter(valid_604768, JString, required = false,
                                 default = nil)
  if valid_604768 != nil:
    section.add "X-Amz-SignedHeaders", valid_604768
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604769: Call_GetModifyClusterSnapshotSchedule_604754;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_604769.validator(path, query, header, formData, body)
  let scheme = call_604769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604769.url(scheme.get, call_604769.host, call_604769.base,
                         call_604769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604769, url, valid)

proc call*(call_604770: Call_GetModifyClusterSnapshotSchedule_604754;
          ClusterIdentifier: string; ScheduleIdentifier: string = "";
          Action: string = "ModifyClusterSnapshotSchedule";
          DisassociateSchedule: bool = false; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Action: string (required)
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Version: string (required)
  var query_604771 = newJObject()
  add(query_604771, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_604771, "Action", newJString(Action))
  add(query_604771, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_604771, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604771, "Version", newJString(Version))
  result = call_604770.call(nil, query_604771, nil, nil, nil)

var getModifyClusterSnapshotSchedule* = Call_GetModifyClusterSnapshotSchedule_604754(
    name: "getModifyClusterSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_GetModifyClusterSnapshotSchedule_604755, base: "/",
    url: url_GetModifyClusterSnapshotSchedule_604756,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSubnetGroup_604809 = ref object of OpenApiRestCall_601373
proc url_PostModifyClusterSubnetGroup_604811(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSubnetGroup_604810(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604812 = query.getOrDefault("Action")
  valid_604812 = validateParameter(valid_604812, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_604812 != nil:
    section.add "Action", valid_604812
  var valid_604813 = query.getOrDefault("Version")
  valid_604813 = validateParameter(valid_604813, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604813 != nil:
    section.add "Version", valid_604813
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604814 = header.getOrDefault("X-Amz-Signature")
  valid_604814 = validateParameter(valid_604814, JString, required = false,
                                 default = nil)
  if valid_604814 != nil:
    section.add "X-Amz-Signature", valid_604814
  var valid_604815 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604815 = validateParameter(valid_604815, JString, required = false,
                                 default = nil)
  if valid_604815 != nil:
    section.add "X-Amz-Content-Sha256", valid_604815
  var valid_604816 = header.getOrDefault("X-Amz-Date")
  valid_604816 = validateParameter(valid_604816, JString, required = false,
                                 default = nil)
  if valid_604816 != nil:
    section.add "X-Amz-Date", valid_604816
  var valid_604817 = header.getOrDefault("X-Amz-Credential")
  valid_604817 = validateParameter(valid_604817, JString, required = false,
                                 default = nil)
  if valid_604817 != nil:
    section.add "X-Amz-Credential", valid_604817
  var valid_604818 = header.getOrDefault("X-Amz-Security-Token")
  valid_604818 = validateParameter(valid_604818, JString, required = false,
                                 default = nil)
  if valid_604818 != nil:
    section.add "X-Amz-Security-Token", valid_604818
  var valid_604819 = header.getOrDefault("X-Amz-Algorithm")
  valid_604819 = validateParameter(valid_604819, JString, required = false,
                                 default = nil)
  if valid_604819 != nil:
    section.add "X-Amz-Algorithm", valid_604819
  var valid_604820 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604820 = validateParameter(valid_604820, JString, required = false,
                                 default = nil)
  if valid_604820 != nil:
    section.add "X-Amz-SignedHeaders", valid_604820
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  section = newJObject()
  var valid_604821 = formData.getOrDefault("Description")
  valid_604821 = validateParameter(valid_604821, JString, required = false,
                                 default = nil)
  if valid_604821 != nil:
    section.add "Description", valid_604821
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_604822 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_604822 = validateParameter(valid_604822, JString, required = true,
                                 default = nil)
  if valid_604822 != nil:
    section.add "ClusterSubnetGroupName", valid_604822
  var valid_604823 = formData.getOrDefault("SubnetIds")
  valid_604823 = validateParameter(valid_604823, JArray, required = true, default = nil)
  if valid_604823 != nil:
    section.add "SubnetIds", valid_604823
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604824: Call_PostModifyClusterSubnetGroup_604809; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_604824.validator(path, query, header, formData, body)
  let scheme = call_604824.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604824.url(scheme.get, call_604824.host, call_604824.base,
                         call_604824.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604824, url, valid)

proc call*(call_604825: Call_PostModifyClusterSubnetGroup_604809;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Description: string = ""; Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  var query_604826 = newJObject()
  var formData_604827 = newJObject()
  add(formData_604827, "Description", newJString(Description))
  add(formData_604827, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_604826, "Action", newJString(Action))
  add(query_604826, "Version", newJString(Version))
  if SubnetIds != nil:
    formData_604827.add "SubnetIds", SubnetIds
  result = call_604825.call(nil, query_604826, nil, formData_604827, nil)

var postModifyClusterSubnetGroup* = Call_PostModifyClusterSubnetGroup_604809(
    name: "postModifyClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_PostModifyClusterSubnetGroup_604810, base: "/",
    url: url_PostModifyClusterSubnetGroup_604811,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSubnetGroup_604791 = ref object of OpenApiRestCall_601373
proc url_GetModifyClusterSubnetGroup_604793(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSubnetGroup_604792(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: JString (required)
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_604794 = query.getOrDefault("ClusterSubnetGroupName")
  valid_604794 = validateParameter(valid_604794, JString, required = true,
                                 default = nil)
  if valid_604794 != nil:
    section.add "ClusterSubnetGroupName", valid_604794
  var valid_604795 = query.getOrDefault("SubnetIds")
  valid_604795 = validateParameter(valid_604795, JArray, required = true, default = nil)
  if valid_604795 != nil:
    section.add "SubnetIds", valid_604795
  var valid_604796 = query.getOrDefault("Action")
  valid_604796 = validateParameter(valid_604796, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_604796 != nil:
    section.add "Action", valid_604796
  var valid_604797 = query.getOrDefault("Description")
  valid_604797 = validateParameter(valid_604797, JString, required = false,
                                 default = nil)
  if valid_604797 != nil:
    section.add "Description", valid_604797
  var valid_604798 = query.getOrDefault("Version")
  valid_604798 = validateParameter(valid_604798, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604798 != nil:
    section.add "Version", valid_604798
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604799 = header.getOrDefault("X-Amz-Signature")
  valid_604799 = validateParameter(valid_604799, JString, required = false,
                                 default = nil)
  if valid_604799 != nil:
    section.add "X-Amz-Signature", valid_604799
  var valid_604800 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604800 = validateParameter(valid_604800, JString, required = false,
                                 default = nil)
  if valid_604800 != nil:
    section.add "X-Amz-Content-Sha256", valid_604800
  var valid_604801 = header.getOrDefault("X-Amz-Date")
  valid_604801 = validateParameter(valid_604801, JString, required = false,
                                 default = nil)
  if valid_604801 != nil:
    section.add "X-Amz-Date", valid_604801
  var valid_604802 = header.getOrDefault("X-Amz-Credential")
  valid_604802 = validateParameter(valid_604802, JString, required = false,
                                 default = nil)
  if valid_604802 != nil:
    section.add "X-Amz-Credential", valid_604802
  var valid_604803 = header.getOrDefault("X-Amz-Security-Token")
  valid_604803 = validateParameter(valid_604803, JString, required = false,
                                 default = nil)
  if valid_604803 != nil:
    section.add "X-Amz-Security-Token", valid_604803
  var valid_604804 = header.getOrDefault("X-Amz-Algorithm")
  valid_604804 = validateParameter(valid_604804, JString, required = false,
                                 default = nil)
  if valid_604804 != nil:
    section.add "X-Amz-Algorithm", valid_604804
  var valid_604805 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604805 = validateParameter(valid_604805, JString, required = false,
                                 default = nil)
  if valid_604805 != nil:
    section.add "X-Amz-SignedHeaders", valid_604805
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604806: Call_GetModifyClusterSubnetGroup_604791; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_604806.validator(path, query, header, formData, body)
  let scheme = call_604806.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604806.url(scheme.get, call_604806.host, call_604806.base,
                         call_604806.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604806, url, valid)

proc call*(call_604807: Call_GetModifyClusterSubnetGroup_604791;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Action: string = "ModifyClusterSubnetGroup"; Description: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   Version: string (required)
  var query_604808 = newJObject()
  add(query_604808, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  if SubnetIds != nil:
    query_604808.add "SubnetIds", SubnetIds
  add(query_604808, "Action", newJString(Action))
  add(query_604808, "Description", newJString(Description))
  add(query_604808, "Version", newJString(Version))
  result = call_604807.call(nil, query_604808, nil, nil, nil)

var getModifyClusterSubnetGroup* = Call_GetModifyClusterSubnetGroup_604791(
    name: "getModifyClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_GetModifyClusterSubnetGroup_604792, base: "/",
    url: url_GetModifyClusterSubnetGroup_604793,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyEventSubscription_604850 = ref object of OpenApiRestCall_601373
proc url_PostModifyEventSubscription_604852(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyEventSubscription_604851(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604853 = query.getOrDefault("Action")
  valid_604853 = validateParameter(valid_604853, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_604853 != nil:
    section.add "Action", valid_604853
  var valid_604854 = query.getOrDefault("Version")
  valid_604854 = validateParameter(valid_604854, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604854 != nil:
    section.add "Version", valid_604854
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604855 = header.getOrDefault("X-Amz-Signature")
  valid_604855 = validateParameter(valid_604855, JString, required = false,
                                 default = nil)
  if valid_604855 != nil:
    section.add "X-Amz-Signature", valid_604855
  var valid_604856 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604856 = validateParameter(valid_604856, JString, required = false,
                                 default = nil)
  if valid_604856 != nil:
    section.add "X-Amz-Content-Sha256", valid_604856
  var valid_604857 = header.getOrDefault("X-Amz-Date")
  valid_604857 = validateParameter(valid_604857, JString, required = false,
                                 default = nil)
  if valid_604857 != nil:
    section.add "X-Amz-Date", valid_604857
  var valid_604858 = header.getOrDefault("X-Amz-Credential")
  valid_604858 = validateParameter(valid_604858, JString, required = false,
                                 default = nil)
  if valid_604858 != nil:
    section.add "X-Amz-Credential", valid_604858
  var valid_604859 = header.getOrDefault("X-Amz-Security-Token")
  valid_604859 = validateParameter(valid_604859, JString, required = false,
                                 default = nil)
  if valid_604859 != nil:
    section.add "X-Amz-Security-Token", valid_604859
  var valid_604860 = header.getOrDefault("X-Amz-Algorithm")
  valid_604860 = validateParameter(valid_604860, JString, required = false,
                                 default = nil)
  if valid_604860 != nil:
    section.add "X-Amz-Algorithm", valid_604860
  var valid_604861 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604861 = validateParameter(valid_604861, JString, required = false,
                                 default = nil)
  if valid_604861 != nil:
    section.add "X-Amz-SignedHeaders", valid_604861
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  section = newJObject()
  var valid_604862 = formData.getOrDefault("SourceIds")
  valid_604862 = validateParameter(valid_604862, JArray, required = false,
                                 default = nil)
  if valid_604862 != nil:
    section.add "SourceIds", valid_604862
  var valid_604863 = formData.getOrDefault("SnsTopicArn")
  valid_604863 = validateParameter(valid_604863, JString, required = false,
                                 default = nil)
  if valid_604863 != nil:
    section.add "SnsTopicArn", valid_604863
  var valid_604864 = formData.getOrDefault("Enabled")
  valid_604864 = validateParameter(valid_604864, JBool, required = false, default = nil)
  if valid_604864 != nil:
    section.add "Enabled", valid_604864
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_604865 = formData.getOrDefault("SubscriptionName")
  valid_604865 = validateParameter(valid_604865, JString, required = true,
                                 default = nil)
  if valid_604865 != nil:
    section.add "SubscriptionName", valid_604865
  var valid_604866 = formData.getOrDefault("SourceType")
  valid_604866 = validateParameter(valid_604866, JString, required = false,
                                 default = nil)
  if valid_604866 != nil:
    section.add "SourceType", valid_604866
  var valid_604867 = formData.getOrDefault("Severity")
  valid_604867 = validateParameter(valid_604867, JString, required = false,
                                 default = nil)
  if valid_604867 != nil:
    section.add "Severity", valid_604867
  var valid_604868 = formData.getOrDefault("EventCategories")
  valid_604868 = validateParameter(valid_604868, JArray, required = false,
                                 default = nil)
  if valid_604868 != nil:
    section.add "EventCategories", valid_604868
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604869: Call_PostModifyEventSubscription_604850; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_604869.validator(path, query, header, formData, body)
  let scheme = call_604869.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604869.url(scheme.get, call_604869.host, call_604869.base,
                         call_604869.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604869, url, valid)

proc call*(call_604870: Call_PostModifyEventSubscription_604850;
          SubscriptionName: string; SourceIds: JsonNode = nil;
          SnsTopicArn: string = ""; Enabled: bool = false; SourceType: string = "";
          Severity: string = ""; EventCategories: JsonNode = nil;
          Action: string = "ModifyEventSubscription"; Version: string = "2012-12-01"): Recallable =
  ## postModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604871 = newJObject()
  var formData_604872 = newJObject()
  if SourceIds != nil:
    formData_604872.add "SourceIds", SourceIds
  add(formData_604872, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_604872, "Enabled", newJBool(Enabled))
  add(formData_604872, "SubscriptionName", newJString(SubscriptionName))
  add(formData_604872, "SourceType", newJString(SourceType))
  add(formData_604872, "Severity", newJString(Severity))
  if EventCategories != nil:
    formData_604872.add "EventCategories", EventCategories
  add(query_604871, "Action", newJString(Action))
  add(query_604871, "Version", newJString(Version))
  result = call_604870.call(nil, query_604871, nil, formData_604872, nil)

var postModifyEventSubscription* = Call_PostModifyEventSubscription_604850(
    name: "postModifyEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_PostModifyEventSubscription_604851, base: "/",
    url: url_PostModifyEventSubscription_604852,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyEventSubscription_604828 = ref object of OpenApiRestCall_601373
proc url_GetModifyEventSubscription_604830(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyEventSubscription_604829(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: JString (required)
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Version: JString (required)
  section = newJObject()
  var valid_604831 = query.getOrDefault("SourceType")
  valid_604831 = validateParameter(valid_604831, JString, required = false,
                                 default = nil)
  if valid_604831 != nil:
    section.add "SourceType", valid_604831
  var valid_604832 = query.getOrDefault("Enabled")
  valid_604832 = validateParameter(valid_604832, JBool, required = false, default = nil)
  if valid_604832 != nil:
    section.add "Enabled", valid_604832
  var valid_604833 = query.getOrDefault("Severity")
  valid_604833 = validateParameter(valid_604833, JString, required = false,
                                 default = nil)
  if valid_604833 != nil:
    section.add "Severity", valid_604833
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_604834 = query.getOrDefault("SubscriptionName")
  valid_604834 = validateParameter(valid_604834, JString, required = true,
                                 default = nil)
  if valid_604834 != nil:
    section.add "SubscriptionName", valid_604834
  var valid_604835 = query.getOrDefault("EventCategories")
  valid_604835 = validateParameter(valid_604835, JArray, required = false,
                                 default = nil)
  if valid_604835 != nil:
    section.add "EventCategories", valid_604835
  var valid_604836 = query.getOrDefault("SourceIds")
  valid_604836 = validateParameter(valid_604836, JArray, required = false,
                                 default = nil)
  if valid_604836 != nil:
    section.add "SourceIds", valid_604836
  var valid_604837 = query.getOrDefault("Action")
  valid_604837 = validateParameter(valid_604837, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_604837 != nil:
    section.add "Action", valid_604837
  var valid_604838 = query.getOrDefault("SnsTopicArn")
  valid_604838 = validateParameter(valid_604838, JString, required = false,
                                 default = nil)
  if valid_604838 != nil:
    section.add "SnsTopicArn", valid_604838
  var valid_604839 = query.getOrDefault("Version")
  valid_604839 = validateParameter(valid_604839, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604839 != nil:
    section.add "Version", valid_604839
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604840 = header.getOrDefault("X-Amz-Signature")
  valid_604840 = validateParameter(valid_604840, JString, required = false,
                                 default = nil)
  if valid_604840 != nil:
    section.add "X-Amz-Signature", valid_604840
  var valid_604841 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604841 = validateParameter(valid_604841, JString, required = false,
                                 default = nil)
  if valid_604841 != nil:
    section.add "X-Amz-Content-Sha256", valid_604841
  var valid_604842 = header.getOrDefault("X-Amz-Date")
  valid_604842 = validateParameter(valid_604842, JString, required = false,
                                 default = nil)
  if valid_604842 != nil:
    section.add "X-Amz-Date", valid_604842
  var valid_604843 = header.getOrDefault("X-Amz-Credential")
  valid_604843 = validateParameter(valid_604843, JString, required = false,
                                 default = nil)
  if valid_604843 != nil:
    section.add "X-Amz-Credential", valid_604843
  var valid_604844 = header.getOrDefault("X-Amz-Security-Token")
  valid_604844 = validateParameter(valid_604844, JString, required = false,
                                 default = nil)
  if valid_604844 != nil:
    section.add "X-Amz-Security-Token", valid_604844
  var valid_604845 = header.getOrDefault("X-Amz-Algorithm")
  valid_604845 = validateParameter(valid_604845, JString, required = false,
                                 default = nil)
  if valid_604845 != nil:
    section.add "X-Amz-Algorithm", valid_604845
  var valid_604846 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604846 = validateParameter(valid_604846, JString, required = false,
                                 default = nil)
  if valid_604846 != nil:
    section.add "X-Amz-SignedHeaders", valid_604846
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604847: Call_GetModifyEventSubscription_604828; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_604847.validator(path, query, header, formData, body)
  let scheme = call_604847.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604847.url(scheme.get, call_604847.host, call_604847.base,
                         call_604847.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604847, url, valid)

proc call*(call_604848: Call_GetModifyEventSubscription_604828;
          SubscriptionName: string; SourceType: string = ""; Enabled: bool = false;
          Severity: string = ""; EventCategories: JsonNode = nil;
          SourceIds: JsonNode = nil; Action: string = "ModifyEventSubscription";
          SnsTopicArn: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: string (required)
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Version: string (required)
  var query_604849 = newJObject()
  add(query_604849, "SourceType", newJString(SourceType))
  add(query_604849, "Enabled", newJBool(Enabled))
  add(query_604849, "Severity", newJString(Severity))
  add(query_604849, "SubscriptionName", newJString(SubscriptionName))
  if EventCategories != nil:
    query_604849.add "EventCategories", EventCategories
  if SourceIds != nil:
    query_604849.add "SourceIds", SourceIds
  add(query_604849, "Action", newJString(Action))
  add(query_604849, "SnsTopicArn", newJString(SnsTopicArn))
  add(query_604849, "Version", newJString(Version))
  result = call_604848.call(nil, query_604849, nil, nil, nil)

var getModifyEventSubscription* = Call_GetModifyEventSubscription_604828(
    name: "getModifyEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_GetModifyEventSubscription_604829, base: "/",
    url: url_GetModifyEventSubscription_604830,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyScheduledAction_604896 = ref object of OpenApiRestCall_601373
proc url_PostModifyScheduledAction_604898(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyScheduledAction_604897(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modify a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604899 = query.getOrDefault("Action")
  valid_604899 = validateParameter(valid_604899, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_604899 != nil:
    section.add "Action", valid_604899
  var valid_604900 = query.getOrDefault("Version")
  valid_604900 = validateParameter(valid_604900, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604900 != nil:
    section.add "Version", valid_604900
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604901 = header.getOrDefault("X-Amz-Signature")
  valid_604901 = validateParameter(valid_604901, JString, required = false,
                                 default = nil)
  if valid_604901 != nil:
    section.add "X-Amz-Signature", valid_604901
  var valid_604902 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604902 = validateParameter(valid_604902, JString, required = false,
                                 default = nil)
  if valid_604902 != nil:
    section.add "X-Amz-Content-Sha256", valid_604902
  var valid_604903 = header.getOrDefault("X-Amz-Date")
  valid_604903 = validateParameter(valid_604903, JString, required = false,
                                 default = nil)
  if valid_604903 != nil:
    section.add "X-Amz-Date", valid_604903
  var valid_604904 = header.getOrDefault("X-Amz-Credential")
  valid_604904 = validateParameter(valid_604904, JString, required = false,
                                 default = nil)
  if valid_604904 != nil:
    section.add "X-Amz-Credential", valid_604904
  var valid_604905 = header.getOrDefault("X-Amz-Security-Token")
  valid_604905 = validateParameter(valid_604905, JString, required = false,
                                 default = nil)
  if valid_604905 != nil:
    section.add "X-Amz-Security-Token", valid_604905
  var valid_604906 = header.getOrDefault("X-Amz-Algorithm")
  valid_604906 = validateParameter(valid_604906, JString, required = false,
                                 default = nil)
  if valid_604906 != nil:
    section.add "X-Amz-Algorithm", valid_604906
  var valid_604907 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604907 = validateParameter(valid_604907, JString, required = false,
                                 default = nil)
  if valid_604907 != nil:
    section.add "X-Amz-SignedHeaders", valid_604907
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  section = newJObject()
  var valid_604908 = formData.getOrDefault("Enable")
  valid_604908 = validateParameter(valid_604908, JBool, required = false, default = nil)
  if valid_604908 != nil:
    section.add "Enable", valid_604908
  var valid_604909 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_604909 = validateParameter(valid_604909, JString, required = false,
                                 default = nil)
  if valid_604909 != nil:
    section.add "TargetAction.ResizeCluster", valid_604909
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_604910 = formData.getOrDefault("ScheduledActionName")
  valid_604910 = validateParameter(valid_604910, JString, required = true,
                                 default = nil)
  if valid_604910 != nil:
    section.add "ScheduledActionName", valid_604910
  var valid_604911 = formData.getOrDefault("ScheduledActionDescription")
  valid_604911 = validateParameter(valid_604911, JString, required = false,
                                 default = nil)
  if valid_604911 != nil:
    section.add "ScheduledActionDescription", valid_604911
  var valid_604912 = formData.getOrDefault("Schedule")
  valid_604912 = validateParameter(valid_604912, JString, required = false,
                                 default = nil)
  if valid_604912 != nil:
    section.add "Schedule", valid_604912
  var valid_604913 = formData.getOrDefault("EndTime")
  valid_604913 = validateParameter(valid_604913, JString, required = false,
                                 default = nil)
  if valid_604913 != nil:
    section.add "EndTime", valid_604913
  var valid_604914 = formData.getOrDefault("StartTime")
  valid_604914 = validateParameter(valid_604914, JString, required = false,
                                 default = nil)
  if valid_604914 != nil:
    section.add "StartTime", valid_604914
  var valid_604915 = formData.getOrDefault("IamRole")
  valid_604915 = validateParameter(valid_604915, JString, required = false,
                                 default = nil)
  if valid_604915 != nil:
    section.add "IamRole", valid_604915
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604916: Call_PostModifyScheduledAction_604896; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modify a scheduled action. 
  ## 
  let valid = call_604916.validator(path, query, header, formData, body)
  let scheme = call_604916.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604916.url(scheme.get, call_604916.host, call_604916.base,
                         call_604916.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604916, url, valid)

proc call*(call_604917: Call_PostModifyScheduledAction_604896;
          ScheduledActionName: string; Enable: bool = false;
          TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = ""; Schedule: string = "";
          EndTime: string = ""; StartTime: string = "";
          Action: string = "ModifyScheduledAction"; Version: string = "2012-12-01";
          IamRole: string = ""): Recallable =
  ## postModifyScheduledAction
  ## Modify a scheduled action. 
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Action: string (required)
  ##   Version: string (required)
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  var query_604918 = newJObject()
  var formData_604919 = newJObject()
  add(formData_604919, "Enable", newJBool(Enable))
  add(formData_604919, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_604919, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_604919, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_604919, "Schedule", newJString(Schedule))
  add(formData_604919, "EndTime", newJString(EndTime))
  add(formData_604919, "StartTime", newJString(StartTime))
  add(query_604918, "Action", newJString(Action))
  add(query_604918, "Version", newJString(Version))
  add(formData_604919, "IamRole", newJString(IamRole))
  result = call_604917.call(nil, query_604918, nil, formData_604919, nil)

var postModifyScheduledAction* = Call_PostModifyScheduledAction_604896(
    name: "postModifyScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_PostModifyScheduledAction_604897, base: "/",
    url: url_PostModifyScheduledAction_604898,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyScheduledAction_604873 = ref object of OpenApiRestCall_601373
proc url_GetModifyScheduledAction_604875(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyScheduledAction_604874(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modify a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_604876 = query.getOrDefault("Schedule")
  valid_604876 = validateParameter(valid_604876, JString, required = false,
                                 default = nil)
  if valid_604876 != nil:
    section.add "Schedule", valid_604876
  var valid_604877 = query.getOrDefault("Enable")
  valid_604877 = validateParameter(valid_604877, JBool, required = false, default = nil)
  if valid_604877 != nil:
    section.add "Enable", valid_604877
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_604878 = query.getOrDefault("ScheduledActionName")
  valid_604878 = validateParameter(valid_604878, JString, required = true,
                                 default = nil)
  if valid_604878 != nil:
    section.add "ScheduledActionName", valid_604878
  var valid_604879 = query.getOrDefault("IamRole")
  valid_604879 = validateParameter(valid_604879, JString, required = false,
                                 default = nil)
  if valid_604879 != nil:
    section.add "IamRole", valid_604879
  var valid_604880 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_604880 = validateParameter(valid_604880, JString, required = false,
                                 default = nil)
  if valid_604880 != nil:
    section.add "TargetAction.ResizeCluster", valid_604880
  var valid_604881 = query.getOrDefault("ScheduledActionDescription")
  valid_604881 = validateParameter(valid_604881, JString, required = false,
                                 default = nil)
  if valid_604881 != nil:
    section.add "ScheduledActionDescription", valid_604881
  var valid_604882 = query.getOrDefault("Action")
  valid_604882 = validateParameter(valid_604882, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_604882 != nil:
    section.add "Action", valid_604882
  var valid_604883 = query.getOrDefault("StartTime")
  valid_604883 = validateParameter(valid_604883, JString, required = false,
                                 default = nil)
  if valid_604883 != nil:
    section.add "StartTime", valid_604883
  var valid_604884 = query.getOrDefault("EndTime")
  valid_604884 = validateParameter(valid_604884, JString, required = false,
                                 default = nil)
  if valid_604884 != nil:
    section.add "EndTime", valid_604884
  var valid_604885 = query.getOrDefault("Version")
  valid_604885 = validateParameter(valid_604885, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604885 != nil:
    section.add "Version", valid_604885
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604886 = header.getOrDefault("X-Amz-Signature")
  valid_604886 = validateParameter(valid_604886, JString, required = false,
                                 default = nil)
  if valid_604886 != nil:
    section.add "X-Amz-Signature", valid_604886
  var valid_604887 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604887 = validateParameter(valid_604887, JString, required = false,
                                 default = nil)
  if valid_604887 != nil:
    section.add "X-Amz-Content-Sha256", valid_604887
  var valid_604888 = header.getOrDefault("X-Amz-Date")
  valid_604888 = validateParameter(valid_604888, JString, required = false,
                                 default = nil)
  if valid_604888 != nil:
    section.add "X-Amz-Date", valid_604888
  var valid_604889 = header.getOrDefault("X-Amz-Credential")
  valid_604889 = validateParameter(valid_604889, JString, required = false,
                                 default = nil)
  if valid_604889 != nil:
    section.add "X-Amz-Credential", valid_604889
  var valid_604890 = header.getOrDefault("X-Amz-Security-Token")
  valid_604890 = validateParameter(valid_604890, JString, required = false,
                                 default = nil)
  if valid_604890 != nil:
    section.add "X-Amz-Security-Token", valid_604890
  var valid_604891 = header.getOrDefault("X-Amz-Algorithm")
  valid_604891 = validateParameter(valid_604891, JString, required = false,
                                 default = nil)
  if valid_604891 != nil:
    section.add "X-Amz-Algorithm", valid_604891
  var valid_604892 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604892 = validateParameter(valid_604892, JString, required = false,
                                 default = nil)
  if valid_604892 != nil:
    section.add "X-Amz-SignedHeaders", valid_604892
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604893: Call_GetModifyScheduledAction_604873; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modify a scheduled action. 
  ## 
  let valid = call_604893.validator(path, query, header, formData, body)
  let scheme = call_604893.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604893.url(scheme.get, call_604893.host, call_604893.base,
                         call_604893.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604893, url, valid)

proc call*(call_604894: Call_GetModifyScheduledAction_604873;
          ScheduledActionName: string; Schedule: string = ""; Enable: bool = false;
          IamRole: string = ""; TargetActionResizeCluster: string = "";
          ScheduledActionDescription: string = "";
          Action: string = "ModifyScheduledAction"; StartTime: string = "";
          EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getModifyScheduledAction
  ## Modify a scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   Action: string (required)
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_604895 = newJObject()
  add(query_604895, "Schedule", newJString(Schedule))
  add(query_604895, "Enable", newJBool(Enable))
  add(query_604895, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_604895, "IamRole", newJString(IamRole))
  add(query_604895, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(query_604895, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_604895, "Action", newJString(Action))
  add(query_604895, "StartTime", newJString(StartTime))
  add(query_604895, "EndTime", newJString(EndTime))
  add(query_604895, "Version", newJString(Version))
  result = call_604894.call(nil, query_604895, nil, nil, nil)

var getModifyScheduledAction* = Call_GetModifyScheduledAction_604873(
    name: "getModifyScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_GetModifyScheduledAction_604874, base: "/",
    url: url_GetModifyScheduledAction_604875, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotCopyRetentionPeriod_604938 = ref object of OpenApiRestCall_601373
proc url_PostModifySnapshotCopyRetentionPeriod_604940(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotCopyRetentionPeriod_604939(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604941 = query.getOrDefault("Action")
  valid_604941 = validateParameter(valid_604941, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_604941 != nil:
    section.add "Action", valid_604941
  var valid_604942 = query.getOrDefault("Version")
  valid_604942 = validateParameter(valid_604942, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604942 != nil:
    section.add "Version", valid_604942
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604943 = header.getOrDefault("X-Amz-Signature")
  valid_604943 = validateParameter(valid_604943, JString, required = false,
                                 default = nil)
  if valid_604943 != nil:
    section.add "X-Amz-Signature", valid_604943
  var valid_604944 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604944 = validateParameter(valid_604944, JString, required = false,
                                 default = nil)
  if valid_604944 != nil:
    section.add "X-Amz-Content-Sha256", valid_604944
  var valid_604945 = header.getOrDefault("X-Amz-Date")
  valid_604945 = validateParameter(valid_604945, JString, required = false,
                                 default = nil)
  if valid_604945 != nil:
    section.add "X-Amz-Date", valid_604945
  var valid_604946 = header.getOrDefault("X-Amz-Credential")
  valid_604946 = validateParameter(valid_604946, JString, required = false,
                                 default = nil)
  if valid_604946 != nil:
    section.add "X-Amz-Credential", valid_604946
  var valid_604947 = header.getOrDefault("X-Amz-Security-Token")
  valid_604947 = validateParameter(valid_604947, JString, required = false,
                                 default = nil)
  if valid_604947 != nil:
    section.add "X-Amz-Security-Token", valid_604947
  var valid_604948 = header.getOrDefault("X-Amz-Algorithm")
  valid_604948 = validateParameter(valid_604948, JString, required = false,
                                 default = nil)
  if valid_604948 != nil:
    section.add "X-Amz-Algorithm", valid_604948
  var valid_604949 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604949 = validateParameter(valid_604949, JString, required = false,
                                 default = nil)
  if valid_604949 != nil:
    section.add "X-Amz-SignedHeaders", valid_604949
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_604950 = formData.getOrDefault("ClusterIdentifier")
  valid_604950 = validateParameter(valid_604950, JString, required = true,
                                 default = nil)
  if valid_604950 != nil:
    section.add "ClusterIdentifier", valid_604950
  var valid_604951 = formData.getOrDefault("RetentionPeriod")
  valid_604951 = validateParameter(valid_604951, JInt, required = true, default = nil)
  if valid_604951 != nil:
    section.add "RetentionPeriod", valid_604951
  var valid_604952 = formData.getOrDefault("Manual")
  valid_604952 = validateParameter(valid_604952, JBool, required = false, default = nil)
  if valid_604952 != nil:
    section.add "Manual", valid_604952
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604953: Call_PostModifySnapshotCopyRetentionPeriod_604938;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_604953.validator(path, query, header, formData, body)
  let scheme = call_604953.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604953.url(scheme.get, call_604953.host, call_604953.base,
                         call_604953.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604953, url, valid)

proc call*(call_604954: Call_PostModifySnapshotCopyRetentionPeriod_604938;
          ClusterIdentifier: string; RetentionPeriod: int;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Manual: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Action: string (required)
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Version: string (required)
  var query_604955 = newJObject()
  var formData_604956 = newJObject()
  add(formData_604956, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_604956, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_604955, "Action", newJString(Action))
  add(formData_604956, "Manual", newJBool(Manual))
  add(query_604955, "Version", newJString(Version))
  result = call_604954.call(nil, query_604955, nil, formData_604956, nil)

var postModifySnapshotCopyRetentionPeriod* = Call_PostModifySnapshotCopyRetentionPeriod_604938(
    name: "postModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_PostModifySnapshotCopyRetentionPeriod_604939, base: "/",
    url: url_PostModifySnapshotCopyRetentionPeriod_604940,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotCopyRetentionPeriod_604920 = ref object of OpenApiRestCall_601373
proc url_GetModifySnapshotCopyRetentionPeriod_604922(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotCopyRetentionPeriod_604921(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  section = newJObject()
  var valid_604923 = query.getOrDefault("Manual")
  valid_604923 = validateParameter(valid_604923, JBool, required = false, default = nil)
  if valid_604923 != nil:
    section.add "Manual", valid_604923
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604924 = query.getOrDefault("Action")
  valid_604924 = validateParameter(valid_604924, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_604924 != nil:
    section.add "Action", valid_604924
  var valid_604925 = query.getOrDefault("ClusterIdentifier")
  valid_604925 = validateParameter(valid_604925, JString, required = true,
                                 default = nil)
  if valid_604925 != nil:
    section.add "ClusterIdentifier", valid_604925
  var valid_604926 = query.getOrDefault("Version")
  valid_604926 = validateParameter(valid_604926, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604926 != nil:
    section.add "Version", valid_604926
  var valid_604927 = query.getOrDefault("RetentionPeriod")
  valid_604927 = validateParameter(valid_604927, JInt, required = true, default = nil)
  if valid_604927 != nil:
    section.add "RetentionPeriod", valid_604927
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604928 = header.getOrDefault("X-Amz-Signature")
  valid_604928 = validateParameter(valid_604928, JString, required = false,
                                 default = nil)
  if valid_604928 != nil:
    section.add "X-Amz-Signature", valid_604928
  var valid_604929 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604929 = validateParameter(valid_604929, JString, required = false,
                                 default = nil)
  if valid_604929 != nil:
    section.add "X-Amz-Content-Sha256", valid_604929
  var valid_604930 = header.getOrDefault("X-Amz-Date")
  valid_604930 = validateParameter(valid_604930, JString, required = false,
                                 default = nil)
  if valid_604930 != nil:
    section.add "X-Amz-Date", valid_604930
  var valid_604931 = header.getOrDefault("X-Amz-Credential")
  valid_604931 = validateParameter(valid_604931, JString, required = false,
                                 default = nil)
  if valid_604931 != nil:
    section.add "X-Amz-Credential", valid_604931
  var valid_604932 = header.getOrDefault("X-Amz-Security-Token")
  valid_604932 = validateParameter(valid_604932, JString, required = false,
                                 default = nil)
  if valid_604932 != nil:
    section.add "X-Amz-Security-Token", valid_604932
  var valid_604933 = header.getOrDefault("X-Amz-Algorithm")
  valid_604933 = validateParameter(valid_604933, JString, required = false,
                                 default = nil)
  if valid_604933 != nil:
    section.add "X-Amz-Algorithm", valid_604933
  var valid_604934 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604934 = validateParameter(valid_604934, JString, required = false,
                                 default = nil)
  if valid_604934 != nil:
    section.add "X-Amz-SignedHeaders", valid_604934
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604935: Call_GetModifySnapshotCopyRetentionPeriod_604920;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_604935.validator(path, query, header, formData, body)
  let scheme = call_604935.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604935.url(scheme.get, call_604935.host, call_604935.base,
                         call_604935.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604935, url, valid)

proc call*(call_604936: Call_GetModifySnapshotCopyRetentionPeriod_604920;
          ClusterIdentifier: string; RetentionPeriod: int; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  var query_604937 = newJObject()
  add(query_604937, "Manual", newJBool(Manual))
  add(query_604937, "Action", newJString(Action))
  add(query_604937, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_604937, "Version", newJString(Version))
  add(query_604937, "RetentionPeriod", newJInt(RetentionPeriod))
  result = call_604936.call(nil, query_604937, nil, nil, nil)

var getModifySnapshotCopyRetentionPeriod* = Call_GetModifySnapshotCopyRetentionPeriod_604920(
    name: "getModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_GetModifySnapshotCopyRetentionPeriod_604921, base: "/",
    url: url_GetModifySnapshotCopyRetentionPeriod_604922,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotSchedule_604974 = ref object of OpenApiRestCall_601373
proc url_PostModifySnapshotSchedule_604976(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotSchedule_604975(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_604977 = query.getOrDefault("Action")
  valid_604977 = validateParameter(valid_604977, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_604977 != nil:
    section.add "Action", valid_604977
  var valid_604978 = query.getOrDefault("Version")
  valid_604978 = validateParameter(valid_604978, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604978 != nil:
    section.add "Version", valid_604978
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604979 = header.getOrDefault("X-Amz-Signature")
  valid_604979 = validateParameter(valid_604979, JString, required = false,
                                 default = nil)
  if valid_604979 != nil:
    section.add "X-Amz-Signature", valid_604979
  var valid_604980 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604980 = validateParameter(valid_604980, JString, required = false,
                                 default = nil)
  if valid_604980 != nil:
    section.add "X-Amz-Content-Sha256", valid_604980
  var valid_604981 = header.getOrDefault("X-Amz-Date")
  valid_604981 = validateParameter(valid_604981, JString, required = false,
                                 default = nil)
  if valid_604981 != nil:
    section.add "X-Amz-Date", valid_604981
  var valid_604982 = header.getOrDefault("X-Amz-Credential")
  valid_604982 = validateParameter(valid_604982, JString, required = false,
                                 default = nil)
  if valid_604982 != nil:
    section.add "X-Amz-Credential", valid_604982
  var valid_604983 = header.getOrDefault("X-Amz-Security-Token")
  valid_604983 = validateParameter(valid_604983, JString, required = false,
                                 default = nil)
  if valid_604983 != nil:
    section.add "X-Amz-Security-Token", valid_604983
  var valid_604984 = header.getOrDefault("X-Amz-Algorithm")
  valid_604984 = validateParameter(valid_604984, JString, required = false,
                                 default = nil)
  if valid_604984 != nil:
    section.add "X-Amz-Algorithm", valid_604984
  var valid_604985 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604985 = validateParameter(valid_604985, JString, required = false,
                                 default = nil)
  if valid_604985 != nil:
    section.add "X-Amz-SignedHeaders", valid_604985
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleDefinitions` field"
  var valid_604986 = formData.getOrDefault("ScheduleDefinitions")
  valid_604986 = validateParameter(valid_604986, JArray, required = true, default = nil)
  if valid_604986 != nil:
    section.add "ScheduleDefinitions", valid_604986
  var valid_604987 = formData.getOrDefault("ScheduleIdentifier")
  valid_604987 = validateParameter(valid_604987, JString, required = true,
                                 default = nil)
  if valid_604987 != nil:
    section.add "ScheduleIdentifier", valid_604987
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604988: Call_PostModifySnapshotSchedule_604974; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_604988.validator(path, query, header, formData, body)
  let scheme = call_604988.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604988.url(scheme.get, call_604988.host, call_604988.base,
                         call_604988.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604988, url, valid)

proc call*(call_604989: Call_PostModifySnapshotSchedule_604974;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_604990 = newJObject()
  var formData_604991 = newJObject()
  if ScheduleDefinitions != nil:
    formData_604991.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_604990, "Action", newJString(Action))
  add(formData_604991, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_604990, "Version", newJString(Version))
  result = call_604989.call(nil, query_604990, nil, formData_604991, nil)

var postModifySnapshotSchedule* = Call_PostModifySnapshotSchedule_604974(
    name: "postModifySnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_PostModifySnapshotSchedule_604975, base: "/",
    url: url_PostModifySnapshotSchedule_604976,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotSchedule_604957 = ref object of OpenApiRestCall_601373
proc url_GetModifySnapshotSchedule_604959(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotSchedule_604958(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleIdentifier` field"
  var valid_604960 = query.getOrDefault("ScheduleIdentifier")
  valid_604960 = validateParameter(valid_604960, JString, required = true,
                                 default = nil)
  if valid_604960 != nil:
    section.add "ScheduleIdentifier", valid_604960
  var valid_604961 = query.getOrDefault("ScheduleDefinitions")
  valid_604961 = validateParameter(valid_604961, JArray, required = true, default = nil)
  if valid_604961 != nil:
    section.add "ScheduleDefinitions", valid_604961
  var valid_604962 = query.getOrDefault("Action")
  valid_604962 = validateParameter(valid_604962, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_604962 != nil:
    section.add "Action", valid_604962
  var valid_604963 = query.getOrDefault("Version")
  valid_604963 = validateParameter(valid_604963, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604963 != nil:
    section.add "Version", valid_604963
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604964 = header.getOrDefault("X-Amz-Signature")
  valid_604964 = validateParameter(valid_604964, JString, required = false,
                                 default = nil)
  if valid_604964 != nil:
    section.add "X-Amz-Signature", valid_604964
  var valid_604965 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_604965 = validateParameter(valid_604965, JString, required = false,
                                 default = nil)
  if valid_604965 != nil:
    section.add "X-Amz-Content-Sha256", valid_604965
  var valid_604966 = header.getOrDefault("X-Amz-Date")
  valid_604966 = validateParameter(valid_604966, JString, required = false,
                                 default = nil)
  if valid_604966 != nil:
    section.add "X-Amz-Date", valid_604966
  var valid_604967 = header.getOrDefault("X-Amz-Credential")
  valid_604967 = validateParameter(valid_604967, JString, required = false,
                                 default = nil)
  if valid_604967 != nil:
    section.add "X-Amz-Credential", valid_604967
  var valid_604968 = header.getOrDefault("X-Amz-Security-Token")
  valid_604968 = validateParameter(valid_604968, JString, required = false,
                                 default = nil)
  if valid_604968 != nil:
    section.add "X-Amz-Security-Token", valid_604968
  var valid_604969 = header.getOrDefault("X-Amz-Algorithm")
  valid_604969 = validateParameter(valid_604969, JString, required = false,
                                 default = nil)
  if valid_604969 != nil:
    section.add "X-Amz-Algorithm", valid_604969
  var valid_604970 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_604970 = validateParameter(valid_604970, JString, required = false,
                                 default = nil)
  if valid_604970 != nil:
    section.add "X-Amz-SignedHeaders", valid_604970
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_604971: Call_GetModifySnapshotSchedule_604957; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_604971.validator(path, query, header, formData, body)
  let scheme = call_604971.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_604971.url(scheme.get, call_604971.host, call_604971.base,
                         call_604971.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_604971, url, valid)

proc call*(call_604972: Call_GetModifySnapshotSchedule_604957;
          ScheduleIdentifier: string; ScheduleDefinitions: JsonNode;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   Version: string (required)
  var query_604973 = newJObject()
  add(query_604973, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if ScheduleDefinitions != nil:
    query_604973.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_604973, "Action", newJString(Action))
  add(query_604973, "Version", newJString(Version))
  result = call_604972.call(nil, query_604973, nil, nil, nil)

var getModifySnapshotSchedule* = Call_GetModifySnapshotSchedule_604957(
    name: "getModifySnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_GetModifySnapshotSchedule_604958, base: "/",
    url: url_GetModifySnapshotSchedule_604959,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostPurchaseReservedNodeOffering_605009 = ref object of OpenApiRestCall_601373
proc url_PostPurchaseReservedNodeOffering_605011(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostPurchaseReservedNodeOffering_605010(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605012 = query.getOrDefault("Action")
  valid_605012 = validateParameter(valid_605012, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_605012 != nil:
    section.add "Action", valid_605012
  var valid_605013 = query.getOrDefault("Version")
  valid_605013 = validateParameter(valid_605013, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605013 != nil:
    section.add "Version", valid_605013
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605014 = header.getOrDefault("X-Amz-Signature")
  valid_605014 = validateParameter(valid_605014, JString, required = false,
                                 default = nil)
  if valid_605014 != nil:
    section.add "X-Amz-Signature", valid_605014
  var valid_605015 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605015 = validateParameter(valid_605015, JString, required = false,
                                 default = nil)
  if valid_605015 != nil:
    section.add "X-Amz-Content-Sha256", valid_605015
  var valid_605016 = header.getOrDefault("X-Amz-Date")
  valid_605016 = validateParameter(valid_605016, JString, required = false,
                                 default = nil)
  if valid_605016 != nil:
    section.add "X-Amz-Date", valid_605016
  var valid_605017 = header.getOrDefault("X-Amz-Credential")
  valid_605017 = validateParameter(valid_605017, JString, required = false,
                                 default = nil)
  if valid_605017 != nil:
    section.add "X-Amz-Credential", valid_605017
  var valid_605018 = header.getOrDefault("X-Amz-Security-Token")
  valid_605018 = validateParameter(valid_605018, JString, required = false,
                                 default = nil)
  if valid_605018 != nil:
    section.add "X-Amz-Security-Token", valid_605018
  var valid_605019 = header.getOrDefault("X-Amz-Algorithm")
  valid_605019 = validateParameter(valid_605019, JString, required = false,
                                 default = nil)
  if valid_605019 != nil:
    section.add "X-Amz-Algorithm", valid_605019
  var valid_605020 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605020 = validateParameter(valid_605020, JString, required = false,
                                 default = nil)
  if valid_605020 != nil:
    section.add "X-Amz-SignedHeaders", valid_605020
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  section = newJObject()
  var valid_605021 = formData.getOrDefault("NodeCount")
  valid_605021 = validateParameter(valid_605021, JInt, required = false, default = nil)
  if valid_605021 != nil:
    section.add "NodeCount", valid_605021
  assert formData != nil, "formData argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_605022 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_605022 = validateParameter(valid_605022, JString, required = true,
                                 default = nil)
  if valid_605022 != nil:
    section.add "ReservedNodeOfferingId", valid_605022
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605023: Call_PostPurchaseReservedNodeOffering_605009;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_605023.validator(path, query, header, formData, body)
  let scheme = call_605023.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605023.url(scheme.get, call_605023.host, call_605023.base,
                         call_605023.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605023, url, valid)

proc call*(call_605024: Call_PostPurchaseReservedNodeOffering_605009;
          ReservedNodeOfferingId: string; NodeCount: int = 0;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"): Recallable =
  ## postPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_605025 = newJObject()
  var formData_605026 = newJObject()
  add(formData_605026, "NodeCount", newJInt(NodeCount))
  add(formData_605026, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(query_605025, "Action", newJString(Action))
  add(query_605025, "Version", newJString(Version))
  result = call_605024.call(nil, query_605025, nil, formData_605026, nil)

var postPurchaseReservedNodeOffering* = Call_PostPurchaseReservedNodeOffering_605009(
    name: "postPurchaseReservedNodeOffering", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_PostPurchaseReservedNodeOffering_605010, base: "/",
    url: url_PostPurchaseReservedNodeOffering_605011,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPurchaseReservedNodeOffering_604992 = ref object of OpenApiRestCall_601373
proc url_GetPurchaseReservedNodeOffering_604994(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetPurchaseReservedNodeOffering_604993(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_604995 = query.getOrDefault("ReservedNodeOfferingId")
  valid_604995 = validateParameter(valid_604995, JString, required = true,
                                 default = nil)
  if valid_604995 != nil:
    section.add "ReservedNodeOfferingId", valid_604995
  var valid_604996 = query.getOrDefault("Action")
  valid_604996 = validateParameter(valid_604996, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_604996 != nil:
    section.add "Action", valid_604996
  var valid_604997 = query.getOrDefault("Version")
  valid_604997 = validateParameter(valid_604997, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_604997 != nil:
    section.add "Version", valid_604997
  var valid_604998 = query.getOrDefault("NodeCount")
  valid_604998 = validateParameter(valid_604998, JInt, required = false, default = nil)
  if valid_604998 != nil:
    section.add "NodeCount", valid_604998
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_604999 = header.getOrDefault("X-Amz-Signature")
  valid_604999 = validateParameter(valid_604999, JString, required = false,
                                 default = nil)
  if valid_604999 != nil:
    section.add "X-Amz-Signature", valid_604999
  var valid_605000 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605000 = validateParameter(valid_605000, JString, required = false,
                                 default = nil)
  if valid_605000 != nil:
    section.add "X-Amz-Content-Sha256", valid_605000
  var valid_605001 = header.getOrDefault("X-Amz-Date")
  valid_605001 = validateParameter(valid_605001, JString, required = false,
                                 default = nil)
  if valid_605001 != nil:
    section.add "X-Amz-Date", valid_605001
  var valid_605002 = header.getOrDefault("X-Amz-Credential")
  valid_605002 = validateParameter(valid_605002, JString, required = false,
                                 default = nil)
  if valid_605002 != nil:
    section.add "X-Amz-Credential", valid_605002
  var valid_605003 = header.getOrDefault("X-Amz-Security-Token")
  valid_605003 = validateParameter(valid_605003, JString, required = false,
                                 default = nil)
  if valid_605003 != nil:
    section.add "X-Amz-Security-Token", valid_605003
  var valid_605004 = header.getOrDefault("X-Amz-Algorithm")
  valid_605004 = validateParameter(valid_605004, JString, required = false,
                                 default = nil)
  if valid_605004 != nil:
    section.add "X-Amz-Algorithm", valid_605004
  var valid_605005 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605005 = validateParameter(valid_605005, JString, required = false,
                                 default = nil)
  if valid_605005 != nil:
    section.add "X-Amz-SignedHeaders", valid_605005
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605006: Call_GetPurchaseReservedNodeOffering_604992;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_605006.validator(path, query, header, formData, body)
  let scheme = call_605006.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605006.url(scheme.get, call_605006.host, call_605006.base,
                         call_605006.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605006, url, valid)

proc call*(call_605007: Call_GetPurchaseReservedNodeOffering_604992;
          ReservedNodeOfferingId: string;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"; NodeCount: int = 0): Recallable =
  ## getPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  var query_605008 = newJObject()
  add(query_605008, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_605008, "Action", newJString(Action))
  add(query_605008, "Version", newJString(Version))
  add(query_605008, "NodeCount", newJInt(NodeCount))
  result = call_605007.call(nil, query_605008, nil, nil, nil)

var getPurchaseReservedNodeOffering* = Call_GetPurchaseReservedNodeOffering_604992(
    name: "getPurchaseReservedNodeOffering", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_GetPurchaseReservedNodeOffering_604993, base: "/",
    url: url_GetPurchaseReservedNodeOffering_604994,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRebootCluster_605043 = ref object of OpenApiRestCall_601373
proc url_PostRebootCluster_605045(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRebootCluster_605044(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605046 = query.getOrDefault("Action")
  valid_605046 = validateParameter(valid_605046, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_605046 != nil:
    section.add "Action", valid_605046
  var valid_605047 = query.getOrDefault("Version")
  valid_605047 = validateParameter(valid_605047, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605047 != nil:
    section.add "Version", valid_605047
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605048 = header.getOrDefault("X-Amz-Signature")
  valid_605048 = validateParameter(valid_605048, JString, required = false,
                                 default = nil)
  if valid_605048 != nil:
    section.add "X-Amz-Signature", valid_605048
  var valid_605049 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605049 = validateParameter(valid_605049, JString, required = false,
                                 default = nil)
  if valid_605049 != nil:
    section.add "X-Amz-Content-Sha256", valid_605049
  var valid_605050 = header.getOrDefault("X-Amz-Date")
  valid_605050 = validateParameter(valid_605050, JString, required = false,
                                 default = nil)
  if valid_605050 != nil:
    section.add "X-Amz-Date", valid_605050
  var valid_605051 = header.getOrDefault("X-Amz-Credential")
  valid_605051 = validateParameter(valid_605051, JString, required = false,
                                 default = nil)
  if valid_605051 != nil:
    section.add "X-Amz-Credential", valid_605051
  var valid_605052 = header.getOrDefault("X-Amz-Security-Token")
  valid_605052 = validateParameter(valid_605052, JString, required = false,
                                 default = nil)
  if valid_605052 != nil:
    section.add "X-Amz-Security-Token", valid_605052
  var valid_605053 = header.getOrDefault("X-Amz-Algorithm")
  valid_605053 = validateParameter(valid_605053, JString, required = false,
                                 default = nil)
  if valid_605053 != nil:
    section.add "X-Amz-Algorithm", valid_605053
  var valid_605054 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605054 = validateParameter(valid_605054, JString, required = false,
                                 default = nil)
  if valid_605054 != nil:
    section.add "X-Amz-SignedHeaders", valid_605054
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605055 = formData.getOrDefault("ClusterIdentifier")
  valid_605055 = validateParameter(valid_605055, JString, required = true,
                                 default = nil)
  if valid_605055 != nil:
    section.add "ClusterIdentifier", valid_605055
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605056: Call_PostRebootCluster_605043; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_605056.validator(path, query, header, formData, body)
  let scheme = call_605056.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605056.url(scheme.get, call_605056.host, call_605056.base,
                         call_605056.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605056, url, valid)

proc call*(call_605057: Call_PostRebootCluster_605043; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## postRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_605058 = newJObject()
  var formData_605059 = newJObject()
  add(formData_605059, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605058, "Action", newJString(Action))
  add(query_605058, "Version", newJString(Version))
  result = call_605057.call(nil, query_605058, nil, formData_605059, nil)

var postRebootCluster* = Call_PostRebootCluster_605043(name: "postRebootCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_PostRebootCluster_605044,
    base: "/", url: url_PostRebootCluster_605045,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRebootCluster_605027 = ref object of OpenApiRestCall_601373
proc url_GetRebootCluster_605029(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRebootCluster_605028(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605030 = query.getOrDefault("Action")
  valid_605030 = validateParameter(valid_605030, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_605030 != nil:
    section.add "Action", valid_605030
  var valid_605031 = query.getOrDefault("ClusterIdentifier")
  valid_605031 = validateParameter(valid_605031, JString, required = true,
                                 default = nil)
  if valid_605031 != nil:
    section.add "ClusterIdentifier", valid_605031
  var valid_605032 = query.getOrDefault("Version")
  valid_605032 = validateParameter(valid_605032, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605032 != nil:
    section.add "Version", valid_605032
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605033 = header.getOrDefault("X-Amz-Signature")
  valid_605033 = validateParameter(valid_605033, JString, required = false,
                                 default = nil)
  if valid_605033 != nil:
    section.add "X-Amz-Signature", valid_605033
  var valid_605034 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605034 = validateParameter(valid_605034, JString, required = false,
                                 default = nil)
  if valid_605034 != nil:
    section.add "X-Amz-Content-Sha256", valid_605034
  var valid_605035 = header.getOrDefault("X-Amz-Date")
  valid_605035 = validateParameter(valid_605035, JString, required = false,
                                 default = nil)
  if valid_605035 != nil:
    section.add "X-Amz-Date", valid_605035
  var valid_605036 = header.getOrDefault("X-Amz-Credential")
  valid_605036 = validateParameter(valid_605036, JString, required = false,
                                 default = nil)
  if valid_605036 != nil:
    section.add "X-Amz-Credential", valid_605036
  var valid_605037 = header.getOrDefault("X-Amz-Security-Token")
  valid_605037 = validateParameter(valid_605037, JString, required = false,
                                 default = nil)
  if valid_605037 != nil:
    section.add "X-Amz-Security-Token", valid_605037
  var valid_605038 = header.getOrDefault("X-Amz-Algorithm")
  valid_605038 = validateParameter(valid_605038, JString, required = false,
                                 default = nil)
  if valid_605038 != nil:
    section.add "X-Amz-Algorithm", valid_605038
  var valid_605039 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605039 = validateParameter(valid_605039, JString, required = false,
                                 default = nil)
  if valid_605039 != nil:
    section.add "X-Amz-SignedHeaders", valid_605039
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605040: Call_GetRebootCluster_605027; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_605040.validator(path, query, header, formData, body)
  let scheme = call_605040.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605040.url(scheme.get, call_605040.host, call_605040.base,
                         call_605040.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605040, url, valid)

proc call*(call_605041: Call_GetRebootCluster_605027; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## getRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_605042 = newJObject()
  add(query_605042, "Action", newJString(Action))
  add(query_605042, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605042, "Version", newJString(Version))
  result = call_605041.call(nil, query_605042, nil, nil, nil)

var getRebootCluster* = Call_GetRebootCluster_605027(name: "getRebootCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_GetRebootCluster_605028,
    base: "/", url: url_GetRebootCluster_605029,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResetClusterParameterGroup_605078 = ref object of OpenApiRestCall_601373
proc url_PostResetClusterParameterGroup_605080(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResetClusterParameterGroup_605079(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605081 = query.getOrDefault("Action")
  valid_605081 = validateParameter(valid_605081, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_605081 != nil:
    section.add "Action", valid_605081
  var valid_605082 = query.getOrDefault("Version")
  valid_605082 = validateParameter(valid_605082, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605082 != nil:
    section.add "Version", valid_605082
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605083 = header.getOrDefault("X-Amz-Signature")
  valid_605083 = validateParameter(valid_605083, JString, required = false,
                                 default = nil)
  if valid_605083 != nil:
    section.add "X-Amz-Signature", valid_605083
  var valid_605084 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605084 = validateParameter(valid_605084, JString, required = false,
                                 default = nil)
  if valid_605084 != nil:
    section.add "X-Amz-Content-Sha256", valid_605084
  var valid_605085 = header.getOrDefault("X-Amz-Date")
  valid_605085 = validateParameter(valid_605085, JString, required = false,
                                 default = nil)
  if valid_605085 != nil:
    section.add "X-Amz-Date", valid_605085
  var valid_605086 = header.getOrDefault("X-Amz-Credential")
  valid_605086 = validateParameter(valid_605086, JString, required = false,
                                 default = nil)
  if valid_605086 != nil:
    section.add "X-Amz-Credential", valid_605086
  var valid_605087 = header.getOrDefault("X-Amz-Security-Token")
  valid_605087 = validateParameter(valid_605087, JString, required = false,
                                 default = nil)
  if valid_605087 != nil:
    section.add "X-Amz-Security-Token", valid_605087
  var valid_605088 = header.getOrDefault("X-Amz-Algorithm")
  valid_605088 = validateParameter(valid_605088, JString, required = false,
                                 default = nil)
  if valid_605088 != nil:
    section.add "X-Amz-Algorithm", valid_605088
  var valid_605089 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605089 = validateParameter(valid_605089, JString, required = false,
                                 default = nil)
  if valid_605089 != nil:
    section.add "X-Amz-SignedHeaders", valid_605089
  result.add "header", section
  ## parameters in `formData` object:
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  section = newJObject()
  var valid_605090 = formData.getOrDefault("ResetAllParameters")
  valid_605090 = validateParameter(valid_605090, JBool, required = false, default = nil)
  if valid_605090 != nil:
    section.add "ResetAllParameters", valid_605090
  var valid_605091 = formData.getOrDefault("Parameters")
  valid_605091 = validateParameter(valid_605091, JArray, required = false,
                                 default = nil)
  if valid_605091 != nil:
    section.add "Parameters", valid_605091
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_605092 = formData.getOrDefault("ParameterGroupName")
  valid_605092 = validateParameter(valid_605092, JString, required = true,
                                 default = nil)
  if valid_605092 != nil:
    section.add "ParameterGroupName", valid_605092
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605093: Call_PostResetClusterParameterGroup_605078; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_605093.validator(path, query, header, formData, body)
  let scheme = call_605093.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605093.url(scheme.get, call_605093.host, call_605093.base,
                         call_605093.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605093, url, valid)

proc call*(call_605094: Call_PostResetClusterParameterGroup_605078;
          ParameterGroupName: string; ResetAllParameters: bool = false;
          Action: string = "ResetClusterParameterGroup"; Parameters: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: string (required)
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: string (required)
  var query_605095 = newJObject()
  var formData_605096 = newJObject()
  add(formData_605096, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_605095, "Action", newJString(Action))
  if Parameters != nil:
    formData_605096.add "Parameters", Parameters
  add(formData_605096, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_605095, "Version", newJString(Version))
  result = call_605094.call(nil, query_605095, nil, formData_605096, nil)

var postResetClusterParameterGroup* = Call_PostResetClusterParameterGroup_605078(
    name: "postResetClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_PostResetClusterParameterGroup_605079, base: "/",
    url: url_PostResetClusterParameterGroup_605080,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResetClusterParameterGroup_605060 = ref object of OpenApiRestCall_601373
proc url_GetResetClusterParameterGroup_605062(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResetClusterParameterGroup_605061(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: JString (required)
  section = newJObject()
  var valid_605063 = query.getOrDefault("Parameters")
  valid_605063 = validateParameter(valid_605063, JArray, required = false,
                                 default = nil)
  if valid_605063 != nil:
    section.add "Parameters", valid_605063
  var valid_605064 = query.getOrDefault("ResetAllParameters")
  valid_605064 = validateParameter(valid_605064, JBool, required = false, default = nil)
  if valid_605064 != nil:
    section.add "ResetAllParameters", valid_605064
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605065 = query.getOrDefault("Action")
  valid_605065 = validateParameter(valid_605065, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_605065 != nil:
    section.add "Action", valid_605065
  var valid_605066 = query.getOrDefault("ParameterGroupName")
  valid_605066 = validateParameter(valid_605066, JString, required = true,
                                 default = nil)
  if valid_605066 != nil:
    section.add "ParameterGroupName", valid_605066
  var valid_605067 = query.getOrDefault("Version")
  valid_605067 = validateParameter(valid_605067, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605067 != nil:
    section.add "Version", valid_605067
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605068 = header.getOrDefault("X-Amz-Signature")
  valid_605068 = validateParameter(valid_605068, JString, required = false,
                                 default = nil)
  if valid_605068 != nil:
    section.add "X-Amz-Signature", valid_605068
  var valid_605069 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605069 = validateParameter(valid_605069, JString, required = false,
                                 default = nil)
  if valid_605069 != nil:
    section.add "X-Amz-Content-Sha256", valid_605069
  var valid_605070 = header.getOrDefault("X-Amz-Date")
  valid_605070 = validateParameter(valid_605070, JString, required = false,
                                 default = nil)
  if valid_605070 != nil:
    section.add "X-Amz-Date", valid_605070
  var valid_605071 = header.getOrDefault("X-Amz-Credential")
  valid_605071 = validateParameter(valid_605071, JString, required = false,
                                 default = nil)
  if valid_605071 != nil:
    section.add "X-Amz-Credential", valid_605071
  var valid_605072 = header.getOrDefault("X-Amz-Security-Token")
  valid_605072 = validateParameter(valid_605072, JString, required = false,
                                 default = nil)
  if valid_605072 != nil:
    section.add "X-Amz-Security-Token", valid_605072
  var valid_605073 = header.getOrDefault("X-Amz-Algorithm")
  valid_605073 = validateParameter(valid_605073, JString, required = false,
                                 default = nil)
  if valid_605073 != nil:
    section.add "X-Amz-Algorithm", valid_605073
  var valid_605074 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605074 = validateParameter(valid_605074, JString, required = false,
                                 default = nil)
  if valid_605074 != nil:
    section.add "X-Amz-SignedHeaders", valid_605074
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605075: Call_GetResetClusterParameterGroup_605060; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_605075.validator(path, query, header, formData, body)
  let scheme = call_605075.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605075.url(scheme.get, call_605075.host, call_605075.base,
                         call_605075.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605075, url, valid)

proc call*(call_605076: Call_GetResetClusterParameterGroup_605060;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          ResetAllParameters: bool = false;
          Action: string = "ResetClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: string (required)
  var query_605077 = newJObject()
  if Parameters != nil:
    query_605077.add "Parameters", Parameters
  add(query_605077, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_605077, "Action", newJString(Action))
  add(query_605077, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_605077, "Version", newJString(Version))
  result = call_605076.call(nil, query_605077, nil, nil, nil)

var getResetClusterParameterGroup* = Call_GetResetClusterParameterGroup_605060(
    name: "getResetClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_GetResetClusterParameterGroup_605061, base: "/",
    url: url_GetResetClusterParameterGroup_605062,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResizeCluster_605117 = ref object of OpenApiRestCall_601373
proc url_PostResizeCluster_605119(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResizeCluster_605118(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605120 = query.getOrDefault("Action")
  valid_605120 = validateParameter(valid_605120, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_605120 != nil:
    section.add "Action", valid_605120
  var valid_605121 = query.getOrDefault("Version")
  valid_605121 = validateParameter(valid_605121, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605121 != nil:
    section.add "Version", valid_605121
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605122 = header.getOrDefault("X-Amz-Signature")
  valid_605122 = validateParameter(valid_605122, JString, required = false,
                                 default = nil)
  if valid_605122 != nil:
    section.add "X-Amz-Signature", valid_605122
  var valid_605123 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605123 = validateParameter(valid_605123, JString, required = false,
                                 default = nil)
  if valid_605123 != nil:
    section.add "X-Amz-Content-Sha256", valid_605123
  var valid_605124 = header.getOrDefault("X-Amz-Date")
  valid_605124 = validateParameter(valid_605124, JString, required = false,
                                 default = nil)
  if valid_605124 != nil:
    section.add "X-Amz-Date", valid_605124
  var valid_605125 = header.getOrDefault("X-Amz-Credential")
  valid_605125 = validateParameter(valid_605125, JString, required = false,
                                 default = nil)
  if valid_605125 != nil:
    section.add "X-Amz-Credential", valid_605125
  var valid_605126 = header.getOrDefault("X-Amz-Security-Token")
  valid_605126 = validateParameter(valid_605126, JString, required = false,
                                 default = nil)
  if valid_605126 != nil:
    section.add "X-Amz-Security-Token", valid_605126
  var valid_605127 = header.getOrDefault("X-Amz-Algorithm")
  valid_605127 = validateParameter(valid_605127, JString, required = false,
                                 default = nil)
  if valid_605127 != nil:
    section.add "X-Amz-Algorithm", valid_605127
  var valid_605128 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605128 = validateParameter(valid_605128, JString, required = false,
                                 default = nil)
  if valid_605128 != nil:
    section.add "X-Amz-SignedHeaders", valid_605128
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  section = newJObject()
  var valid_605129 = formData.getOrDefault("NodeType")
  valid_605129 = validateParameter(valid_605129, JString, required = false,
                                 default = nil)
  if valid_605129 != nil:
    section.add "NodeType", valid_605129
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605130 = formData.getOrDefault("ClusterIdentifier")
  valid_605130 = validateParameter(valid_605130, JString, required = true,
                                 default = nil)
  if valid_605130 != nil:
    section.add "ClusterIdentifier", valid_605130
  var valid_605131 = formData.getOrDefault("NumberOfNodes")
  valid_605131 = validateParameter(valid_605131, JInt, required = true, default = nil)
  if valid_605131 != nil:
    section.add "NumberOfNodes", valid_605131
  var valid_605132 = formData.getOrDefault("ClusterType")
  valid_605132 = validateParameter(valid_605132, JString, required = false,
                                 default = nil)
  if valid_605132 != nil:
    section.add "ClusterType", valid_605132
  var valid_605133 = formData.getOrDefault("Classic")
  valid_605133 = validateParameter(valid_605133, JBool, required = false, default = nil)
  if valid_605133 != nil:
    section.add "Classic", valid_605133
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605134: Call_PostResizeCluster_605117; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_605134.validator(path, query, header, formData, body)
  let scheme = call_605134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605134.url(scheme.get, call_605134.host, call_605134.base,
                         call_605134.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605134, url, valid)

proc call*(call_605135: Call_PostResizeCluster_605117; ClusterIdentifier: string;
          NumberOfNodes: int; NodeType: string = ""; Action: string = "ResizeCluster";
          ClusterType: string = ""; Version: string = "2012-12-01";
          Classic: bool = false): Recallable =
  ## postResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Action: string (required)
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   Version: string (required)
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  var query_605136 = newJObject()
  var formData_605137 = newJObject()
  add(formData_605137, "NodeType", newJString(NodeType))
  add(formData_605137, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_605137, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_605136, "Action", newJString(Action))
  add(formData_605137, "ClusterType", newJString(ClusterType))
  add(query_605136, "Version", newJString(Version))
  add(formData_605137, "Classic", newJBool(Classic))
  result = call_605135.call(nil, query_605136, nil, formData_605137, nil)

var postResizeCluster* = Call_PostResizeCluster_605117(name: "postResizeCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_PostResizeCluster_605118,
    base: "/", url: url_PostResizeCluster_605119,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResizeCluster_605097 = ref object of OpenApiRestCall_601373
proc url_GetResizeCluster_605099(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResizeCluster_605098(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Version: JString (required)
  section = newJObject()
  var valid_605100 = query.getOrDefault("NodeType")
  valid_605100 = validateParameter(valid_605100, JString, required = false,
                                 default = nil)
  if valid_605100 != nil:
    section.add "NodeType", valid_605100
  var valid_605101 = query.getOrDefault("ClusterType")
  valid_605101 = validateParameter(valid_605101, JString, required = false,
                                 default = nil)
  if valid_605101 != nil:
    section.add "ClusterType", valid_605101
  assert query != nil,
        "query argument is necessary due to required `NumberOfNodes` field"
  var valid_605102 = query.getOrDefault("NumberOfNodes")
  valid_605102 = validateParameter(valid_605102, JInt, required = true, default = nil)
  if valid_605102 != nil:
    section.add "NumberOfNodes", valid_605102
  var valid_605103 = query.getOrDefault("Classic")
  valid_605103 = validateParameter(valid_605103, JBool, required = false, default = nil)
  if valid_605103 != nil:
    section.add "Classic", valid_605103
  var valid_605104 = query.getOrDefault("Action")
  valid_605104 = validateParameter(valid_605104, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_605104 != nil:
    section.add "Action", valid_605104
  var valid_605105 = query.getOrDefault("ClusterIdentifier")
  valid_605105 = validateParameter(valid_605105, JString, required = true,
                                 default = nil)
  if valid_605105 != nil:
    section.add "ClusterIdentifier", valid_605105
  var valid_605106 = query.getOrDefault("Version")
  valid_605106 = validateParameter(valid_605106, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605106 != nil:
    section.add "Version", valid_605106
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605107 = header.getOrDefault("X-Amz-Signature")
  valid_605107 = validateParameter(valid_605107, JString, required = false,
                                 default = nil)
  if valid_605107 != nil:
    section.add "X-Amz-Signature", valid_605107
  var valid_605108 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605108 = validateParameter(valid_605108, JString, required = false,
                                 default = nil)
  if valid_605108 != nil:
    section.add "X-Amz-Content-Sha256", valid_605108
  var valid_605109 = header.getOrDefault("X-Amz-Date")
  valid_605109 = validateParameter(valid_605109, JString, required = false,
                                 default = nil)
  if valid_605109 != nil:
    section.add "X-Amz-Date", valid_605109
  var valid_605110 = header.getOrDefault("X-Amz-Credential")
  valid_605110 = validateParameter(valid_605110, JString, required = false,
                                 default = nil)
  if valid_605110 != nil:
    section.add "X-Amz-Credential", valid_605110
  var valid_605111 = header.getOrDefault("X-Amz-Security-Token")
  valid_605111 = validateParameter(valid_605111, JString, required = false,
                                 default = nil)
  if valid_605111 != nil:
    section.add "X-Amz-Security-Token", valid_605111
  var valid_605112 = header.getOrDefault("X-Amz-Algorithm")
  valid_605112 = validateParameter(valid_605112, JString, required = false,
                                 default = nil)
  if valid_605112 != nil:
    section.add "X-Amz-Algorithm", valid_605112
  var valid_605113 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605113 = validateParameter(valid_605113, JString, required = false,
                                 default = nil)
  if valid_605113 != nil:
    section.add "X-Amz-SignedHeaders", valid_605113
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605114: Call_GetResizeCluster_605097; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_605114.validator(path, query, header, formData, body)
  let scheme = call_605114.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605114.url(scheme.get, call_605114.host, call_605114.base,
                         call_605114.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605114, url, valid)

proc call*(call_605115: Call_GetResizeCluster_605097; NumberOfNodes: int;
          ClusterIdentifier: string; NodeType: string = ""; ClusterType: string = "";
          Classic: bool = false; Action: string = "ResizeCluster";
          Version: string = "2012-12-01"): Recallable =
  ## getResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Version: string (required)
  var query_605116 = newJObject()
  add(query_605116, "NodeType", newJString(NodeType))
  add(query_605116, "ClusterType", newJString(ClusterType))
  add(query_605116, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_605116, "Classic", newJBool(Classic))
  add(query_605116, "Action", newJString(Action))
  add(query_605116, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605116, "Version", newJString(Version))
  result = call_605115.call(nil, query_605116, nil, nil, nil)

var getResizeCluster* = Call_GetResizeCluster_605097(name: "getResizeCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_GetResizeCluster_605098,
    base: "/", url: url_GetResizeCluster_605099,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreFromClusterSnapshot_605179 = ref object of OpenApiRestCall_601373
proc url_PostRestoreFromClusterSnapshot_605181(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreFromClusterSnapshot_605180(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605182 = query.getOrDefault("Action")
  valid_605182 = validateParameter(valid_605182, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_605182 != nil:
    section.add "Action", valid_605182
  var valid_605183 = query.getOrDefault("Version")
  valid_605183 = validateParameter(valid_605183, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605183 != nil:
    section.add "Version", valid_605183
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605184 = header.getOrDefault("X-Amz-Signature")
  valid_605184 = validateParameter(valid_605184, JString, required = false,
                                 default = nil)
  if valid_605184 != nil:
    section.add "X-Amz-Signature", valid_605184
  var valid_605185 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605185 = validateParameter(valid_605185, JString, required = false,
                                 default = nil)
  if valid_605185 != nil:
    section.add "X-Amz-Content-Sha256", valid_605185
  var valid_605186 = header.getOrDefault("X-Amz-Date")
  valid_605186 = validateParameter(valid_605186, JString, required = false,
                                 default = nil)
  if valid_605186 != nil:
    section.add "X-Amz-Date", valid_605186
  var valid_605187 = header.getOrDefault("X-Amz-Credential")
  valid_605187 = validateParameter(valid_605187, JString, required = false,
                                 default = nil)
  if valid_605187 != nil:
    section.add "X-Amz-Credential", valid_605187
  var valid_605188 = header.getOrDefault("X-Amz-Security-Token")
  valid_605188 = validateParameter(valid_605188, JString, required = false,
                                 default = nil)
  if valid_605188 != nil:
    section.add "X-Amz-Security-Token", valid_605188
  var valid_605189 = header.getOrDefault("X-Amz-Algorithm")
  valid_605189 = validateParameter(valid_605189, JString, required = false,
                                 default = nil)
  if valid_605189 != nil:
    section.add "X-Amz-Algorithm", valid_605189
  var valid_605190 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605190 = validateParameter(valid_605190, JString, required = false,
                                 default = nil)
  if valid_605190 != nil:
    section.add "X-Amz-SignedHeaders", valid_605190
  result.add "header", section
  ## parameters in `formData` object:
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_605191 = formData.getOrDefault("Port")
  valid_605191 = validateParameter(valid_605191, JInt, required = false, default = nil)
  if valid_605191 != nil:
    section.add "Port", valid_605191
  var valid_605192 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_605192 = validateParameter(valid_605192, JString, required = false,
                                 default = nil)
  if valid_605192 != nil:
    section.add "PreferredMaintenanceWindow", valid_605192
  var valid_605193 = formData.getOrDefault("NodeType")
  valid_605193 = validateParameter(valid_605193, JString, required = false,
                                 default = nil)
  if valid_605193 != nil:
    section.add "NodeType", valid_605193
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605194 = formData.getOrDefault("ClusterIdentifier")
  valid_605194 = validateParameter(valid_605194, JString, required = true,
                                 default = nil)
  if valid_605194 != nil:
    section.add "ClusterIdentifier", valid_605194
  var valid_605195 = formData.getOrDefault("MaintenanceTrackName")
  valid_605195 = validateParameter(valid_605195, JString, required = false,
                                 default = nil)
  if valid_605195 != nil:
    section.add "MaintenanceTrackName", valid_605195
  var valid_605196 = formData.getOrDefault("ClusterSecurityGroups")
  valid_605196 = validateParameter(valid_605196, JArray, required = false,
                                 default = nil)
  if valid_605196 != nil:
    section.add "ClusterSecurityGroups", valid_605196
  var valid_605197 = formData.getOrDefault("IamRoles")
  valid_605197 = validateParameter(valid_605197, JArray, required = false,
                                 default = nil)
  if valid_605197 != nil:
    section.add "IamRoles", valid_605197
  var valid_605198 = formData.getOrDefault("OwnerAccount")
  valid_605198 = validateParameter(valid_605198, JString, required = false,
                                 default = nil)
  if valid_605198 != nil:
    section.add "OwnerAccount", valid_605198
  var valid_605199 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_605199 = validateParameter(valid_605199, JArray, required = false,
                                 default = nil)
  if valid_605199 != nil:
    section.add "VpcSecurityGroupIds", valid_605199
  var valid_605200 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_605200 = validateParameter(valid_605200, JInt, required = false, default = nil)
  if valid_605200 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_605200
  var valid_605201 = formData.getOrDefault("AvailabilityZone")
  valid_605201 = validateParameter(valid_605201, JString, required = false,
                                 default = nil)
  if valid_605201 != nil:
    section.add "AvailabilityZone", valid_605201
  var valid_605202 = formData.getOrDefault("EnhancedVpcRouting")
  valid_605202 = validateParameter(valid_605202, JBool, required = false, default = nil)
  if valid_605202 != nil:
    section.add "EnhancedVpcRouting", valid_605202
  var valid_605203 = formData.getOrDefault("KmsKeyId")
  valid_605203 = validateParameter(valid_605203, JString, required = false,
                                 default = nil)
  if valid_605203 != nil:
    section.add "KmsKeyId", valid_605203
  var valid_605204 = formData.getOrDefault("NumberOfNodes")
  valid_605204 = validateParameter(valid_605204, JInt, required = false, default = nil)
  if valid_605204 != nil:
    section.add "NumberOfNodes", valid_605204
  var valid_605205 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_605205 = validateParameter(valid_605205, JString, required = false,
                                 default = nil)
  if valid_605205 != nil:
    section.add "ClusterSubnetGroupName", valid_605205
  var valid_605206 = formData.getOrDefault("AllowVersionUpgrade")
  valid_605206 = validateParameter(valid_605206, JBool, required = false, default = nil)
  if valid_605206 != nil:
    section.add "AllowVersionUpgrade", valid_605206
  var valid_605207 = formData.getOrDefault("SnapshotIdentifier")
  valid_605207 = validateParameter(valid_605207, JString, required = true,
                                 default = nil)
  if valid_605207 != nil:
    section.add "SnapshotIdentifier", valid_605207
  var valid_605208 = formData.getOrDefault("PubliclyAccessible")
  valid_605208 = validateParameter(valid_605208, JBool, required = false, default = nil)
  if valid_605208 != nil:
    section.add "PubliclyAccessible", valid_605208
  var valid_605209 = formData.getOrDefault("ClusterParameterGroupName")
  valid_605209 = validateParameter(valid_605209, JString, required = false,
                                 default = nil)
  if valid_605209 != nil:
    section.add "ClusterParameterGroupName", valid_605209
  var valid_605210 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_605210 = validateParameter(valid_605210, JString, required = false,
                                 default = nil)
  if valid_605210 != nil:
    section.add "HsmClientCertificateIdentifier", valid_605210
  var valid_605211 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_605211 = validateParameter(valid_605211, JString, required = false,
                                 default = nil)
  if valid_605211 != nil:
    section.add "SnapshotClusterIdentifier", valid_605211
  var valid_605212 = formData.getOrDefault("AdditionalInfo")
  valid_605212 = validateParameter(valid_605212, JString, required = false,
                                 default = nil)
  if valid_605212 != nil:
    section.add "AdditionalInfo", valid_605212
  var valid_605213 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_605213 = validateParameter(valid_605213, JString, required = false,
                                 default = nil)
  if valid_605213 != nil:
    section.add "SnapshotScheduleIdentifier", valid_605213
  var valid_605214 = formData.getOrDefault("ElasticIp")
  valid_605214 = validateParameter(valid_605214, JString, required = false,
                                 default = nil)
  if valid_605214 != nil:
    section.add "ElasticIp", valid_605214
  var valid_605215 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_605215 = validateParameter(valid_605215, JString, required = false,
                                 default = nil)
  if valid_605215 != nil:
    section.add "HsmConfigurationIdentifier", valid_605215
  var valid_605216 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_605216 = validateParameter(valid_605216, JInt, required = false, default = nil)
  if valid_605216 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_605216
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605217: Call_PostRestoreFromClusterSnapshot_605179; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_605217.validator(path, query, header, formData, body)
  let scheme = call_605217.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605217.url(scheme.get, call_605217.host, call_605217.base,
                         call_605217.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605217, url, valid)

proc call*(call_605218: Call_PostRestoreFromClusterSnapshot_605179;
          ClusterIdentifier: string; SnapshotIdentifier: string; Port: int = 0;
          PreferredMaintenanceWindow: string = ""; NodeType: string = "";
          MaintenanceTrackName: string = ""; ClusterSecurityGroups: JsonNode = nil;
          IamRoles: JsonNode = nil; OwnerAccount: string = "";
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0; AvailabilityZone: string = "";
          EnhancedVpcRouting: bool = false; KmsKeyId: string = "";
          NumberOfNodes: int = 0; ClusterSubnetGroupName: string = "";
          AllowVersionUpgrade: bool = false; PubliclyAccessible: bool = false;
          Action: string = "RestoreFromClusterSnapshot";
          ClusterParameterGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          SnapshotClusterIdentifier: string = ""; AdditionalInfo: string = "";
          SnapshotScheduleIdentifier: string = ""; Version: string = "2012-12-01";
          ElasticIp: string = ""; HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_605219 = newJObject()
  var formData_605220 = newJObject()
  add(formData_605220, "Port", newJInt(Port))
  add(formData_605220, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_605220, "NodeType", newJString(NodeType))
  add(formData_605220, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_605220, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if ClusterSecurityGroups != nil:
    formData_605220.add "ClusterSecurityGroups", ClusterSecurityGroups
  if IamRoles != nil:
    formData_605220.add "IamRoles", IamRoles
  add(formData_605220, "OwnerAccount", newJString(OwnerAccount))
  if VpcSecurityGroupIds != nil:
    formData_605220.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_605220, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_605220, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_605220, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_605220, "KmsKeyId", newJString(KmsKeyId))
  add(formData_605220, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_605220, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_605220, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_605220, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_605220, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_605219, "Action", newJString(Action))
  add(formData_605220, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_605220, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_605220, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(formData_605220, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_605220, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_605219, "Version", newJString(Version))
  add(formData_605220, "ElasticIp", newJString(ElasticIp))
  add(formData_605220, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_605220, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_605218.call(nil, query_605219, nil, formData_605220, nil)

var postRestoreFromClusterSnapshot* = Call_PostRestoreFromClusterSnapshot_605179(
    name: "postRestoreFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_PostRestoreFromClusterSnapshot_605180, base: "/",
    url: url_PostRestoreFromClusterSnapshot_605181,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreFromClusterSnapshot_605138 = ref object of OpenApiRestCall_601373
proc url_GetRestoreFromClusterSnapshot_605140(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreFromClusterSnapshot_605139(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  section = newJObject()
  var valid_605141 = query.getOrDefault("ClusterSubnetGroupName")
  valid_605141 = validateParameter(valid_605141, JString, required = false,
                                 default = nil)
  if valid_605141 != nil:
    section.add "ClusterSubnetGroupName", valid_605141
  var valid_605142 = query.getOrDefault("MaintenanceTrackName")
  valid_605142 = validateParameter(valid_605142, JString, required = false,
                                 default = nil)
  if valid_605142 != nil:
    section.add "MaintenanceTrackName", valid_605142
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_605143 = query.getOrDefault("SnapshotIdentifier")
  valid_605143 = validateParameter(valid_605143, JString, required = true,
                                 default = nil)
  if valid_605143 != nil:
    section.add "SnapshotIdentifier", valid_605143
  var valid_605144 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_605144 = validateParameter(valid_605144, JString, required = false,
                                 default = nil)
  if valid_605144 != nil:
    section.add "HsmClientCertificateIdentifier", valid_605144
  var valid_605145 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_605145 = validateParameter(valid_605145, JInt, required = false, default = nil)
  if valid_605145 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_605145
  var valid_605146 = query.getOrDefault("ClusterSecurityGroups")
  valid_605146 = validateParameter(valid_605146, JArray, required = false,
                                 default = nil)
  if valid_605146 != nil:
    section.add "ClusterSecurityGroups", valid_605146
  var valid_605147 = query.getOrDefault("KmsKeyId")
  valid_605147 = validateParameter(valid_605147, JString, required = false,
                                 default = nil)
  if valid_605147 != nil:
    section.add "KmsKeyId", valid_605147
  var valid_605148 = query.getOrDefault("ClusterParameterGroupName")
  valid_605148 = validateParameter(valid_605148, JString, required = false,
                                 default = nil)
  if valid_605148 != nil:
    section.add "ClusterParameterGroupName", valid_605148
  var valid_605149 = query.getOrDefault("NodeType")
  valid_605149 = validateParameter(valid_605149, JString, required = false,
                                 default = nil)
  if valid_605149 != nil:
    section.add "NodeType", valid_605149
  var valid_605150 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_605150 = validateParameter(valid_605150, JString, required = false,
                                 default = nil)
  if valid_605150 != nil:
    section.add "SnapshotScheduleIdentifier", valid_605150
  var valid_605151 = query.getOrDefault("IamRoles")
  valid_605151 = validateParameter(valid_605151, JArray, required = false,
                                 default = nil)
  if valid_605151 != nil:
    section.add "IamRoles", valid_605151
  var valid_605152 = query.getOrDefault("NumberOfNodes")
  valid_605152 = validateParameter(valid_605152, JInt, required = false, default = nil)
  if valid_605152 != nil:
    section.add "NumberOfNodes", valid_605152
  var valid_605153 = query.getOrDefault("AdditionalInfo")
  valid_605153 = validateParameter(valid_605153, JString, required = false,
                                 default = nil)
  if valid_605153 != nil:
    section.add "AdditionalInfo", valid_605153
  var valid_605154 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_605154 = validateParameter(valid_605154, JString, required = false,
                                 default = nil)
  if valid_605154 != nil:
    section.add "SnapshotClusterIdentifier", valid_605154
  var valid_605155 = query.getOrDefault("AllowVersionUpgrade")
  valid_605155 = validateParameter(valid_605155, JBool, required = false, default = nil)
  if valid_605155 != nil:
    section.add "AllowVersionUpgrade", valid_605155
  var valid_605156 = query.getOrDefault("ElasticIp")
  valid_605156 = validateParameter(valid_605156, JString, required = false,
                                 default = nil)
  if valid_605156 != nil:
    section.add "ElasticIp", valid_605156
  var valid_605157 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_605157 = validateParameter(valid_605157, JInt, required = false, default = nil)
  if valid_605157 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_605157
  var valid_605158 = query.getOrDefault("EnhancedVpcRouting")
  valid_605158 = validateParameter(valid_605158, JBool, required = false, default = nil)
  if valid_605158 != nil:
    section.add "EnhancedVpcRouting", valid_605158
  var valid_605159 = query.getOrDefault("Action")
  valid_605159 = validateParameter(valid_605159, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_605159 != nil:
    section.add "Action", valid_605159
  var valid_605160 = query.getOrDefault("ClusterIdentifier")
  valid_605160 = validateParameter(valid_605160, JString, required = true,
                                 default = nil)
  if valid_605160 != nil:
    section.add "ClusterIdentifier", valid_605160
  var valid_605161 = query.getOrDefault("Port")
  valid_605161 = validateParameter(valid_605161, JInt, required = false, default = nil)
  if valid_605161 != nil:
    section.add "Port", valid_605161
  var valid_605162 = query.getOrDefault("VpcSecurityGroupIds")
  valid_605162 = validateParameter(valid_605162, JArray, required = false,
                                 default = nil)
  if valid_605162 != nil:
    section.add "VpcSecurityGroupIds", valid_605162
  var valid_605163 = query.getOrDefault("AvailabilityZone")
  valid_605163 = validateParameter(valid_605163, JString, required = false,
                                 default = nil)
  if valid_605163 != nil:
    section.add "AvailabilityZone", valid_605163
  var valid_605164 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_605164 = validateParameter(valid_605164, JString, required = false,
                                 default = nil)
  if valid_605164 != nil:
    section.add "HsmConfigurationIdentifier", valid_605164
  var valid_605165 = query.getOrDefault("OwnerAccount")
  valid_605165 = validateParameter(valid_605165, JString, required = false,
                                 default = nil)
  if valid_605165 != nil:
    section.add "OwnerAccount", valid_605165
  var valid_605166 = query.getOrDefault("Version")
  valid_605166 = validateParameter(valid_605166, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605166 != nil:
    section.add "Version", valid_605166
  var valid_605167 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_605167 = validateParameter(valid_605167, JString, required = false,
                                 default = nil)
  if valid_605167 != nil:
    section.add "PreferredMaintenanceWindow", valid_605167
  var valid_605168 = query.getOrDefault("PubliclyAccessible")
  valid_605168 = validateParameter(valid_605168, JBool, required = false, default = nil)
  if valid_605168 != nil:
    section.add "PubliclyAccessible", valid_605168
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605169 = header.getOrDefault("X-Amz-Signature")
  valid_605169 = validateParameter(valid_605169, JString, required = false,
                                 default = nil)
  if valid_605169 != nil:
    section.add "X-Amz-Signature", valid_605169
  var valid_605170 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605170 = validateParameter(valid_605170, JString, required = false,
                                 default = nil)
  if valid_605170 != nil:
    section.add "X-Amz-Content-Sha256", valid_605170
  var valid_605171 = header.getOrDefault("X-Amz-Date")
  valid_605171 = validateParameter(valid_605171, JString, required = false,
                                 default = nil)
  if valid_605171 != nil:
    section.add "X-Amz-Date", valid_605171
  var valid_605172 = header.getOrDefault("X-Amz-Credential")
  valid_605172 = validateParameter(valid_605172, JString, required = false,
                                 default = nil)
  if valid_605172 != nil:
    section.add "X-Amz-Credential", valid_605172
  var valid_605173 = header.getOrDefault("X-Amz-Security-Token")
  valid_605173 = validateParameter(valid_605173, JString, required = false,
                                 default = nil)
  if valid_605173 != nil:
    section.add "X-Amz-Security-Token", valid_605173
  var valid_605174 = header.getOrDefault("X-Amz-Algorithm")
  valid_605174 = validateParameter(valid_605174, JString, required = false,
                                 default = nil)
  if valid_605174 != nil:
    section.add "X-Amz-Algorithm", valid_605174
  var valid_605175 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605175 = validateParameter(valid_605175, JString, required = false,
                                 default = nil)
  if valid_605175 != nil:
    section.add "X-Amz-SignedHeaders", valid_605175
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605176: Call_GetRestoreFromClusterSnapshot_605138; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_605176.validator(path, query, header, formData, body)
  let scheme = call_605176.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605176.url(scheme.get, call_605176.host, call_605176.base,
                         call_605176.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605176, url, valid)

proc call*(call_605177: Call_GetRestoreFromClusterSnapshot_605138;
          SnapshotIdentifier: string; ClusterIdentifier: string;
          ClusterSubnetGroupName: string = ""; MaintenanceTrackName: string = "";
          HsmClientCertificateIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0;
          ClusterSecurityGroups: JsonNode = nil; KmsKeyId: string = "";
          ClusterParameterGroupName: string = ""; NodeType: string = "";
          SnapshotScheduleIdentifier: string = ""; IamRoles: JsonNode = nil;
          NumberOfNodes: int = 0; AdditionalInfo: string = "";
          SnapshotClusterIdentifier: string = ""; AllowVersionUpgrade: bool = false;
          ElasticIp: string = ""; AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false;
          Action: string = "RestoreFromClusterSnapshot"; Port: int = 0;
          VpcSecurityGroupIds: JsonNode = nil; AvailabilityZone: string = "";
          HsmConfigurationIdentifier: string = ""; OwnerAccount: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  var query_605178 = newJObject()
  add(query_605178, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_605178, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_605178, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_605178, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_605178, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  if ClusterSecurityGroups != nil:
    query_605178.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_605178, "KmsKeyId", newJString(KmsKeyId))
  add(query_605178, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_605178, "NodeType", newJString(NodeType))
  add(query_605178, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  if IamRoles != nil:
    query_605178.add "IamRoles", IamRoles
  add(query_605178, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_605178, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_605178, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_605178, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_605178, "ElasticIp", newJString(ElasticIp))
  add(query_605178, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_605178, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_605178, "Action", newJString(Action))
  add(query_605178, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605178, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    query_605178.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_605178, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_605178, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_605178, "OwnerAccount", newJString(OwnerAccount))
  add(query_605178, "Version", newJString(Version))
  add(query_605178, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_605178, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_605177.call(nil, query_605178, nil, nil, nil)

var getRestoreFromClusterSnapshot* = Call_GetRestoreFromClusterSnapshot_605138(
    name: "getRestoreFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_GetRestoreFromClusterSnapshot_605139, base: "/",
    url: url_GetRestoreFromClusterSnapshot_605140,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreTableFromClusterSnapshot_605244 = ref object of OpenApiRestCall_601373
proc url_PostRestoreTableFromClusterSnapshot_605246(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreTableFromClusterSnapshot_605245(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605247 = query.getOrDefault("Action")
  valid_605247 = validateParameter(valid_605247, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_605247 != nil:
    section.add "Action", valid_605247
  var valid_605248 = query.getOrDefault("Version")
  valid_605248 = validateParameter(valid_605248, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605248 != nil:
    section.add "Version", valid_605248
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605249 = header.getOrDefault("X-Amz-Signature")
  valid_605249 = validateParameter(valid_605249, JString, required = false,
                                 default = nil)
  if valid_605249 != nil:
    section.add "X-Amz-Signature", valid_605249
  var valid_605250 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605250 = validateParameter(valid_605250, JString, required = false,
                                 default = nil)
  if valid_605250 != nil:
    section.add "X-Amz-Content-Sha256", valid_605250
  var valid_605251 = header.getOrDefault("X-Amz-Date")
  valid_605251 = validateParameter(valid_605251, JString, required = false,
                                 default = nil)
  if valid_605251 != nil:
    section.add "X-Amz-Date", valid_605251
  var valid_605252 = header.getOrDefault("X-Amz-Credential")
  valid_605252 = validateParameter(valid_605252, JString, required = false,
                                 default = nil)
  if valid_605252 != nil:
    section.add "X-Amz-Credential", valid_605252
  var valid_605253 = header.getOrDefault("X-Amz-Security-Token")
  valid_605253 = validateParameter(valid_605253, JString, required = false,
                                 default = nil)
  if valid_605253 != nil:
    section.add "X-Amz-Security-Token", valid_605253
  var valid_605254 = header.getOrDefault("X-Amz-Algorithm")
  valid_605254 = validateParameter(valid_605254, JString, required = false,
                                 default = nil)
  if valid_605254 != nil:
    section.add "X-Amz-Algorithm", valid_605254
  var valid_605255 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605255 = validateParameter(valid_605255, JString, required = false,
                                 default = nil)
  if valid_605255 != nil:
    section.add "X-Amz-SignedHeaders", valid_605255
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605256 = formData.getOrDefault("ClusterIdentifier")
  valid_605256 = validateParameter(valid_605256, JString, required = true,
                                 default = nil)
  if valid_605256 != nil:
    section.add "ClusterIdentifier", valid_605256
  var valid_605257 = formData.getOrDefault("NewTableName")
  valid_605257 = validateParameter(valid_605257, JString, required = true,
                                 default = nil)
  if valid_605257 != nil:
    section.add "NewTableName", valid_605257
  var valid_605258 = formData.getOrDefault("TargetSchemaName")
  valid_605258 = validateParameter(valid_605258, JString, required = false,
                                 default = nil)
  if valid_605258 != nil:
    section.add "TargetSchemaName", valid_605258
  var valid_605259 = formData.getOrDefault("TargetDatabaseName")
  valid_605259 = validateParameter(valid_605259, JString, required = false,
                                 default = nil)
  if valid_605259 != nil:
    section.add "TargetDatabaseName", valid_605259
  var valid_605260 = formData.getOrDefault("SnapshotIdentifier")
  valid_605260 = validateParameter(valid_605260, JString, required = true,
                                 default = nil)
  if valid_605260 != nil:
    section.add "SnapshotIdentifier", valid_605260
  var valid_605261 = formData.getOrDefault("SourceDatabaseName")
  valid_605261 = validateParameter(valid_605261, JString, required = true,
                                 default = nil)
  if valid_605261 != nil:
    section.add "SourceDatabaseName", valid_605261
  var valid_605262 = formData.getOrDefault("SourceSchemaName")
  valid_605262 = validateParameter(valid_605262, JString, required = false,
                                 default = nil)
  if valid_605262 != nil:
    section.add "SourceSchemaName", valid_605262
  var valid_605263 = formData.getOrDefault("SourceTableName")
  valid_605263 = validateParameter(valid_605263, JString, required = true,
                                 default = nil)
  if valid_605263 != nil:
    section.add "SourceTableName", valid_605263
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605264: Call_PostRestoreTableFromClusterSnapshot_605244;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_605264.validator(path, query, header, formData, body)
  let scheme = call_605264.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605264.url(scheme.get, call_605264.host, call_605264.base,
                         call_605264.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605264, url, valid)

proc call*(call_605265: Call_PostRestoreTableFromClusterSnapshot_605244;
          ClusterIdentifier: string; NewTableName: string;
          SnapshotIdentifier: string; SourceDatabaseName: string;
          SourceTableName: string; TargetSchemaName: string = "";
          TargetDatabaseName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          Version: string = "2012-12-01"; SourceSchemaName: string = ""): Recallable =
  ## postRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  var query_605266 = newJObject()
  var formData_605267 = newJObject()
  add(formData_605267, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_605267, "NewTableName", newJString(NewTableName))
  add(formData_605267, "TargetSchemaName", newJString(TargetSchemaName))
  add(formData_605267, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(formData_605267, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_605267, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_605266, "Action", newJString(Action))
  add(query_605266, "Version", newJString(Version))
  add(formData_605267, "SourceSchemaName", newJString(SourceSchemaName))
  add(formData_605267, "SourceTableName", newJString(SourceTableName))
  result = call_605265.call(nil, query_605266, nil, formData_605267, nil)

var postRestoreTableFromClusterSnapshot* = Call_PostRestoreTableFromClusterSnapshot_605244(
    name: "postRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_PostRestoreTableFromClusterSnapshot_605245, base: "/",
    url: url_PostRestoreTableFromClusterSnapshot_605246,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreTableFromClusterSnapshot_605221 = ref object of OpenApiRestCall_601373
proc url_GetRestoreTableFromClusterSnapshot_605223(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreTableFromClusterSnapshot_605222(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   Version: JString (required)
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_605224 = query.getOrDefault("SnapshotIdentifier")
  valid_605224 = validateParameter(valid_605224, JString, required = true,
                                 default = nil)
  if valid_605224 != nil:
    section.add "SnapshotIdentifier", valid_605224
  var valid_605225 = query.getOrDefault("SourceTableName")
  valid_605225 = validateParameter(valid_605225, JString, required = true,
                                 default = nil)
  if valid_605225 != nil:
    section.add "SourceTableName", valid_605225
  var valid_605226 = query.getOrDefault("SourceDatabaseName")
  valid_605226 = validateParameter(valid_605226, JString, required = true,
                                 default = nil)
  if valid_605226 != nil:
    section.add "SourceDatabaseName", valid_605226
  var valid_605227 = query.getOrDefault("TargetSchemaName")
  valid_605227 = validateParameter(valid_605227, JString, required = false,
                                 default = nil)
  if valid_605227 != nil:
    section.add "TargetSchemaName", valid_605227
  var valid_605228 = query.getOrDefault("Action")
  valid_605228 = validateParameter(valid_605228, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_605228 != nil:
    section.add "Action", valid_605228
  var valid_605229 = query.getOrDefault("ClusterIdentifier")
  valid_605229 = validateParameter(valid_605229, JString, required = true,
                                 default = nil)
  if valid_605229 != nil:
    section.add "ClusterIdentifier", valid_605229
  var valid_605230 = query.getOrDefault("SourceSchemaName")
  valid_605230 = validateParameter(valid_605230, JString, required = false,
                                 default = nil)
  if valid_605230 != nil:
    section.add "SourceSchemaName", valid_605230
  var valid_605231 = query.getOrDefault("Version")
  valid_605231 = validateParameter(valid_605231, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605231 != nil:
    section.add "Version", valid_605231
  var valid_605232 = query.getOrDefault("TargetDatabaseName")
  valid_605232 = validateParameter(valid_605232, JString, required = false,
                                 default = nil)
  if valid_605232 != nil:
    section.add "TargetDatabaseName", valid_605232
  var valid_605233 = query.getOrDefault("NewTableName")
  valid_605233 = validateParameter(valid_605233, JString, required = true,
                                 default = nil)
  if valid_605233 != nil:
    section.add "NewTableName", valid_605233
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605234 = header.getOrDefault("X-Amz-Signature")
  valid_605234 = validateParameter(valid_605234, JString, required = false,
                                 default = nil)
  if valid_605234 != nil:
    section.add "X-Amz-Signature", valid_605234
  var valid_605235 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605235 = validateParameter(valid_605235, JString, required = false,
                                 default = nil)
  if valid_605235 != nil:
    section.add "X-Amz-Content-Sha256", valid_605235
  var valid_605236 = header.getOrDefault("X-Amz-Date")
  valid_605236 = validateParameter(valid_605236, JString, required = false,
                                 default = nil)
  if valid_605236 != nil:
    section.add "X-Amz-Date", valid_605236
  var valid_605237 = header.getOrDefault("X-Amz-Credential")
  valid_605237 = validateParameter(valid_605237, JString, required = false,
                                 default = nil)
  if valid_605237 != nil:
    section.add "X-Amz-Credential", valid_605237
  var valid_605238 = header.getOrDefault("X-Amz-Security-Token")
  valid_605238 = validateParameter(valid_605238, JString, required = false,
                                 default = nil)
  if valid_605238 != nil:
    section.add "X-Amz-Security-Token", valid_605238
  var valid_605239 = header.getOrDefault("X-Amz-Algorithm")
  valid_605239 = validateParameter(valid_605239, JString, required = false,
                                 default = nil)
  if valid_605239 != nil:
    section.add "X-Amz-Algorithm", valid_605239
  var valid_605240 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605240 = validateParameter(valid_605240, JString, required = false,
                                 default = nil)
  if valid_605240 != nil:
    section.add "X-Amz-SignedHeaders", valid_605240
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605241: Call_GetRestoreTableFromClusterSnapshot_605221;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_605241.validator(path, query, header, formData, body)
  let scheme = call_605241.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605241.url(scheme.get, call_605241.host, call_605241.base,
                         call_605241.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605241, url, valid)

proc call*(call_605242: Call_GetRestoreTableFromClusterSnapshot_605221;
          SnapshotIdentifier: string; SourceTableName: string;
          SourceDatabaseName: string; ClusterIdentifier: string;
          NewTableName: string; TargetSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          SourceSchemaName: string = ""; Version: string = "2012-12-01";
          TargetDatabaseName: string = ""): Recallable =
  ## getRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   Version: string (required)
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  var query_605243 = newJObject()
  add(query_605243, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_605243, "SourceTableName", newJString(SourceTableName))
  add(query_605243, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_605243, "TargetSchemaName", newJString(TargetSchemaName))
  add(query_605243, "Action", newJString(Action))
  add(query_605243, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605243, "SourceSchemaName", newJString(SourceSchemaName))
  add(query_605243, "Version", newJString(Version))
  add(query_605243, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(query_605243, "NewTableName", newJString(NewTableName))
  result = call_605242.call(nil, query_605243, nil, nil, nil)

var getRestoreTableFromClusterSnapshot* = Call_GetRestoreTableFromClusterSnapshot_605221(
    name: "getRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_GetRestoreTableFromClusterSnapshot_605222, base: "/",
    url: url_GetRestoreTableFromClusterSnapshot_605223,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeClusterSecurityGroupIngress_605287 = ref object of OpenApiRestCall_601373
proc url_PostRevokeClusterSecurityGroupIngress_605289(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeClusterSecurityGroupIngress_605288(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605290 = query.getOrDefault("Action")
  valid_605290 = validateParameter(valid_605290, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_605290 != nil:
    section.add "Action", valid_605290
  var valid_605291 = query.getOrDefault("Version")
  valid_605291 = validateParameter(valid_605291, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605291 != nil:
    section.add "Version", valid_605291
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605292 = header.getOrDefault("X-Amz-Signature")
  valid_605292 = validateParameter(valid_605292, JString, required = false,
                                 default = nil)
  if valid_605292 != nil:
    section.add "X-Amz-Signature", valid_605292
  var valid_605293 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605293 = validateParameter(valid_605293, JString, required = false,
                                 default = nil)
  if valid_605293 != nil:
    section.add "X-Amz-Content-Sha256", valid_605293
  var valid_605294 = header.getOrDefault("X-Amz-Date")
  valid_605294 = validateParameter(valid_605294, JString, required = false,
                                 default = nil)
  if valid_605294 != nil:
    section.add "X-Amz-Date", valid_605294
  var valid_605295 = header.getOrDefault("X-Amz-Credential")
  valid_605295 = validateParameter(valid_605295, JString, required = false,
                                 default = nil)
  if valid_605295 != nil:
    section.add "X-Amz-Credential", valid_605295
  var valid_605296 = header.getOrDefault("X-Amz-Security-Token")
  valid_605296 = validateParameter(valid_605296, JString, required = false,
                                 default = nil)
  if valid_605296 != nil:
    section.add "X-Amz-Security-Token", valid_605296
  var valid_605297 = header.getOrDefault("X-Amz-Algorithm")
  valid_605297 = validateParameter(valid_605297, JString, required = false,
                                 default = nil)
  if valid_605297 != nil:
    section.add "X-Amz-Algorithm", valid_605297
  var valid_605298 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605298 = validateParameter(valid_605298, JString, required = false,
                                 default = nil)
  if valid_605298 != nil:
    section.add "X-Amz-SignedHeaders", valid_605298
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_605299 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_605299 = validateParameter(valid_605299, JString, required = true,
                                 default = nil)
  if valid_605299 != nil:
    section.add "ClusterSecurityGroupName", valid_605299
  var valid_605300 = formData.getOrDefault("EC2SecurityGroupName")
  valid_605300 = validateParameter(valid_605300, JString, required = false,
                                 default = nil)
  if valid_605300 != nil:
    section.add "EC2SecurityGroupName", valid_605300
  var valid_605301 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_605301 = validateParameter(valid_605301, JString, required = false,
                                 default = nil)
  if valid_605301 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_605301
  var valid_605302 = formData.getOrDefault("CIDRIP")
  valid_605302 = validateParameter(valid_605302, JString, required = false,
                                 default = nil)
  if valid_605302 != nil:
    section.add "CIDRIP", valid_605302
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605303: Call_PostRevokeClusterSecurityGroupIngress_605287;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_605303.validator(path, query, header, formData, body)
  let scheme = call_605303.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605303.url(scheme.get, call_605303.host, call_605303.base,
                         call_605303.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605303, url, valid)

proc call*(call_605304: Call_PostRevokeClusterSecurityGroupIngress_605287;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = ""; CIDRIP: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"): Recallable =
  ## postRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_605305 = newJObject()
  var formData_605306 = newJObject()
  add(formData_605306, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_605306, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_605306, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_605306, "CIDRIP", newJString(CIDRIP))
  add(query_605305, "Action", newJString(Action))
  add(query_605305, "Version", newJString(Version))
  result = call_605304.call(nil, query_605305, nil, formData_605306, nil)

var postRevokeClusterSecurityGroupIngress* = Call_PostRevokeClusterSecurityGroupIngress_605287(
    name: "postRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_PostRevokeClusterSecurityGroupIngress_605288, base: "/",
    url: url_PostRevokeClusterSecurityGroupIngress_605289,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeClusterSecurityGroupIngress_605268 = ref object of OpenApiRestCall_601373
proc url_GetRevokeClusterSecurityGroupIngress_605270(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeClusterSecurityGroupIngress_605269(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  section = newJObject()
  var valid_605271 = query.getOrDefault("EC2SecurityGroupName")
  valid_605271 = validateParameter(valid_605271, JString, required = false,
                                 default = nil)
  if valid_605271 != nil:
    section.add "EC2SecurityGroupName", valid_605271
  var valid_605272 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_605272 = validateParameter(valid_605272, JString, required = false,
                                 default = nil)
  if valid_605272 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_605272
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_605273 = query.getOrDefault("ClusterSecurityGroupName")
  valid_605273 = validateParameter(valid_605273, JString, required = true,
                                 default = nil)
  if valid_605273 != nil:
    section.add "ClusterSecurityGroupName", valid_605273
  var valid_605274 = query.getOrDefault("Action")
  valid_605274 = validateParameter(valid_605274, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_605274 != nil:
    section.add "Action", valid_605274
  var valid_605275 = query.getOrDefault("Version")
  valid_605275 = validateParameter(valid_605275, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605275 != nil:
    section.add "Version", valid_605275
  var valid_605276 = query.getOrDefault("CIDRIP")
  valid_605276 = validateParameter(valid_605276, JString, required = false,
                                 default = nil)
  if valid_605276 != nil:
    section.add "CIDRIP", valid_605276
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605277 = header.getOrDefault("X-Amz-Signature")
  valid_605277 = validateParameter(valid_605277, JString, required = false,
                                 default = nil)
  if valid_605277 != nil:
    section.add "X-Amz-Signature", valid_605277
  var valid_605278 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605278 = validateParameter(valid_605278, JString, required = false,
                                 default = nil)
  if valid_605278 != nil:
    section.add "X-Amz-Content-Sha256", valid_605278
  var valid_605279 = header.getOrDefault("X-Amz-Date")
  valid_605279 = validateParameter(valid_605279, JString, required = false,
                                 default = nil)
  if valid_605279 != nil:
    section.add "X-Amz-Date", valid_605279
  var valid_605280 = header.getOrDefault("X-Amz-Credential")
  valid_605280 = validateParameter(valid_605280, JString, required = false,
                                 default = nil)
  if valid_605280 != nil:
    section.add "X-Amz-Credential", valid_605280
  var valid_605281 = header.getOrDefault("X-Amz-Security-Token")
  valid_605281 = validateParameter(valid_605281, JString, required = false,
                                 default = nil)
  if valid_605281 != nil:
    section.add "X-Amz-Security-Token", valid_605281
  var valid_605282 = header.getOrDefault("X-Amz-Algorithm")
  valid_605282 = validateParameter(valid_605282, JString, required = false,
                                 default = nil)
  if valid_605282 != nil:
    section.add "X-Amz-Algorithm", valid_605282
  var valid_605283 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605283 = validateParameter(valid_605283, JString, required = false,
                                 default = nil)
  if valid_605283 != nil:
    section.add "X-Amz-SignedHeaders", valid_605283
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605284: Call_GetRevokeClusterSecurityGroupIngress_605268;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_605284.validator(path, query, header, formData, body)
  let scheme = call_605284.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605284.url(scheme.get, call_605284.host, call_605284.base,
                         call_605284.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605284, url, valid)

proc call*(call_605285: Call_GetRevokeClusterSecurityGroupIngress_605268;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"; CIDRIP: string = ""): Recallable =
  ## getRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  var query_605286 = newJObject()
  add(query_605286, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_605286, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_605286, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_605286, "Action", newJString(Action))
  add(query_605286, "Version", newJString(Version))
  add(query_605286, "CIDRIP", newJString(CIDRIP))
  result = call_605285.call(nil, query_605286, nil, nil, nil)

var getRevokeClusterSecurityGroupIngress* = Call_GetRevokeClusterSecurityGroupIngress_605268(
    name: "getRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_GetRevokeClusterSecurityGroupIngress_605269, base: "/",
    url: url_GetRevokeClusterSecurityGroupIngress_605270,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeSnapshotAccess_605325 = ref object of OpenApiRestCall_601373
proc url_PostRevokeSnapshotAccess_605327(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeSnapshotAccess_605326(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605328 = query.getOrDefault("Action")
  valid_605328 = validateParameter(valid_605328, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_605328 != nil:
    section.add "Action", valid_605328
  var valid_605329 = query.getOrDefault("Version")
  valid_605329 = validateParameter(valid_605329, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605329 != nil:
    section.add "Version", valid_605329
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605330 = header.getOrDefault("X-Amz-Signature")
  valid_605330 = validateParameter(valid_605330, JString, required = false,
                                 default = nil)
  if valid_605330 != nil:
    section.add "X-Amz-Signature", valid_605330
  var valid_605331 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605331 = validateParameter(valid_605331, JString, required = false,
                                 default = nil)
  if valid_605331 != nil:
    section.add "X-Amz-Content-Sha256", valid_605331
  var valid_605332 = header.getOrDefault("X-Amz-Date")
  valid_605332 = validateParameter(valid_605332, JString, required = false,
                                 default = nil)
  if valid_605332 != nil:
    section.add "X-Amz-Date", valid_605332
  var valid_605333 = header.getOrDefault("X-Amz-Credential")
  valid_605333 = validateParameter(valid_605333, JString, required = false,
                                 default = nil)
  if valid_605333 != nil:
    section.add "X-Amz-Credential", valid_605333
  var valid_605334 = header.getOrDefault("X-Amz-Security-Token")
  valid_605334 = validateParameter(valid_605334, JString, required = false,
                                 default = nil)
  if valid_605334 != nil:
    section.add "X-Amz-Security-Token", valid_605334
  var valid_605335 = header.getOrDefault("X-Amz-Algorithm")
  valid_605335 = validateParameter(valid_605335, JString, required = false,
                                 default = nil)
  if valid_605335 != nil:
    section.add "X-Amz-Algorithm", valid_605335
  var valid_605336 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605336 = validateParameter(valid_605336, JString, required = false,
                                 default = nil)
  if valid_605336 != nil:
    section.add "X-Amz-SignedHeaders", valid_605336
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_605337 = formData.getOrDefault("SnapshotIdentifier")
  valid_605337 = validateParameter(valid_605337, JString, required = true,
                                 default = nil)
  if valid_605337 != nil:
    section.add "SnapshotIdentifier", valid_605337
  var valid_605338 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_605338 = validateParameter(valid_605338, JString, required = true,
                                 default = nil)
  if valid_605338 != nil:
    section.add "AccountWithRestoreAccess", valid_605338
  var valid_605339 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_605339 = validateParameter(valid_605339, JString, required = false,
                                 default = nil)
  if valid_605339 != nil:
    section.add "SnapshotClusterIdentifier", valid_605339
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605340: Call_PostRevokeSnapshotAccess_605325; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_605340.validator(path, query, header, formData, body)
  let scheme = call_605340.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605340.url(scheme.get, call_605340.host, call_605340.base,
                         call_605340.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605340, url, valid)

proc call*(call_605341: Call_PostRevokeSnapshotAccess_605325;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          Action: string = "RevokeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Action: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Version: string (required)
  var query_605342 = newJObject()
  var formData_605343 = newJObject()
  add(formData_605343, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_605342, "Action", newJString(Action))
  add(formData_605343, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_605343, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_605342, "Version", newJString(Version))
  result = call_605341.call(nil, query_605342, nil, formData_605343, nil)

var postRevokeSnapshotAccess* = Call_PostRevokeSnapshotAccess_605325(
    name: "postRevokeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_PostRevokeSnapshotAccess_605326, base: "/",
    url: url_PostRevokeSnapshotAccess_605327, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeSnapshotAccess_605307 = ref object of OpenApiRestCall_601373
proc url_GetRevokeSnapshotAccess_605309(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeSnapshotAccess_605308(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_605310 = query.getOrDefault("SnapshotIdentifier")
  valid_605310 = validateParameter(valid_605310, JString, required = true,
                                 default = nil)
  if valid_605310 != nil:
    section.add "SnapshotIdentifier", valid_605310
  var valid_605311 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_605311 = validateParameter(valid_605311, JString, required = false,
                                 default = nil)
  if valid_605311 != nil:
    section.add "SnapshotClusterIdentifier", valid_605311
  var valid_605312 = query.getOrDefault("Action")
  valid_605312 = validateParameter(valid_605312, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_605312 != nil:
    section.add "Action", valid_605312
  var valid_605313 = query.getOrDefault("Version")
  valid_605313 = validateParameter(valid_605313, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605313 != nil:
    section.add "Version", valid_605313
  var valid_605314 = query.getOrDefault("AccountWithRestoreAccess")
  valid_605314 = validateParameter(valid_605314, JString, required = true,
                                 default = nil)
  if valid_605314 != nil:
    section.add "AccountWithRestoreAccess", valid_605314
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605315 = header.getOrDefault("X-Amz-Signature")
  valid_605315 = validateParameter(valid_605315, JString, required = false,
                                 default = nil)
  if valid_605315 != nil:
    section.add "X-Amz-Signature", valid_605315
  var valid_605316 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605316 = validateParameter(valid_605316, JString, required = false,
                                 default = nil)
  if valid_605316 != nil:
    section.add "X-Amz-Content-Sha256", valid_605316
  var valid_605317 = header.getOrDefault("X-Amz-Date")
  valid_605317 = validateParameter(valid_605317, JString, required = false,
                                 default = nil)
  if valid_605317 != nil:
    section.add "X-Amz-Date", valid_605317
  var valid_605318 = header.getOrDefault("X-Amz-Credential")
  valid_605318 = validateParameter(valid_605318, JString, required = false,
                                 default = nil)
  if valid_605318 != nil:
    section.add "X-Amz-Credential", valid_605318
  var valid_605319 = header.getOrDefault("X-Amz-Security-Token")
  valid_605319 = validateParameter(valid_605319, JString, required = false,
                                 default = nil)
  if valid_605319 != nil:
    section.add "X-Amz-Security-Token", valid_605319
  var valid_605320 = header.getOrDefault("X-Amz-Algorithm")
  valid_605320 = validateParameter(valid_605320, JString, required = false,
                                 default = nil)
  if valid_605320 != nil:
    section.add "X-Amz-Algorithm", valid_605320
  var valid_605321 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605321 = validateParameter(valid_605321, JString, required = false,
                                 default = nil)
  if valid_605321 != nil:
    section.add "X-Amz-SignedHeaders", valid_605321
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605322: Call_GetRevokeSnapshotAccess_605307; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_605322.validator(path, query, header, formData, body)
  let scheme = call_605322.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605322.url(scheme.get, call_605322.host, call_605322.base,
                         call_605322.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605322, url, valid)

proc call*(call_605323: Call_GetRevokeSnapshotAccess_605307;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "RevokeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## getRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  var query_605324 = newJObject()
  add(query_605324, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_605324, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_605324, "Action", newJString(Action))
  add(query_605324, "Version", newJString(Version))
  add(query_605324, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  result = call_605323.call(nil, query_605324, nil, nil, nil)

var getRevokeSnapshotAccess* = Call_GetRevokeSnapshotAccess_605307(
    name: "getRevokeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_GetRevokeSnapshotAccess_605308, base: "/",
    url: url_GetRevokeSnapshotAccess_605309, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRotateEncryptionKey_605360 = ref object of OpenApiRestCall_601373
proc url_PostRotateEncryptionKey_605362(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRotateEncryptionKey_605361(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605363 = query.getOrDefault("Action")
  valid_605363 = validateParameter(valid_605363, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_605363 != nil:
    section.add "Action", valid_605363
  var valid_605364 = query.getOrDefault("Version")
  valid_605364 = validateParameter(valid_605364, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605364 != nil:
    section.add "Version", valid_605364
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605365 = header.getOrDefault("X-Amz-Signature")
  valid_605365 = validateParameter(valid_605365, JString, required = false,
                                 default = nil)
  if valid_605365 != nil:
    section.add "X-Amz-Signature", valid_605365
  var valid_605366 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605366 = validateParameter(valid_605366, JString, required = false,
                                 default = nil)
  if valid_605366 != nil:
    section.add "X-Amz-Content-Sha256", valid_605366
  var valid_605367 = header.getOrDefault("X-Amz-Date")
  valid_605367 = validateParameter(valid_605367, JString, required = false,
                                 default = nil)
  if valid_605367 != nil:
    section.add "X-Amz-Date", valid_605367
  var valid_605368 = header.getOrDefault("X-Amz-Credential")
  valid_605368 = validateParameter(valid_605368, JString, required = false,
                                 default = nil)
  if valid_605368 != nil:
    section.add "X-Amz-Credential", valid_605368
  var valid_605369 = header.getOrDefault("X-Amz-Security-Token")
  valid_605369 = validateParameter(valid_605369, JString, required = false,
                                 default = nil)
  if valid_605369 != nil:
    section.add "X-Amz-Security-Token", valid_605369
  var valid_605370 = header.getOrDefault("X-Amz-Algorithm")
  valid_605370 = validateParameter(valid_605370, JString, required = false,
                                 default = nil)
  if valid_605370 != nil:
    section.add "X-Amz-Algorithm", valid_605370
  var valid_605371 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605371 = validateParameter(valid_605371, JString, required = false,
                                 default = nil)
  if valid_605371 != nil:
    section.add "X-Amz-SignedHeaders", valid_605371
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_605372 = formData.getOrDefault("ClusterIdentifier")
  valid_605372 = validateParameter(valid_605372, JString, required = true,
                                 default = nil)
  if valid_605372 != nil:
    section.add "ClusterIdentifier", valid_605372
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605373: Call_PostRotateEncryptionKey_605360; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_605373.validator(path, query, header, formData, body)
  let scheme = call_605373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605373.url(scheme.get, call_605373.host, call_605373.base,
                         call_605373.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605373, url, valid)

proc call*(call_605374: Call_PostRotateEncryptionKey_605360;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## postRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_605375 = newJObject()
  var formData_605376 = newJObject()
  add(formData_605376, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605375, "Action", newJString(Action))
  add(query_605375, "Version", newJString(Version))
  result = call_605374.call(nil, query_605375, nil, formData_605376, nil)

var postRotateEncryptionKey* = Call_PostRotateEncryptionKey_605360(
    name: "postRotateEncryptionKey", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_PostRotateEncryptionKey_605361, base: "/",
    url: url_PostRotateEncryptionKey_605362, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRotateEncryptionKey_605344 = ref object of OpenApiRestCall_601373
proc url_GetRotateEncryptionKey_605346(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and
      route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRotateEncryptionKey_605345(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_605347 = query.getOrDefault("Action")
  valid_605347 = validateParameter(valid_605347, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_605347 != nil:
    section.add "Action", valid_605347
  var valid_605348 = query.getOrDefault("ClusterIdentifier")
  valid_605348 = validateParameter(valid_605348, JString, required = true,
                                 default = nil)
  if valid_605348 != nil:
    section.add "ClusterIdentifier", valid_605348
  var valid_605349 = query.getOrDefault("Version")
  valid_605349 = validateParameter(valid_605349, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_605349 != nil:
    section.add "Version", valid_605349
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_605350 = header.getOrDefault("X-Amz-Signature")
  valid_605350 = validateParameter(valid_605350, JString, required = false,
                                 default = nil)
  if valid_605350 != nil:
    section.add "X-Amz-Signature", valid_605350
  var valid_605351 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_605351 = validateParameter(valid_605351, JString, required = false,
                                 default = nil)
  if valid_605351 != nil:
    section.add "X-Amz-Content-Sha256", valid_605351
  var valid_605352 = header.getOrDefault("X-Amz-Date")
  valid_605352 = validateParameter(valid_605352, JString, required = false,
                                 default = nil)
  if valid_605352 != nil:
    section.add "X-Amz-Date", valid_605352
  var valid_605353 = header.getOrDefault("X-Amz-Credential")
  valid_605353 = validateParameter(valid_605353, JString, required = false,
                                 default = nil)
  if valid_605353 != nil:
    section.add "X-Amz-Credential", valid_605353
  var valid_605354 = header.getOrDefault("X-Amz-Security-Token")
  valid_605354 = validateParameter(valid_605354, JString, required = false,
                                 default = nil)
  if valid_605354 != nil:
    section.add "X-Amz-Security-Token", valid_605354
  var valid_605355 = header.getOrDefault("X-Amz-Algorithm")
  valid_605355 = validateParameter(valid_605355, JString, required = false,
                                 default = nil)
  if valid_605355 != nil:
    section.add "X-Amz-Algorithm", valid_605355
  var valid_605356 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_605356 = validateParameter(valid_605356, JString, required = false,
                                 default = nil)
  if valid_605356 != nil:
    section.add "X-Amz-SignedHeaders", valid_605356
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_605357: Call_GetRotateEncryptionKey_605344; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_605357.validator(path, query, header, formData, body)
  let scheme = call_605357.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_605357.url(scheme.get, call_605357.host, call_605357.base,
                         call_605357.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_605357, url, valid)

proc call*(call_605358: Call_GetRotateEncryptionKey_605344;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## getRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_605359 = newJObject()
  add(query_605359, "Action", newJString(Action))
  add(query_605359, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_605359, "Version", newJString(Version))
  result = call_605358.call(nil, query_605359, nil, nil, nil)

var getRotateEncryptionKey* = Call_GetRotateEncryptionKey_605344(
    name: "getRotateEncryptionKey", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_GetRotateEncryptionKey_605345, base: "/",
    url: url_GetRotateEncryptionKey_605346, schemes: {Scheme.Https, Scheme.Http})
export
  rest

proc atozSign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", "")
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", "")
    region = os.getEnv("AWS_REGION", "")
  assert secret != "", "need secret key in env"
  assert access != "", "need access key in env"
  assert region != "", "need region in env"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
  result.atozSign(input.getOrDefault("query"), SHA256)
