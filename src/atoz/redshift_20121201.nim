
import
  json, options, hashes, uri, strutils, tables, rest, os, uri, strutils, md5, httpcore,
  sigv4

## auto-generated via openapi macro
## title: Amazon Redshift
## version: 2012-12-01
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>Amazon Redshift</fullname> <p> <b>Overview</b> </p> <p>This is an interface reference for Amazon Redshift. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Redshift clusters. Note that Amazon Redshift is asynchronous, which means that some interfaces may require techniques, such as polling or asynchronous callback handlers, to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a change is applied immediately, on the next instance reboot, or during the next maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the Amazon Redshift Management Interfaces</a>.</p> <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data warehouse: provisioning capacity, monitoring and backing up the cluster, and applying patches and upgrades to the Amazon Redshift engine. You can focus on using your data to acquire new insights for your business and customers.</p> <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p> <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design, build, query, and maintain the databases that make up your data warehouse. </p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/redshift/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (path: JsonNode = nil; query: JsonNode = nil;
                          header: JsonNode = nil; formData: JsonNode = nil;
                          body: JsonNode = nil; _: string = ""): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_616850 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_616850](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_616850): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low .. Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js == nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result == nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind == kind, $kind & " expected; received " & $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com", "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
                           "us-west-2": "redshift.us-west-2.amazonaws.com",
                           "eu-west-2": "redshift.eu-west-2.amazonaws.com", "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com", "eu-central-1": "redshift.eu-central-1.amazonaws.com",
                           "us-east-2": "redshift.us-east-2.amazonaws.com",
                           "us-east-1": "redshift.us-east-1.amazonaws.com", "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn", "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
                           "ap-south-1": "redshift.ap-south-1.amazonaws.com",
                           "eu-north-1": "redshift.eu-north-1.amazonaws.com",
                           "us-west-1": "redshift.us-west-1.amazonaws.com", "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "redshift.eu-west-3.amazonaws.com", "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "redshift.sa-east-1.amazonaws.com",
                           "eu-west-1": "redshift.eu-west-1.amazonaws.com", "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com", "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com", "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
      "us-west-2": "redshift.us-west-2.amazonaws.com",
      "eu-west-2": "redshift.eu-west-2.amazonaws.com",
      "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com",
      "eu-central-1": "redshift.eu-central-1.amazonaws.com",
      "us-east-2": "redshift.us-east-2.amazonaws.com",
      "us-east-1": "redshift.us-east-1.amazonaws.com",
      "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
      "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
      "ap-south-1": "redshift.ap-south-1.amazonaws.com",
      "eu-north-1": "redshift.eu-north-1.amazonaws.com",
      "us-west-1": "redshift.us-west-1.amazonaws.com",
      "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
      "eu-west-3": "redshift.eu-west-3.amazonaws.com",
      "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "redshift.sa-east-1.amazonaws.com",
      "eu-west-1": "redshift.eu-west-1.amazonaws.com",
      "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com",
      "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "redshift"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode; body: string = ""): Recallable {.
    base.}
type
  Call_PostAcceptReservedNodeExchange_617464 = ref object of OpenApiRestCall_616850
proc url_PostAcceptReservedNodeExchange_617466(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAcceptReservedNodeExchange_617465(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617467 = query.getOrDefault("Action")
  valid_617467 = validateParameter(valid_617467, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_617467 != nil:
    section.add "Action", valid_617467
  var valid_617468 = query.getOrDefault("Version")
  valid_617468 = validateParameter(valid_617468, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617468 != nil:
    section.add "Version", valid_617468
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617469 = header.getOrDefault("X-Amz-Date")
  valid_617469 = validateParameter(valid_617469, JString, required = false,
                                 default = nil)
  if valid_617469 != nil:
    section.add "X-Amz-Date", valid_617469
  var valid_617470 = header.getOrDefault("X-Amz-Security-Token")
  valid_617470 = validateParameter(valid_617470, JString, required = false,
                                 default = nil)
  if valid_617470 != nil:
    section.add "X-Amz-Security-Token", valid_617470
  var valid_617471 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617471 = validateParameter(valid_617471, JString, required = false,
                                 default = nil)
  if valid_617471 != nil:
    section.add "X-Amz-Content-Sha256", valid_617471
  var valid_617472 = header.getOrDefault("X-Amz-Algorithm")
  valid_617472 = validateParameter(valid_617472, JString, required = false,
                                 default = nil)
  if valid_617472 != nil:
    section.add "X-Amz-Algorithm", valid_617472
  var valid_617473 = header.getOrDefault("X-Amz-Signature")
  valid_617473 = validateParameter(valid_617473, JString, required = false,
                                 default = nil)
  if valid_617473 != nil:
    section.add "X-Amz-Signature", valid_617473
  var valid_617474 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617474 = validateParameter(valid_617474, JString, required = false,
                                 default = nil)
  if valid_617474 != nil:
    section.add "X-Amz-SignedHeaders", valid_617474
  var valid_617475 = header.getOrDefault("X-Amz-Credential")
  valid_617475 = validateParameter(valid_617475, JString, required = false,
                                 default = nil)
  if valid_617475 != nil:
    section.add "X-Amz-Credential", valid_617475
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_617476 = formData.getOrDefault("ReservedNodeId")
  valid_617476 = validateParameter(valid_617476, JString, required = true,
                                 default = nil)
  if valid_617476 != nil:
    section.add "ReservedNodeId", valid_617476
  var valid_617477 = formData.getOrDefault("TargetReservedNodeOfferingId")
  valid_617477 = validateParameter(valid_617477, JString, required = true,
                                 default = nil)
  if valid_617477 != nil:
    section.add "TargetReservedNodeOfferingId", valid_617477
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617478: Call_PostAcceptReservedNodeExchange_617464;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_617478.validator(path, query, header, formData, body, _)
  let scheme = call_617478.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617478.url(scheme.get, call_617478.host, call_617478.base,
                         call_617478.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617478, url, valid, _)

proc call*(call_617479: Call_PostAcceptReservedNodeExchange_617464;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## postAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_617480 = newJObject()
  var formData_617481 = newJObject()
  add(formData_617481, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_617481, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_617480, "Action", newJString(Action))
  add(query_617480, "Version", newJString(Version))
  result = call_617479.call(nil, query_617480, nil, formData_617481, nil)

var postAcceptReservedNodeExchange* = Call_PostAcceptReservedNodeExchange_617464(
    name: "postAcceptReservedNodeExchange", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_PostAcceptReservedNodeExchange_617465, base: "/",
    url: url_PostAcceptReservedNodeExchange_617466,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAcceptReservedNodeExchange_617189 = ref object of OpenApiRestCall_616850
proc url_GetAcceptReservedNodeExchange_617191(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAcceptReservedNodeExchange_617190(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Version: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  section = newJObject()
  var valid_617316 = query.getOrDefault("Action")
  valid_617316 = validateParameter(valid_617316, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_617316 != nil:
    section.add "Action", valid_617316
  var valid_617317 = query.getOrDefault("TargetReservedNodeOfferingId")
  valid_617317 = validateParameter(valid_617317, JString, required = true,
                                 default = nil)
  if valid_617317 != nil:
    section.add "TargetReservedNodeOfferingId", valid_617317
  var valid_617318 = query.getOrDefault("Version")
  valid_617318 = validateParameter(valid_617318, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617318 != nil:
    section.add "Version", valid_617318
  var valid_617319 = query.getOrDefault("ReservedNodeId")
  valid_617319 = validateParameter(valid_617319, JString, required = true,
                                 default = nil)
  if valid_617319 != nil:
    section.add "ReservedNodeId", valid_617319
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617320 = header.getOrDefault("X-Amz-Date")
  valid_617320 = validateParameter(valid_617320, JString, required = false,
                                 default = nil)
  if valid_617320 != nil:
    section.add "X-Amz-Date", valid_617320
  var valid_617321 = header.getOrDefault("X-Amz-Security-Token")
  valid_617321 = validateParameter(valid_617321, JString, required = false,
                                 default = nil)
  if valid_617321 != nil:
    section.add "X-Amz-Security-Token", valid_617321
  var valid_617322 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617322 = validateParameter(valid_617322, JString, required = false,
                                 default = nil)
  if valid_617322 != nil:
    section.add "X-Amz-Content-Sha256", valid_617322
  var valid_617323 = header.getOrDefault("X-Amz-Algorithm")
  valid_617323 = validateParameter(valid_617323, JString, required = false,
                                 default = nil)
  if valid_617323 != nil:
    section.add "X-Amz-Algorithm", valid_617323
  var valid_617324 = header.getOrDefault("X-Amz-Signature")
  valid_617324 = validateParameter(valid_617324, JString, required = false,
                                 default = nil)
  if valid_617324 != nil:
    section.add "X-Amz-Signature", valid_617324
  var valid_617325 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617325 = validateParameter(valid_617325, JString, required = false,
                                 default = nil)
  if valid_617325 != nil:
    section.add "X-Amz-SignedHeaders", valid_617325
  var valid_617326 = header.getOrDefault("X-Amz-Credential")
  valid_617326 = validateParameter(valid_617326, JString, required = false,
                                 default = nil)
  if valid_617326 != nil:
    section.add "X-Amz-Credential", valid_617326
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617350: Call_GetAcceptReservedNodeExchange_617189;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_617350.validator(path, query, header, formData, body, _)
  let scheme = call_617350.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617350.url(scheme.get, call_617350.host, call_617350.base,
                         call_617350.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617350, url, valid, _)

proc call*(call_617421: Call_GetAcceptReservedNodeExchange_617189;
          TargetReservedNodeOfferingId: string; ReservedNodeId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## getAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   Action: string (required)
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Version: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  var query_617422 = newJObject()
  add(query_617422, "Action", newJString(Action))
  add(query_617422, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_617422, "Version", newJString(Version))
  add(query_617422, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_617421.call(nil, query_617422, nil, nil, nil)

var getAcceptReservedNodeExchange* = Call_GetAcceptReservedNodeExchange_617189(
    name: "getAcceptReservedNodeExchange", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_GetAcceptReservedNodeExchange_617190, base: "/",
    url: url_GetAcceptReservedNodeExchange_617191,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeClusterSecurityGroupIngress_617501 = ref object of OpenApiRestCall_616850
proc url_PostAuthorizeClusterSecurityGroupIngress_617503(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeClusterSecurityGroupIngress_617502(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617504 = query.getOrDefault("Action")
  valid_617504 = validateParameter(valid_617504, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_617504 != nil:
    section.add "Action", valid_617504
  var valid_617505 = query.getOrDefault("Version")
  valid_617505 = validateParameter(valid_617505, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617505 != nil:
    section.add "Version", valid_617505
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617506 = header.getOrDefault("X-Amz-Date")
  valid_617506 = validateParameter(valid_617506, JString, required = false,
                                 default = nil)
  if valid_617506 != nil:
    section.add "X-Amz-Date", valid_617506
  var valid_617507 = header.getOrDefault("X-Amz-Security-Token")
  valid_617507 = validateParameter(valid_617507, JString, required = false,
                                 default = nil)
  if valid_617507 != nil:
    section.add "X-Amz-Security-Token", valid_617507
  var valid_617508 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617508 = validateParameter(valid_617508, JString, required = false,
                                 default = nil)
  if valid_617508 != nil:
    section.add "X-Amz-Content-Sha256", valid_617508
  var valid_617509 = header.getOrDefault("X-Amz-Algorithm")
  valid_617509 = validateParameter(valid_617509, JString, required = false,
                                 default = nil)
  if valid_617509 != nil:
    section.add "X-Amz-Algorithm", valid_617509
  var valid_617510 = header.getOrDefault("X-Amz-Signature")
  valid_617510 = validateParameter(valid_617510, JString, required = false,
                                 default = nil)
  if valid_617510 != nil:
    section.add "X-Amz-Signature", valid_617510
  var valid_617511 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617511 = validateParameter(valid_617511, JString, required = false,
                                 default = nil)
  if valid_617511 != nil:
    section.add "X-Amz-SignedHeaders", valid_617511
  var valid_617512 = header.getOrDefault("X-Amz-Credential")
  valid_617512 = validateParameter(valid_617512, JString, required = false,
                                 default = nil)
  if valid_617512 != nil:
    section.add "X-Amz-Credential", valid_617512
  result.add "header", section
  ## parameters in `formData` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  section = newJObject()
  var valid_617513 = formData.getOrDefault("EC2SecurityGroupName")
  valid_617513 = validateParameter(valid_617513, JString, required = false,
                                 default = nil)
  if valid_617513 != nil:
    section.add "EC2SecurityGroupName", valid_617513
  var valid_617514 = formData.getOrDefault("CIDRIP")
  valid_617514 = validateParameter(valid_617514, JString, required = false,
                                 default = nil)
  if valid_617514 != nil:
    section.add "CIDRIP", valid_617514
  var valid_617515 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_617515 = validateParameter(valid_617515, JString, required = false,
                                 default = nil)
  if valid_617515 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_617515
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_617516 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_617516 = validateParameter(valid_617516, JString, required = true,
                                 default = nil)
  if valid_617516 != nil:
    section.add "ClusterSecurityGroupName", valid_617516
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617517: Call_PostAuthorizeClusterSecurityGroupIngress_617501;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617517.validator(path, query, header, formData, body, _)
  let scheme = call_617517.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617517.url(scheme.get, call_617517.host, call_617517.base,
                         call_617517.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617517, url, valid, _)

proc call*(call_617518: Call_PostAuthorizeClusterSecurityGroupIngress_617501;
          ClusterSecurityGroupName: string;
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          EC2SecurityGroupName: string = ""; CIDRIP: string = "";
          Version: string = "2012-12-01"; EC2SecurityGroupOwnerId: string = ""): Recallable =
  ## postAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   Version: string (required)
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  var query_617519 = newJObject()
  var formData_617520 = newJObject()
  add(query_617519, "Action", newJString(Action))
  add(formData_617520, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_617520, "CIDRIP", newJString(CIDRIP))
  add(query_617519, "Version", newJString(Version))
  add(formData_617520, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_617520, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_617518.call(nil, query_617519, nil, formData_617520, nil)

var postAuthorizeClusterSecurityGroupIngress* = Call_PostAuthorizeClusterSecurityGroupIngress_617501(
    name: "postAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_PostAuthorizeClusterSecurityGroupIngress_617502,
    base: "/", url: url_PostAuthorizeClusterSecurityGroupIngress_617503,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeClusterSecurityGroupIngress_617482 = ref object of OpenApiRestCall_616850
proc url_GetAuthorizeClusterSecurityGroupIngress_617484(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeClusterSecurityGroupIngress_617483(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_617485 = query.getOrDefault("ClusterSecurityGroupName")
  valid_617485 = validateParameter(valid_617485, JString, required = true,
                                 default = nil)
  if valid_617485 != nil:
    section.add "ClusterSecurityGroupName", valid_617485
  var valid_617486 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_617486 = validateParameter(valid_617486, JString, required = false,
                                 default = nil)
  if valid_617486 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_617486
  var valid_617487 = query.getOrDefault("Action")
  valid_617487 = validateParameter(valid_617487, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_617487 != nil:
    section.add "Action", valid_617487
  var valid_617488 = query.getOrDefault("CIDRIP")
  valid_617488 = validateParameter(valid_617488, JString, required = false,
                                 default = nil)
  if valid_617488 != nil:
    section.add "CIDRIP", valid_617488
  var valid_617489 = query.getOrDefault("EC2SecurityGroupName")
  valid_617489 = validateParameter(valid_617489, JString, required = false,
                                 default = nil)
  if valid_617489 != nil:
    section.add "EC2SecurityGroupName", valid_617489
  var valid_617490 = query.getOrDefault("Version")
  valid_617490 = validateParameter(valid_617490, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617490 != nil:
    section.add "Version", valid_617490
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617491 = header.getOrDefault("X-Amz-Date")
  valid_617491 = validateParameter(valid_617491, JString, required = false,
                                 default = nil)
  if valid_617491 != nil:
    section.add "X-Amz-Date", valid_617491
  var valid_617492 = header.getOrDefault("X-Amz-Security-Token")
  valid_617492 = validateParameter(valid_617492, JString, required = false,
                                 default = nil)
  if valid_617492 != nil:
    section.add "X-Amz-Security-Token", valid_617492
  var valid_617493 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617493 = validateParameter(valid_617493, JString, required = false,
                                 default = nil)
  if valid_617493 != nil:
    section.add "X-Amz-Content-Sha256", valid_617493
  var valid_617494 = header.getOrDefault("X-Amz-Algorithm")
  valid_617494 = validateParameter(valid_617494, JString, required = false,
                                 default = nil)
  if valid_617494 != nil:
    section.add "X-Amz-Algorithm", valid_617494
  var valid_617495 = header.getOrDefault("X-Amz-Signature")
  valid_617495 = validateParameter(valid_617495, JString, required = false,
                                 default = nil)
  if valid_617495 != nil:
    section.add "X-Amz-Signature", valid_617495
  var valid_617496 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617496 = validateParameter(valid_617496, JString, required = false,
                                 default = nil)
  if valid_617496 != nil:
    section.add "X-Amz-SignedHeaders", valid_617496
  var valid_617497 = header.getOrDefault("X-Amz-Credential")
  valid_617497 = validateParameter(valid_617497, JString, required = false,
                                 default = nil)
  if valid_617497 != nil:
    section.add "X-Amz-Credential", valid_617497
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617498: Call_GetAuthorizeClusterSecurityGroupIngress_617482;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617498.validator(path, query, header, formData, body, _)
  let scheme = call_617498.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617498.url(scheme.get, call_617498.host, call_617498.base,
                         call_617498.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617498, url, valid, _)

proc call*(call_617499: Call_GetAuthorizeClusterSecurityGroupIngress_617482;
          ClusterSecurityGroupName: string; EC2SecurityGroupOwnerId: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          CIDRIP: string = ""; EC2SecurityGroupName: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: string (required)
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   Version: string (required)
  var query_617500 = newJObject()
  add(query_617500, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_617500, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_617500, "Action", newJString(Action))
  add(query_617500, "CIDRIP", newJString(CIDRIP))
  add(query_617500, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_617500, "Version", newJString(Version))
  result = call_617499.call(nil, query_617500, nil, nil, nil)

var getAuthorizeClusterSecurityGroupIngress* = Call_GetAuthorizeClusterSecurityGroupIngress_617482(
    name: "getAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_GetAuthorizeClusterSecurityGroupIngress_617483, base: "/",
    url: url_GetAuthorizeClusterSecurityGroupIngress_617484,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeSnapshotAccess_617539 = ref object of OpenApiRestCall_616850
proc url_PostAuthorizeSnapshotAccess_617541(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeSnapshotAccess_617540(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617542 = query.getOrDefault("Action")
  valid_617542 = validateParameter(valid_617542, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_617542 != nil:
    section.add "Action", valid_617542
  var valid_617543 = query.getOrDefault("Version")
  valid_617543 = validateParameter(valid_617543, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617543 != nil:
    section.add "Version", valid_617543
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617544 = header.getOrDefault("X-Amz-Date")
  valid_617544 = validateParameter(valid_617544, JString, required = false,
                                 default = nil)
  if valid_617544 != nil:
    section.add "X-Amz-Date", valid_617544
  var valid_617545 = header.getOrDefault("X-Amz-Security-Token")
  valid_617545 = validateParameter(valid_617545, JString, required = false,
                                 default = nil)
  if valid_617545 != nil:
    section.add "X-Amz-Security-Token", valid_617545
  var valid_617546 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617546 = validateParameter(valid_617546, JString, required = false,
                                 default = nil)
  if valid_617546 != nil:
    section.add "X-Amz-Content-Sha256", valid_617546
  var valid_617547 = header.getOrDefault("X-Amz-Algorithm")
  valid_617547 = validateParameter(valid_617547, JString, required = false,
                                 default = nil)
  if valid_617547 != nil:
    section.add "X-Amz-Algorithm", valid_617547
  var valid_617548 = header.getOrDefault("X-Amz-Signature")
  valid_617548 = validateParameter(valid_617548, JString, required = false,
                                 default = nil)
  if valid_617548 != nil:
    section.add "X-Amz-Signature", valid_617548
  var valid_617549 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617549 = validateParameter(valid_617549, JString, required = false,
                                 default = nil)
  if valid_617549 != nil:
    section.add "X-Amz-SignedHeaders", valid_617549
  var valid_617550 = header.getOrDefault("X-Amz-Credential")
  valid_617550 = validateParameter(valid_617550, JString, required = false,
                                 default = nil)
  if valid_617550 != nil:
    section.add "X-Amz-Credential", valid_617550
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  section = newJObject()
  var valid_617551 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_617551 = validateParameter(valid_617551, JString, required = false,
                                 default = nil)
  if valid_617551 != nil:
    section.add "SnapshotClusterIdentifier", valid_617551
  assert formData != nil, "formData argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_617552 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_617552 = validateParameter(valid_617552, JString, required = true,
                                 default = nil)
  if valid_617552 != nil:
    section.add "AccountWithRestoreAccess", valid_617552
  var valid_617553 = formData.getOrDefault("SnapshotIdentifier")
  valid_617553 = validateParameter(valid_617553, JString, required = true,
                                 default = nil)
  if valid_617553 != nil:
    section.add "SnapshotIdentifier", valid_617553
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617554: Call_PostAuthorizeSnapshotAccess_617539;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617554.validator(path, query, header, formData, body, _)
  let scheme = call_617554.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617554.url(scheme.get, call_617554.host, call_617554.base,
                         call_617554.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617554, url, valid, _)

proc call*(call_617555: Call_PostAuthorizeSnapshotAccess_617539;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "AuthorizeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: string (required)
  var query_617556 = newJObject()
  var formData_617557 = newJObject()
  add(formData_617557, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(formData_617557, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_617556, "Action", newJString(Action))
  add(formData_617557, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_617556, "Version", newJString(Version))
  result = call_617555.call(nil, query_617556, nil, formData_617557, nil)

var postAuthorizeSnapshotAccess* = Call_PostAuthorizeSnapshotAccess_617539(
    name: "postAuthorizeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_PostAuthorizeSnapshotAccess_617540, base: "/",
    url: url_PostAuthorizeSnapshotAccess_617541,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeSnapshotAccess_617521 = ref object of OpenApiRestCall_616850
proc url_GetAuthorizeSnapshotAccess_617523(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeSnapshotAccess_617522(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_617524 = query.getOrDefault("AccountWithRestoreAccess")
  valid_617524 = validateParameter(valid_617524, JString, required = true,
                                 default = nil)
  if valid_617524 != nil:
    section.add "AccountWithRestoreAccess", valid_617524
  var valid_617525 = query.getOrDefault("Action")
  valid_617525 = validateParameter(valid_617525, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_617525 != nil:
    section.add "Action", valid_617525
  var valid_617526 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_617526 = validateParameter(valid_617526, JString, required = false,
                                 default = nil)
  if valid_617526 != nil:
    section.add "SnapshotClusterIdentifier", valid_617526
  var valid_617527 = query.getOrDefault("SnapshotIdentifier")
  valid_617527 = validateParameter(valid_617527, JString, required = true,
                                 default = nil)
  if valid_617527 != nil:
    section.add "SnapshotIdentifier", valid_617527
  var valid_617528 = query.getOrDefault("Version")
  valid_617528 = validateParameter(valid_617528, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617528 != nil:
    section.add "Version", valid_617528
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617529 = header.getOrDefault("X-Amz-Date")
  valid_617529 = validateParameter(valid_617529, JString, required = false,
                                 default = nil)
  if valid_617529 != nil:
    section.add "X-Amz-Date", valid_617529
  var valid_617530 = header.getOrDefault("X-Amz-Security-Token")
  valid_617530 = validateParameter(valid_617530, JString, required = false,
                                 default = nil)
  if valid_617530 != nil:
    section.add "X-Amz-Security-Token", valid_617530
  var valid_617531 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617531 = validateParameter(valid_617531, JString, required = false,
                                 default = nil)
  if valid_617531 != nil:
    section.add "X-Amz-Content-Sha256", valid_617531
  var valid_617532 = header.getOrDefault("X-Amz-Algorithm")
  valid_617532 = validateParameter(valid_617532, JString, required = false,
                                 default = nil)
  if valid_617532 != nil:
    section.add "X-Amz-Algorithm", valid_617532
  var valid_617533 = header.getOrDefault("X-Amz-Signature")
  valid_617533 = validateParameter(valid_617533, JString, required = false,
                                 default = nil)
  if valid_617533 != nil:
    section.add "X-Amz-Signature", valid_617533
  var valid_617534 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617534 = validateParameter(valid_617534, JString, required = false,
                                 default = nil)
  if valid_617534 != nil:
    section.add "X-Amz-SignedHeaders", valid_617534
  var valid_617535 = header.getOrDefault("X-Amz-Credential")
  valid_617535 = validateParameter(valid_617535, JString, required = false,
                                 default = nil)
  if valid_617535 != nil:
    section.add "X-Amz-Credential", valid_617535
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617536: Call_GetAuthorizeSnapshotAccess_617521;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617536.validator(path, query, header, formData, body, _)
  let scheme = call_617536.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617536.url(scheme.get, call_617536.host, call_617536.base,
                         call_617536.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617536, url, valid, _)

proc call*(call_617537: Call_GetAuthorizeSnapshotAccess_617521;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          Action: string = "AuthorizeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: string (required)
  var query_617538 = newJObject()
  add(query_617538, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_617538, "Action", newJString(Action))
  add(query_617538, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_617538, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_617538, "Version", newJString(Version))
  result = call_617537.call(nil, query_617538, nil, nil, nil)

var getAuthorizeSnapshotAccess* = Call_GetAuthorizeSnapshotAccess_617521(
    name: "getAuthorizeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_GetAuthorizeSnapshotAccess_617522, base: "/",
    url: url_GetAuthorizeSnapshotAccess_617523,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchDeleteClusterSnapshots_617574 = ref object of OpenApiRestCall_616850
proc url_PostBatchDeleteClusterSnapshots_617576(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchDeleteClusterSnapshots_617575(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617577 = query.getOrDefault("Action")
  valid_617577 = validateParameter(valid_617577, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_617577 != nil:
    section.add "Action", valid_617577
  var valid_617578 = query.getOrDefault("Version")
  valid_617578 = validateParameter(valid_617578, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617578 != nil:
    section.add "Version", valid_617578
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617579 = header.getOrDefault("X-Amz-Date")
  valid_617579 = validateParameter(valid_617579, JString, required = false,
                                 default = nil)
  if valid_617579 != nil:
    section.add "X-Amz-Date", valid_617579
  var valid_617580 = header.getOrDefault("X-Amz-Security-Token")
  valid_617580 = validateParameter(valid_617580, JString, required = false,
                                 default = nil)
  if valid_617580 != nil:
    section.add "X-Amz-Security-Token", valid_617580
  var valid_617581 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617581 = validateParameter(valid_617581, JString, required = false,
                                 default = nil)
  if valid_617581 != nil:
    section.add "X-Amz-Content-Sha256", valid_617581
  var valid_617582 = header.getOrDefault("X-Amz-Algorithm")
  valid_617582 = validateParameter(valid_617582, JString, required = false,
                                 default = nil)
  if valid_617582 != nil:
    section.add "X-Amz-Algorithm", valid_617582
  var valid_617583 = header.getOrDefault("X-Amz-Signature")
  valid_617583 = validateParameter(valid_617583, JString, required = false,
                                 default = nil)
  if valid_617583 != nil:
    section.add "X-Amz-Signature", valid_617583
  var valid_617584 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617584 = validateParameter(valid_617584, JString, required = false,
                                 default = nil)
  if valid_617584 != nil:
    section.add "X-Amz-SignedHeaders", valid_617584
  var valid_617585 = header.getOrDefault("X-Amz-Credential")
  valid_617585 = validateParameter(valid_617585, JString, required = false,
                                 default = nil)
  if valid_617585 != nil:
    section.add "X-Amz-Credential", valid_617585
  result.add "header", section
  ## parameters in `formData` object:
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Identifiers` field"
  var valid_617586 = formData.getOrDefault("Identifiers")
  valid_617586 = validateParameter(valid_617586, JArray, required = true, default = nil)
  if valid_617586 != nil:
    section.add "Identifiers", valid_617586
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617587: Call_PostBatchDeleteClusterSnapshots_617574;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_617587.validator(path, query, header, formData, body, _)
  let scheme = call_617587.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617587.url(scheme.get, call_617587.host, call_617587.base,
                         call_617587.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617587, url, valid, _)

proc call*(call_617588: Call_PostBatchDeleteClusterSnapshots_617574;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## postBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_617589 = newJObject()
  var formData_617590 = newJObject()
  if Identifiers != nil:
    formData_617590.add "Identifiers", Identifiers
  add(query_617589, "Action", newJString(Action))
  add(query_617589, "Version", newJString(Version))
  result = call_617588.call(nil, query_617589, nil, formData_617590, nil)

var postBatchDeleteClusterSnapshots* = Call_PostBatchDeleteClusterSnapshots_617574(
    name: "postBatchDeleteClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_PostBatchDeleteClusterSnapshots_617575, base: "/",
    url: url_PostBatchDeleteClusterSnapshots_617576,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchDeleteClusterSnapshots_617558 = ref object of OpenApiRestCall_616850
proc url_GetBatchDeleteClusterSnapshots_617560(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchDeleteClusterSnapshots_617559(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  var valid_617561 = query.getOrDefault("Action")
  valid_617561 = validateParameter(valid_617561, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_617561 != nil:
    section.add "Action", valid_617561
  var valid_617562 = query.getOrDefault("Identifiers")
  valid_617562 = validateParameter(valid_617562, JArray, required = true, default = nil)
  if valid_617562 != nil:
    section.add "Identifiers", valid_617562
  var valid_617563 = query.getOrDefault("Version")
  valid_617563 = validateParameter(valid_617563, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617563 != nil:
    section.add "Version", valid_617563
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617564 = header.getOrDefault("X-Amz-Date")
  valid_617564 = validateParameter(valid_617564, JString, required = false,
                                 default = nil)
  if valid_617564 != nil:
    section.add "X-Amz-Date", valid_617564
  var valid_617565 = header.getOrDefault("X-Amz-Security-Token")
  valid_617565 = validateParameter(valid_617565, JString, required = false,
                                 default = nil)
  if valid_617565 != nil:
    section.add "X-Amz-Security-Token", valid_617565
  var valid_617566 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617566 = validateParameter(valid_617566, JString, required = false,
                                 default = nil)
  if valid_617566 != nil:
    section.add "X-Amz-Content-Sha256", valid_617566
  var valid_617567 = header.getOrDefault("X-Amz-Algorithm")
  valid_617567 = validateParameter(valid_617567, JString, required = false,
                                 default = nil)
  if valid_617567 != nil:
    section.add "X-Amz-Algorithm", valid_617567
  var valid_617568 = header.getOrDefault("X-Amz-Signature")
  valid_617568 = validateParameter(valid_617568, JString, required = false,
                                 default = nil)
  if valid_617568 != nil:
    section.add "X-Amz-Signature", valid_617568
  var valid_617569 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617569 = validateParameter(valid_617569, JString, required = false,
                                 default = nil)
  if valid_617569 != nil:
    section.add "X-Amz-SignedHeaders", valid_617569
  var valid_617570 = header.getOrDefault("X-Amz-Credential")
  valid_617570 = validateParameter(valid_617570, JString, required = false,
                                 default = nil)
  if valid_617570 != nil:
    section.add "X-Amz-Credential", valid_617570
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617571: Call_GetBatchDeleteClusterSnapshots_617558;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_617571.validator(path, query, header, formData, body, _)
  let scheme = call_617571.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617571.url(scheme.get, call_617571.host, call_617571.base,
                         call_617571.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617571, url, valid, _)

proc call*(call_617572: Call_GetBatchDeleteClusterSnapshots_617558;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Action: string (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: string (required)
  var query_617573 = newJObject()
  add(query_617573, "Action", newJString(Action))
  if Identifiers != nil:
    query_617573.add "Identifiers", Identifiers
  add(query_617573, "Version", newJString(Version))
  result = call_617572.call(nil, query_617573, nil, nil, nil)

var getBatchDeleteClusterSnapshots* = Call_GetBatchDeleteClusterSnapshots_617558(
    name: "getBatchDeleteClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_GetBatchDeleteClusterSnapshots_617559, base: "/",
    url: url_GetBatchDeleteClusterSnapshots_617560,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchModifyClusterSnapshots_617609 = ref object of OpenApiRestCall_616850
proc url_PostBatchModifyClusterSnapshots_617611(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchModifyClusterSnapshots_617610(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617612 = query.getOrDefault("Action")
  valid_617612 = validateParameter(valid_617612, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_617612 != nil:
    section.add "Action", valid_617612
  var valid_617613 = query.getOrDefault("Version")
  valid_617613 = validateParameter(valid_617613, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617613 != nil:
    section.add "Version", valid_617613
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617614 = header.getOrDefault("X-Amz-Date")
  valid_617614 = validateParameter(valid_617614, JString, required = false,
                                 default = nil)
  if valid_617614 != nil:
    section.add "X-Amz-Date", valid_617614
  var valid_617615 = header.getOrDefault("X-Amz-Security-Token")
  valid_617615 = validateParameter(valid_617615, JString, required = false,
                                 default = nil)
  if valid_617615 != nil:
    section.add "X-Amz-Security-Token", valid_617615
  var valid_617616 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617616 = validateParameter(valid_617616, JString, required = false,
                                 default = nil)
  if valid_617616 != nil:
    section.add "X-Amz-Content-Sha256", valid_617616
  var valid_617617 = header.getOrDefault("X-Amz-Algorithm")
  valid_617617 = validateParameter(valid_617617, JString, required = false,
                                 default = nil)
  if valid_617617 != nil:
    section.add "X-Amz-Algorithm", valid_617617
  var valid_617618 = header.getOrDefault("X-Amz-Signature")
  valid_617618 = validateParameter(valid_617618, JString, required = false,
                                 default = nil)
  if valid_617618 != nil:
    section.add "X-Amz-Signature", valid_617618
  var valid_617619 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617619 = validateParameter(valid_617619, JString, required = false,
                                 default = nil)
  if valid_617619 != nil:
    section.add "X-Amz-SignedHeaders", valid_617619
  var valid_617620 = header.getOrDefault("X-Amz-Credential")
  valid_617620 = validateParameter(valid_617620, JString, required = false,
                                 default = nil)
  if valid_617620 != nil:
    section.add "X-Amz-Credential", valid_617620
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_617621 = formData.getOrDefault("SnapshotIdentifierList")
  valid_617621 = validateParameter(valid_617621, JArray, required = true, default = nil)
  if valid_617621 != nil:
    section.add "SnapshotIdentifierList", valid_617621
  var valid_617622 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_617622 = validateParameter(valid_617622, JInt, required = false, default = nil)
  if valid_617622 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_617622
  var valid_617623 = formData.getOrDefault("Force")
  valid_617623 = validateParameter(valid_617623, JBool, required = false, default = nil)
  if valid_617623 != nil:
    section.add "Force", valid_617623
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617624: Call_PostBatchModifyClusterSnapshots_617609;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  let valid = call_617624.validator(path, query, header, formData, body, _)
  let scheme = call_617624.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617624.url(scheme.get, call_617624.host, call_617624.base,
                         call_617624.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617624, url, valid, _)

proc call*(call_617625: Call_PostBatchModifyClusterSnapshots_617609;
          SnapshotIdentifierList: JsonNode;
          Action: string = "BatchModifyClusterSnapshots";
          ManualSnapshotRetentionPeriod: int = 0; Force: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postBatchModifyClusterSnapshots
  ## Modifies the settings for a set of cluster snapshots.
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   Version: string (required)
  var query_617626 = newJObject()
  var formData_617627 = newJObject()
  if SnapshotIdentifierList != nil:
    formData_617627.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_617626, "Action", newJString(Action))
  add(formData_617627, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_617627, "Force", newJBool(Force))
  add(query_617626, "Version", newJString(Version))
  result = call_617625.call(nil, query_617626, nil, formData_617627, nil)

var postBatchModifyClusterSnapshots* = Call_PostBatchModifyClusterSnapshots_617609(
    name: "postBatchModifyClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_PostBatchModifyClusterSnapshots_617610, base: "/",
    url: url_PostBatchModifyClusterSnapshots_617611,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchModifyClusterSnapshots_617591 = ref object of OpenApiRestCall_616850
proc url_GetBatchModifyClusterSnapshots_617593(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchModifyClusterSnapshots_617592(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_617594 = query.getOrDefault("SnapshotIdentifierList")
  valid_617594 = validateParameter(valid_617594, JArray, required = true, default = nil)
  if valid_617594 != nil:
    section.add "SnapshotIdentifierList", valid_617594
  var valid_617595 = query.getOrDefault("Action")
  valid_617595 = validateParameter(valid_617595, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_617595 != nil:
    section.add "Action", valid_617595
  var valid_617596 = query.getOrDefault("Version")
  valid_617596 = validateParameter(valid_617596, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617596 != nil:
    section.add "Version", valid_617596
  var valid_617597 = query.getOrDefault("Force")
  valid_617597 = validateParameter(valid_617597, JBool, required = false, default = nil)
  if valid_617597 != nil:
    section.add "Force", valid_617597
  var valid_617598 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_617598 = validateParameter(valid_617598, JInt, required = false, default = nil)
  if valid_617598 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_617598
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617599 = header.getOrDefault("X-Amz-Date")
  valid_617599 = validateParameter(valid_617599, JString, required = false,
                                 default = nil)
  if valid_617599 != nil:
    section.add "X-Amz-Date", valid_617599
  var valid_617600 = header.getOrDefault("X-Amz-Security-Token")
  valid_617600 = validateParameter(valid_617600, JString, required = false,
                                 default = nil)
  if valid_617600 != nil:
    section.add "X-Amz-Security-Token", valid_617600
  var valid_617601 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617601 = validateParameter(valid_617601, JString, required = false,
                                 default = nil)
  if valid_617601 != nil:
    section.add "X-Amz-Content-Sha256", valid_617601
  var valid_617602 = header.getOrDefault("X-Amz-Algorithm")
  valid_617602 = validateParameter(valid_617602, JString, required = false,
                                 default = nil)
  if valid_617602 != nil:
    section.add "X-Amz-Algorithm", valid_617602
  var valid_617603 = header.getOrDefault("X-Amz-Signature")
  valid_617603 = validateParameter(valid_617603, JString, required = false,
                                 default = nil)
  if valid_617603 != nil:
    section.add "X-Amz-Signature", valid_617603
  var valid_617604 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617604 = validateParameter(valid_617604, JString, required = false,
                                 default = nil)
  if valid_617604 != nil:
    section.add "X-Amz-SignedHeaders", valid_617604
  var valid_617605 = header.getOrDefault("X-Amz-Credential")
  valid_617605 = validateParameter(valid_617605, JString, required = false,
                                 default = nil)
  if valid_617605 != nil:
    section.add "X-Amz-Credential", valid_617605
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617606: Call_GetBatchModifyClusterSnapshots_617591;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies the settings for a set of cluster snapshots.
  ## 
  let valid = call_617606.validator(path, query, header, formData, body, _)
  let scheme = call_617606.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617606.url(scheme.get, call_617606.host, call_617606.base,
                         call_617606.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617606, url, valid, _)

proc call*(call_617607: Call_GetBatchModifyClusterSnapshots_617591;
          SnapshotIdentifierList: JsonNode;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"; Force: bool = false;
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getBatchModifyClusterSnapshots
  ## Modifies the settings for a set of cluster snapshots.
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  var query_617608 = newJObject()
  if SnapshotIdentifierList != nil:
    query_617608.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_617608, "Action", newJString(Action))
  add(query_617608, "Version", newJString(Version))
  add(query_617608, "Force", newJBool(Force))
  add(query_617608, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_617607.call(nil, query_617608, nil, nil, nil)

var getBatchModifyClusterSnapshots* = Call_GetBatchModifyClusterSnapshots_617591(
    name: "getBatchModifyClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_GetBatchModifyClusterSnapshots_617592, base: "/",
    url: url_GetBatchModifyClusterSnapshots_617593,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCancelResize_617644 = ref object of OpenApiRestCall_616850
proc url_PostCancelResize_617646(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCancelResize_617645(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## Cancels a resize operation for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617647 = query.getOrDefault("Action")
  valid_617647 = validateParameter(valid_617647, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_617647 != nil:
    section.add "Action", valid_617647
  var valid_617648 = query.getOrDefault("Version")
  valid_617648 = validateParameter(valid_617648, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617648 != nil:
    section.add "Version", valid_617648
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617649 = header.getOrDefault("X-Amz-Date")
  valid_617649 = validateParameter(valid_617649, JString, required = false,
                                 default = nil)
  if valid_617649 != nil:
    section.add "X-Amz-Date", valid_617649
  var valid_617650 = header.getOrDefault("X-Amz-Security-Token")
  valid_617650 = validateParameter(valid_617650, JString, required = false,
                                 default = nil)
  if valid_617650 != nil:
    section.add "X-Amz-Security-Token", valid_617650
  var valid_617651 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617651 = validateParameter(valid_617651, JString, required = false,
                                 default = nil)
  if valid_617651 != nil:
    section.add "X-Amz-Content-Sha256", valid_617651
  var valid_617652 = header.getOrDefault("X-Amz-Algorithm")
  valid_617652 = validateParameter(valid_617652, JString, required = false,
                                 default = nil)
  if valid_617652 != nil:
    section.add "X-Amz-Algorithm", valid_617652
  var valid_617653 = header.getOrDefault("X-Amz-Signature")
  valid_617653 = validateParameter(valid_617653, JString, required = false,
                                 default = nil)
  if valid_617653 != nil:
    section.add "X-Amz-Signature", valid_617653
  var valid_617654 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617654 = validateParameter(valid_617654, JString, required = false,
                                 default = nil)
  if valid_617654 != nil:
    section.add "X-Amz-SignedHeaders", valid_617654
  var valid_617655 = header.getOrDefault("X-Amz-Credential")
  valid_617655 = validateParameter(valid_617655, JString, required = false,
                                 default = nil)
  if valid_617655 != nil:
    section.add "X-Amz-Credential", valid_617655
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_617656 = formData.getOrDefault("ClusterIdentifier")
  valid_617656 = validateParameter(valid_617656, JString, required = true,
                                 default = nil)
  if valid_617656 != nil:
    section.add "ClusterIdentifier", valid_617656
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617657: Call_PostCancelResize_617644; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Cancels a resize operation for a cluster.
  ## 
  let valid = call_617657.validator(path, query, header, formData, body, _)
  let scheme = call_617657.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617657.url(scheme.get, call_617657.host, call_617657.base,
                         call_617657.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617657, url, valid, _)

proc call*(call_617658: Call_PostCancelResize_617644; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## postCancelResize
  ## Cancels a resize operation for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_617659 = newJObject()
  var formData_617660 = newJObject()
  add(query_617659, "Action", newJString(Action))
  add(formData_617660, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_617659, "Version", newJString(Version))
  result = call_617658.call(nil, query_617659, nil, formData_617660, nil)

var postCancelResize* = Call_PostCancelResize_617644(name: "postCancelResize",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_PostCancelResize_617645,
    base: "/", url: url_PostCancelResize_617646,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCancelResize_617628 = ref object of OpenApiRestCall_616850
proc url_GetCancelResize_617630(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCancelResize_617629(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode =
  ## Cancels a resize operation for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: JString (required)
  section = newJObject()
  var valid_617631 = query.getOrDefault("Action")
  valid_617631 = validateParameter(valid_617631, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_617631 != nil:
    section.add "Action", valid_617631
  var valid_617632 = query.getOrDefault("ClusterIdentifier")
  valid_617632 = validateParameter(valid_617632, JString, required = true,
                                 default = nil)
  if valid_617632 != nil:
    section.add "ClusterIdentifier", valid_617632
  var valid_617633 = query.getOrDefault("Version")
  valid_617633 = validateParameter(valid_617633, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617633 != nil:
    section.add "Version", valid_617633
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617634 = header.getOrDefault("X-Amz-Date")
  valid_617634 = validateParameter(valid_617634, JString, required = false,
                                 default = nil)
  if valid_617634 != nil:
    section.add "X-Amz-Date", valid_617634
  var valid_617635 = header.getOrDefault("X-Amz-Security-Token")
  valid_617635 = validateParameter(valid_617635, JString, required = false,
                                 default = nil)
  if valid_617635 != nil:
    section.add "X-Amz-Security-Token", valid_617635
  var valid_617636 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617636 = validateParameter(valid_617636, JString, required = false,
                                 default = nil)
  if valid_617636 != nil:
    section.add "X-Amz-Content-Sha256", valid_617636
  var valid_617637 = header.getOrDefault("X-Amz-Algorithm")
  valid_617637 = validateParameter(valid_617637, JString, required = false,
                                 default = nil)
  if valid_617637 != nil:
    section.add "X-Amz-Algorithm", valid_617637
  var valid_617638 = header.getOrDefault("X-Amz-Signature")
  valid_617638 = validateParameter(valid_617638, JString, required = false,
                                 default = nil)
  if valid_617638 != nil:
    section.add "X-Amz-Signature", valid_617638
  var valid_617639 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617639 = validateParameter(valid_617639, JString, required = false,
                                 default = nil)
  if valid_617639 != nil:
    section.add "X-Amz-SignedHeaders", valid_617639
  var valid_617640 = header.getOrDefault("X-Amz-Credential")
  valid_617640 = validateParameter(valid_617640, JString, required = false,
                                 default = nil)
  if valid_617640 != nil:
    section.add "X-Amz-Credential", valid_617640
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617641: Call_GetCancelResize_617628; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Cancels a resize operation for a cluster.
  ## 
  let valid = call_617641.validator(path, query, header, formData, body, _)
  let scheme = call_617641.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617641.url(scheme.get, call_617641.host, call_617641.base,
                         call_617641.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617641, url, valid, _)

proc call*(call_617642: Call_GetCancelResize_617628; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## getCancelResize
  ## Cancels a resize operation for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_617643 = newJObject()
  add(query_617643, "Action", newJString(Action))
  add(query_617643, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_617643, "Version", newJString(Version))
  result = call_617642.call(nil, query_617643, nil, nil, nil)

var getCancelResize* = Call_GetCancelResize_617628(name: "getCancelResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_GetCancelResize_617629,
    base: "/", url: url_GetCancelResize_617630, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCopyClusterSnapshot_617680 = ref object of OpenApiRestCall_616850
proc url_PostCopyClusterSnapshot_617682(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCopyClusterSnapshot_617681(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617683 = query.getOrDefault("Action")
  valid_617683 = validateParameter(valid_617683, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_617683 != nil:
    section.add "Action", valid_617683
  var valid_617684 = query.getOrDefault("Version")
  valid_617684 = validateParameter(valid_617684, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617684 != nil:
    section.add "Version", valid_617684
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617685 = header.getOrDefault("X-Amz-Date")
  valid_617685 = validateParameter(valid_617685, JString, required = false,
                                 default = nil)
  if valid_617685 != nil:
    section.add "X-Amz-Date", valid_617685
  var valid_617686 = header.getOrDefault("X-Amz-Security-Token")
  valid_617686 = validateParameter(valid_617686, JString, required = false,
                                 default = nil)
  if valid_617686 != nil:
    section.add "X-Amz-Security-Token", valid_617686
  var valid_617687 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617687 = validateParameter(valid_617687, JString, required = false,
                                 default = nil)
  if valid_617687 != nil:
    section.add "X-Amz-Content-Sha256", valid_617687
  var valid_617688 = header.getOrDefault("X-Amz-Algorithm")
  valid_617688 = validateParameter(valid_617688, JString, required = false,
                                 default = nil)
  if valid_617688 != nil:
    section.add "X-Amz-Algorithm", valid_617688
  var valid_617689 = header.getOrDefault("X-Amz-Signature")
  valid_617689 = validateParameter(valid_617689, JString, required = false,
                                 default = nil)
  if valid_617689 != nil:
    section.add "X-Amz-Signature", valid_617689
  var valid_617690 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617690 = validateParameter(valid_617690, JString, required = false,
                                 default = nil)
  if valid_617690 != nil:
    section.add "X-Amz-SignedHeaders", valid_617690
  var valid_617691 = header.getOrDefault("X-Amz-Credential")
  valid_617691 = validateParameter(valid_617691, JString, required = false,
                                 default = nil)
  if valid_617691 != nil:
    section.add "X-Amz-Credential", valid_617691
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_617692 = formData.getOrDefault("SourceSnapshotIdentifier")
  valid_617692 = validateParameter(valid_617692, JString, required = true,
                                 default = nil)
  if valid_617692 != nil:
    section.add "SourceSnapshotIdentifier", valid_617692
  var valid_617693 = formData.getOrDefault("TargetSnapshotIdentifier")
  valid_617693 = validateParameter(valid_617693, JString, required = true,
                                 default = nil)
  if valid_617693 != nil:
    section.add "TargetSnapshotIdentifier", valid_617693
  var valid_617694 = formData.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_617694 = validateParameter(valid_617694, JString, required = false,
                                 default = nil)
  if valid_617694 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_617694
  var valid_617695 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_617695 = validateParameter(valid_617695, JInt, required = false, default = nil)
  if valid_617695 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_617695
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617696: Call_PostCopyClusterSnapshot_617680; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617696.validator(path, query, header, formData, body, _)
  let scheme = call_617696.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617696.url(scheme.get, call_617696.host, call_617696.base,
                         call_617696.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617696, url, valid, _)

proc call*(call_617697: Call_PostCopyClusterSnapshot_617680;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          Action: string = "CopyClusterSnapshot";
          SourceSnapshotClusterIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  var query_617698 = newJObject()
  var formData_617699 = newJObject()
  add(formData_617699, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(formData_617699, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_617698, "Action", newJString(Action))
  add(formData_617699, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(formData_617699, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_617698, "Version", newJString(Version))
  result = call_617697.call(nil, query_617698, nil, formData_617699, nil)

var postCopyClusterSnapshot* = Call_PostCopyClusterSnapshot_617680(
    name: "postCopyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_PostCopyClusterSnapshot_617681, base: "/",
    url: url_PostCopyClusterSnapshot_617682, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCopyClusterSnapshot_617661 = ref object of OpenApiRestCall_616850
proc url_GetCopyClusterSnapshot_617663(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCopyClusterSnapshot_617662(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   Action: JString (required)
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Version: JString (required)
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_617664 = query.getOrDefault("SourceSnapshotIdentifier")
  valid_617664 = validateParameter(valid_617664, JString, required = true,
                                 default = nil)
  if valid_617664 != nil:
    section.add "SourceSnapshotIdentifier", valid_617664
  var valid_617665 = query.getOrDefault("Action")
  valid_617665 = validateParameter(valid_617665, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_617665 != nil:
    section.add "Action", valid_617665
  var valid_617666 = query.getOrDefault("TargetSnapshotIdentifier")
  valid_617666 = validateParameter(valid_617666, JString, required = true,
                                 default = nil)
  if valid_617666 != nil:
    section.add "TargetSnapshotIdentifier", valid_617666
  var valid_617667 = query.getOrDefault("Version")
  valid_617667 = validateParameter(valid_617667, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617667 != nil:
    section.add "Version", valid_617667
  var valid_617668 = query.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_617668 = validateParameter(valid_617668, JString, required = false,
                                 default = nil)
  if valid_617668 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_617668
  var valid_617669 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_617669 = validateParameter(valid_617669, JInt, required = false, default = nil)
  if valid_617669 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_617669
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617670 = header.getOrDefault("X-Amz-Date")
  valid_617670 = validateParameter(valid_617670, JString, required = false,
                                 default = nil)
  if valid_617670 != nil:
    section.add "X-Amz-Date", valid_617670
  var valid_617671 = header.getOrDefault("X-Amz-Security-Token")
  valid_617671 = validateParameter(valid_617671, JString, required = false,
                                 default = nil)
  if valid_617671 != nil:
    section.add "X-Amz-Security-Token", valid_617671
  var valid_617672 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617672 = validateParameter(valid_617672, JString, required = false,
                                 default = nil)
  if valid_617672 != nil:
    section.add "X-Amz-Content-Sha256", valid_617672
  var valid_617673 = header.getOrDefault("X-Amz-Algorithm")
  valid_617673 = validateParameter(valid_617673, JString, required = false,
                                 default = nil)
  if valid_617673 != nil:
    section.add "X-Amz-Algorithm", valid_617673
  var valid_617674 = header.getOrDefault("X-Amz-Signature")
  valid_617674 = validateParameter(valid_617674, JString, required = false,
                                 default = nil)
  if valid_617674 != nil:
    section.add "X-Amz-Signature", valid_617674
  var valid_617675 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617675 = validateParameter(valid_617675, JString, required = false,
                                 default = nil)
  if valid_617675 != nil:
    section.add "X-Amz-SignedHeaders", valid_617675
  var valid_617676 = header.getOrDefault("X-Amz-Credential")
  valid_617676 = validateParameter(valid_617676, JString, required = false,
                                 default = nil)
  if valid_617676 != nil:
    section.add "X-Amz-Credential", valid_617676
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617677: Call_GetCopyClusterSnapshot_617661; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617677.validator(path, query, header, formData, body, _)
  let scheme = call_617677.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617677.url(scheme.get, call_617677.host, call_617677.base,
                         call_617677.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617677, url, valid, _)

proc call*(call_617678: Call_GetCopyClusterSnapshot_617661;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          SourceSnapshotClusterIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   Action: string (required)
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Version: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_617679 = newJObject()
  add(query_617679, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(query_617679, "Action", newJString(Action))
  add(query_617679, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_617679, "Version", newJString(Version))
  add(query_617679, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(query_617679, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_617678.call(nil, query_617679, nil, nil, nil)

var getCopyClusterSnapshot* = Call_GetCopyClusterSnapshot_617661(
    name: "getCopyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_GetCopyClusterSnapshot_617662, base: "/",
    url: url_GetCopyClusterSnapshot_617663, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateCluster_617745 = ref object of OpenApiRestCall_616850
proc url_PostCreateCluster_617747(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateCluster_617746(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617748 = query.getOrDefault("Action")
  valid_617748 = validateParameter(valid_617748, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_617748 != nil:
    section.add "Action", valid_617748
  var valid_617749 = query.getOrDefault("Version")
  valid_617749 = validateParameter(valid_617749, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617749 != nil:
    section.add "Version", valid_617749
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617750 = header.getOrDefault("X-Amz-Date")
  valid_617750 = validateParameter(valid_617750, JString, required = false,
                                 default = nil)
  if valid_617750 != nil:
    section.add "X-Amz-Date", valid_617750
  var valid_617751 = header.getOrDefault("X-Amz-Security-Token")
  valid_617751 = validateParameter(valid_617751, JString, required = false,
                                 default = nil)
  if valid_617751 != nil:
    section.add "X-Amz-Security-Token", valid_617751
  var valid_617752 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617752 = validateParameter(valid_617752, JString, required = false,
                                 default = nil)
  if valid_617752 != nil:
    section.add "X-Amz-Content-Sha256", valid_617752
  var valid_617753 = header.getOrDefault("X-Amz-Algorithm")
  valid_617753 = validateParameter(valid_617753, JString, required = false,
                                 default = nil)
  if valid_617753 != nil:
    section.add "X-Amz-Algorithm", valid_617753
  var valid_617754 = header.getOrDefault("X-Amz-Signature")
  valid_617754 = validateParameter(valid_617754, JString, required = false,
                                 default = nil)
  if valid_617754 != nil:
    section.add "X-Amz-Signature", valid_617754
  var valid_617755 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617755 = validateParameter(valid_617755, JString, required = false,
                                 default = nil)
  if valid_617755 != nil:
    section.add "X-Amz-SignedHeaders", valid_617755
  var valid_617756 = header.getOrDefault("X-Amz-Credential")
  valid_617756 = validateParameter(valid_617756, JString, required = false,
                                 default = nil)
  if valid_617756 != nil:
    section.add "X-Amz-Credential", valid_617756
  result.add "header", section
  ## parameters in `formData` object:
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  section = newJObject()
  var valid_617757 = formData.getOrDefault("EnhancedVpcRouting")
  valid_617757 = validateParameter(valid_617757, JBool, required = false, default = nil)
  if valid_617757 != nil:
    section.add "EnhancedVpcRouting", valid_617757
  assert formData != nil,
        "formData argument is necessary due to required `MasterUsername` field"
  var valid_617758 = formData.getOrDefault("MasterUsername")
  valid_617758 = validateParameter(valid_617758, JString, required = true,
                                 default = nil)
  if valid_617758 != nil:
    section.add "MasterUsername", valid_617758
  var valid_617759 = formData.getOrDefault("Port")
  valid_617759 = validateParameter(valid_617759, JInt, required = false, default = nil)
  if valid_617759 != nil:
    section.add "Port", valid_617759
  var valid_617760 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_617760 = validateParameter(valid_617760, JArray, required = false,
                                 default = nil)
  if valid_617760 != nil:
    section.add "VpcSecurityGroupIds", valid_617760
  var valid_617761 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_617761 = validateParameter(valid_617761, JString, required = false,
                                 default = nil)
  if valid_617761 != nil:
    section.add "ClusterSubnetGroupName", valid_617761
  var valid_617762 = formData.getOrDefault("PubliclyAccessible")
  valid_617762 = validateParameter(valid_617762, JBool, required = false, default = nil)
  if valid_617762 != nil:
    section.add "PubliclyAccessible", valid_617762
  var valid_617763 = formData.getOrDefault("ClusterVersion")
  valid_617763 = validateParameter(valid_617763, JString, required = false,
                                 default = nil)
  if valid_617763 != nil:
    section.add "ClusterVersion", valid_617763
  var valid_617764 = formData.getOrDefault("Tags")
  valid_617764 = validateParameter(valid_617764, JArray, required = false,
                                 default = nil)
  if valid_617764 != nil:
    section.add "Tags", valid_617764
  var valid_617765 = formData.getOrDefault("MasterUserPassword")
  valid_617765 = validateParameter(valid_617765, JString, required = true,
                                 default = nil)
  if valid_617765 != nil:
    section.add "MasterUserPassword", valid_617765
  var valid_617766 = formData.getOrDefault("AdditionalInfo")
  valid_617766 = validateParameter(valid_617766, JString, required = false,
                                 default = nil)
  if valid_617766 != nil:
    section.add "AdditionalInfo", valid_617766
  var valid_617767 = formData.getOrDefault("MaintenanceTrackName")
  valid_617767 = validateParameter(valid_617767, JString, required = false,
                                 default = nil)
  if valid_617767 != nil:
    section.add "MaintenanceTrackName", valid_617767
  var valid_617768 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_617768 = validateParameter(valid_617768, JString, required = false,
                                 default = nil)
  if valid_617768 != nil:
    section.add "PreferredMaintenanceWindow", valid_617768
  var valid_617769 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_617769 = validateParameter(valid_617769, JString, required = false,
                                 default = nil)
  if valid_617769 != nil:
    section.add "HsmConfigurationIdentifier", valid_617769
  var valid_617770 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_617770 = validateParameter(valid_617770, JString, required = false,
                                 default = nil)
  if valid_617770 != nil:
    section.add "HsmClientCertificateIdentifier", valid_617770
  var valid_617771 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_617771 = validateParameter(valid_617771, JString, required = false,
                                 default = nil)
  if valid_617771 != nil:
    section.add "SnapshotScheduleIdentifier", valid_617771
  var valid_617772 = formData.getOrDefault("NumberOfNodes")
  valid_617772 = validateParameter(valid_617772, JInt, required = false, default = nil)
  if valid_617772 != nil:
    section.add "NumberOfNodes", valid_617772
  var valid_617773 = formData.getOrDefault("Encrypted")
  valid_617773 = validateParameter(valid_617773, JBool, required = false, default = nil)
  if valid_617773 != nil:
    section.add "Encrypted", valid_617773
  var valid_617774 = formData.getOrDefault("IamRoles")
  valid_617774 = validateParameter(valid_617774, JArray, required = false,
                                 default = nil)
  if valid_617774 != nil:
    section.add "IamRoles", valid_617774
  var valid_617775 = formData.getOrDefault("ClusterType")
  valid_617775 = validateParameter(valid_617775, JString, required = false,
                                 default = nil)
  if valid_617775 != nil:
    section.add "ClusterType", valid_617775
  var valid_617776 = formData.getOrDefault("AvailabilityZone")
  valid_617776 = validateParameter(valid_617776, JString, required = false,
                                 default = nil)
  if valid_617776 != nil:
    section.add "AvailabilityZone", valid_617776
  var valid_617777 = formData.getOrDefault("KmsKeyId")
  valid_617777 = validateParameter(valid_617777, JString, required = false,
                                 default = nil)
  if valid_617777 != nil:
    section.add "KmsKeyId", valid_617777
  var valid_617778 = formData.getOrDefault("ClusterIdentifier")
  valid_617778 = validateParameter(valid_617778, JString, required = true,
                                 default = nil)
  if valid_617778 != nil:
    section.add "ClusterIdentifier", valid_617778
  var valid_617779 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_617779 = validateParameter(valid_617779, JInt, required = false, default = nil)
  if valid_617779 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_617779
  var valid_617780 = formData.getOrDefault("ElasticIp")
  valid_617780 = validateParameter(valid_617780, JString, required = false,
                                 default = nil)
  if valid_617780 != nil:
    section.add "ElasticIp", valid_617780
  var valid_617781 = formData.getOrDefault("AllowVersionUpgrade")
  valid_617781 = validateParameter(valid_617781, JBool, required = false, default = nil)
  if valid_617781 != nil:
    section.add "AllowVersionUpgrade", valid_617781
  var valid_617782 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_617782 = validateParameter(valid_617782, JInt, required = false, default = nil)
  if valid_617782 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_617782
  var valid_617783 = formData.getOrDefault("ClusterParameterGroupName")
  valid_617783 = validateParameter(valid_617783, JString, required = false,
                                 default = nil)
  if valid_617783 != nil:
    section.add "ClusterParameterGroupName", valid_617783
  var valid_617784 = formData.getOrDefault("NodeType")
  valid_617784 = validateParameter(valid_617784, JString, required = true,
                                 default = nil)
  if valid_617784 != nil:
    section.add "NodeType", valid_617784
  var valid_617785 = formData.getOrDefault("DBName")
  valid_617785 = validateParameter(valid_617785, JString, required = false,
                                 default = nil)
  if valid_617785 != nil:
    section.add "DBName", valid_617785
  var valid_617786 = formData.getOrDefault("ClusterSecurityGroups")
  valid_617786 = validateParameter(valid_617786, JArray, required = false,
                                 default = nil)
  if valid_617786 != nil:
    section.add "ClusterSecurityGroups", valid_617786
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617787: Call_PostCreateCluster_617745; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617787.validator(path, query, header, formData, body, _)
  let scheme = call_617787.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617787.url(scheme.get, call_617787.host, call_617787.base,
                         call_617787.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617787, url, valid, _)

proc call*(call_617788: Call_PostCreateCluster_617745; MasterUsername: string;
          MasterUserPassword: string; ClusterIdentifier: string; NodeType: string;
          EnhancedVpcRouting: bool = false; Port: int = 0;
          VpcSecurityGroupIds: JsonNode = nil; ClusterSubnetGroupName: string = "";
          PubliclyAccessible: bool = false; ClusterVersion: string = "";
          Tags: JsonNode = nil; AdditionalInfo: string = "";
          MaintenanceTrackName: string = "";
          PreferredMaintenanceWindow: string = "";
          HsmConfigurationIdentifier: string = ""; Action: string = "CreateCluster";
          HsmClientCertificateIdentifier: string = "";
          SnapshotScheduleIdentifier: string = ""; NumberOfNodes: int = 0;
          Encrypted: bool = false; IamRoles: JsonNode = nil; ClusterType: string = "";
          AvailabilityZone: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0;
          ClusterParameterGroupName: string = ""; Version: string = "2012-12-01";
          DBName: string = ""; ClusterSecurityGroups: JsonNode = nil): Recallable =
  ## postCreateCluster
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   Version: string (required)
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  var query_617789 = newJObject()
  var formData_617790 = newJObject()
  add(formData_617790, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_617790, "MasterUsername", newJString(MasterUsername))
  add(formData_617790, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    formData_617790.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_617790, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_617790, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_617790, "ClusterVersion", newJString(ClusterVersion))
  if Tags != nil:
    formData_617790.add "Tags", Tags
  add(formData_617790, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_617790, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_617790, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_617790, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_617790, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_617789, "Action", newJString(Action))
  add(formData_617790, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_617790, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(formData_617790, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_617790, "Encrypted", newJBool(Encrypted))
  if IamRoles != nil:
    formData_617790.add "IamRoles", IamRoles
  add(formData_617790, "ClusterType", newJString(ClusterType))
  add(formData_617790, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_617790, "KmsKeyId", newJString(KmsKeyId))
  add(formData_617790, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_617790, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_617790, "ElasticIp", newJString(ElasticIp))
  add(formData_617790, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_617790, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_617790, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_617790, "NodeType", newJString(NodeType))
  add(query_617789, "Version", newJString(Version))
  add(formData_617790, "DBName", newJString(DBName))
  if ClusterSecurityGroups != nil:
    formData_617790.add "ClusterSecurityGroups", ClusterSecurityGroups
  result = call_617788.call(nil, query_617789, nil, formData_617790, nil)

var postCreateCluster* = Call_PostCreateCluster_617745(name: "postCreateCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_PostCreateCluster_617746,
    base: "/", url: url_PostCreateCluster_617747,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateCluster_617700 = ref object of OpenApiRestCall_616850
proc url_GetCreateCluster_617702(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateCluster_617701(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: JString (required)
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  section = newJObject()
  var valid_617703 = query.getOrDefault("ClusterSecurityGroups")
  valid_617703 = validateParameter(valid_617703, JArray, required = false,
                                 default = nil)
  if valid_617703 != nil:
    section.add "ClusterSecurityGroups", valid_617703
  var valid_617704 = query.getOrDefault("ClusterSubnetGroupName")
  valid_617704 = validateParameter(valid_617704, JString, required = false,
                                 default = nil)
  if valid_617704 != nil:
    section.add "ClusterSubnetGroupName", valid_617704
  var valid_617705 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_617705 = validateParameter(valid_617705, JString, required = false,
                                 default = nil)
  if valid_617705 != nil:
    section.add "HsmClientCertificateIdentifier", valid_617705
  var valid_617706 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_617706 = validateParameter(valid_617706, JString, required = false,
                                 default = nil)
  if valid_617706 != nil:
    section.add "PreferredMaintenanceWindow", valid_617706
  var valid_617707 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_617707 = validateParameter(valid_617707, JString, required = false,
                                 default = nil)
  if valid_617707 != nil:
    section.add "HsmConfigurationIdentifier", valid_617707
  var valid_617708 = query.getOrDefault("MaintenanceTrackName")
  valid_617708 = validateParameter(valid_617708, JString, required = false,
                                 default = nil)
  if valid_617708 != nil:
    section.add "MaintenanceTrackName", valid_617708
  var valid_617709 = query.getOrDefault("IamRoles")
  valid_617709 = validateParameter(valid_617709, JArray, required = false,
                                 default = nil)
  if valid_617709 != nil:
    section.add "IamRoles", valid_617709
  var valid_617710 = query.getOrDefault("ClusterType")
  valid_617710 = validateParameter(valid_617710, JString, required = false,
                                 default = nil)
  if valid_617710 != nil:
    section.add "ClusterType", valid_617710
  var valid_617711 = query.getOrDefault("AvailabilityZone")
  valid_617711 = validateParameter(valid_617711, JString, required = false,
                                 default = nil)
  if valid_617711 != nil:
    section.add "AvailabilityZone", valid_617711
  assert query != nil, "query argument is necessary due to required `MasterUserPassword` field"
  var valid_617712 = query.getOrDefault("MasterUserPassword")
  valid_617712 = validateParameter(valid_617712, JString, required = true,
                                 default = nil)
  if valid_617712 != nil:
    section.add "MasterUserPassword", valid_617712
  var valid_617713 = query.getOrDefault("AllowVersionUpgrade")
  valid_617713 = validateParameter(valid_617713, JBool, required = false, default = nil)
  if valid_617713 != nil:
    section.add "AllowVersionUpgrade", valid_617713
  var valid_617714 = query.getOrDefault("VpcSecurityGroupIds")
  valid_617714 = validateParameter(valid_617714, JArray, required = false,
                                 default = nil)
  if valid_617714 != nil:
    section.add "VpcSecurityGroupIds", valid_617714
  var valid_617715 = query.getOrDefault("ClusterParameterGroupName")
  valid_617715 = validateParameter(valid_617715, JString, required = false,
                                 default = nil)
  if valid_617715 != nil:
    section.add "ClusterParameterGroupName", valid_617715
  var valid_617716 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_617716 = validateParameter(valid_617716, JString, required = false,
                                 default = nil)
  if valid_617716 != nil:
    section.add "SnapshotScheduleIdentifier", valid_617716
  var valid_617717 = query.getOrDefault("EnhancedVpcRouting")
  valid_617717 = validateParameter(valid_617717, JBool, required = false, default = nil)
  if valid_617717 != nil:
    section.add "EnhancedVpcRouting", valid_617717
  var valid_617718 = query.getOrDefault("Port")
  valid_617718 = validateParameter(valid_617718, JInt, required = false, default = nil)
  if valid_617718 != nil:
    section.add "Port", valid_617718
  var valid_617719 = query.getOrDefault("AdditionalInfo")
  valid_617719 = validateParameter(valid_617719, JString, required = false,
                                 default = nil)
  if valid_617719 != nil:
    section.add "AdditionalInfo", valid_617719
  var valid_617720 = query.getOrDefault("ElasticIp")
  valid_617720 = validateParameter(valid_617720, JString, required = false,
                                 default = nil)
  if valid_617720 != nil:
    section.add "ElasticIp", valid_617720
  var valid_617721 = query.getOrDefault("ClusterIdentifier")
  valid_617721 = validateParameter(valid_617721, JString, required = true,
                                 default = nil)
  if valid_617721 != nil:
    section.add "ClusterIdentifier", valid_617721
  var valid_617722 = query.getOrDefault("KmsKeyId")
  valid_617722 = validateParameter(valid_617722, JString, required = false,
                                 default = nil)
  if valid_617722 != nil:
    section.add "KmsKeyId", valid_617722
  var valid_617723 = query.getOrDefault("PubliclyAccessible")
  valid_617723 = validateParameter(valid_617723, JBool, required = false, default = nil)
  if valid_617723 != nil:
    section.add "PubliclyAccessible", valid_617723
  var valid_617724 = query.getOrDefault("Action")
  valid_617724 = validateParameter(valid_617724, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_617724 != nil:
    section.add "Action", valid_617724
  var valid_617725 = query.getOrDefault("Encrypted")
  valid_617725 = validateParameter(valid_617725, JBool, required = false, default = nil)
  if valid_617725 != nil:
    section.add "Encrypted", valid_617725
  var valid_617726 = query.getOrDefault("NumberOfNodes")
  valid_617726 = validateParameter(valid_617726, JInt, required = false, default = nil)
  if valid_617726 != nil:
    section.add "NumberOfNodes", valid_617726
  var valid_617727 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_617727 = validateParameter(valid_617727, JInt, required = false, default = nil)
  if valid_617727 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_617727
  var valid_617728 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_617728 = validateParameter(valid_617728, JInt, required = false, default = nil)
  if valid_617728 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_617728
  var valid_617729 = query.getOrDefault("NodeType")
  valid_617729 = validateParameter(valid_617729, JString, required = true,
                                 default = nil)
  if valid_617729 != nil:
    section.add "NodeType", valid_617729
  var valid_617730 = query.getOrDefault("ClusterVersion")
  valid_617730 = validateParameter(valid_617730, JString, required = false,
                                 default = nil)
  if valid_617730 != nil:
    section.add "ClusterVersion", valid_617730
  var valid_617731 = query.getOrDefault("Version")
  valid_617731 = validateParameter(valid_617731, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617731 != nil:
    section.add "Version", valid_617731
  var valid_617732 = query.getOrDefault("Tags")
  valid_617732 = validateParameter(valid_617732, JArray, required = false,
                                 default = nil)
  if valid_617732 != nil:
    section.add "Tags", valid_617732
  var valid_617733 = query.getOrDefault("MasterUsername")
  valid_617733 = validateParameter(valid_617733, JString, required = true,
                                 default = nil)
  if valid_617733 != nil:
    section.add "MasterUsername", valid_617733
  var valid_617734 = query.getOrDefault("DBName")
  valid_617734 = validateParameter(valid_617734, JString, required = false,
                                 default = nil)
  if valid_617734 != nil:
    section.add "DBName", valid_617734
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617735 = header.getOrDefault("X-Amz-Date")
  valid_617735 = validateParameter(valid_617735, JString, required = false,
                                 default = nil)
  if valid_617735 != nil:
    section.add "X-Amz-Date", valid_617735
  var valid_617736 = header.getOrDefault("X-Amz-Security-Token")
  valid_617736 = validateParameter(valid_617736, JString, required = false,
                                 default = nil)
  if valid_617736 != nil:
    section.add "X-Amz-Security-Token", valid_617736
  var valid_617737 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617737 = validateParameter(valid_617737, JString, required = false,
                                 default = nil)
  if valid_617737 != nil:
    section.add "X-Amz-Content-Sha256", valid_617737
  var valid_617738 = header.getOrDefault("X-Amz-Algorithm")
  valid_617738 = validateParameter(valid_617738, JString, required = false,
                                 default = nil)
  if valid_617738 != nil:
    section.add "X-Amz-Algorithm", valid_617738
  var valid_617739 = header.getOrDefault("X-Amz-Signature")
  valid_617739 = validateParameter(valid_617739, JString, required = false,
                                 default = nil)
  if valid_617739 != nil:
    section.add "X-Amz-Signature", valid_617739
  var valid_617740 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617740 = validateParameter(valid_617740, JString, required = false,
                                 default = nil)
  if valid_617740 != nil:
    section.add "X-Amz-SignedHeaders", valid_617740
  var valid_617741 = header.getOrDefault("X-Amz-Credential")
  valid_617741 = validateParameter(valid_617741, JString, required = false,
                                 default = nil)
  if valid_617741 != nil:
    section.add "X-Amz-Credential", valid_617741
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617742: Call_GetCreateCluster_617700; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617742.validator(path, query, header, formData, body, _)
  let scheme = call_617742.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617742.url(scheme.get, call_617742.host, call_617742.base,
                         call_617742.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617742, url, valid, _)

proc call*(call_617743: Call_GetCreateCluster_617700; MasterUserPassword: string;
          ClusterIdentifier: string; NodeType: string; MasterUsername: string;
          ClusterSecurityGroups: JsonNode = nil;
          ClusterSubnetGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = "";
          HsmConfigurationIdentifier: string = "";
          MaintenanceTrackName: string = ""; IamRoles: JsonNode = nil;
          ClusterType: string = ""; AvailabilityZone: string = "";
          AllowVersionUpgrade: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          SnapshotScheduleIdentifier: string = ""; EnhancedVpcRouting: bool = false;
          Port: int = 0; AdditionalInfo: string = ""; ElasticIp: string = "";
          KmsKeyId: string = ""; PubliclyAccessible: bool = false;
          Action: string = "CreateCluster"; Encrypted: bool = false;
          NumberOfNodes: int = 0; ManualSnapshotRetentionPeriod: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; ClusterVersion: string = "";
          Version: string = "2012-12-01"; Tags: JsonNode = nil; DBName: string = ""): Recallable =
  ## getCreateCluster
  ## <p>Creates a new cluster with the specified parameters.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-2d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: string (required)
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  var query_617744 = newJObject()
  if ClusterSecurityGroups != nil:
    query_617744.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_617744, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_617744, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_617744, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_617744, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_617744, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if IamRoles != nil:
    query_617744.add "IamRoles", IamRoles
  add(query_617744, "ClusterType", newJString(ClusterType))
  add(query_617744, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_617744, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_617744, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  if VpcSecurityGroupIds != nil:
    query_617744.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_617744, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_617744, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_617744, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_617744, "Port", newJInt(Port))
  add(query_617744, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_617744, "ElasticIp", newJString(ElasticIp))
  add(query_617744, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_617744, "KmsKeyId", newJString(KmsKeyId))
  add(query_617744, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_617744, "Action", newJString(Action))
  add(query_617744, "Encrypted", newJBool(Encrypted))
  add(query_617744, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_617744, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_617744, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_617744, "NodeType", newJString(NodeType))
  add(query_617744, "ClusterVersion", newJString(ClusterVersion))
  add(query_617744, "Version", newJString(Version))
  if Tags != nil:
    query_617744.add "Tags", Tags
  add(query_617744, "MasterUsername", newJString(MasterUsername))
  add(query_617744, "DBName", newJString(DBName))
  result = call_617743.call(nil, query_617744, nil, nil, nil)

var getCreateCluster* = Call_GetCreateCluster_617700(name: "getCreateCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_GetCreateCluster_617701,
    base: "/", url: url_GetCreateCluster_617702,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterParameterGroup_617810 = ref object of OpenApiRestCall_616850
proc url_PostCreateClusterParameterGroup_617812(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterParameterGroup_617811(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617813 = query.getOrDefault("Action")
  valid_617813 = validateParameter(valid_617813, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_617813 != nil:
    section.add "Action", valid_617813
  var valid_617814 = query.getOrDefault("Version")
  valid_617814 = validateParameter(valid_617814, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617814 != nil:
    section.add "Version", valid_617814
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617815 = header.getOrDefault("X-Amz-Date")
  valid_617815 = validateParameter(valid_617815, JString, required = false,
                                 default = nil)
  if valid_617815 != nil:
    section.add "X-Amz-Date", valid_617815
  var valid_617816 = header.getOrDefault("X-Amz-Security-Token")
  valid_617816 = validateParameter(valid_617816, JString, required = false,
                                 default = nil)
  if valid_617816 != nil:
    section.add "X-Amz-Security-Token", valid_617816
  var valid_617817 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617817 = validateParameter(valid_617817, JString, required = false,
                                 default = nil)
  if valid_617817 != nil:
    section.add "X-Amz-Content-Sha256", valid_617817
  var valid_617818 = header.getOrDefault("X-Amz-Algorithm")
  valid_617818 = validateParameter(valid_617818, JString, required = false,
                                 default = nil)
  if valid_617818 != nil:
    section.add "X-Amz-Algorithm", valid_617818
  var valid_617819 = header.getOrDefault("X-Amz-Signature")
  valid_617819 = validateParameter(valid_617819, JString, required = false,
                                 default = nil)
  if valid_617819 != nil:
    section.add "X-Amz-Signature", valid_617819
  var valid_617820 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617820 = validateParameter(valid_617820, JString, required = false,
                                 default = nil)
  if valid_617820 != nil:
    section.add "X-Amz-SignedHeaders", valid_617820
  var valid_617821 = header.getOrDefault("X-Amz-Credential")
  valid_617821 = validateParameter(valid_617821, JString, required = false,
                                 default = nil)
  if valid_617821 != nil:
    section.add "X-Amz-Credential", valid_617821
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_617822 = formData.getOrDefault("ParameterGroupName")
  valid_617822 = validateParameter(valid_617822, JString, required = true,
                                 default = nil)
  if valid_617822 != nil:
    section.add "ParameterGroupName", valid_617822
  var valid_617823 = formData.getOrDefault("Tags")
  valid_617823 = validateParameter(valid_617823, JArray, required = false,
                                 default = nil)
  if valid_617823 != nil:
    section.add "Tags", valid_617823
  var valid_617824 = formData.getOrDefault("ParameterGroupFamily")
  valid_617824 = validateParameter(valid_617824, JString, required = true,
                                 default = nil)
  if valid_617824 != nil:
    section.add "ParameterGroupFamily", valid_617824
  var valid_617825 = formData.getOrDefault("Description")
  valid_617825 = validateParameter(valid_617825, JString, required = true,
                                 default = nil)
  if valid_617825 != nil:
    section.add "Description", valid_617825
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617826: Call_PostCreateClusterParameterGroup_617810;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617826.validator(path, query, header, formData, body, _)
  let scheme = call_617826.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617826.url(scheme.get, call_617826.host, call_617826.base,
                         call_617826.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617826, url, valid, _)

proc call*(call_617827: Call_PostCreateClusterParameterGroup_617810;
          ParameterGroupName: string; ParameterGroupFamily: string;
          Description: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description of the parameter group.
  var query_617828 = newJObject()
  var formData_617829 = newJObject()
  add(formData_617829, "ParameterGroupName", newJString(ParameterGroupName))
  if Tags != nil:
    formData_617829.add "Tags", Tags
  add(query_617828, "Action", newJString(Action))
  add(formData_617829, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_617828, "Version", newJString(Version))
  add(formData_617829, "Description", newJString(Description))
  result = call_617827.call(nil, query_617828, nil, formData_617829, nil)

var postCreateClusterParameterGroup* = Call_PostCreateClusterParameterGroup_617810(
    name: "postCreateClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_PostCreateClusterParameterGroup_617811, base: "/",
    url: url_PostCreateClusterParameterGroup_617812,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterParameterGroup_617791 = ref object of OpenApiRestCall_616850
proc url_GetCreateClusterParameterGroup_617793(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterParameterGroup_617792(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Action: JString (required)
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Description` field"
  var valid_617794 = query.getOrDefault("Description")
  valid_617794 = validateParameter(valid_617794, JString, required = true,
                                 default = nil)
  if valid_617794 != nil:
    section.add "Description", valid_617794
  var valid_617795 = query.getOrDefault("Tags")
  valid_617795 = validateParameter(valid_617795, JArray, required = false,
                                 default = nil)
  if valid_617795 != nil:
    section.add "Tags", valid_617795
  var valid_617796 = query.getOrDefault("ParameterGroupName")
  valid_617796 = validateParameter(valid_617796, JString, required = true,
                                 default = nil)
  if valid_617796 != nil:
    section.add "ParameterGroupName", valid_617796
  var valid_617797 = query.getOrDefault("Action")
  valid_617797 = validateParameter(valid_617797, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_617797 != nil:
    section.add "Action", valid_617797
  var valid_617798 = query.getOrDefault("ParameterGroupFamily")
  valid_617798 = validateParameter(valid_617798, JString, required = true,
                                 default = nil)
  if valid_617798 != nil:
    section.add "ParameterGroupFamily", valid_617798
  var valid_617799 = query.getOrDefault("Version")
  valid_617799 = validateParameter(valid_617799, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617799 != nil:
    section.add "Version", valid_617799
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617800 = header.getOrDefault("X-Amz-Date")
  valid_617800 = validateParameter(valid_617800, JString, required = false,
                                 default = nil)
  if valid_617800 != nil:
    section.add "X-Amz-Date", valid_617800
  var valid_617801 = header.getOrDefault("X-Amz-Security-Token")
  valid_617801 = validateParameter(valid_617801, JString, required = false,
                                 default = nil)
  if valid_617801 != nil:
    section.add "X-Amz-Security-Token", valid_617801
  var valid_617802 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617802 = validateParameter(valid_617802, JString, required = false,
                                 default = nil)
  if valid_617802 != nil:
    section.add "X-Amz-Content-Sha256", valid_617802
  var valid_617803 = header.getOrDefault("X-Amz-Algorithm")
  valid_617803 = validateParameter(valid_617803, JString, required = false,
                                 default = nil)
  if valid_617803 != nil:
    section.add "X-Amz-Algorithm", valid_617803
  var valid_617804 = header.getOrDefault("X-Amz-Signature")
  valid_617804 = validateParameter(valid_617804, JString, required = false,
                                 default = nil)
  if valid_617804 != nil:
    section.add "X-Amz-Signature", valid_617804
  var valid_617805 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617805 = validateParameter(valid_617805, JString, required = false,
                                 default = nil)
  if valid_617805 != nil:
    section.add "X-Amz-SignedHeaders", valid_617805
  var valid_617806 = header.getOrDefault("X-Amz-Credential")
  valid_617806 = validateParameter(valid_617806, JString, required = false,
                                 default = nil)
  if valid_617806 != nil:
    section.add "X-Amz-Credential", valid_617806
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617807: Call_GetCreateClusterParameterGroup_617791;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617807.validator(path, query, header, formData, body, _)
  let scheme = call_617807.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617807.url(scheme.get, call_617807.host, call_617807.base,
                         call_617807.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617807, url, valid, _)

proc call*(call_617808: Call_GetCreateClusterParameterGroup_617791;
          Description: string; ParameterGroupName: string;
          ParameterGroupFamily: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: string (required)
  var query_617809 = newJObject()
  add(query_617809, "Description", newJString(Description))
  if Tags != nil:
    query_617809.add "Tags", Tags
  add(query_617809, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_617809, "Action", newJString(Action))
  add(query_617809, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_617809, "Version", newJString(Version))
  result = call_617808.call(nil, query_617809, nil, nil, nil)

var getCreateClusterParameterGroup* = Call_GetCreateClusterParameterGroup_617791(
    name: "getCreateClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_GetCreateClusterParameterGroup_617792, base: "/",
    url: url_GetCreateClusterParameterGroup_617793,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSecurityGroup_617848 = ref object of OpenApiRestCall_616850
proc url_PostCreateClusterSecurityGroup_617850(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSecurityGroup_617849(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617851 = query.getOrDefault("Action")
  valid_617851 = validateParameter(valid_617851, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_617851 != nil:
    section.add "Action", valid_617851
  var valid_617852 = query.getOrDefault("Version")
  valid_617852 = validateParameter(valid_617852, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617852 != nil:
    section.add "Version", valid_617852
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617853 = header.getOrDefault("X-Amz-Date")
  valid_617853 = validateParameter(valid_617853, JString, required = false,
                                 default = nil)
  if valid_617853 != nil:
    section.add "X-Amz-Date", valid_617853
  var valid_617854 = header.getOrDefault("X-Amz-Security-Token")
  valid_617854 = validateParameter(valid_617854, JString, required = false,
                                 default = nil)
  if valid_617854 != nil:
    section.add "X-Amz-Security-Token", valid_617854
  var valid_617855 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617855 = validateParameter(valid_617855, JString, required = false,
                                 default = nil)
  if valid_617855 != nil:
    section.add "X-Amz-Content-Sha256", valid_617855
  var valid_617856 = header.getOrDefault("X-Amz-Algorithm")
  valid_617856 = validateParameter(valid_617856, JString, required = false,
                                 default = nil)
  if valid_617856 != nil:
    section.add "X-Amz-Algorithm", valid_617856
  var valid_617857 = header.getOrDefault("X-Amz-Signature")
  valid_617857 = validateParameter(valid_617857, JString, required = false,
                                 default = nil)
  if valid_617857 != nil:
    section.add "X-Amz-Signature", valid_617857
  var valid_617858 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617858 = validateParameter(valid_617858, JString, required = false,
                                 default = nil)
  if valid_617858 != nil:
    section.add "X-Amz-SignedHeaders", valid_617858
  var valid_617859 = header.getOrDefault("X-Amz-Credential")
  valid_617859 = validateParameter(valid_617859, JString, required = false,
                                 default = nil)
  if valid_617859 != nil:
    section.add "X-Amz-Credential", valid_617859
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  section = newJObject()
  var valid_617860 = formData.getOrDefault("Tags")
  valid_617860 = validateParameter(valid_617860, JArray, required = false,
                                 default = nil)
  if valid_617860 != nil:
    section.add "Tags", valid_617860
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_617861 = formData.getOrDefault("Description")
  valid_617861 = validateParameter(valid_617861, JString, required = true,
                                 default = nil)
  if valid_617861 != nil:
    section.add "Description", valid_617861
  var valid_617862 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_617862 = validateParameter(valid_617862, JString, required = true,
                                 default = nil)
  if valid_617862 != nil:
    section.add "ClusterSecurityGroupName", valid_617862
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617863: Call_PostCreateClusterSecurityGroup_617848;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617863.validator(path, query, header, formData, body, _)
  let scheme = call_617863.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617863.url(scheme.get, call_617863.host, call_617863.base,
                         call_617863.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617863, url, valid, _)

proc call*(call_617864: Call_PostCreateClusterSecurityGroup_617848;
          Description: string; ClusterSecurityGroupName: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  var query_617865 = newJObject()
  var formData_617866 = newJObject()
  if Tags != nil:
    formData_617866.add "Tags", Tags
  add(query_617865, "Action", newJString(Action))
  add(query_617865, "Version", newJString(Version))
  add(formData_617866, "Description", newJString(Description))
  add(formData_617866, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_617864.call(nil, query_617865, nil, formData_617866, nil)

var postCreateClusterSecurityGroup* = Call_PostCreateClusterSecurityGroup_617848(
    name: "postCreateClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_PostCreateClusterSecurityGroup_617849, base: "/",
    url: url_PostCreateClusterSecurityGroup_617850,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSecurityGroup_617830 = ref object of OpenApiRestCall_616850
proc url_GetCreateClusterSecurityGroup_617832(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSecurityGroup_617831(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_617833 = query.getOrDefault("ClusterSecurityGroupName")
  valid_617833 = validateParameter(valid_617833, JString, required = true,
                                 default = nil)
  if valid_617833 != nil:
    section.add "ClusterSecurityGroupName", valid_617833
  var valid_617834 = query.getOrDefault("Description")
  valid_617834 = validateParameter(valid_617834, JString, required = true,
                                 default = nil)
  if valid_617834 != nil:
    section.add "Description", valid_617834
  var valid_617835 = query.getOrDefault("Tags")
  valid_617835 = validateParameter(valid_617835, JArray, required = false,
                                 default = nil)
  if valid_617835 != nil:
    section.add "Tags", valid_617835
  var valid_617836 = query.getOrDefault("Action")
  valid_617836 = validateParameter(valid_617836, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_617836 != nil:
    section.add "Action", valid_617836
  var valid_617837 = query.getOrDefault("Version")
  valid_617837 = validateParameter(valid_617837, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617837 != nil:
    section.add "Version", valid_617837
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617838 = header.getOrDefault("X-Amz-Date")
  valid_617838 = validateParameter(valid_617838, JString, required = false,
                                 default = nil)
  if valid_617838 != nil:
    section.add "X-Amz-Date", valid_617838
  var valid_617839 = header.getOrDefault("X-Amz-Security-Token")
  valid_617839 = validateParameter(valid_617839, JString, required = false,
                                 default = nil)
  if valid_617839 != nil:
    section.add "X-Amz-Security-Token", valid_617839
  var valid_617840 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617840 = validateParameter(valid_617840, JString, required = false,
                                 default = nil)
  if valid_617840 != nil:
    section.add "X-Amz-Content-Sha256", valid_617840
  var valid_617841 = header.getOrDefault("X-Amz-Algorithm")
  valid_617841 = validateParameter(valid_617841, JString, required = false,
                                 default = nil)
  if valid_617841 != nil:
    section.add "X-Amz-Algorithm", valid_617841
  var valid_617842 = header.getOrDefault("X-Amz-Signature")
  valid_617842 = validateParameter(valid_617842, JString, required = false,
                                 default = nil)
  if valid_617842 != nil:
    section.add "X-Amz-Signature", valid_617842
  var valid_617843 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617843 = validateParameter(valid_617843, JString, required = false,
                                 default = nil)
  if valid_617843 != nil:
    section.add "X-Amz-SignedHeaders", valid_617843
  var valid_617844 = header.getOrDefault("X-Amz-Credential")
  valid_617844 = validateParameter(valid_617844, JString, required = false,
                                 default = nil)
  if valid_617844 != nil:
    section.add "X-Amz-Credential", valid_617844
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617845: Call_GetCreateClusterSecurityGroup_617830;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617845.validator(path, query, header, formData, body, _)
  let scheme = call_617845.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617845.url(scheme.get, call_617845.host, call_617845.base,
                         call_617845.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617845, url, valid, _)

proc call*(call_617846: Call_GetCreateClusterSecurityGroup_617830;
          ClusterSecurityGroupName: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_617847 = newJObject()
  add(query_617847, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_617847, "Description", newJString(Description))
  if Tags != nil:
    query_617847.add "Tags", Tags
  add(query_617847, "Action", newJString(Action))
  add(query_617847, "Version", newJString(Version))
  result = call_617846.call(nil, query_617847, nil, nil, nil)

var getCreateClusterSecurityGroup* = Call_GetCreateClusterSecurityGroup_617830(
    name: "getCreateClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_GetCreateClusterSecurityGroup_617831, base: "/",
    url: url_GetCreateClusterSecurityGroup_617832,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSnapshot_617886 = ref object of OpenApiRestCall_616850
proc url_PostCreateClusterSnapshot_617888(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSnapshot_617887(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617889 = query.getOrDefault("Action")
  valid_617889 = validateParameter(valid_617889, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_617889 != nil:
    section.add "Action", valid_617889
  var valid_617890 = query.getOrDefault("Version")
  valid_617890 = validateParameter(valid_617890, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617890 != nil:
    section.add "Version", valid_617890
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617891 = header.getOrDefault("X-Amz-Date")
  valid_617891 = validateParameter(valid_617891, JString, required = false,
                                 default = nil)
  if valid_617891 != nil:
    section.add "X-Amz-Date", valid_617891
  var valid_617892 = header.getOrDefault("X-Amz-Security-Token")
  valid_617892 = validateParameter(valid_617892, JString, required = false,
                                 default = nil)
  if valid_617892 != nil:
    section.add "X-Amz-Security-Token", valid_617892
  var valid_617893 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617893 = validateParameter(valid_617893, JString, required = false,
                                 default = nil)
  if valid_617893 != nil:
    section.add "X-Amz-Content-Sha256", valid_617893
  var valid_617894 = header.getOrDefault("X-Amz-Algorithm")
  valid_617894 = validateParameter(valid_617894, JString, required = false,
                                 default = nil)
  if valid_617894 != nil:
    section.add "X-Amz-Algorithm", valid_617894
  var valid_617895 = header.getOrDefault("X-Amz-Signature")
  valid_617895 = validateParameter(valid_617895, JString, required = false,
                                 default = nil)
  if valid_617895 != nil:
    section.add "X-Amz-Signature", valid_617895
  var valid_617896 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617896 = validateParameter(valid_617896, JString, required = false,
                                 default = nil)
  if valid_617896 != nil:
    section.add "X-Amz-SignedHeaders", valid_617896
  var valid_617897 = header.getOrDefault("X-Amz-Credential")
  valid_617897 = validateParameter(valid_617897, JString, required = false,
                                 default = nil)
  if valid_617897 != nil:
    section.add "X-Amz-Credential", valid_617897
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_617898 = formData.getOrDefault("Tags")
  valid_617898 = validateParameter(valid_617898, JArray, required = false,
                                 default = nil)
  if valid_617898 != nil:
    section.add "Tags", valid_617898
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_617899 = formData.getOrDefault("ClusterIdentifier")
  valid_617899 = validateParameter(valid_617899, JString, required = true,
                                 default = nil)
  if valid_617899 != nil:
    section.add "ClusterIdentifier", valid_617899
  var valid_617900 = formData.getOrDefault("SnapshotIdentifier")
  valid_617900 = validateParameter(valid_617900, JString, required = true,
                                 default = nil)
  if valid_617900 != nil:
    section.add "SnapshotIdentifier", valid_617900
  var valid_617901 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_617901 = validateParameter(valid_617901, JInt, required = false, default = nil)
  if valid_617901 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_617901
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617902: Call_PostCreateClusterSnapshot_617886;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617902.validator(path, query, header, formData, body, _)
  let scheme = call_617902.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617902.url(scheme.get, call_617902.host, call_617902.base,
                         call_617902.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617902, url, valid, _)

proc call*(call_617903: Call_PostCreateClusterSnapshot_617886;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSnapshot";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  var query_617904 = newJObject()
  var formData_617905 = newJObject()
  if Tags != nil:
    formData_617905.add "Tags", Tags
  add(query_617904, "Action", newJString(Action))
  add(formData_617905, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_617905, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_617905, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_617904, "Version", newJString(Version))
  result = call_617903.call(nil, query_617904, nil, formData_617905, nil)

var postCreateClusterSnapshot* = Call_PostCreateClusterSnapshot_617886(
    name: "postCreateClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_PostCreateClusterSnapshot_617887, base: "/",
    url: url_PostCreateClusterSnapshot_617888,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSnapshot_617867 = ref object of OpenApiRestCall_616850
proc url_GetCreateClusterSnapshot_617869(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSnapshot_617868(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_617870 = query.getOrDefault("Tags")
  valid_617870 = validateParameter(valid_617870, JArray, required = false,
                                 default = nil)
  if valid_617870 != nil:
    section.add "Tags", valid_617870
  var valid_617871 = query.getOrDefault("Action")
  valid_617871 = validateParameter(valid_617871, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_617871 != nil:
    section.add "Action", valid_617871
  var valid_617872 = query.getOrDefault("ClusterIdentifier")
  valid_617872 = validateParameter(valid_617872, JString, required = true,
                                 default = nil)
  if valid_617872 != nil:
    section.add "ClusterIdentifier", valid_617872
  var valid_617873 = query.getOrDefault("SnapshotIdentifier")
  valid_617873 = validateParameter(valid_617873, JString, required = true,
                                 default = nil)
  if valid_617873 != nil:
    section.add "SnapshotIdentifier", valid_617873
  var valid_617874 = query.getOrDefault("Version")
  valid_617874 = validateParameter(valid_617874, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617874 != nil:
    section.add "Version", valid_617874
  var valid_617875 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_617875 = validateParameter(valid_617875, JInt, required = false, default = nil)
  if valid_617875 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_617875
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617876 = header.getOrDefault("X-Amz-Date")
  valid_617876 = validateParameter(valid_617876, JString, required = false,
                                 default = nil)
  if valid_617876 != nil:
    section.add "X-Amz-Date", valid_617876
  var valid_617877 = header.getOrDefault("X-Amz-Security-Token")
  valid_617877 = validateParameter(valid_617877, JString, required = false,
                                 default = nil)
  if valid_617877 != nil:
    section.add "X-Amz-Security-Token", valid_617877
  var valid_617878 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617878 = validateParameter(valid_617878, JString, required = false,
                                 default = nil)
  if valid_617878 != nil:
    section.add "X-Amz-Content-Sha256", valid_617878
  var valid_617879 = header.getOrDefault("X-Amz-Algorithm")
  valid_617879 = validateParameter(valid_617879, JString, required = false,
                                 default = nil)
  if valid_617879 != nil:
    section.add "X-Amz-Algorithm", valid_617879
  var valid_617880 = header.getOrDefault("X-Amz-Signature")
  valid_617880 = validateParameter(valid_617880, JString, required = false,
                                 default = nil)
  if valid_617880 != nil:
    section.add "X-Amz-Signature", valid_617880
  var valid_617881 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617881 = validateParameter(valid_617881, JString, required = false,
                                 default = nil)
  if valid_617881 != nil:
    section.add "X-Amz-SignedHeaders", valid_617881
  var valid_617882 = header.getOrDefault("X-Amz-Credential")
  valid_617882 = validateParameter(valid_617882, JString, required = false,
                                 default = nil)
  if valid_617882 != nil:
    section.add "X-Amz-Credential", valid_617882
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617883: Call_GetCreateClusterSnapshot_617867; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617883.validator(path, query, header, formData, body, _)
  let scheme = call_617883.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617883.url(scheme.get, call_617883.host, call_617883.base,
                         call_617883.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617883, url, valid, _)

proc call*(call_617884: Call_GetCreateClusterSnapshot_617867;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSnapshot";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_617885 = newJObject()
  if Tags != nil:
    query_617885.add "Tags", Tags
  add(query_617885, "Action", newJString(Action))
  add(query_617885, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_617885, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_617885, "Version", newJString(Version))
  add(query_617885, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_617884.call(nil, query_617885, nil, nil, nil)

var getCreateClusterSnapshot* = Call_GetCreateClusterSnapshot_617867(
    name: "getCreateClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_GetCreateClusterSnapshot_617868, base: "/",
    url: url_GetCreateClusterSnapshot_617869, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSubnetGroup_617925 = ref object of OpenApiRestCall_616850
proc url_PostCreateClusterSubnetGroup_617927(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSubnetGroup_617926(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617928 = query.getOrDefault("Action")
  valid_617928 = validateParameter(valid_617928, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_617928 != nil:
    section.add "Action", valid_617928
  var valid_617929 = query.getOrDefault("Version")
  valid_617929 = validateParameter(valid_617929, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617929 != nil:
    section.add "Version", valid_617929
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617930 = header.getOrDefault("X-Amz-Date")
  valid_617930 = validateParameter(valid_617930, JString, required = false,
                                 default = nil)
  if valid_617930 != nil:
    section.add "X-Amz-Date", valid_617930
  var valid_617931 = header.getOrDefault("X-Amz-Security-Token")
  valid_617931 = validateParameter(valid_617931, JString, required = false,
                                 default = nil)
  if valid_617931 != nil:
    section.add "X-Amz-Security-Token", valid_617931
  var valid_617932 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617932 = validateParameter(valid_617932, JString, required = false,
                                 default = nil)
  if valid_617932 != nil:
    section.add "X-Amz-Content-Sha256", valid_617932
  var valid_617933 = header.getOrDefault("X-Amz-Algorithm")
  valid_617933 = validateParameter(valid_617933, JString, required = false,
                                 default = nil)
  if valid_617933 != nil:
    section.add "X-Amz-Algorithm", valid_617933
  var valid_617934 = header.getOrDefault("X-Amz-Signature")
  valid_617934 = validateParameter(valid_617934, JString, required = false,
                                 default = nil)
  if valid_617934 != nil:
    section.add "X-Amz-Signature", valid_617934
  var valid_617935 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617935 = validateParameter(valid_617935, JString, required = false,
                                 default = nil)
  if valid_617935 != nil:
    section.add "X-Amz-SignedHeaders", valid_617935
  var valid_617936 = header.getOrDefault("X-Amz-Credential")
  valid_617936 = validateParameter(valid_617936, JString, required = false,
                                 default = nil)
  if valid_617936 != nil:
    section.add "X-Amz-Credential", valid_617936
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  section = newJObject()
  var valid_617937 = formData.getOrDefault("Tags")
  valid_617937 = validateParameter(valid_617937, JArray, required = false,
                                 default = nil)
  if valid_617937 != nil:
    section.add "Tags", valid_617937
  assert formData != nil,
        "formData argument is necessary due to required `SubnetIds` field"
  var valid_617938 = formData.getOrDefault("SubnetIds")
  valid_617938 = validateParameter(valid_617938, JArray, required = true, default = nil)
  if valid_617938 != nil:
    section.add "SubnetIds", valid_617938
  var valid_617939 = formData.getOrDefault("Description")
  valid_617939 = validateParameter(valid_617939, JString, required = true,
                                 default = nil)
  if valid_617939 != nil:
    section.add "Description", valid_617939
  var valid_617940 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_617940 = validateParameter(valid_617940, JString, required = true,
                                 default = nil)
  if valid_617940 != nil:
    section.add "ClusterSubnetGroupName", valid_617940
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617941: Call_PostCreateClusterSubnetGroup_617925;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617941.validator(path, query, header, formData, body, _)
  let scheme = call_617941.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617941.url(scheme.get, call_617941.host, call_617941.base,
                         call_617941.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617941, url, valid, _)

proc call*(call_617942: Call_PostCreateClusterSubnetGroup_617925;
          SubnetIds: JsonNode; Description: string; ClusterSubnetGroupName: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  var query_617943 = newJObject()
  var formData_617944 = newJObject()
  if Tags != nil:
    formData_617944.add "Tags", Tags
  if SubnetIds != nil:
    formData_617944.add "SubnetIds", SubnetIds
  add(query_617943, "Action", newJString(Action))
  add(query_617943, "Version", newJString(Version))
  add(formData_617944, "Description", newJString(Description))
  add(formData_617944, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_617942.call(nil, query_617943, nil, formData_617944, nil)

var postCreateClusterSubnetGroup* = Call_PostCreateClusterSubnetGroup_617925(
    name: "postCreateClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_PostCreateClusterSubnetGroup_617926, base: "/",
    url: url_PostCreateClusterSubnetGroup_617927,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSubnetGroup_617906 = ref object of OpenApiRestCall_616850
proc url_GetCreateClusterSubnetGroup_617908(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSubnetGroup_617907(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_617909 = query.getOrDefault("ClusterSubnetGroupName")
  valid_617909 = validateParameter(valid_617909, JString, required = true,
                                 default = nil)
  if valid_617909 != nil:
    section.add "ClusterSubnetGroupName", valid_617909
  var valid_617910 = query.getOrDefault("Description")
  valid_617910 = validateParameter(valid_617910, JString, required = true,
                                 default = nil)
  if valid_617910 != nil:
    section.add "Description", valid_617910
  var valid_617911 = query.getOrDefault("Tags")
  valid_617911 = validateParameter(valid_617911, JArray, required = false,
                                 default = nil)
  if valid_617911 != nil:
    section.add "Tags", valid_617911
  var valid_617912 = query.getOrDefault("Action")
  valid_617912 = validateParameter(valid_617912, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_617912 != nil:
    section.add "Action", valid_617912
  var valid_617913 = query.getOrDefault("SubnetIds")
  valid_617913 = validateParameter(valid_617913, JArray, required = true, default = nil)
  if valid_617913 != nil:
    section.add "SubnetIds", valid_617913
  var valid_617914 = query.getOrDefault("Version")
  valid_617914 = validateParameter(valid_617914, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617914 != nil:
    section.add "Version", valid_617914
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617915 = header.getOrDefault("X-Amz-Date")
  valid_617915 = validateParameter(valid_617915, JString, required = false,
                                 default = nil)
  if valid_617915 != nil:
    section.add "X-Amz-Date", valid_617915
  var valid_617916 = header.getOrDefault("X-Amz-Security-Token")
  valid_617916 = validateParameter(valid_617916, JString, required = false,
                                 default = nil)
  if valid_617916 != nil:
    section.add "X-Amz-Security-Token", valid_617916
  var valid_617917 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617917 = validateParameter(valid_617917, JString, required = false,
                                 default = nil)
  if valid_617917 != nil:
    section.add "X-Amz-Content-Sha256", valid_617917
  var valid_617918 = header.getOrDefault("X-Amz-Algorithm")
  valid_617918 = validateParameter(valid_617918, JString, required = false,
                                 default = nil)
  if valid_617918 != nil:
    section.add "X-Amz-Algorithm", valid_617918
  var valid_617919 = header.getOrDefault("X-Amz-Signature")
  valid_617919 = validateParameter(valid_617919, JString, required = false,
                                 default = nil)
  if valid_617919 != nil:
    section.add "X-Amz-Signature", valid_617919
  var valid_617920 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617920 = validateParameter(valid_617920, JString, required = false,
                                 default = nil)
  if valid_617920 != nil:
    section.add "X-Amz-SignedHeaders", valid_617920
  var valid_617921 = header.getOrDefault("X-Amz-Credential")
  valid_617921 = validateParameter(valid_617921, JString, required = false,
                                 default = nil)
  if valid_617921 != nil:
    section.add "X-Amz-Credential", valid_617921
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617922: Call_GetCreateClusterSubnetGroup_617906;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_617922.validator(path, query, header, formData, body, _)
  let scheme = call_617922.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617922.url(scheme.get, call_617922.host, call_617922.base,
                         call_617922.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617922, url, valid, _)

proc call*(call_617923: Call_GetCreateClusterSubnetGroup_617906;
          ClusterSubnetGroupName: string; Description: string; SubnetIds: JsonNode;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: string (required)
  var query_617924 = newJObject()
  add(query_617924, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_617924, "Description", newJString(Description))
  if Tags != nil:
    query_617924.add "Tags", Tags
  add(query_617924, "Action", newJString(Action))
  if SubnetIds != nil:
    query_617924.add "SubnetIds", SubnetIds
  add(query_617924, "Version", newJString(Version))
  result = call_617923.call(nil, query_617924, nil, nil, nil)

var getCreateClusterSubnetGroup* = Call_GetCreateClusterSubnetGroup_617906(
    name: "getCreateClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_GetCreateClusterSubnetGroup_617907, base: "/",
    url: url_GetCreateClusterSubnetGroup_617908,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateEventSubscription_617968 = ref object of OpenApiRestCall_616850
proc url_PostCreateEventSubscription_617970(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateEventSubscription_617969(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_617971 = query.getOrDefault("Action")
  valid_617971 = validateParameter(valid_617971, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_617971 != nil:
    section.add "Action", valid_617971
  var valid_617972 = query.getOrDefault("Version")
  valid_617972 = validateParameter(valid_617972, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617972 != nil:
    section.add "Version", valid_617972
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617973 = header.getOrDefault("X-Amz-Date")
  valid_617973 = validateParameter(valid_617973, JString, required = false,
                                 default = nil)
  if valid_617973 != nil:
    section.add "X-Amz-Date", valid_617973
  var valid_617974 = header.getOrDefault("X-Amz-Security-Token")
  valid_617974 = validateParameter(valid_617974, JString, required = false,
                                 default = nil)
  if valid_617974 != nil:
    section.add "X-Amz-Security-Token", valid_617974
  var valid_617975 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617975 = validateParameter(valid_617975, JString, required = false,
                                 default = nil)
  if valid_617975 != nil:
    section.add "X-Amz-Content-Sha256", valid_617975
  var valid_617976 = header.getOrDefault("X-Amz-Algorithm")
  valid_617976 = validateParameter(valid_617976, JString, required = false,
                                 default = nil)
  if valid_617976 != nil:
    section.add "X-Amz-Algorithm", valid_617976
  var valid_617977 = header.getOrDefault("X-Amz-Signature")
  valid_617977 = validateParameter(valid_617977, JString, required = false,
                                 default = nil)
  if valid_617977 != nil:
    section.add "X-Amz-Signature", valid_617977
  var valid_617978 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617978 = validateParameter(valid_617978, JString, required = false,
                                 default = nil)
  if valid_617978 != nil:
    section.add "X-Amz-SignedHeaders", valid_617978
  var valid_617979 = header.getOrDefault("X-Amz-Credential")
  valid_617979 = validateParameter(valid_617979, JString, required = false,
                                 default = nil)
  if valid_617979 != nil:
    section.add "X-Amz-Credential", valid_617979
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  section = newJObject()
  var valid_617980 = formData.getOrDefault("Enabled")
  valid_617980 = validateParameter(valid_617980, JBool, required = false, default = nil)
  if valid_617980 != nil:
    section.add "Enabled", valid_617980
  var valid_617981 = formData.getOrDefault("EventCategories")
  valid_617981 = validateParameter(valid_617981, JArray, required = false,
                                 default = nil)
  if valid_617981 != nil:
    section.add "EventCategories", valid_617981
  assert formData != nil,
        "formData argument is necessary due to required `SnsTopicArn` field"
  var valid_617982 = formData.getOrDefault("SnsTopicArn")
  valid_617982 = validateParameter(valid_617982, JString, required = true,
                                 default = nil)
  if valid_617982 != nil:
    section.add "SnsTopicArn", valid_617982
  var valid_617983 = formData.getOrDefault("Severity")
  valid_617983 = validateParameter(valid_617983, JString, required = false,
                                 default = nil)
  if valid_617983 != nil:
    section.add "Severity", valid_617983
  var valid_617984 = formData.getOrDefault("SourceIds")
  valid_617984 = validateParameter(valid_617984, JArray, required = false,
                                 default = nil)
  if valid_617984 != nil:
    section.add "SourceIds", valid_617984
  var valid_617985 = formData.getOrDefault("Tags")
  valid_617985 = validateParameter(valid_617985, JArray, required = false,
                                 default = nil)
  if valid_617985 != nil:
    section.add "Tags", valid_617985
  var valid_617986 = formData.getOrDefault("SubscriptionName")
  valid_617986 = validateParameter(valid_617986, JString, required = true,
                                 default = nil)
  if valid_617986 != nil:
    section.add "SubscriptionName", valid_617986
  var valid_617987 = formData.getOrDefault("SourceType")
  valid_617987 = validateParameter(valid_617987, JString, required = false,
                                 default = nil)
  if valid_617987 != nil:
    section.add "SourceType", valid_617987
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617988: Call_PostCreateEventSubscription_617968;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_617988.validator(path, query, header, formData, body, _)
  let scheme = call_617988.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617988.url(scheme.get, call_617988.host, call_617988.base,
                         call_617988.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617988, url, valid, _)

proc call*(call_617989: Call_PostCreateEventSubscription_617968;
          SnsTopicArn: string; SubscriptionName: string; Enabled: bool = false;
          EventCategories: JsonNode = nil; Severity: string = "";
          SourceIds: JsonNode = nil; Tags: JsonNode = nil;
          Action: string = "CreateEventSubscription";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  var query_617990 = newJObject()
  var formData_617991 = newJObject()
  add(formData_617991, "Enabled", newJBool(Enabled))
  if EventCategories != nil:
    formData_617991.add "EventCategories", EventCategories
  add(formData_617991, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_617991, "Severity", newJString(Severity))
  if SourceIds != nil:
    formData_617991.add "SourceIds", SourceIds
  if Tags != nil:
    formData_617991.add "Tags", Tags
  add(formData_617991, "SubscriptionName", newJString(SubscriptionName))
  add(query_617990, "Action", newJString(Action))
  add(query_617990, "Version", newJString(Version))
  add(formData_617991, "SourceType", newJString(SourceType))
  result = call_617989.call(nil, query_617990, nil, formData_617991, nil)

var postCreateEventSubscription* = Call_PostCreateEventSubscription_617968(
    name: "postCreateEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_PostCreateEventSubscription_617969, base: "/",
    url: url_PostCreateEventSubscription_617970,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateEventSubscription_617945 = ref object of OpenApiRestCall_616850
proc url_GetCreateEventSubscription_617947(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateEventSubscription_617946(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_617948 = query.getOrDefault("SourceType")
  valid_617948 = validateParameter(valid_617948, JString, required = false,
                                 default = nil)
  if valid_617948 != nil:
    section.add "SourceType", valid_617948
  var valid_617949 = query.getOrDefault("SourceIds")
  valid_617949 = validateParameter(valid_617949, JArray, required = false,
                                 default = nil)
  if valid_617949 != nil:
    section.add "SourceIds", valid_617949
  var valid_617950 = query.getOrDefault("Enabled")
  valid_617950 = validateParameter(valid_617950, JBool, required = false, default = nil)
  if valid_617950 != nil:
    section.add "Enabled", valid_617950
  var valid_617951 = query.getOrDefault("Tags")
  valid_617951 = validateParameter(valid_617951, JArray, required = false,
                                 default = nil)
  if valid_617951 != nil:
    section.add "Tags", valid_617951
  var valid_617952 = query.getOrDefault("Action")
  valid_617952 = validateParameter(valid_617952, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_617952 != nil:
    section.add "Action", valid_617952
  var valid_617953 = query.getOrDefault("SnsTopicArn")
  valid_617953 = validateParameter(valid_617953, JString, required = true,
                                 default = nil)
  if valid_617953 != nil:
    section.add "SnsTopicArn", valid_617953
  var valid_617954 = query.getOrDefault("EventCategories")
  valid_617954 = validateParameter(valid_617954, JArray, required = false,
                                 default = nil)
  if valid_617954 != nil:
    section.add "EventCategories", valid_617954
  var valid_617955 = query.getOrDefault("SubscriptionName")
  valid_617955 = validateParameter(valid_617955, JString, required = true,
                                 default = nil)
  if valid_617955 != nil:
    section.add "SubscriptionName", valid_617955
  var valid_617956 = query.getOrDefault("Severity")
  valid_617956 = validateParameter(valid_617956, JString, required = false,
                                 default = nil)
  if valid_617956 != nil:
    section.add "Severity", valid_617956
  var valid_617957 = query.getOrDefault("Version")
  valid_617957 = validateParameter(valid_617957, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617957 != nil:
    section.add "Version", valid_617957
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617958 = header.getOrDefault("X-Amz-Date")
  valid_617958 = validateParameter(valid_617958, JString, required = false,
                                 default = nil)
  if valid_617958 != nil:
    section.add "X-Amz-Date", valid_617958
  var valid_617959 = header.getOrDefault("X-Amz-Security-Token")
  valid_617959 = validateParameter(valid_617959, JString, required = false,
                                 default = nil)
  if valid_617959 != nil:
    section.add "X-Amz-Security-Token", valid_617959
  var valid_617960 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_617960 = validateParameter(valid_617960, JString, required = false,
                                 default = nil)
  if valid_617960 != nil:
    section.add "X-Amz-Content-Sha256", valid_617960
  var valid_617961 = header.getOrDefault("X-Amz-Algorithm")
  valid_617961 = validateParameter(valid_617961, JString, required = false,
                                 default = nil)
  if valid_617961 != nil:
    section.add "X-Amz-Algorithm", valid_617961
  var valid_617962 = header.getOrDefault("X-Amz-Signature")
  valid_617962 = validateParameter(valid_617962, JString, required = false,
                                 default = nil)
  if valid_617962 != nil:
    section.add "X-Amz-Signature", valid_617962
  var valid_617963 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_617963 = validateParameter(valid_617963, JString, required = false,
                                 default = nil)
  if valid_617963 != nil:
    section.add "X-Amz-SignedHeaders", valid_617963
  var valid_617964 = header.getOrDefault("X-Amz-Credential")
  valid_617964 = validateParameter(valid_617964, JString, required = false,
                                 default = nil)
  if valid_617964 != nil:
    section.add "X-Amz-Credential", valid_617964
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_617965: Call_GetCreateEventSubscription_617945;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_617965.validator(path, query, header, formData, body, _)
  let scheme = call_617965.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_617965.url(scheme.get, call_617965.host, call_617965.base,
                         call_617965.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_617965, url, valid, _)

proc call*(call_617966: Call_GetCreateEventSubscription_617945;
          SnsTopicArn: string; SubscriptionName: string; SourceType: string = "";
          SourceIds: JsonNode = nil; Enabled: bool = false; Tags: JsonNode = nil;
          Action: string = "CreateEventSubscription";
          EventCategories: JsonNode = nil; Severity: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: string (required)
  var query_617967 = newJObject()
  add(query_617967, "SourceType", newJString(SourceType))
  if SourceIds != nil:
    query_617967.add "SourceIds", SourceIds
  add(query_617967, "Enabled", newJBool(Enabled))
  if Tags != nil:
    query_617967.add "Tags", Tags
  add(query_617967, "Action", newJString(Action))
  add(query_617967, "SnsTopicArn", newJString(SnsTopicArn))
  if EventCategories != nil:
    query_617967.add "EventCategories", EventCategories
  add(query_617967, "SubscriptionName", newJString(SubscriptionName))
  add(query_617967, "Severity", newJString(Severity))
  add(query_617967, "Version", newJString(Version))
  result = call_617966.call(nil, query_617967, nil, nil, nil)

var getCreateEventSubscription* = Call_GetCreateEventSubscription_617945(
    name: "getCreateEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_GetCreateEventSubscription_617946, base: "/",
    url: url_GetCreateEventSubscription_617947,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmClientCertificate_618009 = ref object of OpenApiRestCall_616850
proc url_PostCreateHsmClientCertificate_618011(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmClientCertificate_618010(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618012 = query.getOrDefault("Action")
  valid_618012 = validateParameter(valid_618012, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_618012 != nil:
    section.add "Action", valid_618012
  var valid_618013 = query.getOrDefault("Version")
  valid_618013 = validateParameter(valid_618013, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618013 != nil:
    section.add "Version", valid_618013
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618014 = header.getOrDefault("X-Amz-Date")
  valid_618014 = validateParameter(valid_618014, JString, required = false,
                                 default = nil)
  if valid_618014 != nil:
    section.add "X-Amz-Date", valid_618014
  var valid_618015 = header.getOrDefault("X-Amz-Security-Token")
  valid_618015 = validateParameter(valid_618015, JString, required = false,
                                 default = nil)
  if valid_618015 != nil:
    section.add "X-Amz-Security-Token", valid_618015
  var valid_618016 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618016 = validateParameter(valid_618016, JString, required = false,
                                 default = nil)
  if valid_618016 != nil:
    section.add "X-Amz-Content-Sha256", valid_618016
  var valid_618017 = header.getOrDefault("X-Amz-Algorithm")
  valid_618017 = validateParameter(valid_618017, JString, required = false,
                                 default = nil)
  if valid_618017 != nil:
    section.add "X-Amz-Algorithm", valid_618017
  var valid_618018 = header.getOrDefault("X-Amz-Signature")
  valid_618018 = validateParameter(valid_618018, JString, required = false,
                                 default = nil)
  if valid_618018 != nil:
    section.add "X-Amz-Signature", valid_618018
  var valid_618019 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618019 = validateParameter(valid_618019, JString, required = false,
                                 default = nil)
  if valid_618019 != nil:
    section.add "X-Amz-SignedHeaders", valid_618019
  var valid_618020 = header.getOrDefault("X-Amz-Credential")
  valid_618020 = validateParameter(valid_618020, JString, required = false,
                                 default = nil)
  if valid_618020 != nil:
    section.add "X-Amz-Credential", valid_618020
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  section = newJObject()
  var valid_618021 = formData.getOrDefault("Tags")
  valid_618021 = validateParameter(valid_618021, JArray, required = false,
                                 default = nil)
  if valid_618021 != nil:
    section.add "Tags", valid_618021
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_618022 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_618022 = validateParameter(valid_618022, JString, required = true,
                                 default = nil)
  if valid_618022 != nil:
    section.add "HsmClientCertificateIdentifier", valid_618022
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618023: Call_PostCreateHsmClientCertificate_618009;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_618023.validator(path, query, header, formData, body, _)
  let scheme = call_618023.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618023.url(scheme.get, call_618023.host, call_618023.base,
                         call_618023.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618023, url, valid, _)

proc call*(call_618024: Call_PostCreateHsmClientCertificate_618009;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Version: string (required)
  var query_618025 = newJObject()
  var formData_618026 = newJObject()
  if Tags != nil:
    formData_618026.add "Tags", Tags
  add(query_618025, "Action", newJString(Action))
  add(formData_618026, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_618025, "Version", newJString(Version))
  result = call_618024.call(nil, query_618025, nil, formData_618026, nil)

var postCreateHsmClientCertificate* = Call_PostCreateHsmClientCertificate_618009(
    name: "postCreateHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_PostCreateHsmClientCertificate_618010, base: "/",
    url: url_PostCreateHsmClientCertificate_618011,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmClientCertificate_617992 = ref object of OpenApiRestCall_616850
proc url_GetCreateHsmClientCertificate_617994(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmClientCertificate_617993(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_617995 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_617995 = validateParameter(valid_617995, JString, required = true,
                                 default = nil)
  if valid_617995 != nil:
    section.add "HsmClientCertificateIdentifier", valid_617995
  var valid_617996 = query.getOrDefault("Tags")
  valid_617996 = validateParameter(valid_617996, JArray, required = false,
                                 default = nil)
  if valid_617996 != nil:
    section.add "Tags", valid_617996
  var valid_617997 = query.getOrDefault("Action")
  valid_617997 = validateParameter(valid_617997, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_617997 != nil:
    section.add "Action", valid_617997
  var valid_617998 = query.getOrDefault("Version")
  valid_617998 = validateParameter(valid_617998, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_617998 != nil:
    section.add "Version", valid_617998
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_617999 = header.getOrDefault("X-Amz-Date")
  valid_617999 = validateParameter(valid_617999, JString, required = false,
                                 default = nil)
  if valid_617999 != nil:
    section.add "X-Amz-Date", valid_617999
  var valid_618000 = header.getOrDefault("X-Amz-Security-Token")
  valid_618000 = validateParameter(valid_618000, JString, required = false,
                                 default = nil)
  if valid_618000 != nil:
    section.add "X-Amz-Security-Token", valid_618000
  var valid_618001 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618001 = validateParameter(valid_618001, JString, required = false,
                                 default = nil)
  if valid_618001 != nil:
    section.add "X-Amz-Content-Sha256", valid_618001
  var valid_618002 = header.getOrDefault("X-Amz-Algorithm")
  valid_618002 = validateParameter(valid_618002, JString, required = false,
                                 default = nil)
  if valid_618002 != nil:
    section.add "X-Amz-Algorithm", valid_618002
  var valid_618003 = header.getOrDefault("X-Amz-Signature")
  valid_618003 = validateParameter(valid_618003, JString, required = false,
                                 default = nil)
  if valid_618003 != nil:
    section.add "X-Amz-Signature", valid_618003
  var valid_618004 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618004 = validateParameter(valid_618004, JString, required = false,
                                 default = nil)
  if valid_618004 != nil:
    section.add "X-Amz-SignedHeaders", valid_618004
  var valid_618005 = header.getOrDefault("X-Amz-Credential")
  valid_618005 = validateParameter(valid_618005, JString, required = false,
                                 default = nil)
  if valid_618005 != nil:
    section.add "X-Amz-Credential", valid_618005
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618006: Call_GetCreateHsmClientCertificate_617992;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_618006.validator(path, query, header, formData, body, _)
  let scheme = call_618006.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618006.url(scheme.get, call_618006.host, call_618006.base,
                         call_618006.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618006, url, valid, _)

proc call*(call_618007: Call_GetCreateHsmClientCertificate_617992;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_618008 = newJObject()
  add(query_618008, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    query_618008.add "Tags", Tags
  add(query_618008, "Action", newJString(Action))
  add(query_618008, "Version", newJString(Version))
  result = call_618007.call(nil, query_618008, nil, nil, nil)

var getCreateHsmClientCertificate* = Call_GetCreateHsmClientCertificate_617992(
    name: "getCreateHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_GetCreateHsmClientCertificate_617993, base: "/",
    url: url_GetCreateHsmClientCertificate_617994,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmConfiguration_618049 = ref object of OpenApiRestCall_616850
proc url_PostCreateHsmConfiguration_618051(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmConfiguration_618050(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618052 = query.getOrDefault("Action")
  valid_618052 = validateParameter(valid_618052, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_618052 != nil:
    section.add "Action", valid_618052
  var valid_618053 = query.getOrDefault("Version")
  valid_618053 = validateParameter(valid_618053, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618053 != nil:
    section.add "Version", valid_618053
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618054 = header.getOrDefault("X-Amz-Date")
  valid_618054 = validateParameter(valid_618054, JString, required = false,
                                 default = nil)
  if valid_618054 != nil:
    section.add "X-Amz-Date", valid_618054
  var valid_618055 = header.getOrDefault("X-Amz-Security-Token")
  valid_618055 = validateParameter(valid_618055, JString, required = false,
                                 default = nil)
  if valid_618055 != nil:
    section.add "X-Amz-Security-Token", valid_618055
  var valid_618056 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618056 = validateParameter(valid_618056, JString, required = false,
                                 default = nil)
  if valid_618056 != nil:
    section.add "X-Amz-Content-Sha256", valid_618056
  var valid_618057 = header.getOrDefault("X-Amz-Algorithm")
  valid_618057 = validateParameter(valid_618057, JString, required = false,
                                 default = nil)
  if valid_618057 != nil:
    section.add "X-Amz-Algorithm", valid_618057
  var valid_618058 = header.getOrDefault("X-Amz-Signature")
  valid_618058 = validateParameter(valid_618058, JString, required = false,
                                 default = nil)
  if valid_618058 != nil:
    section.add "X-Amz-Signature", valid_618058
  var valid_618059 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618059 = validateParameter(valid_618059, JString, required = false,
                                 default = nil)
  if valid_618059 != nil:
    section.add "X-Amz-SignedHeaders", valid_618059
  var valid_618060 = header.getOrDefault("X-Amz-Credential")
  valid_618060 = validateParameter(valid_618060, JString, required = false,
                                 default = nil)
  if valid_618060 != nil:
    section.add "X-Amz-Credential", valid_618060
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `HsmIpAddress` field"
  var valid_618061 = formData.getOrDefault("HsmIpAddress")
  valid_618061 = validateParameter(valid_618061, JString, required = true,
                                 default = nil)
  if valid_618061 != nil:
    section.add "HsmIpAddress", valid_618061
  var valid_618062 = formData.getOrDefault("HsmPartitionName")
  valid_618062 = validateParameter(valid_618062, JString, required = true,
                                 default = nil)
  if valid_618062 != nil:
    section.add "HsmPartitionName", valid_618062
  var valid_618063 = formData.getOrDefault("Tags")
  valid_618063 = validateParameter(valid_618063, JArray, required = false,
                                 default = nil)
  if valid_618063 != nil:
    section.add "Tags", valid_618063
  var valid_618064 = formData.getOrDefault("HsmPartitionPassword")
  valid_618064 = validateParameter(valid_618064, JString, required = true,
                                 default = nil)
  if valid_618064 != nil:
    section.add "HsmPartitionPassword", valid_618064
  var valid_618065 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_618065 = validateParameter(valid_618065, JString, required = true,
                                 default = nil)
  if valid_618065 != nil:
    section.add "HsmConfigurationIdentifier", valid_618065
  var valid_618066 = formData.getOrDefault("HsmServerPublicCertificate")
  valid_618066 = validateParameter(valid_618066, JString, required = true,
                                 default = nil)
  if valid_618066 != nil:
    section.add "HsmServerPublicCertificate", valid_618066
  var valid_618067 = formData.getOrDefault("Description")
  valid_618067 = validateParameter(valid_618067, JString, required = true,
                                 default = nil)
  if valid_618067 != nil:
    section.add "Description", valid_618067
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618068: Call_PostCreateHsmConfiguration_618049;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_618068.validator(path, query, header, formData, body, _)
  let scheme = call_618068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618068.url(scheme.get, call_618068.host, call_618068.base,
                         call_618068.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618068, url, valid, _)

proc call*(call_618069: Call_PostCreateHsmConfiguration_618049;
          HsmIpAddress: string; HsmPartitionName: string;
          HsmPartitionPassword: string; HsmConfigurationIdentifier: string;
          HsmServerPublicCertificate: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  var query_618070 = newJObject()
  var formData_618071 = newJObject()
  add(formData_618071, "HsmIpAddress", newJString(HsmIpAddress))
  add(formData_618071, "HsmPartitionName", newJString(HsmPartitionName))
  if Tags != nil:
    formData_618071.add "Tags", Tags
  add(formData_618071, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(formData_618071, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_618070, "Action", newJString(Action))
  add(formData_618071, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_618070, "Version", newJString(Version))
  add(formData_618071, "Description", newJString(Description))
  result = call_618069.call(nil, query_618070, nil, formData_618071, nil)

var postCreateHsmConfiguration* = Call_PostCreateHsmConfiguration_618049(
    name: "postCreateHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_PostCreateHsmConfiguration_618050, base: "/",
    url: url_PostCreateHsmConfiguration_618051,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmConfiguration_618027 = ref object of OpenApiRestCall_616850
proc url_GetCreateHsmConfiguration_618029(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmConfiguration_618028(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Action: JString (required)
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Description` field"
  var valid_618030 = query.getOrDefault("Description")
  valid_618030 = validateParameter(valid_618030, JString, required = true,
                                 default = nil)
  if valid_618030 != nil:
    section.add "Description", valid_618030
  var valid_618031 = query.getOrDefault("HsmPartitionName")
  valid_618031 = validateParameter(valid_618031, JString, required = true,
                                 default = nil)
  if valid_618031 != nil:
    section.add "HsmPartitionName", valid_618031
  var valid_618032 = query.getOrDefault("HsmIpAddress")
  valid_618032 = validateParameter(valid_618032, JString, required = true,
                                 default = nil)
  if valid_618032 != nil:
    section.add "HsmIpAddress", valid_618032
  var valid_618033 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_618033 = validateParameter(valid_618033, JString, required = true,
                                 default = nil)
  if valid_618033 != nil:
    section.add "HsmConfigurationIdentifier", valid_618033
  var valid_618034 = query.getOrDefault("Tags")
  valid_618034 = validateParameter(valid_618034, JArray, required = false,
                                 default = nil)
  if valid_618034 != nil:
    section.add "Tags", valid_618034
  var valid_618035 = query.getOrDefault("HsmServerPublicCertificate")
  valid_618035 = validateParameter(valid_618035, JString, required = true,
                                 default = nil)
  if valid_618035 != nil:
    section.add "HsmServerPublicCertificate", valid_618035
  var valid_618036 = query.getOrDefault("Action")
  valid_618036 = validateParameter(valid_618036, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_618036 != nil:
    section.add "Action", valid_618036
  var valid_618037 = query.getOrDefault("HsmPartitionPassword")
  valid_618037 = validateParameter(valid_618037, JString, required = true,
                                 default = nil)
  if valid_618037 != nil:
    section.add "HsmPartitionPassword", valid_618037
  var valid_618038 = query.getOrDefault("Version")
  valid_618038 = validateParameter(valid_618038, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618038 != nil:
    section.add "Version", valid_618038
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618039 = header.getOrDefault("X-Amz-Date")
  valid_618039 = validateParameter(valid_618039, JString, required = false,
                                 default = nil)
  if valid_618039 != nil:
    section.add "X-Amz-Date", valid_618039
  var valid_618040 = header.getOrDefault("X-Amz-Security-Token")
  valid_618040 = validateParameter(valid_618040, JString, required = false,
                                 default = nil)
  if valid_618040 != nil:
    section.add "X-Amz-Security-Token", valid_618040
  var valid_618041 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618041 = validateParameter(valid_618041, JString, required = false,
                                 default = nil)
  if valid_618041 != nil:
    section.add "X-Amz-Content-Sha256", valid_618041
  var valid_618042 = header.getOrDefault("X-Amz-Algorithm")
  valid_618042 = validateParameter(valid_618042, JString, required = false,
                                 default = nil)
  if valid_618042 != nil:
    section.add "X-Amz-Algorithm", valid_618042
  var valid_618043 = header.getOrDefault("X-Amz-Signature")
  valid_618043 = validateParameter(valid_618043, JString, required = false,
                                 default = nil)
  if valid_618043 != nil:
    section.add "X-Amz-Signature", valid_618043
  var valid_618044 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618044 = validateParameter(valid_618044, JString, required = false,
                                 default = nil)
  if valid_618044 != nil:
    section.add "X-Amz-SignedHeaders", valid_618044
  var valid_618045 = header.getOrDefault("X-Amz-Credential")
  valid_618045 = validateParameter(valid_618045, JString, required = false,
                                 default = nil)
  if valid_618045 != nil:
    section.add "X-Amz-Credential", valid_618045
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618046: Call_GetCreateHsmConfiguration_618027;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_618046.validator(path, query, header, formData, body, _)
  let scheme = call_618046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618046.url(scheme.get, call_618046.host, call_618046.base,
                         call_618046.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618046, url, valid, _)

proc call*(call_618047: Call_GetCreateHsmConfiguration_618027; Description: string;
          HsmPartitionName: string; HsmIpAddress: string;
          HsmConfigurationIdentifier: string; HsmServerPublicCertificate: string;
          HsmPartitionPassword: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Action: string (required)
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   Version: string (required)
  var query_618048 = newJObject()
  add(query_618048, "Description", newJString(Description))
  add(query_618048, "HsmPartitionName", newJString(HsmPartitionName))
  add(query_618048, "HsmIpAddress", newJString(HsmIpAddress))
  add(query_618048, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  if Tags != nil:
    query_618048.add "Tags", Tags
  add(query_618048, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_618048, "Action", newJString(Action))
  add(query_618048, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_618048, "Version", newJString(Version))
  result = call_618047.call(nil, query_618048, nil, nil, nil)

var getCreateHsmConfiguration* = Call_GetCreateHsmConfiguration_618027(
    name: "getCreateHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_GetCreateHsmConfiguration_618028, base: "/",
    url: url_GetCreateHsmConfiguration_618029,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateScheduledAction_618095 = ref object of OpenApiRestCall_616850
proc url_PostCreateScheduledAction_618097(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateScheduledAction_618096(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618098 = query.getOrDefault("Action")
  valid_618098 = validateParameter(valid_618098, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_618098 != nil:
    section.add "Action", valid_618098
  var valid_618099 = query.getOrDefault("Version")
  valid_618099 = validateParameter(valid_618099, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618099 != nil:
    section.add "Version", valid_618099
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618100 = header.getOrDefault("X-Amz-Date")
  valid_618100 = validateParameter(valid_618100, JString, required = false,
                                 default = nil)
  if valid_618100 != nil:
    section.add "X-Amz-Date", valid_618100
  var valid_618101 = header.getOrDefault("X-Amz-Security-Token")
  valid_618101 = validateParameter(valid_618101, JString, required = false,
                                 default = nil)
  if valid_618101 != nil:
    section.add "X-Amz-Security-Token", valid_618101
  var valid_618102 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618102 = validateParameter(valid_618102, JString, required = false,
                                 default = nil)
  if valid_618102 != nil:
    section.add "X-Amz-Content-Sha256", valid_618102
  var valid_618103 = header.getOrDefault("X-Amz-Algorithm")
  valid_618103 = validateParameter(valid_618103, JString, required = false,
                                 default = nil)
  if valid_618103 != nil:
    section.add "X-Amz-Algorithm", valid_618103
  var valid_618104 = header.getOrDefault("X-Amz-Signature")
  valid_618104 = validateParameter(valid_618104, JString, required = false,
                                 default = nil)
  if valid_618104 != nil:
    section.add "X-Amz-Signature", valid_618104
  var valid_618105 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618105 = validateParameter(valid_618105, JString, required = false,
                                 default = nil)
  if valid_618105 != nil:
    section.add "X-Amz-SignedHeaders", valid_618105
  var valid_618106 = header.getOrDefault("X-Amz-Credential")
  valid_618106 = validateParameter(valid_618106, JString, required = false,
                                 default = nil)
  if valid_618106 != nil:
    section.add "X-Amz-Credential", valid_618106
  result.add "header", section
  ## parameters in `formData` object:
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Schedule` field"
  var valid_618107 = formData.getOrDefault("Schedule")
  valid_618107 = validateParameter(valid_618107, JString, required = true,
                                 default = nil)
  if valid_618107 != nil:
    section.add "Schedule", valid_618107
  var valid_618108 = formData.getOrDefault("ScheduledActionDescription")
  valid_618108 = validateParameter(valid_618108, JString, required = false,
                                 default = nil)
  if valid_618108 != nil:
    section.add "ScheduledActionDescription", valid_618108
  var valid_618109 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_618109 = validateParameter(valid_618109, JString, required = false,
                                 default = nil)
  if valid_618109 != nil:
    section.add "TargetAction.ResizeCluster", valid_618109
  var valid_618110 = formData.getOrDefault("StartTime")
  valid_618110 = validateParameter(valid_618110, JString, required = false,
                                 default = nil)
  if valid_618110 != nil:
    section.add "StartTime", valid_618110
  var valid_618111 = formData.getOrDefault("ScheduledActionName")
  valid_618111 = validateParameter(valid_618111, JString, required = true,
                                 default = nil)
  if valid_618111 != nil:
    section.add "ScheduledActionName", valid_618111
  var valid_618112 = formData.getOrDefault("Enable")
  valid_618112 = validateParameter(valid_618112, JBool, required = false, default = nil)
  if valid_618112 != nil:
    section.add "Enable", valid_618112
  var valid_618113 = formData.getOrDefault("IamRole")
  valid_618113 = validateParameter(valid_618113, JString, required = true,
                                 default = nil)
  if valid_618113 != nil:
    section.add "IamRole", valid_618113
  var valid_618114 = formData.getOrDefault("EndTime")
  valid_618114 = validateParameter(valid_618114, JString, required = false,
                                 default = nil)
  if valid_618114 != nil:
    section.add "EndTime", valid_618114
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618115: Call_PostCreateScheduledAction_618095;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_618115.validator(path, query, header, formData, body, _)
  let scheme = call_618115.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618115.url(scheme.get, call_618115.host, call_618115.base,
                         call_618115.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618115, url, valid, _)

proc call*(call_618116: Call_PostCreateScheduledAction_618095; Schedule: string;
          ScheduledActionName: string; IamRole: string;
          ScheduledActionDescription: string = "";
          TargetActionResizeCluster: string = ""; StartTime: string = "";
          Action: string = "CreateScheduledAction"; Enable: bool = false;
          EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Action: string (required)
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_618117 = newJObject()
  var formData_618118 = newJObject()
  add(formData_618118, "Schedule", newJString(Schedule))
  add(formData_618118, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_618118, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_618118, "StartTime", newJString(StartTime))
  add(query_618117, "Action", newJString(Action))
  add(formData_618118, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_618118, "Enable", newJBool(Enable))
  add(formData_618118, "IamRole", newJString(IamRole))
  add(formData_618118, "EndTime", newJString(EndTime))
  add(query_618117, "Version", newJString(Version))
  result = call_618116.call(nil, query_618117, nil, formData_618118, nil)

var postCreateScheduledAction* = Call_PostCreateScheduledAction_618095(
    name: "postCreateScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_PostCreateScheduledAction_618096, base: "/",
    url: url_PostCreateScheduledAction_618097,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateScheduledAction_618072 = ref object of OpenApiRestCall_616850
proc url_GetCreateScheduledAction_618074(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateScheduledAction_618073(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   Action: JString (required)
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Schedule` field"
  var valid_618075 = query.getOrDefault("Schedule")
  valid_618075 = validateParameter(valid_618075, JString, required = true,
                                 default = nil)
  if valid_618075 != nil:
    section.add "Schedule", valid_618075
  var valid_618076 = query.getOrDefault("ScheduledActionName")
  valid_618076 = validateParameter(valid_618076, JString, required = true,
                                 default = nil)
  if valid_618076 != nil:
    section.add "ScheduledActionName", valid_618076
  var valid_618077 = query.getOrDefault("StartTime")
  valid_618077 = validateParameter(valid_618077, JString, required = false,
                                 default = nil)
  if valid_618077 != nil:
    section.add "StartTime", valid_618077
  var valid_618078 = query.getOrDefault("IamRole")
  valid_618078 = validateParameter(valid_618078, JString, required = true,
                                 default = nil)
  if valid_618078 != nil:
    section.add "IamRole", valid_618078
  var valid_618079 = query.getOrDefault("Enable")
  valid_618079 = validateParameter(valid_618079, JBool, required = false, default = nil)
  if valid_618079 != nil:
    section.add "Enable", valid_618079
  var valid_618080 = query.getOrDefault("Action")
  valid_618080 = validateParameter(valid_618080, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_618080 != nil:
    section.add "Action", valid_618080
  var valid_618081 = query.getOrDefault("EndTime")
  valid_618081 = validateParameter(valid_618081, JString, required = false,
                                 default = nil)
  if valid_618081 != nil:
    section.add "EndTime", valid_618081
  var valid_618082 = query.getOrDefault("Version")
  valid_618082 = validateParameter(valid_618082, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618082 != nil:
    section.add "Version", valid_618082
  var valid_618083 = query.getOrDefault("ScheduledActionDescription")
  valid_618083 = validateParameter(valid_618083, JString, required = false,
                                 default = nil)
  if valid_618083 != nil:
    section.add "ScheduledActionDescription", valid_618083
  var valid_618084 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_618084 = validateParameter(valid_618084, JString, required = false,
                                 default = nil)
  if valid_618084 != nil:
    section.add "TargetAction.ResizeCluster", valid_618084
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618085 = header.getOrDefault("X-Amz-Date")
  valid_618085 = validateParameter(valid_618085, JString, required = false,
                                 default = nil)
  if valid_618085 != nil:
    section.add "X-Amz-Date", valid_618085
  var valid_618086 = header.getOrDefault("X-Amz-Security-Token")
  valid_618086 = validateParameter(valid_618086, JString, required = false,
                                 default = nil)
  if valid_618086 != nil:
    section.add "X-Amz-Security-Token", valid_618086
  var valid_618087 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618087 = validateParameter(valid_618087, JString, required = false,
                                 default = nil)
  if valid_618087 != nil:
    section.add "X-Amz-Content-Sha256", valid_618087
  var valid_618088 = header.getOrDefault("X-Amz-Algorithm")
  valid_618088 = validateParameter(valid_618088, JString, required = false,
                                 default = nil)
  if valid_618088 != nil:
    section.add "X-Amz-Algorithm", valid_618088
  var valid_618089 = header.getOrDefault("X-Amz-Signature")
  valid_618089 = validateParameter(valid_618089, JString, required = false,
                                 default = nil)
  if valid_618089 != nil:
    section.add "X-Amz-Signature", valid_618089
  var valid_618090 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618090 = validateParameter(valid_618090, JString, required = false,
                                 default = nil)
  if valid_618090 != nil:
    section.add "X-Amz-SignedHeaders", valid_618090
  var valid_618091 = header.getOrDefault("X-Amz-Credential")
  valid_618091 = validateParameter(valid_618091, JString, required = false,
                                 default = nil)
  if valid_618091 != nil:
    section.add "X-Amz-Credential", valid_618091
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618092: Call_GetCreateScheduledAction_618072; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_618092.validator(path, query, header, formData, body, _)
  let scheme = call_618092.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618092.url(scheme.get, call_618092.host, call_618092.base,
                         call_618092.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618092, url, valid, _)

proc call*(call_618093: Call_GetCreateScheduledAction_618072; Schedule: string;
          ScheduledActionName: string; IamRole: string; StartTime: string = "";
          Enable: bool = false; Action: string = "CreateScheduledAction";
          EndTime: string = ""; Version: string = "2012-12-01";
          ScheduledActionDescription: string = "";
          TargetActionResizeCluster: string = ""): Recallable =
  ## getCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   Action: string (required)
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  var query_618094 = newJObject()
  add(query_618094, "Schedule", newJString(Schedule))
  add(query_618094, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_618094, "StartTime", newJString(StartTime))
  add(query_618094, "IamRole", newJString(IamRole))
  add(query_618094, "Enable", newJBool(Enable))
  add(query_618094, "Action", newJString(Action))
  add(query_618094, "EndTime", newJString(EndTime))
  add(query_618094, "Version", newJString(Version))
  add(query_618094, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_618094, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  result = call_618093.call(nil, query_618094, nil, nil, nil)

var getCreateScheduledAction* = Call_GetCreateScheduledAction_618072(
    name: "getCreateScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_GetCreateScheduledAction_618073, base: "/",
    url: url_GetCreateScheduledAction_618074, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotCopyGrant_618137 = ref object of OpenApiRestCall_616850
proc url_PostCreateSnapshotCopyGrant_618139(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotCopyGrant_618138(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618140 = query.getOrDefault("Action")
  valid_618140 = validateParameter(valid_618140, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_618140 != nil:
    section.add "Action", valid_618140
  var valid_618141 = query.getOrDefault("Version")
  valid_618141 = validateParameter(valid_618141, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618141 != nil:
    section.add "Version", valid_618141
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618142 = header.getOrDefault("X-Amz-Date")
  valid_618142 = validateParameter(valid_618142, JString, required = false,
                                 default = nil)
  if valid_618142 != nil:
    section.add "X-Amz-Date", valid_618142
  var valid_618143 = header.getOrDefault("X-Amz-Security-Token")
  valid_618143 = validateParameter(valid_618143, JString, required = false,
                                 default = nil)
  if valid_618143 != nil:
    section.add "X-Amz-Security-Token", valid_618143
  var valid_618144 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618144 = validateParameter(valid_618144, JString, required = false,
                                 default = nil)
  if valid_618144 != nil:
    section.add "X-Amz-Content-Sha256", valid_618144
  var valid_618145 = header.getOrDefault("X-Amz-Algorithm")
  valid_618145 = validateParameter(valid_618145, JString, required = false,
                                 default = nil)
  if valid_618145 != nil:
    section.add "X-Amz-Algorithm", valid_618145
  var valid_618146 = header.getOrDefault("X-Amz-Signature")
  valid_618146 = validateParameter(valid_618146, JString, required = false,
                                 default = nil)
  if valid_618146 != nil:
    section.add "X-Amz-Signature", valid_618146
  var valid_618147 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618147 = validateParameter(valid_618147, JString, required = false,
                                 default = nil)
  if valid_618147 != nil:
    section.add "X-Amz-SignedHeaders", valid_618147
  var valid_618148 = header.getOrDefault("X-Amz-Credential")
  valid_618148 = validateParameter(valid_618148, JString, required = false,
                                 default = nil)
  if valid_618148 != nil:
    section.add "X-Amz-Credential", valid_618148
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  section = newJObject()
  var valid_618149 = formData.getOrDefault("Tags")
  valid_618149 = validateParameter(valid_618149, JArray, required = false,
                                 default = nil)
  if valid_618149 != nil:
    section.add "Tags", valid_618149
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_618150 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_618150 = validateParameter(valid_618150, JString, required = true,
                                 default = nil)
  if valid_618150 != nil:
    section.add "SnapshotCopyGrantName", valid_618150
  var valid_618151 = formData.getOrDefault("KmsKeyId")
  valid_618151 = validateParameter(valid_618151, JString, required = false,
                                 default = nil)
  if valid_618151 != nil:
    section.add "KmsKeyId", valid_618151
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618152: Call_PostCreateSnapshotCopyGrant_618137;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_618152.validator(path, query, header, formData, body, _)
  let scheme = call_618152.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618152.url(scheme.get, call_618152.host, call_618152.base,
                         call_618152.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618152, url, valid, _)

proc call*(call_618153: Call_PostCreateSnapshotCopyGrant_618137;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil;
          Action: string = "CreateSnapshotCopyGrant"; KmsKeyId: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Version: string (required)
  var query_618154 = newJObject()
  var formData_618155 = newJObject()
  if Tags != nil:
    formData_618155.add "Tags", Tags
  add(query_618154, "Action", newJString(Action))
  add(formData_618155, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(formData_618155, "KmsKeyId", newJString(KmsKeyId))
  add(query_618154, "Version", newJString(Version))
  result = call_618153.call(nil, query_618154, nil, formData_618155, nil)

var postCreateSnapshotCopyGrant* = Call_PostCreateSnapshotCopyGrant_618137(
    name: "postCreateSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_PostCreateSnapshotCopyGrant_618138, base: "/",
    url: url_PostCreateSnapshotCopyGrant_618139,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotCopyGrant_618119 = ref object of OpenApiRestCall_616850
proc url_GetCreateSnapshotCopyGrant_618121(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotCopyGrant_618120(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_618122 = query.getOrDefault("Tags")
  valid_618122 = validateParameter(valid_618122, JArray, required = false,
                                 default = nil)
  if valid_618122 != nil:
    section.add "Tags", valid_618122
  var valid_618123 = query.getOrDefault("Action")
  valid_618123 = validateParameter(valid_618123, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_618123 != nil:
    section.add "Action", valid_618123
  var valid_618124 = query.getOrDefault("KmsKeyId")
  valid_618124 = validateParameter(valid_618124, JString, required = false,
                                 default = nil)
  if valid_618124 != nil:
    section.add "KmsKeyId", valid_618124
  var valid_618125 = query.getOrDefault("SnapshotCopyGrantName")
  valid_618125 = validateParameter(valid_618125, JString, required = true,
                                 default = nil)
  if valid_618125 != nil:
    section.add "SnapshotCopyGrantName", valid_618125
  var valid_618126 = query.getOrDefault("Version")
  valid_618126 = validateParameter(valid_618126, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618126 != nil:
    section.add "Version", valid_618126
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618127 = header.getOrDefault("X-Amz-Date")
  valid_618127 = validateParameter(valid_618127, JString, required = false,
                                 default = nil)
  if valid_618127 != nil:
    section.add "X-Amz-Date", valid_618127
  var valid_618128 = header.getOrDefault("X-Amz-Security-Token")
  valid_618128 = validateParameter(valid_618128, JString, required = false,
                                 default = nil)
  if valid_618128 != nil:
    section.add "X-Amz-Security-Token", valid_618128
  var valid_618129 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618129 = validateParameter(valid_618129, JString, required = false,
                                 default = nil)
  if valid_618129 != nil:
    section.add "X-Amz-Content-Sha256", valid_618129
  var valid_618130 = header.getOrDefault("X-Amz-Algorithm")
  valid_618130 = validateParameter(valid_618130, JString, required = false,
                                 default = nil)
  if valid_618130 != nil:
    section.add "X-Amz-Algorithm", valid_618130
  var valid_618131 = header.getOrDefault("X-Amz-Signature")
  valid_618131 = validateParameter(valid_618131, JString, required = false,
                                 default = nil)
  if valid_618131 != nil:
    section.add "X-Amz-Signature", valid_618131
  var valid_618132 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618132 = validateParameter(valid_618132, JString, required = false,
                                 default = nil)
  if valid_618132 != nil:
    section.add "X-Amz-SignedHeaders", valid_618132
  var valid_618133 = header.getOrDefault("X-Amz-Credential")
  valid_618133 = validateParameter(valid_618133, JString, required = false,
                                 default = nil)
  if valid_618133 != nil:
    section.add "X-Amz-Credential", valid_618133
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618134: Call_GetCreateSnapshotCopyGrant_618119;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_618134.validator(path, query, header, formData, body, _)
  let scheme = call_618134.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618134.url(scheme.get, call_618134.host, call_618134.base,
                         call_618134.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618134, url, valid, _)

proc call*(call_618135: Call_GetCreateSnapshotCopyGrant_618119;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil;
          Action: string = "CreateSnapshotCopyGrant"; KmsKeyId: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: string (required)
  var query_618136 = newJObject()
  if Tags != nil:
    query_618136.add "Tags", Tags
  add(query_618136, "Action", newJString(Action))
  add(query_618136, "KmsKeyId", newJString(KmsKeyId))
  add(query_618136, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_618136, "Version", newJString(Version))
  result = call_618135.call(nil, query_618136, nil, nil, nil)

var getCreateSnapshotCopyGrant* = Call_GetCreateSnapshotCopyGrant_618119(
    name: "getCreateSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_GetCreateSnapshotCopyGrant_618120, base: "/",
    url: url_GetCreateSnapshotCopyGrant_618121,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotSchedule_618177 = ref object of OpenApiRestCall_616850
proc url_PostCreateSnapshotSchedule_618179(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotSchedule_618178(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618180 = query.getOrDefault("Action")
  valid_618180 = validateParameter(valid_618180, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_618180 != nil:
    section.add "Action", valid_618180
  var valid_618181 = query.getOrDefault("Version")
  valid_618181 = validateParameter(valid_618181, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618181 != nil:
    section.add "Version", valid_618181
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618182 = header.getOrDefault("X-Amz-Date")
  valid_618182 = validateParameter(valid_618182, JString, required = false,
                                 default = nil)
  if valid_618182 != nil:
    section.add "X-Amz-Date", valid_618182
  var valid_618183 = header.getOrDefault("X-Amz-Security-Token")
  valid_618183 = validateParameter(valid_618183, JString, required = false,
                                 default = nil)
  if valid_618183 != nil:
    section.add "X-Amz-Security-Token", valid_618183
  var valid_618184 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618184 = validateParameter(valid_618184, JString, required = false,
                                 default = nil)
  if valid_618184 != nil:
    section.add "X-Amz-Content-Sha256", valid_618184
  var valid_618185 = header.getOrDefault("X-Amz-Algorithm")
  valid_618185 = validateParameter(valid_618185, JString, required = false,
                                 default = nil)
  if valid_618185 != nil:
    section.add "X-Amz-Algorithm", valid_618185
  var valid_618186 = header.getOrDefault("X-Amz-Signature")
  valid_618186 = validateParameter(valid_618186, JString, required = false,
                                 default = nil)
  if valid_618186 != nil:
    section.add "X-Amz-Signature", valid_618186
  var valid_618187 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618187 = validateParameter(valid_618187, JString, required = false,
                                 default = nil)
  if valid_618187 != nil:
    section.add "X-Amz-SignedHeaders", valid_618187
  var valid_618188 = header.getOrDefault("X-Amz-Credential")
  valid_618188 = validateParameter(valid_618188, JString, required = false,
                                 default = nil)
  if valid_618188 != nil:
    section.add "X-Amz-Credential", valid_618188
  result.add "header", section
  ## parameters in `formData` object:
  ##   DryRun: JBool
  ##         : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  section = newJObject()
  var valid_618189 = formData.getOrDefault("DryRun")
  valid_618189 = validateParameter(valid_618189, JBool, required = false, default = nil)
  if valid_618189 != nil:
    section.add "DryRun", valid_618189
  var valid_618190 = formData.getOrDefault("Tags")
  valid_618190 = validateParameter(valid_618190, JArray, required = false,
                                 default = nil)
  if valid_618190 != nil:
    section.add "Tags", valid_618190
  var valid_618191 = formData.getOrDefault("ScheduleDescription")
  valid_618191 = validateParameter(valid_618191, JString, required = false,
                                 default = nil)
  if valid_618191 != nil:
    section.add "ScheduleDescription", valid_618191
  var valid_618192 = formData.getOrDefault("ScheduleIdentifier")
  valid_618192 = validateParameter(valid_618192, JString, required = false,
                                 default = nil)
  if valid_618192 != nil:
    section.add "ScheduleIdentifier", valid_618192
  var valid_618193 = formData.getOrDefault("NextInvocations")
  valid_618193 = validateParameter(valid_618193, JInt, required = false, default = nil)
  if valid_618193 != nil:
    section.add "NextInvocations", valid_618193
  var valid_618194 = formData.getOrDefault("ScheduleDefinitions")
  valid_618194 = validateParameter(valid_618194, JArray, required = false,
                                 default = nil)
  if valid_618194 != nil:
    section.add "ScheduleDefinitions", valid_618194
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618195: Call_PostCreateSnapshotSchedule_618177;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  let valid = call_618195.validator(path, query, header, formData, body, _)
  let scheme = call_618195.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618195.url(scheme.get, call_618195.host, call_618195.base,
                         call_618195.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618195, url, valid, _)

proc call*(call_618196: Call_PostCreateSnapshotSchedule_618177;
          DryRun: bool = false; Tags: JsonNode = nil; ScheduleDescription: string = "";
          Action: string = "CreateSnapshotSchedule";
          ScheduleIdentifier: string = ""; NextInvocations: int = 0;
          ScheduleDefinitions: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotSchedule
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ##   DryRun: bool
  ##         : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   NextInvocations: int
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   Version: string (required)
  var query_618197 = newJObject()
  var formData_618198 = newJObject()
  add(formData_618198, "DryRun", newJBool(DryRun))
  if Tags != nil:
    formData_618198.add "Tags", Tags
  add(formData_618198, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_618197, "Action", newJString(Action))
  add(formData_618198, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(formData_618198, "NextInvocations", newJInt(NextInvocations))
  if ScheduleDefinitions != nil:
    formData_618198.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_618197, "Version", newJString(Version))
  result = call_618196.call(nil, query_618197, nil, formData_618198, nil)

var postCreateSnapshotSchedule* = Call_PostCreateSnapshotSchedule_618177(
    name: "postCreateSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_PostCreateSnapshotSchedule_618178, base: "/",
    url: url_PostCreateSnapshotSchedule_618179,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotSchedule_618156 = ref object of OpenApiRestCall_616850
proc url_GetCreateSnapshotSchedule_618158(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotSchedule_618157(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   DryRun: JBool
  ##         : <p/>
  ##   Version: JString (required)
  section = newJObject()
  var valid_618159 = query.getOrDefault("ScheduleDefinitions")
  valid_618159 = validateParameter(valid_618159, JArray, required = false,
                                 default = nil)
  if valid_618159 != nil:
    section.add "ScheduleDefinitions", valid_618159
  var valid_618160 = query.getOrDefault("NextInvocations")
  valid_618160 = validateParameter(valid_618160, JInt, required = false, default = nil)
  if valid_618160 != nil:
    section.add "NextInvocations", valid_618160
  var valid_618161 = query.getOrDefault("Tags")
  valid_618161 = validateParameter(valid_618161, JArray, required = false,
                                 default = nil)
  if valid_618161 != nil:
    section.add "Tags", valid_618161
  var valid_618162 = query.getOrDefault("Action")
  valid_618162 = validateParameter(valid_618162, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_618162 != nil:
    section.add "Action", valid_618162
  var valid_618163 = query.getOrDefault("ScheduleIdentifier")
  valid_618163 = validateParameter(valid_618163, JString, required = false,
                                 default = nil)
  if valid_618163 != nil:
    section.add "ScheduleIdentifier", valid_618163
  var valid_618164 = query.getOrDefault("ScheduleDescription")
  valid_618164 = validateParameter(valid_618164, JString, required = false,
                                 default = nil)
  if valid_618164 != nil:
    section.add "ScheduleDescription", valid_618164
  var valid_618165 = query.getOrDefault("DryRun")
  valid_618165 = validateParameter(valid_618165, JBool, required = false, default = nil)
  if valid_618165 != nil:
    section.add "DryRun", valid_618165
  var valid_618166 = query.getOrDefault("Version")
  valid_618166 = validateParameter(valid_618166, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618166 != nil:
    section.add "Version", valid_618166
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618167 = header.getOrDefault("X-Amz-Date")
  valid_618167 = validateParameter(valid_618167, JString, required = false,
                                 default = nil)
  if valid_618167 != nil:
    section.add "X-Amz-Date", valid_618167
  var valid_618168 = header.getOrDefault("X-Amz-Security-Token")
  valid_618168 = validateParameter(valid_618168, JString, required = false,
                                 default = nil)
  if valid_618168 != nil:
    section.add "X-Amz-Security-Token", valid_618168
  var valid_618169 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618169 = validateParameter(valid_618169, JString, required = false,
                                 default = nil)
  if valid_618169 != nil:
    section.add "X-Amz-Content-Sha256", valid_618169
  var valid_618170 = header.getOrDefault("X-Amz-Algorithm")
  valid_618170 = validateParameter(valid_618170, JString, required = false,
                                 default = nil)
  if valid_618170 != nil:
    section.add "X-Amz-Algorithm", valid_618170
  var valid_618171 = header.getOrDefault("X-Amz-Signature")
  valid_618171 = validateParameter(valid_618171, JString, required = false,
                                 default = nil)
  if valid_618171 != nil:
    section.add "X-Amz-Signature", valid_618171
  var valid_618172 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618172 = validateParameter(valid_618172, JString, required = false,
                                 default = nil)
  if valid_618172 != nil:
    section.add "X-Amz-SignedHeaders", valid_618172
  var valid_618173 = header.getOrDefault("X-Amz-Credential")
  valid_618173 = validateParameter(valid_618173, JString, required = false,
                                 default = nil)
  if valid_618173 != nil:
    section.add "X-Amz-Credential", valid_618173
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618174: Call_GetCreateSnapshotSchedule_618156;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ## 
  let valid = call_618174.validator(path, query, header, formData, body, _)
  let scheme = call_618174.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618174.url(scheme.get, call_618174.host, call_618174.base,
                         call_618174.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618174, url, valid, _)

proc call*(call_618175: Call_GetCreateSnapshotSchedule_618156;
          ScheduleDefinitions: JsonNode = nil; NextInvocations: int = 0;
          Tags: JsonNode = nil; Action: string = "CreateSnapshotSchedule";
          ScheduleIdentifier: string = ""; ScheduleDescription: string = "";
          DryRun: bool = false; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotSchedule
  ## Creates a snapshot schedule with the rate of every 12 hours.
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   DryRun: bool
  ##         : <p/>
  ##   Version: string (required)
  var query_618176 = newJObject()
  if ScheduleDefinitions != nil:
    query_618176.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_618176, "NextInvocations", newJInt(NextInvocations))
  if Tags != nil:
    query_618176.add "Tags", Tags
  add(query_618176, "Action", newJString(Action))
  add(query_618176, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_618176, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_618176, "DryRun", newJBool(DryRun))
  add(query_618176, "Version", newJString(Version))
  result = call_618175.call(nil, query_618176, nil, nil, nil)

var getCreateSnapshotSchedule* = Call_GetCreateSnapshotSchedule_618156(
    name: "getCreateSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_GetCreateSnapshotSchedule_618157, base: "/",
    url: url_GetCreateSnapshotSchedule_618158,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateTags_618216 = ref object of OpenApiRestCall_616850
proc url_PostCreateTags_618218(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateTags_618217(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618219 = query.getOrDefault("Action")
  valid_618219 = validateParameter(valid_618219, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_618219 != nil:
    section.add "Action", valid_618219
  var valid_618220 = query.getOrDefault("Version")
  valid_618220 = validateParameter(valid_618220, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618220 != nil:
    section.add "Version", valid_618220
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618221 = header.getOrDefault("X-Amz-Date")
  valid_618221 = validateParameter(valid_618221, JString, required = false,
                                 default = nil)
  if valid_618221 != nil:
    section.add "X-Amz-Date", valid_618221
  var valid_618222 = header.getOrDefault("X-Amz-Security-Token")
  valid_618222 = validateParameter(valid_618222, JString, required = false,
                                 default = nil)
  if valid_618222 != nil:
    section.add "X-Amz-Security-Token", valid_618222
  var valid_618223 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618223 = validateParameter(valid_618223, JString, required = false,
                                 default = nil)
  if valid_618223 != nil:
    section.add "X-Amz-Content-Sha256", valid_618223
  var valid_618224 = header.getOrDefault("X-Amz-Algorithm")
  valid_618224 = validateParameter(valid_618224, JString, required = false,
                                 default = nil)
  if valid_618224 != nil:
    section.add "X-Amz-Algorithm", valid_618224
  var valid_618225 = header.getOrDefault("X-Amz-Signature")
  valid_618225 = validateParameter(valid_618225, JString, required = false,
                                 default = nil)
  if valid_618225 != nil:
    section.add "X-Amz-Signature", valid_618225
  var valid_618226 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618226 = validateParameter(valid_618226, JString, required = false,
                                 default = nil)
  if valid_618226 != nil:
    section.add "X-Amz-SignedHeaders", valid_618226
  var valid_618227 = header.getOrDefault("X-Amz-Credential")
  valid_618227 = validateParameter(valid_618227, JString, required = false,
                                 default = nil)
  if valid_618227 != nil:
    section.add "X-Amz-Credential", valid_618227
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Tags` field"
  var valid_618228 = formData.getOrDefault("Tags")
  valid_618228 = validateParameter(valid_618228, JArray, required = true, default = nil)
  if valid_618228 != nil:
    section.add "Tags", valid_618228
  var valid_618229 = formData.getOrDefault("ResourceName")
  valid_618229 = validateParameter(valid_618229, JString, required = true,
                                 default = nil)
  if valid_618229 != nil:
    section.add "ResourceName", valid_618229
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618230: Call_PostCreateTags_618216; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_618230.validator(path, query, header, formData, body, _)
  let scheme = call_618230.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618230.url(scheme.get, call_618230.host, call_618230.base,
                         call_618230.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618230, url, valid, _)

proc call*(call_618231: Call_PostCreateTags_618216; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateTags
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Action: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Version: string (required)
  var query_618232 = newJObject()
  var formData_618233 = newJObject()
  if Tags != nil:
    formData_618233.add "Tags", Tags
  add(query_618232, "Action", newJString(Action))
  add(formData_618233, "ResourceName", newJString(ResourceName))
  add(query_618232, "Version", newJString(Version))
  result = call_618231.call(nil, query_618232, nil, formData_618233, nil)

var postCreateTags* = Call_PostCreateTags_618216(name: "postCreateTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_PostCreateTags_618217,
    base: "/", url: url_PostCreateTags_618218, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateTags_618199 = ref object of OpenApiRestCall_616850
proc url_GetCreateTags_618201(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateTags_618200(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Action: JString (required)
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Tags` field"
  var valid_618202 = query.getOrDefault("Tags")
  valid_618202 = validateParameter(valid_618202, JArray, required = true, default = nil)
  if valid_618202 != nil:
    section.add "Tags", valid_618202
  var valid_618203 = query.getOrDefault("Action")
  valid_618203 = validateParameter(valid_618203, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_618203 != nil:
    section.add "Action", valid_618203
  var valid_618204 = query.getOrDefault("ResourceName")
  valid_618204 = validateParameter(valid_618204, JString, required = true,
                                 default = nil)
  if valid_618204 != nil:
    section.add "ResourceName", valid_618204
  var valid_618205 = query.getOrDefault("Version")
  valid_618205 = validateParameter(valid_618205, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618205 != nil:
    section.add "Version", valid_618205
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618206 = header.getOrDefault("X-Amz-Date")
  valid_618206 = validateParameter(valid_618206, JString, required = false,
                                 default = nil)
  if valid_618206 != nil:
    section.add "X-Amz-Date", valid_618206
  var valid_618207 = header.getOrDefault("X-Amz-Security-Token")
  valid_618207 = validateParameter(valid_618207, JString, required = false,
                                 default = nil)
  if valid_618207 != nil:
    section.add "X-Amz-Security-Token", valid_618207
  var valid_618208 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618208 = validateParameter(valid_618208, JString, required = false,
                                 default = nil)
  if valid_618208 != nil:
    section.add "X-Amz-Content-Sha256", valid_618208
  var valid_618209 = header.getOrDefault("X-Amz-Algorithm")
  valid_618209 = validateParameter(valid_618209, JString, required = false,
                                 default = nil)
  if valid_618209 != nil:
    section.add "X-Amz-Algorithm", valid_618209
  var valid_618210 = header.getOrDefault("X-Amz-Signature")
  valid_618210 = validateParameter(valid_618210, JString, required = false,
                                 default = nil)
  if valid_618210 != nil:
    section.add "X-Amz-Signature", valid_618210
  var valid_618211 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618211 = validateParameter(valid_618211, JString, required = false,
                                 default = nil)
  if valid_618211 != nil:
    section.add "X-Amz-SignedHeaders", valid_618211
  var valid_618212 = header.getOrDefault("X-Amz-Credential")
  valid_618212 = validateParameter(valid_618212, JString, required = false,
                                 default = nil)
  if valid_618212 != nil:
    section.add "X-Amz-Credential", valid_618212
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618213: Call_GetCreateTags_618199; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_618213.validator(path, query, header, formData, body, _)
  let scheme = call_618213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618213.url(scheme.get, call_618213.host, call_618213.base,
                         call_618213.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618213, url, valid, _)

proc call*(call_618214: Call_GetCreateTags_618199; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateTags
  ## <p>Adds tags to a cluster.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Action: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Version: string (required)
  var query_618215 = newJObject()
  if Tags != nil:
    query_618215.add "Tags", Tags
  add(query_618215, "Action", newJString(Action))
  add(query_618215, "ResourceName", newJString(ResourceName))
  add(query_618215, "Version", newJString(Version))
  result = call_618214.call(nil, query_618215, nil, nil, nil)

var getCreateTags* = Call_GetCreateTags_618199(name: "getCreateTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_GetCreateTags_618200,
    base: "/", url: url_GetCreateTags_618201, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteCluster_618253 = ref object of OpenApiRestCall_616850
proc url_PostDeleteCluster_618255(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteCluster_618254(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618256 = query.getOrDefault("Action")
  valid_618256 = validateParameter(valid_618256, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_618256 != nil:
    section.add "Action", valid_618256
  var valid_618257 = query.getOrDefault("Version")
  valid_618257 = validateParameter(valid_618257, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618257 != nil:
    section.add "Version", valid_618257
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618258 = header.getOrDefault("X-Amz-Date")
  valid_618258 = validateParameter(valid_618258, JString, required = false,
                                 default = nil)
  if valid_618258 != nil:
    section.add "X-Amz-Date", valid_618258
  var valid_618259 = header.getOrDefault("X-Amz-Security-Token")
  valid_618259 = validateParameter(valid_618259, JString, required = false,
                                 default = nil)
  if valid_618259 != nil:
    section.add "X-Amz-Security-Token", valid_618259
  var valid_618260 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618260 = validateParameter(valid_618260, JString, required = false,
                                 default = nil)
  if valid_618260 != nil:
    section.add "X-Amz-Content-Sha256", valid_618260
  var valid_618261 = header.getOrDefault("X-Amz-Algorithm")
  valid_618261 = validateParameter(valid_618261, JString, required = false,
                                 default = nil)
  if valid_618261 != nil:
    section.add "X-Amz-Algorithm", valid_618261
  var valid_618262 = header.getOrDefault("X-Amz-Signature")
  valid_618262 = validateParameter(valid_618262, JString, required = false,
                                 default = nil)
  if valid_618262 != nil:
    section.add "X-Amz-Signature", valid_618262
  var valid_618263 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618263 = validateParameter(valid_618263, JString, required = false,
                                 default = nil)
  if valid_618263 != nil:
    section.add "X-Amz-SignedHeaders", valid_618263
  var valid_618264 = header.getOrDefault("X-Amz-Credential")
  valid_618264 = validateParameter(valid_618264, JString, required = false,
                                 default = nil)
  if valid_618264 != nil:
    section.add "X-Amz-Credential", valid_618264
  result.add "header", section
  ## parameters in `formData` object:
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  section = newJObject()
  var valid_618265 = formData.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_618265 = validateParameter(valid_618265, JString, required = false,
                                 default = nil)
  if valid_618265 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_618265
  var valid_618266 = formData.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_618266 = validateParameter(valid_618266, JInt, required = false, default = nil)
  if valid_618266 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_618266
  var valid_618267 = formData.getOrDefault("SkipFinalClusterSnapshot")
  valid_618267 = validateParameter(valid_618267, JBool, required = false, default = nil)
  if valid_618267 != nil:
    section.add "SkipFinalClusterSnapshot", valid_618267
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_618268 = formData.getOrDefault("ClusterIdentifier")
  valid_618268 = validateParameter(valid_618268, JString, required = true,
                                 default = nil)
  if valid_618268 != nil:
    section.add "ClusterIdentifier", valid_618268
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618269: Call_PostDeleteCluster_618253; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_618269.validator(path, query, header, formData, body, _)
  let scheme = call_618269.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618269.url(scheme.get, call_618269.host, call_618269.base,
                         call_618269.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618269, url, valid, _)

proc call*(call_618270: Call_PostDeleteCluster_618253; ClusterIdentifier: string;
          FinalClusterSnapshotIdentifier: string = "";
          Action: string = "DeleteCluster";
          FinalClusterSnapshotRetentionPeriod: int = 0;
          SkipFinalClusterSnapshot: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postDeleteCluster
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: string (required)
  var query_618271 = newJObject()
  var formData_618272 = newJObject()
  add(formData_618272, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_618271, "Action", newJString(Action))
  add(formData_618272, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(formData_618272, "SkipFinalClusterSnapshot",
      newJBool(SkipFinalClusterSnapshot))
  add(formData_618272, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_618271, "Version", newJString(Version))
  result = call_618270.call(nil, query_618271, nil, formData_618272, nil)

var postDeleteCluster* = Call_PostDeleteCluster_618253(name: "postDeleteCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_PostDeleteCluster_618254,
    base: "/", url: url_PostDeleteCluster_618255,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteCluster_618234 = ref object of OpenApiRestCall_616850
proc url_GetDeleteCluster_618236(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteCluster_618235(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_618237 = query.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_618237 = validateParameter(valid_618237, JInt, required = false, default = nil)
  if valid_618237 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_618237
  var valid_618238 = query.getOrDefault("Action")
  valid_618238 = validateParameter(valid_618238, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_618238 != nil:
    section.add "Action", valid_618238
  var valid_618239 = query.getOrDefault("ClusterIdentifier")
  valid_618239 = validateParameter(valid_618239, JString, required = true,
                                 default = nil)
  if valid_618239 != nil:
    section.add "ClusterIdentifier", valid_618239
  var valid_618240 = query.getOrDefault("SkipFinalClusterSnapshot")
  valid_618240 = validateParameter(valid_618240, JBool, required = false, default = nil)
  if valid_618240 != nil:
    section.add "SkipFinalClusterSnapshot", valid_618240
  var valid_618241 = query.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_618241 = validateParameter(valid_618241, JString, required = false,
                                 default = nil)
  if valid_618241 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_618241
  var valid_618242 = query.getOrDefault("Version")
  valid_618242 = validateParameter(valid_618242, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618242 != nil:
    section.add "Version", valid_618242
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618243 = header.getOrDefault("X-Amz-Date")
  valid_618243 = validateParameter(valid_618243, JString, required = false,
                                 default = nil)
  if valid_618243 != nil:
    section.add "X-Amz-Date", valid_618243
  var valid_618244 = header.getOrDefault("X-Amz-Security-Token")
  valid_618244 = validateParameter(valid_618244, JString, required = false,
                                 default = nil)
  if valid_618244 != nil:
    section.add "X-Amz-Security-Token", valid_618244
  var valid_618245 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618245 = validateParameter(valid_618245, JString, required = false,
                                 default = nil)
  if valid_618245 != nil:
    section.add "X-Amz-Content-Sha256", valid_618245
  var valid_618246 = header.getOrDefault("X-Amz-Algorithm")
  valid_618246 = validateParameter(valid_618246, JString, required = false,
                                 default = nil)
  if valid_618246 != nil:
    section.add "X-Amz-Algorithm", valid_618246
  var valid_618247 = header.getOrDefault("X-Amz-Signature")
  valid_618247 = validateParameter(valid_618247, JString, required = false,
                                 default = nil)
  if valid_618247 != nil:
    section.add "X-Amz-Signature", valid_618247
  var valid_618248 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618248 = validateParameter(valid_618248, JString, required = false,
                                 default = nil)
  if valid_618248 != nil:
    section.add "X-Amz-SignedHeaders", valid_618248
  var valid_618249 = header.getOrDefault("X-Amz-Credential")
  valid_618249 = validateParameter(valid_618249, JString, required = false,
                                 default = nil)
  if valid_618249 != nil:
    section.add "X-Amz-Credential", valid_618249
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618250: Call_GetDeleteCluster_618234; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_618250.validator(path, query, header, formData, body, _)
  let scheme = call_618250.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618250.url(scheme.get, call_618250.host, call_618250.base,
                         call_618250.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618250, url, valid, _)

proc call*(call_618251: Call_GetDeleteCluster_618234; ClusterIdentifier: string;
          FinalClusterSnapshotRetentionPeriod: int = 0;
          Action: string = "DeleteCluster"; SkipFinalClusterSnapshot: bool = false;
          FinalClusterSnapshotIdentifier: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteCluster
  ## <p>Deletes a previously provisioned cluster without its final snapshot being created. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: string (required)
  var query_618252 = newJObject()
  add(query_618252, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(query_618252, "Action", newJString(Action))
  add(query_618252, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_618252, "SkipFinalClusterSnapshot", newJBool(SkipFinalClusterSnapshot))
  add(query_618252, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_618252, "Version", newJString(Version))
  result = call_618251.call(nil, query_618252, nil, nil, nil)

var getDeleteCluster* = Call_GetDeleteCluster_618234(name: "getDeleteCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_GetDeleteCluster_618235,
    base: "/", url: url_GetDeleteCluster_618236,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterParameterGroup_618289 = ref object of OpenApiRestCall_616850
proc url_PostDeleteClusterParameterGroup_618291(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterParameterGroup_618290(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618292 = query.getOrDefault("Action")
  valid_618292 = validateParameter(valid_618292, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_618292 != nil:
    section.add "Action", valid_618292
  var valid_618293 = query.getOrDefault("Version")
  valid_618293 = validateParameter(valid_618293, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618293 != nil:
    section.add "Version", valid_618293
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618294 = header.getOrDefault("X-Amz-Date")
  valid_618294 = validateParameter(valid_618294, JString, required = false,
                                 default = nil)
  if valid_618294 != nil:
    section.add "X-Amz-Date", valid_618294
  var valid_618295 = header.getOrDefault("X-Amz-Security-Token")
  valid_618295 = validateParameter(valid_618295, JString, required = false,
                                 default = nil)
  if valid_618295 != nil:
    section.add "X-Amz-Security-Token", valid_618295
  var valid_618296 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618296 = validateParameter(valid_618296, JString, required = false,
                                 default = nil)
  if valid_618296 != nil:
    section.add "X-Amz-Content-Sha256", valid_618296
  var valid_618297 = header.getOrDefault("X-Amz-Algorithm")
  valid_618297 = validateParameter(valid_618297, JString, required = false,
                                 default = nil)
  if valid_618297 != nil:
    section.add "X-Amz-Algorithm", valid_618297
  var valid_618298 = header.getOrDefault("X-Amz-Signature")
  valid_618298 = validateParameter(valid_618298, JString, required = false,
                                 default = nil)
  if valid_618298 != nil:
    section.add "X-Amz-Signature", valid_618298
  var valid_618299 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618299 = validateParameter(valid_618299, JString, required = false,
                                 default = nil)
  if valid_618299 != nil:
    section.add "X-Amz-SignedHeaders", valid_618299
  var valid_618300 = header.getOrDefault("X-Amz-Credential")
  valid_618300 = validateParameter(valid_618300, JString, required = false,
                                 default = nil)
  if valid_618300 != nil:
    section.add "X-Amz-Credential", valid_618300
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_618301 = formData.getOrDefault("ParameterGroupName")
  valid_618301 = validateParameter(valid_618301, JString, required = true,
                                 default = nil)
  if valid_618301 != nil:
    section.add "ParameterGroupName", valid_618301
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618302: Call_PostDeleteClusterParameterGroup_618289;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_618302.validator(path, query, header, formData, body, _)
  let scheme = call_618302.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618302.url(scheme.get, call_618302.host, call_618302.base,
                         call_618302.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618302, url, valid, _)

proc call*(call_618303: Call_PostDeleteClusterParameterGroup_618289;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_618304 = newJObject()
  var formData_618305 = newJObject()
  add(formData_618305, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_618304, "Action", newJString(Action))
  add(query_618304, "Version", newJString(Version))
  result = call_618303.call(nil, query_618304, nil, formData_618305, nil)

var postDeleteClusterParameterGroup* = Call_PostDeleteClusterParameterGroup_618289(
    name: "postDeleteClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_PostDeleteClusterParameterGroup_618290, base: "/",
    url: url_PostDeleteClusterParameterGroup_618291,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterParameterGroup_618273 = ref object of OpenApiRestCall_616850
proc url_GetDeleteClusterParameterGroup_618275(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterParameterGroup_618274(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_618276 = query.getOrDefault("ParameterGroupName")
  valid_618276 = validateParameter(valid_618276, JString, required = true,
                                 default = nil)
  if valid_618276 != nil:
    section.add "ParameterGroupName", valid_618276
  var valid_618277 = query.getOrDefault("Action")
  valid_618277 = validateParameter(valid_618277, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_618277 != nil:
    section.add "Action", valid_618277
  var valid_618278 = query.getOrDefault("Version")
  valid_618278 = validateParameter(valid_618278, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618278 != nil:
    section.add "Version", valid_618278
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618279 = header.getOrDefault("X-Amz-Date")
  valid_618279 = validateParameter(valid_618279, JString, required = false,
                                 default = nil)
  if valid_618279 != nil:
    section.add "X-Amz-Date", valid_618279
  var valid_618280 = header.getOrDefault("X-Amz-Security-Token")
  valid_618280 = validateParameter(valid_618280, JString, required = false,
                                 default = nil)
  if valid_618280 != nil:
    section.add "X-Amz-Security-Token", valid_618280
  var valid_618281 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618281 = validateParameter(valid_618281, JString, required = false,
                                 default = nil)
  if valid_618281 != nil:
    section.add "X-Amz-Content-Sha256", valid_618281
  var valid_618282 = header.getOrDefault("X-Amz-Algorithm")
  valid_618282 = validateParameter(valid_618282, JString, required = false,
                                 default = nil)
  if valid_618282 != nil:
    section.add "X-Amz-Algorithm", valid_618282
  var valid_618283 = header.getOrDefault("X-Amz-Signature")
  valid_618283 = validateParameter(valid_618283, JString, required = false,
                                 default = nil)
  if valid_618283 != nil:
    section.add "X-Amz-Signature", valid_618283
  var valid_618284 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618284 = validateParameter(valid_618284, JString, required = false,
                                 default = nil)
  if valid_618284 != nil:
    section.add "X-Amz-SignedHeaders", valid_618284
  var valid_618285 = header.getOrDefault("X-Amz-Credential")
  valid_618285 = validateParameter(valid_618285, JString, required = false,
                                 default = nil)
  if valid_618285 != nil:
    section.add "X-Amz-Credential", valid_618285
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618286: Call_GetDeleteClusterParameterGroup_618273;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_618286.validator(path, query, header, formData, body, _)
  let scheme = call_618286.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618286.url(scheme.get, call_618286.host, call_618286.base,
                         call_618286.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618286, url, valid, _)

proc call*(call_618287: Call_GetDeleteClusterParameterGroup_618273;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_618288 = newJObject()
  add(query_618288, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_618288, "Action", newJString(Action))
  add(query_618288, "Version", newJString(Version))
  result = call_618287.call(nil, query_618288, nil, nil, nil)

var getDeleteClusterParameterGroup* = Call_GetDeleteClusterParameterGroup_618273(
    name: "getDeleteClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_GetDeleteClusterParameterGroup_618274, base: "/",
    url: url_GetDeleteClusterParameterGroup_618275,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSecurityGroup_618322 = ref object of OpenApiRestCall_616850
proc url_PostDeleteClusterSecurityGroup_618324(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSecurityGroup_618323(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618325 = query.getOrDefault("Action")
  valid_618325 = validateParameter(valid_618325, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_618325 != nil:
    section.add "Action", valid_618325
  var valid_618326 = query.getOrDefault("Version")
  valid_618326 = validateParameter(valid_618326, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618326 != nil:
    section.add "Version", valid_618326
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618327 = header.getOrDefault("X-Amz-Date")
  valid_618327 = validateParameter(valid_618327, JString, required = false,
                                 default = nil)
  if valid_618327 != nil:
    section.add "X-Amz-Date", valid_618327
  var valid_618328 = header.getOrDefault("X-Amz-Security-Token")
  valid_618328 = validateParameter(valid_618328, JString, required = false,
                                 default = nil)
  if valid_618328 != nil:
    section.add "X-Amz-Security-Token", valid_618328
  var valid_618329 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618329 = validateParameter(valid_618329, JString, required = false,
                                 default = nil)
  if valid_618329 != nil:
    section.add "X-Amz-Content-Sha256", valid_618329
  var valid_618330 = header.getOrDefault("X-Amz-Algorithm")
  valid_618330 = validateParameter(valid_618330, JString, required = false,
                                 default = nil)
  if valid_618330 != nil:
    section.add "X-Amz-Algorithm", valid_618330
  var valid_618331 = header.getOrDefault("X-Amz-Signature")
  valid_618331 = validateParameter(valid_618331, JString, required = false,
                                 default = nil)
  if valid_618331 != nil:
    section.add "X-Amz-Signature", valid_618331
  var valid_618332 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618332 = validateParameter(valid_618332, JString, required = false,
                                 default = nil)
  if valid_618332 != nil:
    section.add "X-Amz-SignedHeaders", valid_618332
  var valid_618333 = header.getOrDefault("X-Amz-Credential")
  valid_618333 = validateParameter(valid_618333, JString, required = false,
                                 default = nil)
  if valid_618333 != nil:
    section.add "X-Amz-Credential", valid_618333
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_618334 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_618334 = validateParameter(valid_618334, JString, required = true,
                                 default = nil)
  if valid_618334 != nil:
    section.add "ClusterSecurityGroupName", valid_618334
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618335: Call_PostDeleteClusterSecurityGroup_618322;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_618335.validator(path, query, header, formData, body, _)
  let scheme = call_618335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618335.url(scheme.get, call_618335.host, call_618335.base,
                         call_618335.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618335, url, valid, _)

proc call*(call_618336: Call_PostDeleteClusterSecurityGroup_618322;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  var query_618337 = newJObject()
  var formData_618338 = newJObject()
  add(query_618337, "Action", newJString(Action))
  add(query_618337, "Version", newJString(Version))
  add(formData_618338, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_618336.call(nil, query_618337, nil, formData_618338, nil)

var postDeleteClusterSecurityGroup* = Call_PostDeleteClusterSecurityGroup_618322(
    name: "postDeleteClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_PostDeleteClusterSecurityGroup_618323, base: "/",
    url: url_PostDeleteClusterSecurityGroup_618324,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSecurityGroup_618306 = ref object of OpenApiRestCall_616850
proc url_GetDeleteClusterSecurityGroup_618308(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSecurityGroup_618307(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_618309 = query.getOrDefault("ClusterSecurityGroupName")
  valid_618309 = validateParameter(valid_618309, JString, required = true,
                                 default = nil)
  if valid_618309 != nil:
    section.add "ClusterSecurityGroupName", valid_618309
  var valid_618310 = query.getOrDefault("Action")
  valid_618310 = validateParameter(valid_618310, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_618310 != nil:
    section.add "Action", valid_618310
  var valid_618311 = query.getOrDefault("Version")
  valid_618311 = validateParameter(valid_618311, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618311 != nil:
    section.add "Version", valid_618311
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618312 = header.getOrDefault("X-Amz-Date")
  valid_618312 = validateParameter(valid_618312, JString, required = false,
                                 default = nil)
  if valid_618312 != nil:
    section.add "X-Amz-Date", valid_618312
  var valid_618313 = header.getOrDefault("X-Amz-Security-Token")
  valid_618313 = validateParameter(valid_618313, JString, required = false,
                                 default = nil)
  if valid_618313 != nil:
    section.add "X-Amz-Security-Token", valid_618313
  var valid_618314 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618314 = validateParameter(valid_618314, JString, required = false,
                                 default = nil)
  if valid_618314 != nil:
    section.add "X-Amz-Content-Sha256", valid_618314
  var valid_618315 = header.getOrDefault("X-Amz-Algorithm")
  valid_618315 = validateParameter(valid_618315, JString, required = false,
                                 default = nil)
  if valid_618315 != nil:
    section.add "X-Amz-Algorithm", valid_618315
  var valid_618316 = header.getOrDefault("X-Amz-Signature")
  valid_618316 = validateParameter(valid_618316, JString, required = false,
                                 default = nil)
  if valid_618316 != nil:
    section.add "X-Amz-Signature", valid_618316
  var valid_618317 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618317 = validateParameter(valid_618317, JString, required = false,
                                 default = nil)
  if valid_618317 != nil:
    section.add "X-Amz-SignedHeaders", valid_618317
  var valid_618318 = header.getOrDefault("X-Amz-Credential")
  valid_618318 = validateParameter(valid_618318, JString, required = false,
                                 default = nil)
  if valid_618318 != nil:
    section.add "X-Amz-Credential", valid_618318
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618319: Call_GetDeleteClusterSecurityGroup_618306;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_618319.validator(path, query, header, formData, body, _)
  let scheme = call_618319.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618319.url(scheme.get, call_618319.host, call_618319.base,
                         call_618319.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618319, url, valid, _)

proc call*(call_618320: Call_GetDeleteClusterSecurityGroup_618306;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_618321 = newJObject()
  add(query_618321, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_618321, "Action", newJString(Action))
  add(query_618321, "Version", newJString(Version))
  result = call_618320.call(nil, query_618321, nil, nil, nil)

var getDeleteClusterSecurityGroup* = Call_GetDeleteClusterSecurityGroup_618306(
    name: "getDeleteClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_GetDeleteClusterSecurityGroup_618307, base: "/",
    url: url_GetDeleteClusterSecurityGroup_618308,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSnapshot_618356 = ref object of OpenApiRestCall_616850
proc url_PostDeleteClusterSnapshot_618358(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSnapshot_618357(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618359 = query.getOrDefault("Action")
  valid_618359 = validateParameter(valid_618359, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_618359 != nil:
    section.add "Action", valid_618359
  var valid_618360 = query.getOrDefault("Version")
  valid_618360 = validateParameter(valid_618360, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618360 != nil:
    section.add "Version", valid_618360
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618361 = header.getOrDefault("X-Amz-Date")
  valid_618361 = validateParameter(valid_618361, JString, required = false,
                                 default = nil)
  if valid_618361 != nil:
    section.add "X-Amz-Date", valid_618361
  var valid_618362 = header.getOrDefault("X-Amz-Security-Token")
  valid_618362 = validateParameter(valid_618362, JString, required = false,
                                 default = nil)
  if valid_618362 != nil:
    section.add "X-Amz-Security-Token", valid_618362
  var valid_618363 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618363 = validateParameter(valid_618363, JString, required = false,
                                 default = nil)
  if valid_618363 != nil:
    section.add "X-Amz-Content-Sha256", valid_618363
  var valid_618364 = header.getOrDefault("X-Amz-Algorithm")
  valid_618364 = validateParameter(valid_618364, JString, required = false,
                                 default = nil)
  if valid_618364 != nil:
    section.add "X-Amz-Algorithm", valid_618364
  var valid_618365 = header.getOrDefault("X-Amz-Signature")
  valid_618365 = validateParameter(valid_618365, JString, required = false,
                                 default = nil)
  if valid_618365 != nil:
    section.add "X-Amz-Signature", valid_618365
  var valid_618366 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618366 = validateParameter(valid_618366, JString, required = false,
                                 default = nil)
  if valid_618366 != nil:
    section.add "X-Amz-SignedHeaders", valid_618366
  var valid_618367 = header.getOrDefault("X-Amz-Credential")
  valid_618367 = validateParameter(valid_618367, JString, required = false,
                                 default = nil)
  if valid_618367 != nil:
    section.add "X-Amz-Credential", valid_618367
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  section = newJObject()
  var valid_618368 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_618368 = validateParameter(valid_618368, JString, required = false,
                                 default = nil)
  if valid_618368 != nil:
    section.add "SnapshotClusterIdentifier", valid_618368
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_618369 = formData.getOrDefault("SnapshotIdentifier")
  valid_618369 = validateParameter(valid_618369, JString, required = true,
                                 default = nil)
  if valid_618369 != nil:
    section.add "SnapshotIdentifier", valid_618369
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618370: Call_PostDeleteClusterSnapshot_618356;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_618370.validator(path, query, header, formData, body, _)
  let scheme = call_618370.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618370.url(scheme.get, call_618370.host, call_618370.base,
                         call_618370.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618370, url, valid, _)

proc call*(call_618371: Call_PostDeleteClusterSnapshot_618356;
          SnapshotIdentifier: string; SnapshotClusterIdentifier: string = "";
          Action: string = "DeleteClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: string (required)
  var query_618372 = newJObject()
  var formData_618373 = newJObject()
  add(formData_618373, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_618372, "Action", newJString(Action))
  add(formData_618373, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_618372, "Version", newJString(Version))
  result = call_618371.call(nil, query_618372, nil, formData_618373, nil)

var postDeleteClusterSnapshot* = Call_PostDeleteClusterSnapshot_618356(
    name: "postDeleteClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_PostDeleteClusterSnapshot_618357, base: "/",
    url: url_PostDeleteClusterSnapshot_618358,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSnapshot_618339 = ref object of OpenApiRestCall_616850
proc url_GetDeleteClusterSnapshot_618341(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSnapshot_618340(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_618342 = query.getOrDefault("Action")
  valid_618342 = validateParameter(valid_618342, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_618342 != nil:
    section.add "Action", valid_618342
  var valid_618343 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_618343 = validateParameter(valid_618343, JString, required = false,
                                 default = nil)
  if valid_618343 != nil:
    section.add "SnapshotClusterIdentifier", valid_618343
  var valid_618344 = query.getOrDefault("SnapshotIdentifier")
  valid_618344 = validateParameter(valid_618344, JString, required = true,
                                 default = nil)
  if valid_618344 != nil:
    section.add "SnapshotIdentifier", valid_618344
  var valid_618345 = query.getOrDefault("Version")
  valid_618345 = validateParameter(valid_618345, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618345 != nil:
    section.add "Version", valid_618345
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618346 = header.getOrDefault("X-Amz-Date")
  valid_618346 = validateParameter(valid_618346, JString, required = false,
                                 default = nil)
  if valid_618346 != nil:
    section.add "X-Amz-Date", valid_618346
  var valid_618347 = header.getOrDefault("X-Amz-Security-Token")
  valid_618347 = validateParameter(valid_618347, JString, required = false,
                                 default = nil)
  if valid_618347 != nil:
    section.add "X-Amz-Security-Token", valid_618347
  var valid_618348 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618348 = validateParameter(valid_618348, JString, required = false,
                                 default = nil)
  if valid_618348 != nil:
    section.add "X-Amz-Content-Sha256", valid_618348
  var valid_618349 = header.getOrDefault("X-Amz-Algorithm")
  valid_618349 = validateParameter(valid_618349, JString, required = false,
                                 default = nil)
  if valid_618349 != nil:
    section.add "X-Amz-Algorithm", valid_618349
  var valid_618350 = header.getOrDefault("X-Amz-Signature")
  valid_618350 = validateParameter(valid_618350, JString, required = false,
                                 default = nil)
  if valid_618350 != nil:
    section.add "X-Amz-Signature", valid_618350
  var valid_618351 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618351 = validateParameter(valid_618351, JString, required = false,
                                 default = nil)
  if valid_618351 != nil:
    section.add "X-Amz-SignedHeaders", valid_618351
  var valid_618352 = header.getOrDefault("X-Amz-Credential")
  valid_618352 = validateParameter(valid_618352, JString, required = false,
                                 default = nil)
  if valid_618352 != nil:
    section.add "X-Amz-Credential", valid_618352
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618353: Call_GetDeleteClusterSnapshot_618339; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_618353.validator(path, query, header, formData, body, _)
  let scheme = call_618353.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618353.url(scheme.get, call_618353.host, call_618353.base,
                         call_618353.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618353, url, valid, _)

proc call*(call_618354: Call_GetDeleteClusterSnapshot_618339;
          SnapshotIdentifier: string; Action: string = "DeleteClusterSnapshot";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: string (required)
  var query_618355 = newJObject()
  add(query_618355, "Action", newJString(Action))
  add(query_618355, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_618355, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_618355, "Version", newJString(Version))
  result = call_618354.call(nil, query_618355, nil, nil, nil)

var getDeleteClusterSnapshot* = Call_GetDeleteClusterSnapshot_618339(
    name: "getDeleteClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_GetDeleteClusterSnapshot_618340, base: "/",
    url: url_GetDeleteClusterSnapshot_618341, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSubnetGroup_618390 = ref object of OpenApiRestCall_616850
proc url_PostDeleteClusterSubnetGroup_618392(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSubnetGroup_618391(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618393 = query.getOrDefault("Action")
  valid_618393 = validateParameter(valid_618393, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_618393 != nil:
    section.add "Action", valid_618393
  var valid_618394 = query.getOrDefault("Version")
  valid_618394 = validateParameter(valid_618394, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618394 != nil:
    section.add "Version", valid_618394
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618395 = header.getOrDefault("X-Amz-Date")
  valid_618395 = validateParameter(valid_618395, JString, required = false,
                                 default = nil)
  if valid_618395 != nil:
    section.add "X-Amz-Date", valid_618395
  var valid_618396 = header.getOrDefault("X-Amz-Security-Token")
  valid_618396 = validateParameter(valid_618396, JString, required = false,
                                 default = nil)
  if valid_618396 != nil:
    section.add "X-Amz-Security-Token", valid_618396
  var valid_618397 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618397 = validateParameter(valid_618397, JString, required = false,
                                 default = nil)
  if valid_618397 != nil:
    section.add "X-Amz-Content-Sha256", valid_618397
  var valid_618398 = header.getOrDefault("X-Amz-Algorithm")
  valid_618398 = validateParameter(valid_618398, JString, required = false,
                                 default = nil)
  if valid_618398 != nil:
    section.add "X-Amz-Algorithm", valid_618398
  var valid_618399 = header.getOrDefault("X-Amz-Signature")
  valid_618399 = validateParameter(valid_618399, JString, required = false,
                                 default = nil)
  if valid_618399 != nil:
    section.add "X-Amz-Signature", valid_618399
  var valid_618400 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618400 = validateParameter(valid_618400, JString, required = false,
                                 default = nil)
  if valid_618400 != nil:
    section.add "X-Amz-SignedHeaders", valid_618400
  var valid_618401 = header.getOrDefault("X-Amz-Credential")
  valid_618401 = validateParameter(valid_618401, JString, required = false,
                                 default = nil)
  if valid_618401 != nil:
    section.add "X-Amz-Credential", valid_618401
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_618402 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_618402 = validateParameter(valid_618402, JString, required = true,
                                 default = nil)
  if valid_618402 != nil:
    section.add "ClusterSubnetGroupName", valid_618402
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618403: Call_PostDeleteClusterSubnetGroup_618390;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_618403.validator(path, query, header, formData, body, _)
  let scheme = call_618403.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618403.url(scheme.get, call_618403.host, call_618403.base,
                         call_618403.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618403, url, valid, _)

proc call*(call_618404: Call_PostDeleteClusterSubnetGroup_618390;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  var query_618405 = newJObject()
  var formData_618406 = newJObject()
  add(query_618405, "Action", newJString(Action))
  add(query_618405, "Version", newJString(Version))
  add(formData_618406, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_618404.call(nil, query_618405, nil, formData_618406, nil)

var postDeleteClusterSubnetGroup* = Call_PostDeleteClusterSubnetGroup_618390(
    name: "postDeleteClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_PostDeleteClusterSubnetGroup_618391, base: "/",
    url: url_PostDeleteClusterSubnetGroup_618392,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSubnetGroup_618374 = ref object of OpenApiRestCall_616850
proc url_GetDeleteClusterSubnetGroup_618376(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSubnetGroup_618375(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_618377 = query.getOrDefault("ClusterSubnetGroupName")
  valid_618377 = validateParameter(valid_618377, JString, required = true,
                                 default = nil)
  if valid_618377 != nil:
    section.add "ClusterSubnetGroupName", valid_618377
  var valid_618378 = query.getOrDefault("Action")
  valid_618378 = validateParameter(valid_618378, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_618378 != nil:
    section.add "Action", valid_618378
  var valid_618379 = query.getOrDefault("Version")
  valid_618379 = validateParameter(valid_618379, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618379 != nil:
    section.add "Version", valid_618379
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618380 = header.getOrDefault("X-Amz-Date")
  valid_618380 = validateParameter(valid_618380, JString, required = false,
                                 default = nil)
  if valid_618380 != nil:
    section.add "X-Amz-Date", valid_618380
  var valid_618381 = header.getOrDefault("X-Amz-Security-Token")
  valid_618381 = validateParameter(valid_618381, JString, required = false,
                                 default = nil)
  if valid_618381 != nil:
    section.add "X-Amz-Security-Token", valid_618381
  var valid_618382 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618382 = validateParameter(valid_618382, JString, required = false,
                                 default = nil)
  if valid_618382 != nil:
    section.add "X-Amz-Content-Sha256", valid_618382
  var valid_618383 = header.getOrDefault("X-Amz-Algorithm")
  valid_618383 = validateParameter(valid_618383, JString, required = false,
                                 default = nil)
  if valid_618383 != nil:
    section.add "X-Amz-Algorithm", valid_618383
  var valid_618384 = header.getOrDefault("X-Amz-Signature")
  valid_618384 = validateParameter(valid_618384, JString, required = false,
                                 default = nil)
  if valid_618384 != nil:
    section.add "X-Amz-Signature", valid_618384
  var valid_618385 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618385 = validateParameter(valid_618385, JString, required = false,
                                 default = nil)
  if valid_618385 != nil:
    section.add "X-Amz-SignedHeaders", valid_618385
  var valid_618386 = header.getOrDefault("X-Amz-Credential")
  valid_618386 = validateParameter(valid_618386, JString, required = false,
                                 default = nil)
  if valid_618386 != nil:
    section.add "X-Amz-Credential", valid_618386
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618387: Call_GetDeleteClusterSubnetGroup_618374;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_618387.validator(path, query, header, formData, body, _)
  let scheme = call_618387.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618387.url(scheme.get, call_618387.host, call_618387.base,
                         call_618387.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618387, url, valid, _)

proc call*(call_618388: Call_GetDeleteClusterSubnetGroup_618374;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_618389 = newJObject()
  add(query_618389, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_618389, "Action", newJString(Action))
  add(query_618389, "Version", newJString(Version))
  result = call_618388.call(nil, query_618389, nil, nil, nil)

var getDeleteClusterSubnetGroup* = Call_GetDeleteClusterSubnetGroup_618374(
    name: "getDeleteClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_GetDeleteClusterSubnetGroup_618375, base: "/",
    url: url_GetDeleteClusterSubnetGroup_618376,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteEventSubscription_618423 = ref object of OpenApiRestCall_616850
proc url_PostDeleteEventSubscription_618425(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteEventSubscription_618424(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618426 = query.getOrDefault("Action")
  valid_618426 = validateParameter(valid_618426, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_618426 != nil:
    section.add "Action", valid_618426
  var valid_618427 = query.getOrDefault("Version")
  valid_618427 = validateParameter(valid_618427, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618427 != nil:
    section.add "Version", valid_618427
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618428 = header.getOrDefault("X-Amz-Date")
  valid_618428 = validateParameter(valid_618428, JString, required = false,
                                 default = nil)
  if valid_618428 != nil:
    section.add "X-Amz-Date", valid_618428
  var valid_618429 = header.getOrDefault("X-Amz-Security-Token")
  valid_618429 = validateParameter(valid_618429, JString, required = false,
                                 default = nil)
  if valid_618429 != nil:
    section.add "X-Amz-Security-Token", valid_618429
  var valid_618430 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618430 = validateParameter(valid_618430, JString, required = false,
                                 default = nil)
  if valid_618430 != nil:
    section.add "X-Amz-Content-Sha256", valid_618430
  var valid_618431 = header.getOrDefault("X-Amz-Algorithm")
  valid_618431 = validateParameter(valid_618431, JString, required = false,
                                 default = nil)
  if valid_618431 != nil:
    section.add "X-Amz-Algorithm", valid_618431
  var valid_618432 = header.getOrDefault("X-Amz-Signature")
  valid_618432 = validateParameter(valid_618432, JString, required = false,
                                 default = nil)
  if valid_618432 != nil:
    section.add "X-Amz-Signature", valid_618432
  var valid_618433 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618433 = validateParameter(valid_618433, JString, required = false,
                                 default = nil)
  if valid_618433 != nil:
    section.add "X-Amz-SignedHeaders", valid_618433
  var valid_618434 = header.getOrDefault("X-Amz-Credential")
  valid_618434 = validateParameter(valid_618434, JString, required = false,
                                 default = nil)
  if valid_618434 != nil:
    section.add "X-Amz-Credential", valid_618434
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_618435 = formData.getOrDefault("SubscriptionName")
  valid_618435 = validateParameter(valid_618435, JString, required = true,
                                 default = nil)
  if valid_618435 != nil:
    section.add "SubscriptionName", valid_618435
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618436: Call_PostDeleteEventSubscription_618423;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_618436.validator(path, query, header, formData, body, _)
  let scheme = call_618436.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618436.url(scheme.get, call_618436.host, call_618436.base,
                         call_618436.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618436, url, valid, _)

proc call*(call_618437: Call_PostDeleteEventSubscription_618423;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_618438 = newJObject()
  var formData_618439 = newJObject()
  add(formData_618439, "SubscriptionName", newJString(SubscriptionName))
  add(query_618438, "Action", newJString(Action))
  add(query_618438, "Version", newJString(Version))
  result = call_618437.call(nil, query_618438, nil, formData_618439, nil)

var postDeleteEventSubscription* = Call_PostDeleteEventSubscription_618423(
    name: "postDeleteEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_PostDeleteEventSubscription_618424, base: "/",
    url: url_PostDeleteEventSubscription_618425,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteEventSubscription_618407 = ref object of OpenApiRestCall_616850
proc url_GetDeleteEventSubscription_618409(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteEventSubscription_618408(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Version: JString (required)
  section = newJObject()
  var valid_618410 = query.getOrDefault("Action")
  valid_618410 = validateParameter(valid_618410, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_618410 != nil:
    section.add "Action", valid_618410
  var valid_618411 = query.getOrDefault("SubscriptionName")
  valid_618411 = validateParameter(valid_618411, JString, required = true,
                                 default = nil)
  if valid_618411 != nil:
    section.add "SubscriptionName", valid_618411
  var valid_618412 = query.getOrDefault("Version")
  valid_618412 = validateParameter(valid_618412, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618412 != nil:
    section.add "Version", valid_618412
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618413 = header.getOrDefault("X-Amz-Date")
  valid_618413 = validateParameter(valid_618413, JString, required = false,
                                 default = nil)
  if valid_618413 != nil:
    section.add "X-Amz-Date", valid_618413
  var valid_618414 = header.getOrDefault("X-Amz-Security-Token")
  valid_618414 = validateParameter(valid_618414, JString, required = false,
                                 default = nil)
  if valid_618414 != nil:
    section.add "X-Amz-Security-Token", valid_618414
  var valid_618415 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618415 = validateParameter(valid_618415, JString, required = false,
                                 default = nil)
  if valid_618415 != nil:
    section.add "X-Amz-Content-Sha256", valid_618415
  var valid_618416 = header.getOrDefault("X-Amz-Algorithm")
  valid_618416 = validateParameter(valid_618416, JString, required = false,
                                 default = nil)
  if valid_618416 != nil:
    section.add "X-Amz-Algorithm", valid_618416
  var valid_618417 = header.getOrDefault("X-Amz-Signature")
  valid_618417 = validateParameter(valid_618417, JString, required = false,
                                 default = nil)
  if valid_618417 != nil:
    section.add "X-Amz-Signature", valid_618417
  var valid_618418 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618418 = validateParameter(valid_618418, JString, required = false,
                                 default = nil)
  if valid_618418 != nil:
    section.add "X-Amz-SignedHeaders", valid_618418
  var valid_618419 = header.getOrDefault("X-Amz-Credential")
  valid_618419 = validateParameter(valid_618419, JString, required = false,
                                 default = nil)
  if valid_618419 != nil:
    section.add "X-Amz-Credential", valid_618419
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618420: Call_GetDeleteEventSubscription_618407;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_618420.validator(path, query, header, formData, body, _)
  let scheme = call_618420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618420.url(scheme.get, call_618420.host, call_618420.base,
                         call_618420.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618420, url, valid, _)

proc call*(call_618421: Call_GetDeleteEventSubscription_618407;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   Action: string (required)
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Version: string (required)
  var query_618422 = newJObject()
  add(query_618422, "Action", newJString(Action))
  add(query_618422, "SubscriptionName", newJString(SubscriptionName))
  add(query_618422, "Version", newJString(Version))
  result = call_618421.call(nil, query_618422, nil, nil, nil)

var getDeleteEventSubscription* = Call_GetDeleteEventSubscription_618407(
    name: "getDeleteEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_GetDeleteEventSubscription_618408, base: "/",
    url: url_GetDeleteEventSubscription_618409,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmClientCertificate_618456 = ref object of OpenApiRestCall_616850
proc url_PostDeleteHsmClientCertificate_618458(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmClientCertificate_618457(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618459 = query.getOrDefault("Action")
  valid_618459 = validateParameter(valid_618459, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_618459 != nil:
    section.add "Action", valid_618459
  var valid_618460 = query.getOrDefault("Version")
  valid_618460 = validateParameter(valid_618460, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618460 != nil:
    section.add "Version", valid_618460
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618461 = header.getOrDefault("X-Amz-Date")
  valid_618461 = validateParameter(valid_618461, JString, required = false,
                                 default = nil)
  if valid_618461 != nil:
    section.add "X-Amz-Date", valid_618461
  var valid_618462 = header.getOrDefault("X-Amz-Security-Token")
  valid_618462 = validateParameter(valid_618462, JString, required = false,
                                 default = nil)
  if valid_618462 != nil:
    section.add "X-Amz-Security-Token", valid_618462
  var valid_618463 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618463 = validateParameter(valid_618463, JString, required = false,
                                 default = nil)
  if valid_618463 != nil:
    section.add "X-Amz-Content-Sha256", valid_618463
  var valid_618464 = header.getOrDefault("X-Amz-Algorithm")
  valid_618464 = validateParameter(valid_618464, JString, required = false,
                                 default = nil)
  if valid_618464 != nil:
    section.add "X-Amz-Algorithm", valid_618464
  var valid_618465 = header.getOrDefault("X-Amz-Signature")
  valid_618465 = validateParameter(valid_618465, JString, required = false,
                                 default = nil)
  if valid_618465 != nil:
    section.add "X-Amz-Signature", valid_618465
  var valid_618466 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618466 = validateParameter(valid_618466, JString, required = false,
                                 default = nil)
  if valid_618466 != nil:
    section.add "X-Amz-SignedHeaders", valid_618466
  var valid_618467 = header.getOrDefault("X-Amz-Credential")
  valid_618467 = validateParameter(valid_618467, JString, required = false,
                                 default = nil)
  if valid_618467 != nil:
    section.add "X-Amz-Credential", valid_618467
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_618468 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_618468 = validateParameter(valid_618468, JString, required = true,
                                 default = nil)
  if valid_618468 != nil:
    section.add "HsmClientCertificateIdentifier", valid_618468
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618469: Call_PostDeleteHsmClientCertificate_618456;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_618469.validator(path, query, header, formData, body, _)
  let scheme = call_618469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618469.url(scheme.get, call_618469.host, call_618469.base,
                         call_618469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618469, url, valid, _)

proc call*(call_618470: Call_PostDeleteHsmClientCertificate_618456;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Version: string (required)
  var query_618471 = newJObject()
  var formData_618472 = newJObject()
  add(query_618471, "Action", newJString(Action))
  add(formData_618472, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_618471, "Version", newJString(Version))
  result = call_618470.call(nil, query_618471, nil, formData_618472, nil)

var postDeleteHsmClientCertificate* = Call_PostDeleteHsmClientCertificate_618456(
    name: "postDeleteHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_PostDeleteHsmClientCertificate_618457, base: "/",
    url: url_PostDeleteHsmClientCertificate_618458,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmClientCertificate_618440 = ref object of OpenApiRestCall_616850
proc url_GetDeleteHsmClientCertificate_618442(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmClientCertificate_618441(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_618443 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_618443 = validateParameter(valid_618443, JString, required = true,
                                 default = nil)
  if valid_618443 != nil:
    section.add "HsmClientCertificateIdentifier", valid_618443
  var valid_618444 = query.getOrDefault("Action")
  valid_618444 = validateParameter(valid_618444, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_618444 != nil:
    section.add "Action", valid_618444
  var valid_618445 = query.getOrDefault("Version")
  valid_618445 = validateParameter(valid_618445, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618445 != nil:
    section.add "Version", valid_618445
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618446 = header.getOrDefault("X-Amz-Date")
  valid_618446 = validateParameter(valid_618446, JString, required = false,
                                 default = nil)
  if valid_618446 != nil:
    section.add "X-Amz-Date", valid_618446
  var valid_618447 = header.getOrDefault("X-Amz-Security-Token")
  valid_618447 = validateParameter(valid_618447, JString, required = false,
                                 default = nil)
  if valid_618447 != nil:
    section.add "X-Amz-Security-Token", valid_618447
  var valid_618448 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618448 = validateParameter(valid_618448, JString, required = false,
                                 default = nil)
  if valid_618448 != nil:
    section.add "X-Amz-Content-Sha256", valid_618448
  var valid_618449 = header.getOrDefault("X-Amz-Algorithm")
  valid_618449 = validateParameter(valid_618449, JString, required = false,
                                 default = nil)
  if valid_618449 != nil:
    section.add "X-Amz-Algorithm", valid_618449
  var valid_618450 = header.getOrDefault("X-Amz-Signature")
  valid_618450 = validateParameter(valid_618450, JString, required = false,
                                 default = nil)
  if valid_618450 != nil:
    section.add "X-Amz-Signature", valid_618450
  var valid_618451 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618451 = validateParameter(valid_618451, JString, required = false,
                                 default = nil)
  if valid_618451 != nil:
    section.add "X-Amz-SignedHeaders", valid_618451
  var valid_618452 = header.getOrDefault("X-Amz-Credential")
  valid_618452 = validateParameter(valid_618452, JString, required = false,
                                 default = nil)
  if valid_618452 != nil:
    section.add "X-Amz-Credential", valid_618452
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618453: Call_GetDeleteHsmClientCertificate_618440;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_618453.validator(path, query, header, formData, body, _)
  let scheme = call_618453.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618453.url(scheme.get, call_618453.host, call_618453.base,
                         call_618453.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618453, url, valid, _)

proc call*(call_618454: Call_GetDeleteHsmClientCertificate_618440;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_618455 = newJObject()
  add(query_618455, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_618455, "Action", newJString(Action))
  add(query_618455, "Version", newJString(Version))
  result = call_618454.call(nil, query_618455, nil, nil, nil)

var getDeleteHsmClientCertificate* = Call_GetDeleteHsmClientCertificate_618440(
    name: "getDeleteHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_GetDeleteHsmClientCertificate_618441, base: "/",
    url: url_GetDeleteHsmClientCertificate_618442,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmConfiguration_618489 = ref object of OpenApiRestCall_616850
proc url_PostDeleteHsmConfiguration_618491(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmConfiguration_618490(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618492 = query.getOrDefault("Action")
  valid_618492 = validateParameter(valid_618492, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_618492 != nil:
    section.add "Action", valid_618492
  var valid_618493 = query.getOrDefault("Version")
  valid_618493 = validateParameter(valid_618493, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618493 != nil:
    section.add "Version", valid_618493
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618494 = header.getOrDefault("X-Amz-Date")
  valid_618494 = validateParameter(valid_618494, JString, required = false,
                                 default = nil)
  if valid_618494 != nil:
    section.add "X-Amz-Date", valid_618494
  var valid_618495 = header.getOrDefault("X-Amz-Security-Token")
  valid_618495 = validateParameter(valid_618495, JString, required = false,
                                 default = nil)
  if valid_618495 != nil:
    section.add "X-Amz-Security-Token", valid_618495
  var valid_618496 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618496 = validateParameter(valid_618496, JString, required = false,
                                 default = nil)
  if valid_618496 != nil:
    section.add "X-Amz-Content-Sha256", valid_618496
  var valid_618497 = header.getOrDefault("X-Amz-Algorithm")
  valid_618497 = validateParameter(valid_618497, JString, required = false,
                                 default = nil)
  if valid_618497 != nil:
    section.add "X-Amz-Algorithm", valid_618497
  var valid_618498 = header.getOrDefault("X-Amz-Signature")
  valid_618498 = validateParameter(valid_618498, JString, required = false,
                                 default = nil)
  if valid_618498 != nil:
    section.add "X-Amz-Signature", valid_618498
  var valid_618499 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618499 = validateParameter(valid_618499, JString, required = false,
                                 default = nil)
  if valid_618499 != nil:
    section.add "X-Amz-SignedHeaders", valid_618499
  var valid_618500 = header.getOrDefault("X-Amz-Credential")
  valid_618500 = validateParameter(valid_618500, JString, required = false,
                                 default = nil)
  if valid_618500 != nil:
    section.add "X-Amz-Credential", valid_618500
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_618501 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_618501 = validateParameter(valid_618501, JString, required = true,
                                 default = nil)
  if valid_618501 != nil:
    section.add "HsmConfigurationIdentifier", valid_618501
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618502: Call_PostDeleteHsmConfiguration_618489;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_618502.validator(path, query, header, formData, body, _)
  let scheme = call_618502.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618502.url(scheme.get, call_618502.host, call_618502.base,
                         call_618502.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618502, url, valid, _)

proc call*(call_618503: Call_PostDeleteHsmConfiguration_618489;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_618504 = newJObject()
  var formData_618505 = newJObject()
  add(formData_618505, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_618504, "Action", newJString(Action))
  add(query_618504, "Version", newJString(Version))
  result = call_618503.call(nil, query_618504, nil, formData_618505, nil)

var postDeleteHsmConfiguration* = Call_PostDeleteHsmConfiguration_618489(
    name: "postDeleteHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_PostDeleteHsmConfiguration_618490, base: "/",
    url: url_PostDeleteHsmConfiguration_618491,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmConfiguration_618473 = ref object of OpenApiRestCall_616850
proc url_GetDeleteHsmConfiguration_618475(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmConfiguration_618474(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_618476 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_618476 = validateParameter(valid_618476, JString, required = true,
                                 default = nil)
  if valid_618476 != nil:
    section.add "HsmConfigurationIdentifier", valid_618476
  var valid_618477 = query.getOrDefault("Action")
  valid_618477 = validateParameter(valid_618477, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_618477 != nil:
    section.add "Action", valid_618477
  var valid_618478 = query.getOrDefault("Version")
  valid_618478 = validateParameter(valid_618478, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618478 != nil:
    section.add "Version", valid_618478
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618479 = header.getOrDefault("X-Amz-Date")
  valid_618479 = validateParameter(valid_618479, JString, required = false,
                                 default = nil)
  if valid_618479 != nil:
    section.add "X-Amz-Date", valid_618479
  var valid_618480 = header.getOrDefault("X-Amz-Security-Token")
  valid_618480 = validateParameter(valid_618480, JString, required = false,
                                 default = nil)
  if valid_618480 != nil:
    section.add "X-Amz-Security-Token", valid_618480
  var valid_618481 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618481 = validateParameter(valid_618481, JString, required = false,
                                 default = nil)
  if valid_618481 != nil:
    section.add "X-Amz-Content-Sha256", valid_618481
  var valid_618482 = header.getOrDefault("X-Amz-Algorithm")
  valid_618482 = validateParameter(valid_618482, JString, required = false,
                                 default = nil)
  if valid_618482 != nil:
    section.add "X-Amz-Algorithm", valid_618482
  var valid_618483 = header.getOrDefault("X-Amz-Signature")
  valid_618483 = validateParameter(valid_618483, JString, required = false,
                                 default = nil)
  if valid_618483 != nil:
    section.add "X-Amz-Signature", valid_618483
  var valid_618484 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618484 = validateParameter(valid_618484, JString, required = false,
                                 default = nil)
  if valid_618484 != nil:
    section.add "X-Amz-SignedHeaders", valid_618484
  var valid_618485 = header.getOrDefault("X-Amz-Credential")
  valid_618485 = validateParameter(valid_618485, JString, required = false,
                                 default = nil)
  if valid_618485 != nil:
    section.add "X-Amz-Credential", valid_618485
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618486: Call_GetDeleteHsmConfiguration_618473;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_618486.validator(path, query, header, formData, body, _)
  let scheme = call_618486.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618486.url(scheme.get, call_618486.host, call_618486.base,
                         call_618486.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618486, url, valid, _)

proc call*(call_618487: Call_GetDeleteHsmConfiguration_618473;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_618488 = newJObject()
  add(query_618488, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_618488, "Action", newJString(Action))
  add(query_618488, "Version", newJString(Version))
  result = call_618487.call(nil, query_618488, nil, nil, nil)

var getDeleteHsmConfiguration* = Call_GetDeleteHsmConfiguration_618473(
    name: "getDeleteHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_GetDeleteHsmConfiguration_618474, base: "/",
    url: url_GetDeleteHsmConfiguration_618475,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteScheduledAction_618522 = ref object of OpenApiRestCall_616850
proc url_PostDeleteScheduledAction_618524(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteScheduledAction_618523(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618525 = query.getOrDefault("Action")
  valid_618525 = validateParameter(valid_618525, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_618525 != nil:
    section.add "Action", valid_618525
  var valid_618526 = query.getOrDefault("Version")
  valid_618526 = validateParameter(valid_618526, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618526 != nil:
    section.add "Version", valid_618526
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618527 = header.getOrDefault("X-Amz-Date")
  valid_618527 = validateParameter(valid_618527, JString, required = false,
                                 default = nil)
  if valid_618527 != nil:
    section.add "X-Amz-Date", valid_618527
  var valid_618528 = header.getOrDefault("X-Amz-Security-Token")
  valid_618528 = validateParameter(valid_618528, JString, required = false,
                                 default = nil)
  if valid_618528 != nil:
    section.add "X-Amz-Security-Token", valid_618528
  var valid_618529 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618529 = validateParameter(valid_618529, JString, required = false,
                                 default = nil)
  if valid_618529 != nil:
    section.add "X-Amz-Content-Sha256", valid_618529
  var valid_618530 = header.getOrDefault("X-Amz-Algorithm")
  valid_618530 = validateParameter(valid_618530, JString, required = false,
                                 default = nil)
  if valid_618530 != nil:
    section.add "X-Amz-Algorithm", valid_618530
  var valid_618531 = header.getOrDefault("X-Amz-Signature")
  valid_618531 = validateParameter(valid_618531, JString, required = false,
                                 default = nil)
  if valid_618531 != nil:
    section.add "X-Amz-Signature", valid_618531
  var valid_618532 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618532 = validateParameter(valid_618532, JString, required = false,
                                 default = nil)
  if valid_618532 != nil:
    section.add "X-Amz-SignedHeaders", valid_618532
  var valid_618533 = header.getOrDefault("X-Amz-Credential")
  valid_618533 = validateParameter(valid_618533, JString, required = false,
                                 default = nil)
  if valid_618533 != nil:
    section.add "X-Amz-Credential", valid_618533
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_618534 = formData.getOrDefault("ScheduledActionName")
  valid_618534 = validateParameter(valid_618534, JString, required = true,
                                 default = nil)
  if valid_618534 != nil:
    section.add "ScheduledActionName", valid_618534
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618535: Call_PostDeleteScheduledAction_618522;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_618535.validator(path, query, header, formData, body, _)
  let scheme = call_618535.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618535.url(scheme.get, call_618535.host, call_618535.base,
                         call_618535.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618535, url, valid, _)

proc call*(call_618536: Call_PostDeleteScheduledAction_618522;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   Action: string (required)
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Version: string (required)
  var query_618537 = newJObject()
  var formData_618538 = newJObject()
  add(query_618537, "Action", newJString(Action))
  add(formData_618538, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_618537, "Version", newJString(Version))
  result = call_618536.call(nil, query_618537, nil, formData_618538, nil)

var postDeleteScheduledAction* = Call_PostDeleteScheduledAction_618522(
    name: "postDeleteScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_PostDeleteScheduledAction_618523, base: "/",
    url: url_PostDeleteScheduledAction_618524,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteScheduledAction_618506 = ref object of OpenApiRestCall_616850
proc url_GetDeleteScheduledAction_618508(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteScheduledAction_618507(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_618509 = query.getOrDefault("ScheduledActionName")
  valid_618509 = validateParameter(valid_618509, JString, required = true,
                                 default = nil)
  if valid_618509 != nil:
    section.add "ScheduledActionName", valid_618509
  var valid_618510 = query.getOrDefault("Action")
  valid_618510 = validateParameter(valid_618510, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_618510 != nil:
    section.add "Action", valid_618510
  var valid_618511 = query.getOrDefault("Version")
  valid_618511 = validateParameter(valid_618511, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618511 != nil:
    section.add "Version", valid_618511
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618512 = header.getOrDefault("X-Amz-Date")
  valid_618512 = validateParameter(valid_618512, JString, required = false,
                                 default = nil)
  if valid_618512 != nil:
    section.add "X-Amz-Date", valid_618512
  var valid_618513 = header.getOrDefault("X-Amz-Security-Token")
  valid_618513 = validateParameter(valid_618513, JString, required = false,
                                 default = nil)
  if valid_618513 != nil:
    section.add "X-Amz-Security-Token", valid_618513
  var valid_618514 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618514 = validateParameter(valid_618514, JString, required = false,
                                 default = nil)
  if valid_618514 != nil:
    section.add "X-Amz-Content-Sha256", valid_618514
  var valid_618515 = header.getOrDefault("X-Amz-Algorithm")
  valid_618515 = validateParameter(valid_618515, JString, required = false,
                                 default = nil)
  if valid_618515 != nil:
    section.add "X-Amz-Algorithm", valid_618515
  var valid_618516 = header.getOrDefault("X-Amz-Signature")
  valid_618516 = validateParameter(valid_618516, JString, required = false,
                                 default = nil)
  if valid_618516 != nil:
    section.add "X-Amz-Signature", valid_618516
  var valid_618517 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618517 = validateParameter(valid_618517, JString, required = false,
                                 default = nil)
  if valid_618517 != nil:
    section.add "X-Amz-SignedHeaders", valid_618517
  var valid_618518 = header.getOrDefault("X-Amz-Credential")
  valid_618518 = validateParameter(valid_618518, JString, required = false,
                                 default = nil)
  if valid_618518 != nil:
    section.add "X-Amz-Credential", valid_618518
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618519: Call_GetDeleteScheduledAction_618506; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_618519.validator(path, query, header, formData, body, _)
  let scheme = call_618519.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618519.url(scheme.get, call_618519.host, call_618519.base,
                         call_618519.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618519, url, valid, _)

proc call*(call_618520: Call_GetDeleteScheduledAction_618506;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_618521 = newJObject()
  add(query_618521, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_618521, "Action", newJString(Action))
  add(query_618521, "Version", newJString(Version))
  result = call_618520.call(nil, query_618521, nil, nil, nil)

var getDeleteScheduledAction* = Call_GetDeleteScheduledAction_618506(
    name: "getDeleteScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_GetDeleteScheduledAction_618507, base: "/",
    url: url_GetDeleteScheduledAction_618508, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotCopyGrant_618555 = ref object of OpenApiRestCall_616850
proc url_PostDeleteSnapshotCopyGrant_618557(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotCopyGrant_618556(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618558 = query.getOrDefault("Action")
  valid_618558 = validateParameter(valid_618558, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_618558 != nil:
    section.add "Action", valid_618558
  var valid_618559 = query.getOrDefault("Version")
  valid_618559 = validateParameter(valid_618559, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618559 != nil:
    section.add "Version", valid_618559
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618560 = header.getOrDefault("X-Amz-Date")
  valid_618560 = validateParameter(valid_618560, JString, required = false,
                                 default = nil)
  if valid_618560 != nil:
    section.add "X-Amz-Date", valid_618560
  var valid_618561 = header.getOrDefault("X-Amz-Security-Token")
  valid_618561 = validateParameter(valid_618561, JString, required = false,
                                 default = nil)
  if valid_618561 != nil:
    section.add "X-Amz-Security-Token", valid_618561
  var valid_618562 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618562 = validateParameter(valid_618562, JString, required = false,
                                 default = nil)
  if valid_618562 != nil:
    section.add "X-Amz-Content-Sha256", valid_618562
  var valid_618563 = header.getOrDefault("X-Amz-Algorithm")
  valid_618563 = validateParameter(valid_618563, JString, required = false,
                                 default = nil)
  if valid_618563 != nil:
    section.add "X-Amz-Algorithm", valid_618563
  var valid_618564 = header.getOrDefault("X-Amz-Signature")
  valid_618564 = validateParameter(valid_618564, JString, required = false,
                                 default = nil)
  if valid_618564 != nil:
    section.add "X-Amz-Signature", valid_618564
  var valid_618565 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618565 = validateParameter(valid_618565, JString, required = false,
                                 default = nil)
  if valid_618565 != nil:
    section.add "X-Amz-SignedHeaders", valid_618565
  var valid_618566 = header.getOrDefault("X-Amz-Credential")
  valid_618566 = validateParameter(valid_618566, JString, required = false,
                                 default = nil)
  if valid_618566 != nil:
    section.add "X-Amz-Credential", valid_618566
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_618567 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_618567 = validateParameter(valid_618567, JString, required = true,
                                 default = nil)
  if valid_618567 != nil:
    section.add "SnapshotCopyGrantName", valid_618567
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618568: Call_PostDeleteSnapshotCopyGrant_618555;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_618568.validator(path, query, header, formData, body, _)
  let scheme = call_618568.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618568.url(scheme.get, call_618568.host, call_618568.base,
                         call_618568.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618568, url, valid, _)

proc call*(call_618569: Call_PostDeleteSnapshotCopyGrant_618555;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_618570 = newJObject()
  var formData_618571 = newJObject()
  add(query_618570, "Action", newJString(Action))
  add(formData_618571, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_618570, "Version", newJString(Version))
  result = call_618569.call(nil, query_618570, nil, formData_618571, nil)

var postDeleteSnapshotCopyGrant* = Call_PostDeleteSnapshotCopyGrant_618555(
    name: "postDeleteSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_PostDeleteSnapshotCopyGrant_618556, base: "/",
    url: url_PostDeleteSnapshotCopyGrant_618557,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotCopyGrant_618539 = ref object of OpenApiRestCall_616850
proc url_GetDeleteSnapshotCopyGrant_618541(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotCopyGrant_618540(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: JString (required)
  section = newJObject()
  var valid_618542 = query.getOrDefault("Action")
  valid_618542 = validateParameter(valid_618542, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_618542 != nil:
    section.add "Action", valid_618542
  var valid_618543 = query.getOrDefault("SnapshotCopyGrantName")
  valid_618543 = validateParameter(valid_618543, JString, required = true,
                                 default = nil)
  if valid_618543 != nil:
    section.add "SnapshotCopyGrantName", valid_618543
  var valid_618544 = query.getOrDefault("Version")
  valid_618544 = validateParameter(valid_618544, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618544 != nil:
    section.add "Version", valid_618544
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618545 = header.getOrDefault("X-Amz-Date")
  valid_618545 = validateParameter(valid_618545, JString, required = false,
                                 default = nil)
  if valid_618545 != nil:
    section.add "X-Amz-Date", valid_618545
  var valid_618546 = header.getOrDefault("X-Amz-Security-Token")
  valid_618546 = validateParameter(valid_618546, JString, required = false,
                                 default = nil)
  if valid_618546 != nil:
    section.add "X-Amz-Security-Token", valid_618546
  var valid_618547 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618547 = validateParameter(valid_618547, JString, required = false,
                                 default = nil)
  if valid_618547 != nil:
    section.add "X-Amz-Content-Sha256", valid_618547
  var valid_618548 = header.getOrDefault("X-Amz-Algorithm")
  valid_618548 = validateParameter(valid_618548, JString, required = false,
                                 default = nil)
  if valid_618548 != nil:
    section.add "X-Amz-Algorithm", valid_618548
  var valid_618549 = header.getOrDefault("X-Amz-Signature")
  valid_618549 = validateParameter(valid_618549, JString, required = false,
                                 default = nil)
  if valid_618549 != nil:
    section.add "X-Amz-Signature", valid_618549
  var valid_618550 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618550 = validateParameter(valid_618550, JString, required = false,
                                 default = nil)
  if valid_618550 != nil:
    section.add "X-Amz-SignedHeaders", valid_618550
  var valid_618551 = header.getOrDefault("X-Amz-Credential")
  valid_618551 = validateParameter(valid_618551, JString, required = false,
                                 default = nil)
  if valid_618551 != nil:
    section.add "X-Amz-Credential", valid_618551
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618552: Call_GetDeleteSnapshotCopyGrant_618539;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_618552.validator(path, query, header, formData, body, _)
  let scheme = call_618552.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618552.url(scheme.get, call_618552.host, call_618552.base,
                         call_618552.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618552, url, valid, _)

proc call*(call_618553: Call_GetDeleteSnapshotCopyGrant_618539;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_618554 = newJObject()
  add(query_618554, "Action", newJString(Action))
  add(query_618554, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_618554, "Version", newJString(Version))
  result = call_618553.call(nil, query_618554, nil, nil, nil)

var getDeleteSnapshotCopyGrant* = Call_GetDeleteSnapshotCopyGrant_618539(
    name: "getDeleteSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_GetDeleteSnapshotCopyGrant_618540, base: "/",
    url: url_GetDeleteSnapshotCopyGrant_618541,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotSchedule_618588 = ref object of OpenApiRestCall_616850
proc url_PostDeleteSnapshotSchedule_618590(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotSchedule_618589(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618591 = query.getOrDefault("Action")
  valid_618591 = validateParameter(valid_618591, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_618591 != nil:
    section.add "Action", valid_618591
  var valid_618592 = query.getOrDefault("Version")
  valid_618592 = validateParameter(valid_618592, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618592 != nil:
    section.add "Version", valid_618592
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618593 = header.getOrDefault("X-Amz-Date")
  valid_618593 = validateParameter(valid_618593, JString, required = false,
                                 default = nil)
  if valid_618593 != nil:
    section.add "X-Amz-Date", valid_618593
  var valid_618594 = header.getOrDefault("X-Amz-Security-Token")
  valid_618594 = validateParameter(valid_618594, JString, required = false,
                                 default = nil)
  if valid_618594 != nil:
    section.add "X-Amz-Security-Token", valid_618594
  var valid_618595 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618595 = validateParameter(valid_618595, JString, required = false,
                                 default = nil)
  if valid_618595 != nil:
    section.add "X-Amz-Content-Sha256", valid_618595
  var valid_618596 = header.getOrDefault("X-Amz-Algorithm")
  valid_618596 = validateParameter(valid_618596, JString, required = false,
                                 default = nil)
  if valid_618596 != nil:
    section.add "X-Amz-Algorithm", valid_618596
  var valid_618597 = header.getOrDefault("X-Amz-Signature")
  valid_618597 = validateParameter(valid_618597, JString, required = false,
                                 default = nil)
  if valid_618597 != nil:
    section.add "X-Amz-Signature", valid_618597
  var valid_618598 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618598 = validateParameter(valid_618598, JString, required = false,
                                 default = nil)
  if valid_618598 != nil:
    section.add "X-Amz-SignedHeaders", valid_618598
  var valid_618599 = header.getOrDefault("X-Amz-Credential")
  valid_618599 = validateParameter(valid_618599, JString, required = false,
                                 default = nil)
  if valid_618599 != nil:
    section.add "X-Amz-Credential", valid_618599
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleIdentifier` field"
  var valid_618600 = formData.getOrDefault("ScheduleIdentifier")
  valid_618600 = validateParameter(valid_618600, JString, required = true,
                                 default = nil)
  if valid_618600 != nil:
    section.add "ScheduleIdentifier", valid_618600
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618601: Call_PostDeleteSnapshotSchedule_618588;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_618601.validator(path, query, header, formData, body, _)
  let scheme = call_618601.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618601.url(scheme.get, call_618601.host, call_618601.base,
                         call_618601.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618601, url, valid, _)

proc call*(call_618602: Call_PostDeleteSnapshotSchedule_618588;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_618603 = newJObject()
  var formData_618604 = newJObject()
  add(query_618603, "Action", newJString(Action))
  add(formData_618604, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_618603, "Version", newJString(Version))
  result = call_618602.call(nil, query_618603, nil, formData_618604, nil)

var postDeleteSnapshotSchedule* = Call_PostDeleteSnapshotSchedule_618588(
    name: "postDeleteSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_PostDeleteSnapshotSchedule_618589, base: "/",
    url: url_PostDeleteSnapshotSchedule_618590,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotSchedule_618572 = ref object of OpenApiRestCall_616850
proc url_GetDeleteSnapshotSchedule_618574(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotSchedule_618573(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: JString (required)
  section = newJObject()
  var valid_618575 = query.getOrDefault("Action")
  valid_618575 = validateParameter(valid_618575, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_618575 != nil:
    section.add "Action", valid_618575
  var valid_618576 = query.getOrDefault("ScheduleIdentifier")
  valid_618576 = validateParameter(valid_618576, JString, required = true,
                                 default = nil)
  if valid_618576 != nil:
    section.add "ScheduleIdentifier", valid_618576
  var valid_618577 = query.getOrDefault("Version")
  valid_618577 = validateParameter(valid_618577, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618577 != nil:
    section.add "Version", valid_618577
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618578 = header.getOrDefault("X-Amz-Date")
  valid_618578 = validateParameter(valid_618578, JString, required = false,
                                 default = nil)
  if valid_618578 != nil:
    section.add "X-Amz-Date", valid_618578
  var valid_618579 = header.getOrDefault("X-Amz-Security-Token")
  valid_618579 = validateParameter(valid_618579, JString, required = false,
                                 default = nil)
  if valid_618579 != nil:
    section.add "X-Amz-Security-Token", valid_618579
  var valid_618580 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618580 = validateParameter(valid_618580, JString, required = false,
                                 default = nil)
  if valid_618580 != nil:
    section.add "X-Amz-Content-Sha256", valid_618580
  var valid_618581 = header.getOrDefault("X-Amz-Algorithm")
  valid_618581 = validateParameter(valid_618581, JString, required = false,
                                 default = nil)
  if valid_618581 != nil:
    section.add "X-Amz-Algorithm", valid_618581
  var valid_618582 = header.getOrDefault("X-Amz-Signature")
  valid_618582 = validateParameter(valid_618582, JString, required = false,
                                 default = nil)
  if valid_618582 != nil:
    section.add "X-Amz-Signature", valid_618582
  var valid_618583 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618583 = validateParameter(valid_618583, JString, required = false,
                                 default = nil)
  if valid_618583 != nil:
    section.add "X-Amz-SignedHeaders", valid_618583
  var valid_618584 = header.getOrDefault("X-Amz-Credential")
  valid_618584 = validateParameter(valid_618584, JString, required = false,
                                 default = nil)
  if valid_618584 != nil:
    section.add "X-Amz-Credential", valid_618584
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618585: Call_GetDeleteSnapshotSchedule_618572;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_618585.validator(path, query, header, formData, body, _)
  let scheme = call_618585.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618585.url(scheme.get, call_618585.host, call_618585.base,
                         call_618585.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618585, url, valid, _)

proc call*(call_618586: Call_GetDeleteSnapshotSchedule_618572;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_618587 = newJObject()
  add(query_618587, "Action", newJString(Action))
  add(query_618587, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_618587, "Version", newJString(Version))
  result = call_618586.call(nil, query_618587, nil, nil, nil)

var getDeleteSnapshotSchedule* = Call_GetDeleteSnapshotSchedule_618572(
    name: "getDeleteSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_GetDeleteSnapshotSchedule_618573, base: "/",
    url: url_GetDeleteSnapshotSchedule_618574,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteTags_618622 = ref object of OpenApiRestCall_616850
proc url_PostDeleteTags_618624(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteTags_618623(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode; _: string = ""): JsonNode =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618625 = query.getOrDefault("Action")
  valid_618625 = validateParameter(valid_618625, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_618625 != nil:
    section.add "Action", valid_618625
  var valid_618626 = query.getOrDefault("Version")
  valid_618626 = validateParameter(valid_618626, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618626 != nil:
    section.add "Version", valid_618626
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618627 = header.getOrDefault("X-Amz-Date")
  valid_618627 = validateParameter(valid_618627, JString, required = false,
                                 default = nil)
  if valid_618627 != nil:
    section.add "X-Amz-Date", valid_618627
  var valid_618628 = header.getOrDefault("X-Amz-Security-Token")
  valid_618628 = validateParameter(valid_618628, JString, required = false,
                                 default = nil)
  if valid_618628 != nil:
    section.add "X-Amz-Security-Token", valid_618628
  var valid_618629 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618629 = validateParameter(valid_618629, JString, required = false,
                                 default = nil)
  if valid_618629 != nil:
    section.add "X-Amz-Content-Sha256", valid_618629
  var valid_618630 = header.getOrDefault("X-Amz-Algorithm")
  valid_618630 = validateParameter(valid_618630, JString, required = false,
                                 default = nil)
  if valid_618630 != nil:
    section.add "X-Amz-Algorithm", valid_618630
  var valid_618631 = header.getOrDefault("X-Amz-Signature")
  valid_618631 = validateParameter(valid_618631, JString, required = false,
                                 default = nil)
  if valid_618631 != nil:
    section.add "X-Amz-Signature", valid_618631
  var valid_618632 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618632 = validateParameter(valid_618632, JString, required = false,
                                 default = nil)
  if valid_618632 != nil:
    section.add "X-Amz-SignedHeaders", valid_618632
  var valid_618633 = header.getOrDefault("X-Amz-Credential")
  valid_618633 = validateParameter(valid_618633, JString, required = false,
                                 default = nil)
  if valid_618633 != nil:
    section.add "X-Amz-Credential", valid_618633
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `TagKeys` field"
  var valid_618634 = formData.getOrDefault("TagKeys")
  valid_618634 = validateParameter(valid_618634, JArray, required = true, default = nil)
  if valid_618634 != nil:
    section.add "TagKeys", valid_618634
  var valid_618635 = formData.getOrDefault("ResourceName")
  valid_618635 = validateParameter(valid_618635, JString, required = true,
                                 default = nil)
  if valid_618635 != nil:
    section.add "ResourceName", valid_618635
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618636: Call_PostDeleteTags_618622; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_618636.validator(path, query, header, formData, body, _)
  let scheme = call_618636.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618636.url(scheme.get, call_618636.host, call_618636.base,
                         call_618636.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618636, url, valid, _)

proc call*(call_618637: Call_PostDeleteTags_618622; TagKeys: JsonNode;
          ResourceName: string; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteTags
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   Action: string (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Version: string (required)
  var query_618638 = newJObject()
  var formData_618639 = newJObject()
  add(query_618638, "Action", newJString(Action))
  if TagKeys != nil:
    formData_618639.add "TagKeys", TagKeys
  add(formData_618639, "ResourceName", newJString(ResourceName))
  add(query_618638, "Version", newJString(Version))
  result = call_618637.call(nil, query_618638, nil, formData_618639, nil)

var postDeleteTags* = Call_PostDeleteTags_618622(name: "postDeleteTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_PostDeleteTags_618623,
    base: "/", url: url_PostDeleteTags_618624, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteTags_618605 = ref object of OpenApiRestCall_616850
proc url_GetDeleteTags_618607(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteTags_618606(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  var valid_618608 = query.getOrDefault("Action")
  valid_618608 = validateParameter(valid_618608, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_618608 != nil:
    section.add "Action", valid_618608
  var valid_618609 = query.getOrDefault("ResourceName")
  valid_618609 = validateParameter(valid_618609, JString, required = true,
                                 default = nil)
  if valid_618609 != nil:
    section.add "ResourceName", valid_618609
  var valid_618610 = query.getOrDefault("TagKeys")
  valid_618610 = validateParameter(valid_618610, JArray, required = true, default = nil)
  if valid_618610 != nil:
    section.add "TagKeys", valid_618610
  var valid_618611 = query.getOrDefault("Version")
  valid_618611 = validateParameter(valid_618611, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618611 != nil:
    section.add "Version", valid_618611
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618612 = header.getOrDefault("X-Amz-Date")
  valid_618612 = validateParameter(valid_618612, JString, required = false,
                                 default = nil)
  if valid_618612 != nil:
    section.add "X-Amz-Date", valid_618612
  var valid_618613 = header.getOrDefault("X-Amz-Security-Token")
  valid_618613 = validateParameter(valid_618613, JString, required = false,
                                 default = nil)
  if valid_618613 != nil:
    section.add "X-Amz-Security-Token", valid_618613
  var valid_618614 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618614 = validateParameter(valid_618614, JString, required = false,
                                 default = nil)
  if valid_618614 != nil:
    section.add "X-Amz-Content-Sha256", valid_618614
  var valid_618615 = header.getOrDefault("X-Amz-Algorithm")
  valid_618615 = validateParameter(valid_618615, JString, required = false,
                                 default = nil)
  if valid_618615 != nil:
    section.add "X-Amz-Algorithm", valid_618615
  var valid_618616 = header.getOrDefault("X-Amz-Signature")
  valid_618616 = validateParameter(valid_618616, JString, required = false,
                                 default = nil)
  if valid_618616 != nil:
    section.add "X-Amz-Signature", valid_618616
  var valid_618617 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618617 = validateParameter(valid_618617, JString, required = false,
                                 default = nil)
  if valid_618617 != nil:
    section.add "X-Amz-SignedHeaders", valid_618617
  var valid_618618 = header.getOrDefault("X-Amz-Credential")
  valid_618618 = validateParameter(valid_618618, JString, required = false,
                                 default = nil)
  if valid_618618 != nil:
    section.add "X-Amz-Credential", valid_618618
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618619: Call_GetDeleteTags_618605; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_618619.validator(path, query, header, formData, body, _)
  let scheme = call_618619.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618619.url(scheme.get, call_618619.host, call_618619.base,
                         call_618619.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618619, url, valid, _)

proc call*(call_618620: Call_GetDeleteTags_618605; ResourceName: string;
          TagKeys: JsonNode; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteTags
  ## Deletes tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   Action: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Version: string (required)
  var query_618621 = newJObject()
  add(query_618621, "Action", newJString(Action))
  add(query_618621, "ResourceName", newJString(ResourceName))
  if TagKeys != nil:
    query_618621.add "TagKeys", TagKeys
  add(query_618621, "Version", newJString(Version))
  result = call_618620.call(nil, query_618621, nil, nil, nil)

var getDeleteTags* = Call_GetDeleteTags_618605(name: "getDeleteTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_GetDeleteTags_618606,
    base: "/", url: url_GetDeleteTags_618607, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeAccountAttributes_618656 = ref object of OpenApiRestCall_616850
proc url_PostDescribeAccountAttributes_618658(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeAccountAttributes_618657(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618659 = query.getOrDefault("Action")
  valid_618659 = validateParameter(valid_618659, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_618659 != nil:
    section.add "Action", valid_618659
  var valid_618660 = query.getOrDefault("Version")
  valid_618660 = validateParameter(valid_618660, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618660 != nil:
    section.add "Version", valid_618660
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618661 = header.getOrDefault("X-Amz-Date")
  valid_618661 = validateParameter(valid_618661, JString, required = false,
                                 default = nil)
  if valid_618661 != nil:
    section.add "X-Amz-Date", valid_618661
  var valid_618662 = header.getOrDefault("X-Amz-Security-Token")
  valid_618662 = validateParameter(valid_618662, JString, required = false,
                                 default = nil)
  if valid_618662 != nil:
    section.add "X-Amz-Security-Token", valid_618662
  var valid_618663 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618663 = validateParameter(valid_618663, JString, required = false,
                                 default = nil)
  if valid_618663 != nil:
    section.add "X-Amz-Content-Sha256", valid_618663
  var valid_618664 = header.getOrDefault("X-Amz-Algorithm")
  valid_618664 = validateParameter(valid_618664, JString, required = false,
                                 default = nil)
  if valid_618664 != nil:
    section.add "X-Amz-Algorithm", valid_618664
  var valid_618665 = header.getOrDefault("X-Amz-Signature")
  valid_618665 = validateParameter(valid_618665, JString, required = false,
                                 default = nil)
  if valid_618665 != nil:
    section.add "X-Amz-Signature", valid_618665
  var valid_618666 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618666 = validateParameter(valid_618666, JString, required = false,
                                 default = nil)
  if valid_618666 != nil:
    section.add "X-Amz-SignedHeaders", valid_618666
  var valid_618667 = header.getOrDefault("X-Amz-Credential")
  valid_618667 = validateParameter(valid_618667, JString, required = false,
                                 default = nil)
  if valid_618667 != nil:
    section.add "X-Amz-Credential", valid_618667
  result.add "header", section
  ## parameters in `formData` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  section = newJObject()
  var valid_618668 = formData.getOrDefault("AttributeNames")
  valid_618668 = validateParameter(valid_618668, JArray, required = false,
                                 default = nil)
  if valid_618668 != nil:
    section.add "AttributeNames", valid_618668
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618669: Call_PostDescribeAccountAttributes_618656;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_618669.validator(path, query, header, formData, body, _)
  let scheme = call_618669.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618669.url(scheme.get, call_618669.host, call_618669.base,
                         call_618669.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618669, url, valid, _)

proc call*(call_618670: Call_PostDescribeAccountAttributes_618656;
          Action: string = "DescribeAccountAttributes";
          AttributeNames: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   Action: string (required)
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Version: string (required)
  var query_618671 = newJObject()
  var formData_618672 = newJObject()
  add(query_618671, "Action", newJString(Action))
  if AttributeNames != nil:
    formData_618672.add "AttributeNames", AttributeNames
  add(query_618671, "Version", newJString(Version))
  result = call_618670.call(nil, query_618671, nil, formData_618672, nil)

var postDescribeAccountAttributes* = Call_PostDescribeAccountAttributes_618656(
    name: "postDescribeAccountAttributes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_PostDescribeAccountAttributes_618657, base: "/",
    url: url_PostDescribeAccountAttributes_618658,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeAccountAttributes_618640 = ref object of OpenApiRestCall_616850
proc url_GetDescribeAccountAttributes_618642(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeAccountAttributes_618641(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618643 = query.getOrDefault("AttributeNames")
  valid_618643 = validateParameter(valid_618643, JArray, required = false,
                                 default = nil)
  if valid_618643 != nil:
    section.add "AttributeNames", valid_618643
  var valid_618644 = query.getOrDefault("Action")
  valid_618644 = validateParameter(valid_618644, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_618644 != nil:
    section.add "Action", valid_618644
  var valid_618645 = query.getOrDefault("Version")
  valid_618645 = validateParameter(valid_618645, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618645 != nil:
    section.add "Version", valid_618645
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618646 = header.getOrDefault("X-Amz-Date")
  valid_618646 = validateParameter(valid_618646, JString, required = false,
                                 default = nil)
  if valid_618646 != nil:
    section.add "X-Amz-Date", valid_618646
  var valid_618647 = header.getOrDefault("X-Amz-Security-Token")
  valid_618647 = validateParameter(valid_618647, JString, required = false,
                                 default = nil)
  if valid_618647 != nil:
    section.add "X-Amz-Security-Token", valid_618647
  var valid_618648 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618648 = validateParameter(valid_618648, JString, required = false,
                                 default = nil)
  if valid_618648 != nil:
    section.add "X-Amz-Content-Sha256", valid_618648
  var valid_618649 = header.getOrDefault("X-Amz-Algorithm")
  valid_618649 = validateParameter(valid_618649, JString, required = false,
                                 default = nil)
  if valid_618649 != nil:
    section.add "X-Amz-Algorithm", valid_618649
  var valid_618650 = header.getOrDefault("X-Amz-Signature")
  valid_618650 = validateParameter(valid_618650, JString, required = false,
                                 default = nil)
  if valid_618650 != nil:
    section.add "X-Amz-Signature", valid_618650
  var valid_618651 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618651 = validateParameter(valid_618651, JString, required = false,
                                 default = nil)
  if valid_618651 != nil:
    section.add "X-Amz-SignedHeaders", valid_618651
  var valid_618652 = header.getOrDefault("X-Amz-Credential")
  valid_618652 = validateParameter(valid_618652, JString, required = false,
                                 default = nil)
  if valid_618652 != nil:
    section.add "X-Amz-Credential", valid_618652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618653: Call_GetDescribeAccountAttributes_618640;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_618653.validator(path, query, header, formData, body, _)
  let scheme = call_618653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618653.url(scheme.get, call_618653.host, call_618653.base,
                         call_618653.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618653, url, valid, _)

proc call*(call_618654: Call_GetDescribeAccountAttributes_618640;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_618655 = newJObject()
  if AttributeNames != nil:
    query_618655.add "AttributeNames", AttributeNames
  add(query_618655, "Action", newJString(Action))
  add(query_618655, "Version", newJString(Version))
  result = call_618654.call(nil, query_618655, nil, nil, nil)

var getDescribeAccountAttributes* = Call_GetDescribeAccountAttributes_618640(
    name: "getDescribeAccountAttributes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_GetDescribeAccountAttributes_618641, base: "/",
    url: url_GetDescribeAccountAttributes_618642,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterDbRevisions_618691 = ref object of OpenApiRestCall_616850
proc url_PostDescribeClusterDbRevisions_618693(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterDbRevisions_618692(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618694 = query.getOrDefault("Action")
  valid_618694 = validateParameter(valid_618694, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_618694 != nil:
    section.add "Action", valid_618694
  var valid_618695 = query.getOrDefault("Version")
  valid_618695 = validateParameter(valid_618695, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618695 != nil:
    section.add "Version", valid_618695
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618696 = header.getOrDefault("X-Amz-Date")
  valid_618696 = validateParameter(valid_618696, JString, required = false,
                                 default = nil)
  if valid_618696 != nil:
    section.add "X-Amz-Date", valid_618696
  var valid_618697 = header.getOrDefault("X-Amz-Security-Token")
  valid_618697 = validateParameter(valid_618697, JString, required = false,
                                 default = nil)
  if valid_618697 != nil:
    section.add "X-Amz-Security-Token", valid_618697
  var valid_618698 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618698 = validateParameter(valid_618698, JString, required = false,
                                 default = nil)
  if valid_618698 != nil:
    section.add "X-Amz-Content-Sha256", valid_618698
  var valid_618699 = header.getOrDefault("X-Amz-Algorithm")
  valid_618699 = validateParameter(valid_618699, JString, required = false,
                                 default = nil)
  if valid_618699 != nil:
    section.add "X-Amz-Algorithm", valid_618699
  var valid_618700 = header.getOrDefault("X-Amz-Signature")
  valid_618700 = validateParameter(valid_618700, JString, required = false,
                                 default = nil)
  if valid_618700 != nil:
    section.add "X-Amz-Signature", valid_618700
  var valid_618701 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618701 = validateParameter(valid_618701, JString, required = false,
                                 default = nil)
  if valid_618701 != nil:
    section.add "X-Amz-SignedHeaders", valid_618701
  var valid_618702 = header.getOrDefault("X-Amz-Credential")
  valid_618702 = validateParameter(valid_618702, JString, required = false,
                                 default = nil)
  if valid_618702 != nil:
    section.add "X-Amz-Credential", valid_618702
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_618703 = formData.getOrDefault("ClusterIdentifier")
  valid_618703 = validateParameter(valid_618703, JString, required = false,
                                 default = nil)
  if valid_618703 != nil:
    section.add "ClusterIdentifier", valid_618703
  var valid_618704 = formData.getOrDefault("Marker")
  valid_618704 = validateParameter(valid_618704, JString, required = false,
                                 default = nil)
  if valid_618704 != nil:
    section.add "Marker", valid_618704
  var valid_618705 = formData.getOrDefault("MaxRecords")
  valid_618705 = validateParameter(valid_618705, JInt, required = false, default = nil)
  if valid_618705 != nil:
    section.add "MaxRecords", valid_618705
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618706: Call_PostDescribeClusterDbRevisions_618691;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_618706.validator(path, query, header, formData, body, _)
  let scheme = call_618706.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618706.url(scheme.get, call_618706.host, call_618706.base,
                         call_618706.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618706, url, valid, _)

proc call*(call_618707: Call_PostDescribeClusterDbRevisions_618691;
          Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; Marker: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_618708 = newJObject()
  var formData_618709 = newJObject()
  add(query_618708, "Action", newJString(Action))
  add(formData_618709, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_618709, "Marker", newJString(Marker))
  add(formData_618709, "MaxRecords", newJInt(MaxRecords))
  add(query_618708, "Version", newJString(Version))
  result = call_618707.call(nil, query_618708, nil, formData_618709, nil)

var postDescribeClusterDbRevisions* = Call_PostDescribeClusterDbRevisions_618691(
    name: "postDescribeClusterDbRevisions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_PostDescribeClusterDbRevisions_618692, base: "/",
    url: url_PostDescribeClusterDbRevisions_618693,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterDbRevisions_618673 = ref object of OpenApiRestCall_616850
proc url_GetDescribeClusterDbRevisions_618675(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterDbRevisions_618674(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_618676 = query.getOrDefault("MaxRecords")
  valid_618676 = validateParameter(valid_618676, JInt, required = false, default = nil)
  if valid_618676 != nil:
    section.add "MaxRecords", valid_618676
  var valid_618677 = query.getOrDefault("Action")
  valid_618677 = validateParameter(valid_618677, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_618677 != nil:
    section.add "Action", valid_618677
  var valid_618678 = query.getOrDefault("ClusterIdentifier")
  valid_618678 = validateParameter(valid_618678, JString, required = false,
                                 default = nil)
  if valid_618678 != nil:
    section.add "ClusterIdentifier", valid_618678
  var valid_618679 = query.getOrDefault("Marker")
  valid_618679 = validateParameter(valid_618679, JString, required = false,
                                 default = nil)
  if valid_618679 != nil:
    section.add "Marker", valid_618679
  var valid_618680 = query.getOrDefault("Version")
  valid_618680 = validateParameter(valid_618680, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618680 != nil:
    section.add "Version", valid_618680
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618681 = header.getOrDefault("X-Amz-Date")
  valid_618681 = validateParameter(valid_618681, JString, required = false,
                                 default = nil)
  if valid_618681 != nil:
    section.add "X-Amz-Date", valid_618681
  var valid_618682 = header.getOrDefault("X-Amz-Security-Token")
  valid_618682 = validateParameter(valid_618682, JString, required = false,
                                 default = nil)
  if valid_618682 != nil:
    section.add "X-Amz-Security-Token", valid_618682
  var valid_618683 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618683 = validateParameter(valid_618683, JString, required = false,
                                 default = nil)
  if valid_618683 != nil:
    section.add "X-Amz-Content-Sha256", valid_618683
  var valid_618684 = header.getOrDefault("X-Amz-Algorithm")
  valid_618684 = validateParameter(valid_618684, JString, required = false,
                                 default = nil)
  if valid_618684 != nil:
    section.add "X-Amz-Algorithm", valid_618684
  var valid_618685 = header.getOrDefault("X-Amz-Signature")
  valid_618685 = validateParameter(valid_618685, JString, required = false,
                                 default = nil)
  if valid_618685 != nil:
    section.add "X-Amz-Signature", valid_618685
  var valid_618686 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618686 = validateParameter(valid_618686, JString, required = false,
                                 default = nil)
  if valid_618686 != nil:
    section.add "X-Amz-SignedHeaders", valid_618686
  var valid_618687 = header.getOrDefault("X-Amz-Credential")
  valid_618687 = validateParameter(valid_618687, JString, required = false,
                                 default = nil)
  if valid_618687 != nil:
    section.add "X-Amz-Credential", valid_618687
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618688: Call_GetDescribeClusterDbRevisions_618673;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_618688.validator(path, query, header, formData, body, _)
  let scheme = call_618688.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618688.url(scheme.get, call_618688.host, call_618688.base,
                         call_618688.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618688, url, valid, _)

proc call*(call_618689: Call_GetDescribeClusterDbRevisions_618673;
          MaxRecords: int = 0; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Version: string (required)
  var query_618690 = newJObject()
  add(query_618690, "MaxRecords", newJInt(MaxRecords))
  add(query_618690, "Action", newJString(Action))
  add(query_618690, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_618690, "Marker", newJString(Marker))
  add(query_618690, "Version", newJString(Version))
  result = call_618689.call(nil, query_618690, nil, nil, nil)

var getDescribeClusterDbRevisions* = Call_GetDescribeClusterDbRevisions_618673(
    name: "getDescribeClusterDbRevisions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_GetDescribeClusterDbRevisions_618674, base: "/",
    url: url_GetDescribeClusterDbRevisions_618675,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameterGroups_618730 = ref object of OpenApiRestCall_616850
proc url_PostDescribeClusterParameterGroups_618732(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameterGroups_618731(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618733 = query.getOrDefault("Action")
  valid_618733 = validateParameter(valid_618733, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_618733 != nil:
    section.add "Action", valid_618733
  var valid_618734 = query.getOrDefault("Version")
  valid_618734 = validateParameter(valid_618734, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618734 != nil:
    section.add "Version", valid_618734
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618735 = header.getOrDefault("X-Amz-Date")
  valid_618735 = validateParameter(valid_618735, JString, required = false,
                                 default = nil)
  if valid_618735 != nil:
    section.add "X-Amz-Date", valid_618735
  var valid_618736 = header.getOrDefault("X-Amz-Security-Token")
  valid_618736 = validateParameter(valid_618736, JString, required = false,
                                 default = nil)
  if valid_618736 != nil:
    section.add "X-Amz-Security-Token", valid_618736
  var valid_618737 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618737 = validateParameter(valid_618737, JString, required = false,
                                 default = nil)
  if valid_618737 != nil:
    section.add "X-Amz-Content-Sha256", valid_618737
  var valid_618738 = header.getOrDefault("X-Amz-Algorithm")
  valid_618738 = validateParameter(valid_618738, JString, required = false,
                                 default = nil)
  if valid_618738 != nil:
    section.add "X-Amz-Algorithm", valid_618738
  var valid_618739 = header.getOrDefault("X-Amz-Signature")
  valid_618739 = validateParameter(valid_618739, JString, required = false,
                                 default = nil)
  if valid_618739 != nil:
    section.add "X-Amz-Signature", valid_618739
  var valid_618740 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618740 = validateParameter(valid_618740, JString, required = false,
                                 default = nil)
  if valid_618740 != nil:
    section.add "X-Amz-SignedHeaders", valid_618740
  var valid_618741 = header.getOrDefault("X-Amz-Credential")
  valid_618741 = validateParameter(valid_618741, JString, required = false,
                                 default = nil)
  if valid_618741 != nil:
    section.add "X-Amz-Credential", valid_618741
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_618742 = formData.getOrDefault("ParameterGroupName")
  valid_618742 = validateParameter(valid_618742, JString, required = false,
                                 default = nil)
  if valid_618742 != nil:
    section.add "ParameterGroupName", valid_618742
  var valid_618743 = formData.getOrDefault("TagKeys")
  valid_618743 = validateParameter(valid_618743, JArray, required = false,
                                 default = nil)
  if valid_618743 != nil:
    section.add "TagKeys", valid_618743
  var valid_618744 = formData.getOrDefault("Marker")
  valid_618744 = validateParameter(valid_618744, JString, required = false,
                                 default = nil)
  if valid_618744 != nil:
    section.add "Marker", valid_618744
  var valid_618745 = formData.getOrDefault("MaxRecords")
  valid_618745 = validateParameter(valid_618745, JInt, required = false, default = nil)
  if valid_618745 != nil:
    section.add "MaxRecords", valid_618745
  var valid_618746 = formData.getOrDefault("TagValues")
  valid_618746 = validateParameter(valid_618746, JArray, required = false,
                                 default = nil)
  if valid_618746 != nil:
    section.add "TagValues", valid_618746
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618747: Call_PostDescribeClusterParameterGroups_618730;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_618747.validator(path, query, header, formData, body, _)
  let scheme = call_618747.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618747.url(scheme.get, call_618747.host, call_618747.base,
                         call_618747.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618747, url, valid, _)

proc call*(call_618748: Call_PostDescribeClusterParameterGroups_618730;
          ParameterGroupName: string = "";
          Action: string = "DescribeClusterParameterGroups";
          TagKeys: JsonNode = nil; Marker: string = ""; MaxRecords: int = 0;
          TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_618749 = newJObject()
  var formData_618750 = newJObject()
  add(formData_618750, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_618749, "Action", newJString(Action))
  if TagKeys != nil:
    formData_618750.add "TagKeys", TagKeys
  add(formData_618750, "Marker", newJString(Marker))
  add(formData_618750, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_618750.add "TagValues", TagValues
  add(query_618749, "Version", newJString(Version))
  result = call_618748.call(nil, query_618749, nil, formData_618750, nil)

var postDescribeClusterParameterGroups* = Call_PostDescribeClusterParameterGroups_618730(
    name: "postDescribeClusterParameterGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_PostDescribeClusterParameterGroups_618731, base: "/",
    url: url_PostDescribeClusterParameterGroups_618732,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameterGroups_618710 = ref object of OpenApiRestCall_616850
proc url_GetDescribeClusterParameterGroups_618712(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameterGroups_618711(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_618713 = query.getOrDefault("TagValues")
  valid_618713 = validateParameter(valid_618713, JArray, required = false,
                                 default = nil)
  if valid_618713 != nil:
    section.add "TagValues", valid_618713
  var valid_618714 = query.getOrDefault("MaxRecords")
  valid_618714 = validateParameter(valid_618714, JInt, required = false, default = nil)
  if valid_618714 != nil:
    section.add "MaxRecords", valid_618714
  var valid_618715 = query.getOrDefault("ParameterGroupName")
  valid_618715 = validateParameter(valid_618715, JString, required = false,
                                 default = nil)
  if valid_618715 != nil:
    section.add "ParameterGroupName", valid_618715
  var valid_618716 = query.getOrDefault("Action")
  valid_618716 = validateParameter(valid_618716, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_618716 != nil:
    section.add "Action", valid_618716
  var valid_618717 = query.getOrDefault("Marker")
  valid_618717 = validateParameter(valid_618717, JString, required = false,
                                 default = nil)
  if valid_618717 != nil:
    section.add "Marker", valid_618717
  var valid_618718 = query.getOrDefault("TagKeys")
  valid_618718 = validateParameter(valid_618718, JArray, required = false,
                                 default = nil)
  if valid_618718 != nil:
    section.add "TagKeys", valid_618718
  var valid_618719 = query.getOrDefault("Version")
  valid_618719 = validateParameter(valid_618719, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618719 != nil:
    section.add "Version", valid_618719
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618720 = header.getOrDefault("X-Amz-Date")
  valid_618720 = validateParameter(valid_618720, JString, required = false,
                                 default = nil)
  if valid_618720 != nil:
    section.add "X-Amz-Date", valid_618720
  var valid_618721 = header.getOrDefault("X-Amz-Security-Token")
  valid_618721 = validateParameter(valid_618721, JString, required = false,
                                 default = nil)
  if valid_618721 != nil:
    section.add "X-Amz-Security-Token", valid_618721
  var valid_618722 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618722 = validateParameter(valid_618722, JString, required = false,
                                 default = nil)
  if valid_618722 != nil:
    section.add "X-Amz-Content-Sha256", valid_618722
  var valid_618723 = header.getOrDefault("X-Amz-Algorithm")
  valid_618723 = validateParameter(valid_618723, JString, required = false,
                                 default = nil)
  if valid_618723 != nil:
    section.add "X-Amz-Algorithm", valid_618723
  var valid_618724 = header.getOrDefault("X-Amz-Signature")
  valid_618724 = validateParameter(valid_618724, JString, required = false,
                                 default = nil)
  if valid_618724 != nil:
    section.add "X-Amz-Signature", valid_618724
  var valid_618725 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618725 = validateParameter(valid_618725, JString, required = false,
                                 default = nil)
  if valid_618725 != nil:
    section.add "X-Amz-SignedHeaders", valid_618725
  var valid_618726 = header.getOrDefault("X-Amz-Credential")
  valid_618726 = validateParameter(valid_618726, JString, required = false,
                                 default = nil)
  if valid_618726 != nil:
    section.add "X-Amz-Credential", valid_618726
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618727: Call_GetDescribeClusterParameterGroups_618710;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_618727.validator(path, query, header, formData, body, _)
  let scheme = call_618727.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618727.url(scheme.get, call_618727.host, call_618727.base,
                         call_618727.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618727, url, valid, _)

proc call*(call_618728: Call_GetDescribeClusterParameterGroups_618710;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          ParameterGroupName: string = "";
          Action: string = "DescribeClusterParameterGroups"; Marker: string = "";
          TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_618729 = newJObject()
  if TagValues != nil:
    query_618729.add "TagValues", TagValues
  add(query_618729, "MaxRecords", newJInt(MaxRecords))
  add(query_618729, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_618729, "Action", newJString(Action))
  add(query_618729, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_618729.add "TagKeys", TagKeys
  add(query_618729, "Version", newJString(Version))
  result = call_618728.call(nil, query_618729, nil, nil, nil)

var getDescribeClusterParameterGroups* = Call_GetDescribeClusterParameterGroups_618710(
    name: "getDescribeClusterParameterGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_GetDescribeClusterParameterGroups_618711, base: "/",
    url: url_GetDescribeClusterParameterGroups_618712,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameters_618770 = ref object of OpenApiRestCall_616850
proc url_PostDescribeClusterParameters_618772(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameters_618771(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618773 = query.getOrDefault("Action")
  valid_618773 = validateParameter(valid_618773, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_618773 != nil:
    section.add "Action", valid_618773
  var valid_618774 = query.getOrDefault("Version")
  valid_618774 = validateParameter(valid_618774, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618774 != nil:
    section.add "Version", valid_618774
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618775 = header.getOrDefault("X-Amz-Date")
  valid_618775 = validateParameter(valid_618775, JString, required = false,
                                 default = nil)
  if valid_618775 != nil:
    section.add "X-Amz-Date", valid_618775
  var valid_618776 = header.getOrDefault("X-Amz-Security-Token")
  valid_618776 = validateParameter(valid_618776, JString, required = false,
                                 default = nil)
  if valid_618776 != nil:
    section.add "X-Amz-Security-Token", valid_618776
  var valid_618777 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618777 = validateParameter(valid_618777, JString, required = false,
                                 default = nil)
  if valid_618777 != nil:
    section.add "X-Amz-Content-Sha256", valid_618777
  var valid_618778 = header.getOrDefault("X-Amz-Algorithm")
  valid_618778 = validateParameter(valid_618778, JString, required = false,
                                 default = nil)
  if valid_618778 != nil:
    section.add "X-Amz-Algorithm", valid_618778
  var valid_618779 = header.getOrDefault("X-Amz-Signature")
  valid_618779 = validateParameter(valid_618779, JString, required = false,
                                 default = nil)
  if valid_618779 != nil:
    section.add "X-Amz-Signature", valid_618779
  var valid_618780 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618780 = validateParameter(valid_618780, JString, required = false,
                                 default = nil)
  if valid_618780 != nil:
    section.add "X-Amz-SignedHeaders", valid_618780
  var valid_618781 = header.getOrDefault("X-Amz-Credential")
  valid_618781 = validateParameter(valid_618781, JString, required = false,
                                 default = nil)
  if valid_618781 != nil:
    section.add "X-Amz-Credential", valid_618781
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_618782 = formData.getOrDefault("ParameterGroupName")
  valid_618782 = validateParameter(valid_618782, JString, required = true,
                                 default = nil)
  if valid_618782 != nil:
    section.add "ParameterGroupName", valid_618782
  var valid_618783 = formData.getOrDefault("Marker")
  valid_618783 = validateParameter(valid_618783, JString, required = false,
                                 default = nil)
  if valid_618783 != nil:
    section.add "Marker", valid_618783
  var valid_618784 = formData.getOrDefault("MaxRecords")
  valid_618784 = validateParameter(valid_618784, JInt, required = false, default = nil)
  if valid_618784 != nil:
    section.add "MaxRecords", valid_618784
  var valid_618785 = formData.getOrDefault("Source")
  valid_618785 = validateParameter(valid_618785, JString, required = false,
                                 default = nil)
  if valid_618785 != nil:
    section.add "Source", valid_618785
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618786: Call_PostDescribeClusterParameters_618770;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_618786.validator(path, query, header, formData, body, _)
  let scheme = call_618786.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618786.url(scheme.get, call_618786.host, call_618786.base,
                         call_618786.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618786, url, valid, _)

proc call*(call_618787: Call_PostDescribeClusterParameters_618770;
          ParameterGroupName: string;
          Action: string = "DescribeClusterParameters"; Marker: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01"; Source: string = ""): Recallable =
  ## postDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  var query_618788 = newJObject()
  var formData_618789 = newJObject()
  add(formData_618789, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_618788, "Action", newJString(Action))
  add(formData_618789, "Marker", newJString(Marker))
  add(formData_618789, "MaxRecords", newJInt(MaxRecords))
  add(query_618788, "Version", newJString(Version))
  add(formData_618789, "Source", newJString(Source))
  result = call_618787.call(nil, query_618788, nil, formData_618789, nil)

var postDescribeClusterParameters* = Call_PostDescribeClusterParameters_618770(
    name: "postDescribeClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_PostDescribeClusterParameters_618771, base: "/",
    url: url_PostDescribeClusterParameters_618772,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameters_618751 = ref object of OpenApiRestCall_616850
proc url_GetDescribeClusterParameters_618753(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameters_618752(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_618754 = query.getOrDefault("MaxRecords")
  valid_618754 = validateParameter(valid_618754, JInt, required = false, default = nil)
  if valid_618754 != nil:
    section.add "MaxRecords", valid_618754
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_618755 = query.getOrDefault("ParameterGroupName")
  valid_618755 = validateParameter(valid_618755, JString, required = true,
                                 default = nil)
  if valid_618755 != nil:
    section.add "ParameterGroupName", valid_618755
  var valid_618756 = query.getOrDefault("Action")
  valid_618756 = validateParameter(valid_618756, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_618756 != nil:
    section.add "Action", valid_618756
  var valid_618757 = query.getOrDefault("Marker")
  valid_618757 = validateParameter(valid_618757, JString, required = false,
                                 default = nil)
  if valid_618757 != nil:
    section.add "Marker", valid_618757
  var valid_618758 = query.getOrDefault("Source")
  valid_618758 = validateParameter(valid_618758, JString, required = false,
                                 default = nil)
  if valid_618758 != nil:
    section.add "Source", valid_618758
  var valid_618759 = query.getOrDefault("Version")
  valid_618759 = validateParameter(valid_618759, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618759 != nil:
    section.add "Version", valid_618759
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618760 = header.getOrDefault("X-Amz-Date")
  valid_618760 = validateParameter(valid_618760, JString, required = false,
                                 default = nil)
  if valid_618760 != nil:
    section.add "X-Amz-Date", valid_618760
  var valid_618761 = header.getOrDefault("X-Amz-Security-Token")
  valid_618761 = validateParameter(valid_618761, JString, required = false,
                                 default = nil)
  if valid_618761 != nil:
    section.add "X-Amz-Security-Token", valid_618761
  var valid_618762 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618762 = validateParameter(valid_618762, JString, required = false,
                                 default = nil)
  if valid_618762 != nil:
    section.add "X-Amz-Content-Sha256", valid_618762
  var valid_618763 = header.getOrDefault("X-Amz-Algorithm")
  valid_618763 = validateParameter(valid_618763, JString, required = false,
                                 default = nil)
  if valid_618763 != nil:
    section.add "X-Amz-Algorithm", valid_618763
  var valid_618764 = header.getOrDefault("X-Amz-Signature")
  valid_618764 = validateParameter(valid_618764, JString, required = false,
                                 default = nil)
  if valid_618764 != nil:
    section.add "X-Amz-Signature", valid_618764
  var valid_618765 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618765 = validateParameter(valid_618765, JString, required = false,
                                 default = nil)
  if valid_618765 != nil:
    section.add "X-Amz-SignedHeaders", valid_618765
  var valid_618766 = header.getOrDefault("X-Amz-Credential")
  valid_618766 = validateParameter(valid_618766, JString, required = false,
                                 default = nil)
  if valid_618766 != nil:
    section.add "X-Amz-Credential", valid_618766
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618767: Call_GetDescribeClusterParameters_618751;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_618767.validator(path, query, header, formData, body, _)
  let scheme = call_618767.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618767.url(scheme.get, call_618767.host, call_618767.base,
                         call_618767.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618767, url, valid, _)

proc call*(call_618768: Call_GetDescribeClusterParameters_618751;
          ParameterGroupName: string; MaxRecords: int = 0;
          Action: string = "DescribeClusterParameters"; Marker: string = "";
          Source: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Version: string (required)
  var query_618769 = newJObject()
  add(query_618769, "MaxRecords", newJInt(MaxRecords))
  add(query_618769, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_618769, "Action", newJString(Action))
  add(query_618769, "Marker", newJString(Marker))
  add(query_618769, "Source", newJString(Source))
  add(query_618769, "Version", newJString(Version))
  result = call_618768.call(nil, query_618769, nil, nil, nil)

var getDescribeClusterParameters* = Call_GetDescribeClusterParameters_618751(
    name: "getDescribeClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_GetDescribeClusterParameters_618752, base: "/",
    url: url_GetDescribeClusterParameters_618753,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSecurityGroups_618810 = ref object of OpenApiRestCall_616850
proc url_PostDescribeClusterSecurityGroups_618812(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSecurityGroups_618811(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618813 = query.getOrDefault("Action")
  valid_618813 = validateParameter(valid_618813, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_618813 != nil:
    section.add "Action", valid_618813
  var valid_618814 = query.getOrDefault("Version")
  valid_618814 = validateParameter(valid_618814, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618814 != nil:
    section.add "Version", valid_618814
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618815 = header.getOrDefault("X-Amz-Date")
  valid_618815 = validateParameter(valid_618815, JString, required = false,
                                 default = nil)
  if valid_618815 != nil:
    section.add "X-Amz-Date", valid_618815
  var valid_618816 = header.getOrDefault("X-Amz-Security-Token")
  valid_618816 = validateParameter(valid_618816, JString, required = false,
                                 default = nil)
  if valid_618816 != nil:
    section.add "X-Amz-Security-Token", valid_618816
  var valid_618817 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618817 = validateParameter(valid_618817, JString, required = false,
                                 default = nil)
  if valid_618817 != nil:
    section.add "X-Amz-Content-Sha256", valid_618817
  var valid_618818 = header.getOrDefault("X-Amz-Algorithm")
  valid_618818 = validateParameter(valid_618818, JString, required = false,
                                 default = nil)
  if valid_618818 != nil:
    section.add "X-Amz-Algorithm", valid_618818
  var valid_618819 = header.getOrDefault("X-Amz-Signature")
  valid_618819 = validateParameter(valid_618819, JString, required = false,
                                 default = nil)
  if valid_618819 != nil:
    section.add "X-Amz-Signature", valid_618819
  var valid_618820 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618820 = validateParameter(valid_618820, JString, required = false,
                                 default = nil)
  if valid_618820 != nil:
    section.add "X-Amz-SignedHeaders", valid_618820
  var valid_618821 = header.getOrDefault("X-Amz-Credential")
  valid_618821 = validateParameter(valid_618821, JString, required = false,
                                 default = nil)
  if valid_618821 != nil:
    section.add "X-Amz-Credential", valid_618821
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  section = newJObject()
  var valid_618822 = formData.getOrDefault("TagKeys")
  valid_618822 = validateParameter(valid_618822, JArray, required = false,
                                 default = nil)
  if valid_618822 != nil:
    section.add "TagKeys", valid_618822
  var valid_618823 = formData.getOrDefault("Marker")
  valid_618823 = validateParameter(valid_618823, JString, required = false,
                                 default = nil)
  if valid_618823 != nil:
    section.add "Marker", valid_618823
  var valid_618824 = formData.getOrDefault("MaxRecords")
  valid_618824 = validateParameter(valid_618824, JInt, required = false, default = nil)
  if valid_618824 != nil:
    section.add "MaxRecords", valid_618824
  var valid_618825 = formData.getOrDefault("TagValues")
  valid_618825 = validateParameter(valid_618825, JArray, required = false,
                                 default = nil)
  if valid_618825 != nil:
    section.add "TagValues", valid_618825
  var valid_618826 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_618826 = validateParameter(valid_618826, JString, required = false,
                                 default = nil)
  if valid_618826 != nil:
    section.add "ClusterSecurityGroupName", valid_618826
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618827: Call_PostDescribeClusterSecurityGroups_618810;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_618827.validator(path, query, header, formData, body, _)
  let scheme = call_618827.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618827.url(scheme.get, call_618827.host, call_618827.base,
                         call_618827.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618827, url, valid, _)

proc call*(call_618828: Call_PostDescribeClusterSecurityGroups_618810;
          Action: string = "DescribeClusterSecurityGroups"; TagKeys: JsonNode = nil;
          Marker: string = ""; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"; ClusterSecurityGroupName: string = ""): Recallable =
  ## postDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  var query_618829 = newJObject()
  var formData_618830 = newJObject()
  add(query_618829, "Action", newJString(Action))
  if TagKeys != nil:
    formData_618830.add "TagKeys", TagKeys
  add(formData_618830, "Marker", newJString(Marker))
  add(formData_618830, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_618830.add "TagValues", TagValues
  add(query_618829, "Version", newJString(Version))
  add(formData_618830, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_618828.call(nil, query_618829, nil, formData_618830, nil)

var postDescribeClusterSecurityGroups* = Call_PostDescribeClusterSecurityGroups_618810(
    name: "postDescribeClusterSecurityGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_PostDescribeClusterSecurityGroups_618811, base: "/",
    url: url_PostDescribeClusterSecurityGroups_618812,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSecurityGroups_618790 = ref object of OpenApiRestCall_616850
proc url_GetDescribeClusterSecurityGroups_618792(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSecurityGroups_618791(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  section = newJObject()
  var valid_618793 = query.getOrDefault("TagValues")
  valid_618793 = validateParameter(valid_618793, JArray, required = false,
                                 default = nil)
  if valid_618793 != nil:
    section.add "TagValues", valid_618793
  var valid_618794 = query.getOrDefault("MaxRecords")
  valid_618794 = validateParameter(valid_618794, JInt, required = false, default = nil)
  if valid_618794 != nil:
    section.add "MaxRecords", valid_618794
  var valid_618795 = query.getOrDefault("Action")
  valid_618795 = validateParameter(valid_618795, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_618795 != nil:
    section.add "Action", valid_618795
  var valid_618796 = query.getOrDefault("Marker")
  valid_618796 = validateParameter(valid_618796, JString, required = false,
                                 default = nil)
  if valid_618796 != nil:
    section.add "Marker", valid_618796
  var valid_618797 = query.getOrDefault("TagKeys")
  valid_618797 = validateParameter(valid_618797, JArray, required = false,
                                 default = nil)
  if valid_618797 != nil:
    section.add "TagKeys", valid_618797
  var valid_618798 = query.getOrDefault("Version")
  valid_618798 = validateParameter(valid_618798, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618798 != nil:
    section.add "Version", valid_618798
  var valid_618799 = query.getOrDefault("ClusterSecurityGroupName")
  valid_618799 = validateParameter(valid_618799, JString, required = false,
                                 default = nil)
  if valid_618799 != nil:
    section.add "ClusterSecurityGroupName", valid_618799
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618800 = header.getOrDefault("X-Amz-Date")
  valid_618800 = validateParameter(valid_618800, JString, required = false,
                                 default = nil)
  if valid_618800 != nil:
    section.add "X-Amz-Date", valid_618800
  var valid_618801 = header.getOrDefault("X-Amz-Security-Token")
  valid_618801 = validateParameter(valid_618801, JString, required = false,
                                 default = nil)
  if valid_618801 != nil:
    section.add "X-Amz-Security-Token", valid_618801
  var valid_618802 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618802 = validateParameter(valid_618802, JString, required = false,
                                 default = nil)
  if valid_618802 != nil:
    section.add "X-Amz-Content-Sha256", valid_618802
  var valid_618803 = header.getOrDefault("X-Amz-Algorithm")
  valid_618803 = validateParameter(valid_618803, JString, required = false,
                                 default = nil)
  if valid_618803 != nil:
    section.add "X-Amz-Algorithm", valid_618803
  var valid_618804 = header.getOrDefault("X-Amz-Signature")
  valid_618804 = validateParameter(valid_618804, JString, required = false,
                                 default = nil)
  if valid_618804 != nil:
    section.add "X-Amz-Signature", valid_618804
  var valid_618805 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618805 = validateParameter(valid_618805, JString, required = false,
                                 default = nil)
  if valid_618805 != nil:
    section.add "X-Amz-SignedHeaders", valid_618805
  var valid_618806 = header.getOrDefault("X-Amz-Credential")
  valid_618806 = validateParameter(valid_618806, JString, required = false,
                                 default = nil)
  if valid_618806 != nil:
    section.add "X-Amz-Credential", valid_618806
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618807: Call_GetDescribeClusterSecurityGroups_618790;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_618807.validator(path, query, header, formData, body, _)
  let scheme = call_618807.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618807.url(scheme.get, call_618807.host, call_618807.base,
                         call_618807.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618807, url, valid, _)

proc call*(call_618808: Call_GetDescribeClusterSecurityGroups_618790;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeClusterSecurityGroups"; Marker: string = "";
          TagKeys: JsonNode = nil; Version: string = "2012-12-01";
          ClusterSecurityGroupName: string = ""): Recallable =
  ## getDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  var query_618809 = newJObject()
  if TagValues != nil:
    query_618809.add "TagValues", TagValues
  add(query_618809, "MaxRecords", newJInt(MaxRecords))
  add(query_618809, "Action", newJString(Action))
  add(query_618809, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_618809.add "TagKeys", TagKeys
  add(query_618809, "Version", newJString(Version))
  add(query_618809, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_618808.call(nil, query_618809, nil, nil, nil)

var getDescribeClusterSecurityGroups* = Call_GetDescribeClusterSecurityGroups_618790(
    name: "getDescribeClusterSecurityGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_GetDescribeClusterSecurityGroups_618791, base: "/",
    url: url_GetDescribeClusterSecurityGroups_618792,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSnapshots_618858 = ref object of OpenApiRestCall_616850
proc url_PostDescribeClusterSnapshots_618860(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSnapshots_618859(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618861 = query.getOrDefault("Action")
  valid_618861 = validateParameter(valid_618861, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_618861 != nil:
    section.add "Action", valid_618861
  var valid_618862 = query.getOrDefault("Version")
  valid_618862 = validateParameter(valid_618862, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618862 != nil:
    section.add "Version", valid_618862
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618863 = header.getOrDefault("X-Amz-Date")
  valid_618863 = validateParameter(valid_618863, JString, required = false,
                                 default = nil)
  if valid_618863 != nil:
    section.add "X-Amz-Date", valid_618863
  var valid_618864 = header.getOrDefault("X-Amz-Security-Token")
  valid_618864 = validateParameter(valid_618864, JString, required = false,
                                 default = nil)
  if valid_618864 != nil:
    section.add "X-Amz-Security-Token", valid_618864
  var valid_618865 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618865 = validateParameter(valid_618865, JString, required = false,
                                 default = nil)
  if valid_618865 != nil:
    section.add "X-Amz-Content-Sha256", valid_618865
  var valid_618866 = header.getOrDefault("X-Amz-Algorithm")
  valid_618866 = validateParameter(valid_618866, JString, required = false,
                                 default = nil)
  if valid_618866 != nil:
    section.add "X-Amz-Algorithm", valid_618866
  var valid_618867 = header.getOrDefault("X-Amz-Signature")
  valid_618867 = validateParameter(valid_618867, JString, required = false,
                                 default = nil)
  if valid_618867 != nil:
    section.add "X-Amz-Signature", valid_618867
  var valid_618868 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618868 = validateParameter(valid_618868, JString, required = false,
                                 default = nil)
  if valid_618868 != nil:
    section.add "X-Amz-SignedHeaders", valid_618868
  var valid_618869 = header.getOrDefault("X-Amz-Credential")
  valid_618869 = validateParameter(valid_618869, JString, required = false,
                                 default = nil)
  if valid_618869 != nil:
    section.add "X-Amz-Credential", valid_618869
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_618870 = formData.getOrDefault("SnapshotType")
  valid_618870 = validateParameter(valid_618870, JString, required = false,
                                 default = nil)
  if valid_618870 != nil:
    section.add "SnapshotType", valid_618870
  var valid_618871 = formData.getOrDefault("SortingEntities")
  valid_618871 = validateParameter(valid_618871, JArray, required = false,
                                 default = nil)
  if valid_618871 != nil:
    section.add "SortingEntities", valid_618871
  var valid_618872 = formData.getOrDefault("SnapshotIdentifier")
  valid_618872 = validateParameter(valid_618872, JString, required = false,
                                 default = nil)
  if valid_618872 != nil:
    section.add "SnapshotIdentifier", valid_618872
  var valid_618873 = formData.getOrDefault("TagKeys")
  valid_618873 = validateParameter(valid_618873, JArray, required = false,
                                 default = nil)
  if valid_618873 != nil:
    section.add "TagKeys", valid_618873
  var valid_618874 = formData.getOrDefault("StartTime")
  valid_618874 = validateParameter(valid_618874, JString, required = false,
                                 default = nil)
  if valid_618874 != nil:
    section.add "StartTime", valid_618874
  var valid_618875 = formData.getOrDefault("OwnerAccount")
  valid_618875 = validateParameter(valid_618875, JString, required = false,
                                 default = nil)
  if valid_618875 != nil:
    section.add "OwnerAccount", valid_618875
  var valid_618876 = formData.getOrDefault("ClusterIdentifier")
  valid_618876 = validateParameter(valid_618876, JString, required = false,
                                 default = nil)
  if valid_618876 != nil:
    section.add "ClusterIdentifier", valid_618876
  var valid_618877 = formData.getOrDefault("ClusterExists")
  valid_618877 = validateParameter(valid_618877, JBool, required = false, default = nil)
  if valid_618877 != nil:
    section.add "ClusterExists", valid_618877
  var valid_618878 = formData.getOrDefault("EndTime")
  valid_618878 = validateParameter(valid_618878, JString, required = false,
                                 default = nil)
  if valid_618878 != nil:
    section.add "EndTime", valid_618878
  var valid_618879 = formData.getOrDefault("Marker")
  valid_618879 = validateParameter(valid_618879, JString, required = false,
                                 default = nil)
  if valid_618879 != nil:
    section.add "Marker", valid_618879
  var valid_618880 = formData.getOrDefault("MaxRecords")
  valid_618880 = validateParameter(valid_618880, JInt, required = false, default = nil)
  if valid_618880 != nil:
    section.add "MaxRecords", valid_618880
  var valid_618881 = formData.getOrDefault("TagValues")
  valid_618881 = validateParameter(valid_618881, JArray, required = false,
                                 default = nil)
  if valid_618881 != nil:
    section.add "TagValues", valid_618881
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618882: Call_PostDescribeClusterSnapshots_618858;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_618882.validator(path, query, header, formData, body, _)
  let scheme = call_618882.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618882.url(scheme.get, call_618882.host, call_618882.base,
                         call_618882.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618882, url, valid, _)

proc call*(call_618883: Call_PostDescribeClusterSnapshots_618858;
          SnapshotType: string = ""; SortingEntities: JsonNode = nil;
          SnapshotIdentifier: string = ""; TagKeys: JsonNode = nil;
          StartTime: string = ""; Action: string = "DescribeClusterSnapshots";
          OwnerAccount: string = ""; ClusterIdentifier: string = "";
          ClusterExists: bool = false; EndTime: string = ""; Marker: string = "";
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_618884 = newJObject()
  var formData_618885 = newJObject()
  add(formData_618885, "SnapshotType", newJString(SnapshotType))
  if SortingEntities != nil:
    formData_618885.add "SortingEntities", SortingEntities
  add(formData_618885, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  if TagKeys != nil:
    formData_618885.add "TagKeys", TagKeys
  add(formData_618885, "StartTime", newJString(StartTime))
  add(query_618884, "Action", newJString(Action))
  add(formData_618885, "OwnerAccount", newJString(OwnerAccount))
  add(formData_618885, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_618885, "ClusterExists", newJBool(ClusterExists))
  add(formData_618885, "EndTime", newJString(EndTime))
  add(formData_618885, "Marker", newJString(Marker))
  add(formData_618885, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_618885.add "TagValues", TagValues
  add(query_618884, "Version", newJString(Version))
  result = call_618883.call(nil, query_618884, nil, formData_618885, nil)

var postDescribeClusterSnapshots* = Call_PostDescribeClusterSnapshots_618858(
    name: "postDescribeClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_PostDescribeClusterSnapshots_618859, base: "/",
    url: url_PostDescribeClusterSnapshots_618860,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSnapshots_618831 = ref object of OpenApiRestCall_616850
proc url_GetDescribeClusterSnapshots_618833(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSnapshots_618832(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Version: JString (required)
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  section = newJObject()
  var valid_618834 = query.getOrDefault("TagValues")
  valid_618834 = validateParameter(valid_618834, JArray, required = false,
                                 default = nil)
  if valid_618834 != nil:
    section.add "TagValues", valid_618834
  var valid_618835 = query.getOrDefault("MaxRecords")
  valid_618835 = validateParameter(valid_618835, JInt, required = false, default = nil)
  if valid_618835 != nil:
    section.add "MaxRecords", valid_618835
  var valid_618836 = query.getOrDefault("SortingEntities")
  valid_618836 = validateParameter(valid_618836, JArray, required = false,
                                 default = nil)
  if valid_618836 != nil:
    section.add "SortingEntities", valid_618836
  var valid_618837 = query.getOrDefault("StartTime")
  valid_618837 = validateParameter(valid_618837, JString, required = false,
                                 default = nil)
  if valid_618837 != nil:
    section.add "StartTime", valid_618837
  var valid_618838 = query.getOrDefault("Action")
  valid_618838 = validateParameter(valid_618838, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_618838 != nil:
    section.add "Action", valid_618838
  var valid_618839 = query.getOrDefault("ClusterIdentifier")
  valid_618839 = validateParameter(valid_618839, JString, required = false,
                                 default = nil)
  if valid_618839 != nil:
    section.add "ClusterIdentifier", valid_618839
  var valid_618840 = query.getOrDefault("Marker")
  valid_618840 = validateParameter(valid_618840, JString, required = false,
                                 default = nil)
  if valid_618840 != nil:
    section.add "Marker", valid_618840
  var valid_618841 = query.getOrDefault("ClusterExists")
  valid_618841 = validateParameter(valid_618841, JBool, required = false, default = nil)
  if valid_618841 != nil:
    section.add "ClusterExists", valid_618841
  var valid_618842 = query.getOrDefault("SnapshotIdentifier")
  valid_618842 = validateParameter(valid_618842, JString, required = false,
                                 default = nil)
  if valid_618842 != nil:
    section.add "SnapshotIdentifier", valid_618842
  var valid_618843 = query.getOrDefault("TagKeys")
  valid_618843 = validateParameter(valid_618843, JArray, required = false,
                                 default = nil)
  if valid_618843 != nil:
    section.add "TagKeys", valid_618843
  var valid_618844 = query.getOrDefault("SnapshotType")
  valid_618844 = validateParameter(valid_618844, JString, required = false,
                                 default = nil)
  if valid_618844 != nil:
    section.add "SnapshotType", valid_618844
  var valid_618845 = query.getOrDefault("Version")
  valid_618845 = validateParameter(valid_618845, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618845 != nil:
    section.add "Version", valid_618845
  var valid_618846 = query.getOrDefault("OwnerAccount")
  valid_618846 = validateParameter(valid_618846, JString, required = false,
                                 default = nil)
  if valid_618846 != nil:
    section.add "OwnerAccount", valid_618846
  var valid_618847 = query.getOrDefault("EndTime")
  valid_618847 = validateParameter(valid_618847, JString, required = false,
                                 default = nil)
  if valid_618847 != nil:
    section.add "EndTime", valid_618847
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618848 = header.getOrDefault("X-Amz-Date")
  valid_618848 = validateParameter(valid_618848, JString, required = false,
                                 default = nil)
  if valid_618848 != nil:
    section.add "X-Amz-Date", valid_618848
  var valid_618849 = header.getOrDefault("X-Amz-Security-Token")
  valid_618849 = validateParameter(valid_618849, JString, required = false,
                                 default = nil)
  if valid_618849 != nil:
    section.add "X-Amz-Security-Token", valid_618849
  var valid_618850 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618850 = validateParameter(valid_618850, JString, required = false,
                                 default = nil)
  if valid_618850 != nil:
    section.add "X-Amz-Content-Sha256", valid_618850
  var valid_618851 = header.getOrDefault("X-Amz-Algorithm")
  valid_618851 = validateParameter(valid_618851, JString, required = false,
                                 default = nil)
  if valid_618851 != nil:
    section.add "X-Amz-Algorithm", valid_618851
  var valid_618852 = header.getOrDefault("X-Amz-Signature")
  valid_618852 = validateParameter(valid_618852, JString, required = false,
                                 default = nil)
  if valid_618852 != nil:
    section.add "X-Amz-Signature", valid_618852
  var valid_618853 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618853 = validateParameter(valid_618853, JString, required = false,
                                 default = nil)
  if valid_618853 != nil:
    section.add "X-Amz-SignedHeaders", valid_618853
  var valid_618854 = header.getOrDefault("X-Amz-Credential")
  valid_618854 = validateParameter(valid_618854, JString, required = false,
                                 default = nil)
  if valid_618854 != nil:
    section.add "X-Amz-Credential", valid_618854
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618855: Call_GetDescribeClusterSnapshots_618831;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_618855.validator(path, query, header, formData, body, _)
  let scheme = call_618855.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618855.url(scheme.get, call_618855.host, call_618855.base,
                         call_618855.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618855, url, valid, _)

proc call*(call_618856: Call_GetDescribeClusterSnapshots_618831;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          SortingEntities: JsonNode = nil; StartTime: string = "";
          Action: string = "DescribeClusterSnapshots";
          ClusterIdentifier: string = ""; Marker: string = "";
          ClusterExists: bool = false; SnapshotIdentifier: string = "";
          TagKeys: JsonNode = nil; SnapshotType: string = "";
          Version: string = "2012-12-01"; OwnerAccount: string = "";
          EndTime: string = ""): Recallable =
  ## getDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Version: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  var query_618857 = newJObject()
  if TagValues != nil:
    query_618857.add "TagValues", TagValues
  add(query_618857, "MaxRecords", newJInt(MaxRecords))
  if SortingEntities != nil:
    query_618857.add "SortingEntities", SortingEntities
  add(query_618857, "StartTime", newJString(StartTime))
  add(query_618857, "Action", newJString(Action))
  add(query_618857, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_618857, "Marker", newJString(Marker))
  add(query_618857, "ClusterExists", newJBool(ClusterExists))
  add(query_618857, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  if TagKeys != nil:
    query_618857.add "TagKeys", TagKeys
  add(query_618857, "SnapshotType", newJString(SnapshotType))
  add(query_618857, "Version", newJString(Version))
  add(query_618857, "OwnerAccount", newJString(OwnerAccount))
  add(query_618857, "EndTime", newJString(EndTime))
  result = call_618856.call(nil, query_618857, nil, nil, nil)

var getDescribeClusterSnapshots* = Call_GetDescribeClusterSnapshots_618831(
    name: "getDescribeClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_GetDescribeClusterSnapshots_618832, base: "/",
    url: url_GetDescribeClusterSnapshots_618833,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSubnetGroups_618906 = ref object of OpenApiRestCall_616850
proc url_PostDescribeClusterSubnetGroups_618908(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSubnetGroups_618907(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618909 = query.getOrDefault("Action")
  valid_618909 = validateParameter(valid_618909, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_618909 != nil:
    section.add "Action", valid_618909
  var valid_618910 = query.getOrDefault("Version")
  valid_618910 = validateParameter(valid_618910, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618910 != nil:
    section.add "Version", valid_618910
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618911 = header.getOrDefault("X-Amz-Date")
  valid_618911 = validateParameter(valid_618911, JString, required = false,
                                 default = nil)
  if valid_618911 != nil:
    section.add "X-Amz-Date", valid_618911
  var valid_618912 = header.getOrDefault("X-Amz-Security-Token")
  valid_618912 = validateParameter(valid_618912, JString, required = false,
                                 default = nil)
  if valid_618912 != nil:
    section.add "X-Amz-Security-Token", valid_618912
  var valid_618913 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618913 = validateParameter(valid_618913, JString, required = false,
                                 default = nil)
  if valid_618913 != nil:
    section.add "X-Amz-Content-Sha256", valid_618913
  var valid_618914 = header.getOrDefault("X-Amz-Algorithm")
  valid_618914 = validateParameter(valid_618914, JString, required = false,
                                 default = nil)
  if valid_618914 != nil:
    section.add "X-Amz-Algorithm", valid_618914
  var valid_618915 = header.getOrDefault("X-Amz-Signature")
  valid_618915 = validateParameter(valid_618915, JString, required = false,
                                 default = nil)
  if valid_618915 != nil:
    section.add "X-Amz-Signature", valid_618915
  var valid_618916 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618916 = validateParameter(valid_618916, JString, required = false,
                                 default = nil)
  if valid_618916 != nil:
    section.add "X-Amz-SignedHeaders", valid_618916
  var valid_618917 = header.getOrDefault("X-Amz-Credential")
  valid_618917 = validateParameter(valid_618917, JString, required = false,
                                 default = nil)
  if valid_618917 != nil:
    section.add "X-Amz-Credential", valid_618917
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  section = newJObject()
  var valid_618918 = formData.getOrDefault("TagKeys")
  valid_618918 = validateParameter(valid_618918, JArray, required = false,
                                 default = nil)
  if valid_618918 != nil:
    section.add "TagKeys", valid_618918
  var valid_618919 = formData.getOrDefault("Marker")
  valid_618919 = validateParameter(valid_618919, JString, required = false,
                                 default = nil)
  if valid_618919 != nil:
    section.add "Marker", valid_618919
  var valid_618920 = formData.getOrDefault("MaxRecords")
  valid_618920 = validateParameter(valid_618920, JInt, required = false, default = nil)
  if valid_618920 != nil:
    section.add "MaxRecords", valid_618920
  var valid_618921 = formData.getOrDefault("TagValues")
  valid_618921 = validateParameter(valid_618921, JArray, required = false,
                                 default = nil)
  if valid_618921 != nil:
    section.add "TagValues", valid_618921
  var valid_618922 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_618922 = validateParameter(valid_618922, JString, required = false,
                                 default = nil)
  if valid_618922 != nil:
    section.add "ClusterSubnetGroupName", valid_618922
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618923: Call_PostDescribeClusterSubnetGroups_618906;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_618923.validator(path, query, header, formData, body, _)
  let scheme = call_618923.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618923.url(scheme.get, call_618923.host, call_618923.base,
                         call_618923.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618923, url, valid, _)

proc call*(call_618924: Call_PostDescribeClusterSubnetGroups_618906;
          Action: string = "DescribeClusterSubnetGroups"; TagKeys: JsonNode = nil;
          Marker: string = ""; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"; ClusterSubnetGroupName: string = ""): Recallable =
  ## postDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  var query_618925 = newJObject()
  var formData_618926 = newJObject()
  add(query_618925, "Action", newJString(Action))
  if TagKeys != nil:
    formData_618926.add "TagKeys", TagKeys
  add(formData_618926, "Marker", newJString(Marker))
  add(formData_618926, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_618926.add "TagValues", TagValues
  add(query_618925, "Version", newJString(Version))
  add(formData_618926, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_618924.call(nil, query_618925, nil, formData_618926, nil)

var postDescribeClusterSubnetGroups* = Call_PostDescribeClusterSubnetGroups_618906(
    name: "postDescribeClusterSubnetGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_PostDescribeClusterSubnetGroups_618907, base: "/",
    url: url_PostDescribeClusterSubnetGroups_618908,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSubnetGroups_618886 = ref object of OpenApiRestCall_616850
proc url_GetDescribeClusterSubnetGroups_618888(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSubnetGroups_618887(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_618889 = query.getOrDefault("ClusterSubnetGroupName")
  valid_618889 = validateParameter(valid_618889, JString, required = false,
                                 default = nil)
  if valid_618889 != nil:
    section.add "ClusterSubnetGroupName", valid_618889
  var valid_618890 = query.getOrDefault("TagValues")
  valid_618890 = validateParameter(valid_618890, JArray, required = false,
                                 default = nil)
  if valid_618890 != nil:
    section.add "TagValues", valid_618890
  var valid_618891 = query.getOrDefault("MaxRecords")
  valid_618891 = validateParameter(valid_618891, JInt, required = false, default = nil)
  if valid_618891 != nil:
    section.add "MaxRecords", valid_618891
  var valid_618892 = query.getOrDefault("Action")
  valid_618892 = validateParameter(valid_618892, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_618892 != nil:
    section.add "Action", valid_618892
  var valid_618893 = query.getOrDefault("Marker")
  valid_618893 = validateParameter(valid_618893, JString, required = false,
                                 default = nil)
  if valid_618893 != nil:
    section.add "Marker", valid_618893
  var valid_618894 = query.getOrDefault("TagKeys")
  valid_618894 = validateParameter(valid_618894, JArray, required = false,
                                 default = nil)
  if valid_618894 != nil:
    section.add "TagKeys", valid_618894
  var valid_618895 = query.getOrDefault("Version")
  valid_618895 = validateParameter(valid_618895, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618895 != nil:
    section.add "Version", valid_618895
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618896 = header.getOrDefault("X-Amz-Date")
  valid_618896 = validateParameter(valid_618896, JString, required = false,
                                 default = nil)
  if valid_618896 != nil:
    section.add "X-Amz-Date", valid_618896
  var valid_618897 = header.getOrDefault("X-Amz-Security-Token")
  valid_618897 = validateParameter(valid_618897, JString, required = false,
                                 default = nil)
  if valid_618897 != nil:
    section.add "X-Amz-Security-Token", valid_618897
  var valid_618898 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618898 = validateParameter(valid_618898, JString, required = false,
                                 default = nil)
  if valid_618898 != nil:
    section.add "X-Amz-Content-Sha256", valid_618898
  var valid_618899 = header.getOrDefault("X-Amz-Algorithm")
  valid_618899 = validateParameter(valid_618899, JString, required = false,
                                 default = nil)
  if valid_618899 != nil:
    section.add "X-Amz-Algorithm", valid_618899
  var valid_618900 = header.getOrDefault("X-Amz-Signature")
  valid_618900 = validateParameter(valid_618900, JString, required = false,
                                 default = nil)
  if valid_618900 != nil:
    section.add "X-Amz-Signature", valid_618900
  var valid_618901 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618901 = validateParameter(valid_618901, JString, required = false,
                                 default = nil)
  if valid_618901 != nil:
    section.add "X-Amz-SignedHeaders", valid_618901
  var valid_618902 = header.getOrDefault("X-Amz-Credential")
  valid_618902 = validateParameter(valid_618902, JString, required = false,
                                 default = nil)
  if valid_618902 != nil:
    section.add "X-Amz-Credential", valid_618902
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618903: Call_GetDescribeClusterSubnetGroups_618886;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_618903.validator(path, query, header, formData, body, _)
  let scheme = call_618903.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618903.url(scheme.get, call_618903.host, call_618903.base,
                         call_618903.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618903, url, valid, _)

proc call*(call_618904: Call_GetDescribeClusterSubnetGroups_618886;
          ClusterSubnetGroupName: string = ""; TagValues: JsonNode = nil;
          MaxRecords: int = 0; Action: string = "DescribeClusterSubnetGroups";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_618905 = newJObject()
  add(query_618905, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  if TagValues != nil:
    query_618905.add "TagValues", TagValues
  add(query_618905, "MaxRecords", newJInt(MaxRecords))
  add(query_618905, "Action", newJString(Action))
  add(query_618905, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_618905.add "TagKeys", TagKeys
  add(query_618905, "Version", newJString(Version))
  result = call_618904.call(nil, query_618905, nil, nil, nil)

var getDescribeClusterSubnetGroups* = Call_GetDescribeClusterSubnetGroups_618886(
    name: "getDescribeClusterSubnetGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_GetDescribeClusterSubnetGroups_618887, base: "/",
    url: url_GetDescribeClusterSubnetGroups_618888,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterTracks_618945 = ref object of OpenApiRestCall_616850
proc url_PostDescribeClusterTracks_618947(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterTracks_618946(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618948 = query.getOrDefault("Action")
  valid_618948 = validateParameter(valid_618948, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_618948 != nil:
    section.add "Action", valid_618948
  var valid_618949 = query.getOrDefault("Version")
  valid_618949 = validateParameter(valid_618949, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618949 != nil:
    section.add "Version", valid_618949
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618950 = header.getOrDefault("X-Amz-Date")
  valid_618950 = validateParameter(valid_618950, JString, required = false,
                                 default = nil)
  if valid_618950 != nil:
    section.add "X-Amz-Date", valid_618950
  var valid_618951 = header.getOrDefault("X-Amz-Security-Token")
  valid_618951 = validateParameter(valid_618951, JString, required = false,
                                 default = nil)
  if valid_618951 != nil:
    section.add "X-Amz-Security-Token", valid_618951
  var valid_618952 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618952 = validateParameter(valid_618952, JString, required = false,
                                 default = nil)
  if valid_618952 != nil:
    section.add "X-Amz-Content-Sha256", valid_618952
  var valid_618953 = header.getOrDefault("X-Amz-Algorithm")
  valid_618953 = validateParameter(valid_618953, JString, required = false,
                                 default = nil)
  if valid_618953 != nil:
    section.add "X-Amz-Algorithm", valid_618953
  var valid_618954 = header.getOrDefault("X-Amz-Signature")
  valid_618954 = validateParameter(valid_618954, JString, required = false,
                                 default = nil)
  if valid_618954 != nil:
    section.add "X-Amz-Signature", valid_618954
  var valid_618955 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618955 = validateParameter(valid_618955, JString, required = false,
                                 default = nil)
  if valid_618955 != nil:
    section.add "X-Amz-SignedHeaders", valid_618955
  var valid_618956 = header.getOrDefault("X-Amz-Credential")
  valid_618956 = validateParameter(valid_618956, JString, required = false,
                                 default = nil)
  if valid_618956 != nil:
    section.add "X-Amz-Credential", valid_618956
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  section = newJObject()
  var valid_618957 = formData.getOrDefault("Marker")
  valid_618957 = validateParameter(valid_618957, JString, required = false,
                                 default = nil)
  if valid_618957 != nil:
    section.add "Marker", valid_618957
  var valid_618958 = formData.getOrDefault("MaxRecords")
  valid_618958 = validateParameter(valid_618958, JInt, required = false, default = nil)
  if valid_618958 != nil:
    section.add "MaxRecords", valid_618958
  var valid_618959 = formData.getOrDefault("MaintenanceTrackName")
  valid_618959 = validateParameter(valid_618959, JString, required = false,
                                 default = nil)
  if valid_618959 != nil:
    section.add "MaintenanceTrackName", valid_618959
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618960: Call_PostDescribeClusterTracks_618945;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_618960.validator(path, query, header, formData, body, _)
  let scheme = call_618960.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618960.url(scheme.get, call_618960.host, call_618960.base,
                         call_618960.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618960, url, valid, _)

proc call*(call_618961: Call_PostDescribeClusterTracks_618945;
          Action: string = "DescribeClusterTracks"; Marker: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01";
          MaintenanceTrackName: string = ""): Recallable =
  ## postDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Version: string (required)
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  var query_618962 = newJObject()
  var formData_618963 = newJObject()
  add(query_618962, "Action", newJString(Action))
  add(formData_618963, "Marker", newJString(Marker))
  add(formData_618963, "MaxRecords", newJInt(MaxRecords))
  add(query_618962, "Version", newJString(Version))
  add(formData_618963, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  result = call_618961.call(nil, query_618962, nil, formData_618963, nil)

var postDescribeClusterTracks* = Call_PostDescribeClusterTracks_618945(
    name: "postDescribeClusterTracks", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_PostDescribeClusterTracks_618946, base: "/",
    url: url_PostDescribeClusterTracks_618947,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterTracks_618927 = ref object of OpenApiRestCall_616850
proc url_GetDescribeClusterTracks_618929(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterTracks_618928(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Version: JString (required)
  section = newJObject()
  var valid_618930 = query.getOrDefault("MaintenanceTrackName")
  valid_618930 = validateParameter(valid_618930, JString, required = false,
                                 default = nil)
  if valid_618930 != nil:
    section.add "MaintenanceTrackName", valid_618930
  var valid_618931 = query.getOrDefault("Action")
  valid_618931 = validateParameter(valid_618931, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_618931 != nil:
    section.add "Action", valid_618931
  var valid_618932 = query.getOrDefault("Marker")
  valid_618932 = validateParameter(valid_618932, JString, required = false,
                                 default = nil)
  if valid_618932 != nil:
    section.add "Marker", valid_618932
  var valid_618933 = query.getOrDefault("MaxRecords")
  valid_618933 = validateParameter(valid_618933, JInt, required = false, default = nil)
  if valid_618933 != nil:
    section.add "MaxRecords", valid_618933
  var valid_618934 = query.getOrDefault("Version")
  valid_618934 = validateParameter(valid_618934, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618934 != nil:
    section.add "Version", valid_618934
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618935 = header.getOrDefault("X-Amz-Date")
  valid_618935 = validateParameter(valid_618935, JString, required = false,
                                 default = nil)
  if valid_618935 != nil:
    section.add "X-Amz-Date", valid_618935
  var valid_618936 = header.getOrDefault("X-Amz-Security-Token")
  valid_618936 = validateParameter(valid_618936, JString, required = false,
                                 default = nil)
  if valid_618936 != nil:
    section.add "X-Amz-Security-Token", valid_618936
  var valid_618937 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618937 = validateParameter(valid_618937, JString, required = false,
                                 default = nil)
  if valid_618937 != nil:
    section.add "X-Amz-Content-Sha256", valid_618937
  var valid_618938 = header.getOrDefault("X-Amz-Algorithm")
  valid_618938 = validateParameter(valid_618938, JString, required = false,
                                 default = nil)
  if valid_618938 != nil:
    section.add "X-Amz-Algorithm", valid_618938
  var valid_618939 = header.getOrDefault("X-Amz-Signature")
  valid_618939 = validateParameter(valid_618939, JString, required = false,
                                 default = nil)
  if valid_618939 != nil:
    section.add "X-Amz-Signature", valid_618939
  var valid_618940 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618940 = validateParameter(valid_618940, JString, required = false,
                                 default = nil)
  if valid_618940 != nil:
    section.add "X-Amz-SignedHeaders", valid_618940
  var valid_618941 = header.getOrDefault("X-Amz-Credential")
  valid_618941 = validateParameter(valid_618941, JString, required = false,
                                 default = nil)
  if valid_618941 != nil:
    section.add "X-Amz-Credential", valid_618941
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618942: Call_GetDescribeClusterTracks_618927; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_618942.validator(path, query, header, formData, body, _)
  let scheme = call_618942.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618942.url(scheme.get, call_618942.host, call_618942.base,
                         call_618942.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618942, url, valid, _)

proc call*(call_618943: Call_GetDescribeClusterTracks_618927;
          MaintenanceTrackName: string = "";
          Action: string = "DescribeClusterTracks"; Marker: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Version: string (required)
  var query_618944 = newJObject()
  add(query_618944, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_618944, "Action", newJString(Action))
  add(query_618944, "Marker", newJString(Marker))
  add(query_618944, "MaxRecords", newJInt(MaxRecords))
  add(query_618944, "Version", newJString(Version))
  result = call_618943.call(nil, query_618944, nil, nil, nil)

var getDescribeClusterTracks* = Call_GetDescribeClusterTracks_618927(
    name: "getDescribeClusterTracks", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_GetDescribeClusterTracks_618928, base: "/",
    url: url_GetDescribeClusterTracks_618929, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterVersions_618983 = ref object of OpenApiRestCall_616850
proc url_PostDescribeClusterVersions_618985(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterVersions_618984(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_618986 = query.getOrDefault("Action")
  valid_618986 = validateParameter(valid_618986, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_618986 != nil:
    section.add "Action", valid_618986
  var valid_618987 = query.getOrDefault("Version")
  valid_618987 = validateParameter(valid_618987, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618987 != nil:
    section.add "Version", valid_618987
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618988 = header.getOrDefault("X-Amz-Date")
  valid_618988 = validateParameter(valid_618988, JString, required = false,
                                 default = nil)
  if valid_618988 != nil:
    section.add "X-Amz-Date", valid_618988
  var valid_618989 = header.getOrDefault("X-Amz-Security-Token")
  valid_618989 = validateParameter(valid_618989, JString, required = false,
                                 default = nil)
  if valid_618989 != nil:
    section.add "X-Amz-Security-Token", valid_618989
  var valid_618990 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618990 = validateParameter(valid_618990, JString, required = false,
                                 default = nil)
  if valid_618990 != nil:
    section.add "X-Amz-Content-Sha256", valid_618990
  var valid_618991 = header.getOrDefault("X-Amz-Algorithm")
  valid_618991 = validateParameter(valid_618991, JString, required = false,
                                 default = nil)
  if valid_618991 != nil:
    section.add "X-Amz-Algorithm", valid_618991
  var valid_618992 = header.getOrDefault("X-Amz-Signature")
  valid_618992 = validateParameter(valid_618992, JString, required = false,
                                 default = nil)
  if valid_618992 != nil:
    section.add "X-Amz-Signature", valid_618992
  var valid_618993 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618993 = validateParameter(valid_618993, JString, required = false,
                                 default = nil)
  if valid_618993 != nil:
    section.add "X-Amz-SignedHeaders", valid_618993
  var valid_618994 = header.getOrDefault("X-Amz-Credential")
  valid_618994 = validateParameter(valid_618994, JString, required = false,
                                 default = nil)
  if valid_618994 != nil:
    section.add "X-Amz-Credential", valid_618994
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  section = newJObject()
  var valid_618995 = formData.getOrDefault("ClusterVersion")
  valid_618995 = validateParameter(valid_618995, JString, required = false,
                                 default = nil)
  if valid_618995 != nil:
    section.add "ClusterVersion", valid_618995
  var valid_618996 = formData.getOrDefault("Marker")
  valid_618996 = validateParameter(valid_618996, JString, required = false,
                                 default = nil)
  if valid_618996 != nil:
    section.add "Marker", valid_618996
  var valid_618997 = formData.getOrDefault("MaxRecords")
  valid_618997 = validateParameter(valid_618997, JInt, required = false, default = nil)
  if valid_618997 != nil:
    section.add "MaxRecords", valid_618997
  var valid_618998 = formData.getOrDefault("ClusterParameterGroupFamily")
  valid_618998 = validateParameter(valid_618998, JString, required = false,
                                 default = nil)
  if valid_618998 != nil:
    section.add "ClusterParameterGroupFamily", valid_618998
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618999: Call_PostDescribeClusterVersions_618983;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_618999.validator(path, query, header, formData, body, _)
  let scheme = call_618999.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618999.url(scheme.get, call_618999.host, call_618999.base,
                         call_618999.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618999, url, valid, _)

proc call*(call_619000: Call_PostDescribeClusterVersions_618983;
          ClusterVersion: string = ""; Action: string = "DescribeClusterVersions";
          Marker: string = ""; MaxRecords: int = 0; Version: string = "2012-12-01";
          ClusterParameterGroupFamily: string = ""): Recallable =
  ## postDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  var query_619001 = newJObject()
  var formData_619002 = newJObject()
  add(formData_619002, "ClusterVersion", newJString(ClusterVersion))
  add(query_619001, "Action", newJString(Action))
  add(formData_619002, "Marker", newJString(Marker))
  add(formData_619002, "MaxRecords", newJInt(MaxRecords))
  add(query_619001, "Version", newJString(Version))
  add(formData_619002, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  result = call_619000.call(nil, query_619001, nil, formData_619002, nil)

var postDescribeClusterVersions* = Call_PostDescribeClusterVersions_618983(
    name: "postDescribeClusterVersions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_PostDescribeClusterVersions_618984, base: "/",
    url: url_PostDescribeClusterVersions_618985,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterVersions_618964 = ref object of OpenApiRestCall_616850
proc url_GetDescribeClusterVersions_618966(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterVersions_618965(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  section = newJObject()
  var valid_618967 = query.getOrDefault("MaxRecords")
  valid_618967 = validateParameter(valid_618967, JInt, required = false, default = nil)
  if valid_618967 != nil:
    section.add "MaxRecords", valid_618967
  var valid_618968 = query.getOrDefault("Action")
  valid_618968 = validateParameter(valid_618968, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_618968 != nil:
    section.add "Action", valid_618968
  var valid_618969 = query.getOrDefault("Marker")
  valid_618969 = validateParameter(valid_618969, JString, required = false,
                                 default = nil)
  if valid_618969 != nil:
    section.add "Marker", valid_618969
  var valid_618970 = query.getOrDefault("ClusterVersion")
  valid_618970 = validateParameter(valid_618970, JString, required = false,
                                 default = nil)
  if valid_618970 != nil:
    section.add "ClusterVersion", valid_618970
  var valid_618971 = query.getOrDefault("Version")
  valid_618971 = validateParameter(valid_618971, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_618971 != nil:
    section.add "Version", valid_618971
  var valid_618972 = query.getOrDefault("ClusterParameterGroupFamily")
  valid_618972 = validateParameter(valid_618972, JString, required = false,
                                 default = nil)
  if valid_618972 != nil:
    section.add "ClusterParameterGroupFamily", valid_618972
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_618973 = header.getOrDefault("X-Amz-Date")
  valid_618973 = validateParameter(valid_618973, JString, required = false,
                                 default = nil)
  if valid_618973 != nil:
    section.add "X-Amz-Date", valid_618973
  var valid_618974 = header.getOrDefault("X-Amz-Security-Token")
  valid_618974 = validateParameter(valid_618974, JString, required = false,
                                 default = nil)
  if valid_618974 != nil:
    section.add "X-Amz-Security-Token", valid_618974
  var valid_618975 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_618975 = validateParameter(valid_618975, JString, required = false,
                                 default = nil)
  if valid_618975 != nil:
    section.add "X-Amz-Content-Sha256", valid_618975
  var valid_618976 = header.getOrDefault("X-Amz-Algorithm")
  valid_618976 = validateParameter(valid_618976, JString, required = false,
                                 default = nil)
  if valid_618976 != nil:
    section.add "X-Amz-Algorithm", valid_618976
  var valid_618977 = header.getOrDefault("X-Amz-Signature")
  valid_618977 = validateParameter(valid_618977, JString, required = false,
                                 default = nil)
  if valid_618977 != nil:
    section.add "X-Amz-Signature", valid_618977
  var valid_618978 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_618978 = validateParameter(valid_618978, JString, required = false,
                                 default = nil)
  if valid_618978 != nil:
    section.add "X-Amz-SignedHeaders", valid_618978
  var valid_618979 = header.getOrDefault("X-Amz-Credential")
  valid_618979 = validateParameter(valid_618979, JString, required = false,
                                 default = nil)
  if valid_618979 != nil:
    section.add "X-Amz-Credential", valid_618979
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_618980: Call_GetDescribeClusterVersions_618964;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_618980.validator(path, query, header, formData, body, _)
  let scheme = call_618980.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_618980.url(scheme.get, call_618980.host, call_618980.base,
                         call_618980.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_618980, url, valid, _)

proc call*(call_618981: Call_GetDescribeClusterVersions_618964;
          MaxRecords: int = 0; Action: string = "DescribeClusterVersions";
          Marker: string = ""; ClusterVersion: string = "";
          Version: string = "2012-12-01"; ClusterParameterGroupFamily: string = ""): Recallable =
  ## getDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  var query_618982 = newJObject()
  add(query_618982, "MaxRecords", newJInt(MaxRecords))
  add(query_618982, "Action", newJString(Action))
  add(query_618982, "Marker", newJString(Marker))
  add(query_618982, "ClusterVersion", newJString(ClusterVersion))
  add(query_618982, "Version", newJString(Version))
  add(query_618982, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  result = call_618981.call(nil, query_618982, nil, nil, nil)

var getDescribeClusterVersions* = Call_GetDescribeClusterVersions_618964(
    name: "getDescribeClusterVersions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_GetDescribeClusterVersions_618965, base: "/",
    url: url_GetDescribeClusterVersions_618966,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusters_619023 = ref object of OpenApiRestCall_616850
proc url_PostDescribeClusters_619025(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusters_619024(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619026 = query.getOrDefault("Action")
  valid_619026 = validateParameter(valid_619026, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_619026 != nil:
    section.add "Action", valid_619026
  var valid_619027 = query.getOrDefault("Version")
  valid_619027 = validateParameter(valid_619027, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619027 != nil:
    section.add "Version", valid_619027
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619028 = header.getOrDefault("X-Amz-Date")
  valid_619028 = validateParameter(valid_619028, JString, required = false,
                                 default = nil)
  if valid_619028 != nil:
    section.add "X-Amz-Date", valid_619028
  var valid_619029 = header.getOrDefault("X-Amz-Security-Token")
  valid_619029 = validateParameter(valid_619029, JString, required = false,
                                 default = nil)
  if valid_619029 != nil:
    section.add "X-Amz-Security-Token", valid_619029
  var valid_619030 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619030 = validateParameter(valid_619030, JString, required = false,
                                 default = nil)
  if valid_619030 != nil:
    section.add "X-Amz-Content-Sha256", valid_619030
  var valid_619031 = header.getOrDefault("X-Amz-Algorithm")
  valid_619031 = validateParameter(valid_619031, JString, required = false,
                                 default = nil)
  if valid_619031 != nil:
    section.add "X-Amz-Algorithm", valid_619031
  var valid_619032 = header.getOrDefault("X-Amz-Signature")
  valid_619032 = validateParameter(valid_619032, JString, required = false,
                                 default = nil)
  if valid_619032 != nil:
    section.add "X-Amz-Signature", valid_619032
  var valid_619033 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619033 = validateParameter(valid_619033, JString, required = false,
                                 default = nil)
  if valid_619033 != nil:
    section.add "X-Amz-SignedHeaders", valid_619033
  var valid_619034 = header.getOrDefault("X-Amz-Credential")
  valid_619034 = validateParameter(valid_619034, JString, required = false,
                                 default = nil)
  if valid_619034 != nil:
    section.add "X-Amz-Credential", valid_619034
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_619035 = formData.getOrDefault("ClusterIdentifier")
  valid_619035 = validateParameter(valid_619035, JString, required = false,
                                 default = nil)
  if valid_619035 != nil:
    section.add "ClusterIdentifier", valid_619035
  var valid_619036 = formData.getOrDefault("TagKeys")
  valid_619036 = validateParameter(valid_619036, JArray, required = false,
                                 default = nil)
  if valid_619036 != nil:
    section.add "TagKeys", valid_619036
  var valid_619037 = formData.getOrDefault("Marker")
  valid_619037 = validateParameter(valid_619037, JString, required = false,
                                 default = nil)
  if valid_619037 != nil:
    section.add "Marker", valid_619037
  var valid_619038 = formData.getOrDefault("MaxRecords")
  valid_619038 = validateParameter(valid_619038, JInt, required = false, default = nil)
  if valid_619038 != nil:
    section.add "MaxRecords", valid_619038
  var valid_619039 = formData.getOrDefault("TagValues")
  valid_619039 = validateParameter(valid_619039, JArray, required = false,
                                 default = nil)
  if valid_619039 != nil:
    section.add "TagValues", valid_619039
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619040: Call_PostDescribeClusters_619023; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_619040.validator(path, query, header, formData, body, _)
  let scheme = call_619040.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619040.url(scheme.get, call_619040.host, call_619040.base,
                         call_619040.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619040, url, valid, _)

proc call*(call_619041: Call_PostDescribeClusters_619023;
          Action: string = "DescribeClusters"; ClusterIdentifier: string = "";
          TagKeys: JsonNode = nil; Marker: string = ""; MaxRecords: int = 0;
          TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_619042 = newJObject()
  var formData_619043 = newJObject()
  add(query_619042, "Action", newJString(Action))
  add(formData_619043, "ClusterIdentifier", newJString(ClusterIdentifier))
  if TagKeys != nil:
    formData_619043.add "TagKeys", TagKeys
  add(formData_619043, "Marker", newJString(Marker))
  add(formData_619043, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_619043.add "TagValues", TagValues
  add(query_619042, "Version", newJString(Version))
  result = call_619041.call(nil, query_619042, nil, formData_619043, nil)

var postDescribeClusters* = Call_PostDescribeClusters_619023(
    name: "postDescribeClusters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_PostDescribeClusters_619024, base: "/",
    url: url_PostDescribeClusters_619025, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusters_619003 = ref object of OpenApiRestCall_616850
proc url_GetDescribeClusters_619005(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusters_619004(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_619006 = query.getOrDefault("TagValues")
  valid_619006 = validateParameter(valid_619006, JArray, required = false,
                                 default = nil)
  if valid_619006 != nil:
    section.add "TagValues", valid_619006
  var valid_619007 = query.getOrDefault("MaxRecords")
  valid_619007 = validateParameter(valid_619007, JInt, required = false, default = nil)
  if valid_619007 != nil:
    section.add "MaxRecords", valid_619007
  var valid_619008 = query.getOrDefault("Action")
  valid_619008 = validateParameter(valid_619008, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_619008 != nil:
    section.add "Action", valid_619008
  var valid_619009 = query.getOrDefault("ClusterIdentifier")
  valid_619009 = validateParameter(valid_619009, JString, required = false,
                                 default = nil)
  if valid_619009 != nil:
    section.add "ClusterIdentifier", valid_619009
  var valid_619010 = query.getOrDefault("Marker")
  valid_619010 = validateParameter(valid_619010, JString, required = false,
                                 default = nil)
  if valid_619010 != nil:
    section.add "Marker", valid_619010
  var valid_619011 = query.getOrDefault("TagKeys")
  valid_619011 = validateParameter(valid_619011, JArray, required = false,
                                 default = nil)
  if valid_619011 != nil:
    section.add "TagKeys", valid_619011
  var valid_619012 = query.getOrDefault("Version")
  valid_619012 = validateParameter(valid_619012, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619012 != nil:
    section.add "Version", valid_619012
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619013 = header.getOrDefault("X-Amz-Date")
  valid_619013 = validateParameter(valid_619013, JString, required = false,
                                 default = nil)
  if valid_619013 != nil:
    section.add "X-Amz-Date", valid_619013
  var valid_619014 = header.getOrDefault("X-Amz-Security-Token")
  valid_619014 = validateParameter(valid_619014, JString, required = false,
                                 default = nil)
  if valid_619014 != nil:
    section.add "X-Amz-Security-Token", valid_619014
  var valid_619015 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619015 = validateParameter(valid_619015, JString, required = false,
                                 default = nil)
  if valid_619015 != nil:
    section.add "X-Amz-Content-Sha256", valid_619015
  var valid_619016 = header.getOrDefault("X-Amz-Algorithm")
  valid_619016 = validateParameter(valid_619016, JString, required = false,
                                 default = nil)
  if valid_619016 != nil:
    section.add "X-Amz-Algorithm", valid_619016
  var valid_619017 = header.getOrDefault("X-Amz-Signature")
  valid_619017 = validateParameter(valid_619017, JString, required = false,
                                 default = nil)
  if valid_619017 != nil:
    section.add "X-Amz-Signature", valid_619017
  var valid_619018 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619018 = validateParameter(valid_619018, JString, required = false,
                                 default = nil)
  if valid_619018 != nil:
    section.add "X-Amz-SignedHeaders", valid_619018
  var valid_619019 = header.getOrDefault("X-Amz-Credential")
  valid_619019 = validateParameter(valid_619019, JString, required = false,
                                 default = nil)
  if valid_619019 != nil:
    section.add "X-Amz-Credential", valid_619019
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619020: Call_GetDescribeClusters_619003; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_619020.validator(path, query, header, formData, body, _)
  let scheme = call_619020.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619020.url(scheme.get, call_619020.host, call_619020.base,
                         call_619020.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619020, url, valid, _)

proc call*(call_619021: Call_GetDescribeClusters_619003; TagValues: JsonNode = nil;
          MaxRecords: int = 0; Action: string = "DescribeClusters";
          ClusterIdentifier: string = ""; Marker: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_619022 = newJObject()
  if TagValues != nil:
    query_619022.add "TagValues", TagValues
  add(query_619022, "MaxRecords", newJInt(MaxRecords))
  add(query_619022, "Action", newJString(Action))
  add(query_619022, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619022, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_619022.add "TagKeys", TagKeys
  add(query_619022, "Version", newJString(Version))
  result = call_619021.call(nil, query_619022, nil, nil, nil)

var getDescribeClusters* = Call_GetDescribeClusters_619003(
    name: "getDescribeClusters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_GetDescribeClusters_619004, base: "/",
    url: url_GetDescribeClusters_619005, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeDefaultClusterParameters_619062 = ref object of OpenApiRestCall_616850
proc url_PostDescribeDefaultClusterParameters_619064(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeDefaultClusterParameters_619063(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619065 = query.getOrDefault("Action")
  valid_619065 = validateParameter(valid_619065, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_619065 != nil:
    section.add "Action", valid_619065
  var valid_619066 = query.getOrDefault("Version")
  valid_619066 = validateParameter(valid_619066, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619066 != nil:
    section.add "Version", valid_619066
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619067 = header.getOrDefault("X-Amz-Date")
  valid_619067 = validateParameter(valid_619067, JString, required = false,
                                 default = nil)
  if valid_619067 != nil:
    section.add "X-Amz-Date", valid_619067
  var valid_619068 = header.getOrDefault("X-Amz-Security-Token")
  valid_619068 = validateParameter(valid_619068, JString, required = false,
                                 default = nil)
  if valid_619068 != nil:
    section.add "X-Amz-Security-Token", valid_619068
  var valid_619069 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619069 = validateParameter(valid_619069, JString, required = false,
                                 default = nil)
  if valid_619069 != nil:
    section.add "X-Amz-Content-Sha256", valid_619069
  var valid_619070 = header.getOrDefault("X-Amz-Algorithm")
  valid_619070 = validateParameter(valid_619070, JString, required = false,
                                 default = nil)
  if valid_619070 != nil:
    section.add "X-Amz-Algorithm", valid_619070
  var valid_619071 = header.getOrDefault("X-Amz-Signature")
  valid_619071 = validateParameter(valid_619071, JString, required = false,
                                 default = nil)
  if valid_619071 != nil:
    section.add "X-Amz-Signature", valid_619071
  var valid_619072 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619072 = validateParameter(valid_619072, JString, required = false,
                                 default = nil)
  if valid_619072 != nil:
    section.add "X-Amz-SignedHeaders", valid_619072
  var valid_619073 = header.getOrDefault("X-Amz-Credential")
  valid_619073 = validateParameter(valid_619073, JString, required = false,
                                 default = nil)
  if valid_619073 != nil:
    section.add "X-Amz-Credential", valid_619073
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupFamily` field"
  var valid_619074 = formData.getOrDefault("ParameterGroupFamily")
  valid_619074 = validateParameter(valid_619074, JString, required = true,
                                 default = nil)
  if valid_619074 != nil:
    section.add "ParameterGroupFamily", valid_619074
  var valid_619075 = formData.getOrDefault("Marker")
  valid_619075 = validateParameter(valid_619075, JString, required = false,
                                 default = nil)
  if valid_619075 != nil:
    section.add "Marker", valid_619075
  var valid_619076 = formData.getOrDefault("MaxRecords")
  valid_619076 = validateParameter(valid_619076, JInt, required = false, default = nil)
  if valid_619076 != nil:
    section.add "MaxRecords", valid_619076
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619077: Call_PostDescribeDefaultClusterParameters_619062;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_619077.validator(path, query, header, formData, body, _)
  let scheme = call_619077.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619077.url(scheme.get, call_619077.host, call_619077.base,
                         call_619077.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619077, url, valid, _)

proc call*(call_619078: Call_PostDescribeDefaultClusterParameters_619062;
          ParameterGroupFamily: string;
          Action: string = "DescribeDefaultClusterParameters"; Marker: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_619079 = newJObject()
  var formData_619080 = newJObject()
  add(query_619079, "Action", newJString(Action))
  add(formData_619080, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(formData_619080, "Marker", newJString(Marker))
  add(formData_619080, "MaxRecords", newJInt(MaxRecords))
  add(query_619079, "Version", newJString(Version))
  result = call_619078.call(nil, query_619079, nil, formData_619080, nil)

var postDescribeDefaultClusterParameters* = Call_PostDescribeDefaultClusterParameters_619062(
    name: "postDescribeDefaultClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_PostDescribeDefaultClusterParameters_619063, base: "/",
    url: url_PostDescribeDefaultClusterParameters_619064,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeDefaultClusterParameters_619044 = ref object of OpenApiRestCall_616850
proc url_GetDescribeDefaultClusterParameters_619046(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeDefaultClusterParameters_619045(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   Version: JString (required)
  section = newJObject()
  var valid_619047 = query.getOrDefault("MaxRecords")
  valid_619047 = validateParameter(valid_619047, JInt, required = false, default = nil)
  if valid_619047 != nil:
    section.add "MaxRecords", valid_619047
  var valid_619048 = query.getOrDefault("Action")
  valid_619048 = validateParameter(valid_619048, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_619048 != nil:
    section.add "Action", valid_619048
  var valid_619049 = query.getOrDefault("Marker")
  valid_619049 = validateParameter(valid_619049, JString, required = false,
                                 default = nil)
  if valid_619049 != nil:
    section.add "Marker", valid_619049
  var valid_619050 = query.getOrDefault("ParameterGroupFamily")
  valid_619050 = validateParameter(valid_619050, JString, required = true,
                                 default = nil)
  if valid_619050 != nil:
    section.add "ParameterGroupFamily", valid_619050
  var valid_619051 = query.getOrDefault("Version")
  valid_619051 = validateParameter(valid_619051, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619051 != nil:
    section.add "Version", valid_619051
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619052 = header.getOrDefault("X-Amz-Date")
  valid_619052 = validateParameter(valid_619052, JString, required = false,
                                 default = nil)
  if valid_619052 != nil:
    section.add "X-Amz-Date", valid_619052
  var valid_619053 = header.getOrDefault("X-Amz-Security-Token")
  valid_619053 = validateParameter(valid_619053, JString, required = false,
                                 default = nil)
  if valid_619053 != nil:
    section.add "X-Amz-Security-Token", valid_619053
  var valid_619054 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619054 = validateParameter(valid_619054, JString, required = false,
                                 default = nil)
  if valid_619054 != nil:
    section.add "X-Amz-Content-Sha256", valid_619054
  var valid_619055 = header.getOrDefault("X-Amz-Algorithm")
  valid_619055 = validateParameter(valid_619055, JString, required = false,
                                 default = nil)
  if valid_619055 != nil:
    section.add "X-Amz-Algorithm", valid_619055
  var valid_619056 = header.getOrDefault("X-Amz-Signature")
  valid_619056 = validateParameter(valid_619056, JString, required = false,
                                 default = nil)
  if valid_619056 != nil:
    section.add "X-Amz-Signature", valid_619056
  var valid_619057 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619057 = validateParameter(valid_619057, JString, required = false,
                                 default = nil)
  if valid_619057 != nil:
    section.add "X-Amz-SignedHeaders", valid_619057
  var valid_619058 = header.getOrDefault("X-Amz-Credential")
  valid_619058 = validateParameter(valid_619058, JString, required = false,
                                 default = nil)
  if valid_619058 != nil:
    section.add "X-Amz-Credential", valid_619058
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619059: Call_GetDescribeDefaultClusterParameters_619044;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_619059.validator(path, query, header, formData, body, _)
  let scheme = call_619059.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619059.url(scheme.get, call_619059.host, call_619059.base,
                         call_619059.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619059, url, valid, _)

proc call*(call_619060: Call_GetDescribeDefaultClusterParameters_619044;
          ParameterGroupFamily: string; MaxRecords: int = 0;
          Action: string = "DescribeDefaultClusterParameters"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Version: string (required)
  var query_619061 = newJObject()
  add(query_619061, "MaxRecords", newJInt(MaxRecords))
  add(query_619061, "Action", newJString(Action))
  add(query_619061, "Marker", newJString(Marker))
  add(query_619061, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_619061, "Version", newJString(Version))
  result = call_619060.call(nil, query_619061, nil, nil, nil)

var getDescribeDefaultClusterParameters* = Call_GetDescribeDefaultClusterParameters_619044(
    name: "getDescribeDefaultClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_GetDescribeDefaultClusterParameters_619045, base: "/",
    url: url_GetDescribeDefaultClusterParameters_619046,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventCategories_619097 = ref object of OpenApiRestCall_616850
proc url_PostDescribeEventCategories_619099(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventCategories_619098(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619100 = query.getOrDefault("Action")
  valid_619100 = validateParameter(valid_619100, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_619100 != nil:
    section.add "Action", valid_619100
  var valid_619101 = query.getOrDefault("Version")
  valid_619101 = validateParameter(valid_619101, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619101 != nil:
    section.add "Version", valid_619101
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619102 = header.getOrDefault("X-Amz-Date")
  valid_619102 = validateParameter(valid_619102, JString, required = false,
                                 default = nil)
  if valid_619102 != nil:
    section.add "X-Amz-Date", valid_619102
  var valid_619103 = header.getOrDefault("X-Amz-Security-Token")
  valid_619103 = validateParameter(valid_619103, JString, required = false,
                                 default = nil)
  if valid_619103 != nil:
    section.add "X-Amz-Security-Token", valid_619103
  var valid_619104 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619104 = validateParameter(valid_619104, JString, required = false,
                                 default = nil)
  if valid_619104 != nil:
    section.add "X-Amz-Content-Sha256", valid_619104
  var valid_619105 = header.getOrDefault("X-Amz-Algorithm")
  valid_619105 = validateParameter(valid_619105, JString, required = false,
                                 default = nil)
  if valid_619105 != nil:
    section.add "X-Amz-Algorithm", valid_619105
  var valid_619106 = header.getOrDefault("X-Amz-Signature")
  valid_619106 = validateParameter(valid_619106, JString, required = false,
                                 default = nil)
  if valid_619106 != nil:
    section.add "X-Amz-Signature", valid_619106
  var valid_619107 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619107 = validateParameter(valid_619107, JString, required = false,
                                 default = nil)
  if valid_619107 != nil:
    section.add "X-Amz-SignedHeaders", valid_619107
  var valid_619108 = header.getOrDefault("X-Amz-Credential")
  valid_619108 = validateParameter(valid_619108, JString, required = false,
                                 default = nil)
  if valid_619108 != nil:
    section.add "X-Amz-Credential", valid_619108
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  section = newJObject()
  var valid_619109 = formData.getOrDefault("SourceType")
  valid_619109 = validateParameter(valid_619109, JString, required = false,
                                 default = nil)
  if valid_619109 != nil:
    section.add "SourceType", valid_619109
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619110: Call_PostDescribeEventCategories_619097;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_619110.validator(path, query, header, formData, body, _)
  let scheme = call_619110.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619110.url(scheme.get, call_619110.host, call_619110.base,
                         call_619110.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619110, url, valid, _)

proc call*(call_619111: Call_PostDescribeEventCategories_619097;
          Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  var query_619112 = newJObject()
  var formData_619113 = newJObject()
  add(query_619112, "Action", newJString(Action))
  add(query_619112, "Version", newJString(Version))
  add(formData_619113, "SourceType", newJString(SourceType))
  result = call_619111.call(nil, query_619112, nil, formData_619113, nil)

var postDescribeEventCategories* = Call_PostDescribeEventCategories_619097(
    name: "postDescribeEventCategories", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_PostDescribeEventCategories_619098, base: "/",
    url: url_PostDescribeEventCategories_619099,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventCategories_619081 = ref object of OpenApiRestCall_616850
proc url_GetDescribeEventCategories_619083(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventCategories_619082(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619084 = query.getOrDefault("SourceType")
  valid_619084 = validateParameter(valid_619084, JString, required = false,
                                 default = nil)
  if valid_619084 != nil:
    section.add "SourceType", valid_619084
  var valid_619085 = query.getOrDefault("Action")
  valid_619085 = validateParameter(valid_619085, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_619085 != nil:
    section.add "Action", valid_619085
  var valid_619086 = query.getOrDefault("Version")
  valid_619086 = validateParameter(valid_619086, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619086 != nil:
    section.add "Version", valid_619086
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619087 = header.getOrDefault("X-Amz-Date")
  valid_619087 = validateParameter(valid_619087, JString, required = false,
                                 default = nil)
  if valid_619087 != nil:
    section.add "X-Amz-Date", valid_619087
  var valid_619088 = header.getOrDefault("X-Amz-Security-Token")
  valid_619088 = validateParameter(valid_619088, JString, required = false,
                                 default = nil)
  if valid_619088 != nil:
    section.add "X-Amz-Security-Token", valid_619088
  var valid_619089 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619089 = validateParameter(valid_619089, JString, required = false,
                                 default = nil)
  if valid_619089 != nil:
    section.add "X-Amz-Content-Sha256", valid_619089
  var valid_619090 = header.getOrDefault("X-Amz-Algorithm")
  valid_619090 = validateParameter(valid_619090, JString, required = false,
                                 default = nil)
  if valid_619090 != nil:
    section.add "X-Amz-Algorithm", valid_619090
  var valid_619091 = header.getOrDefault("X-Amz-Signature")
  valid_619091 = validateParameter(valid_619091, JString, required = false,
                                 default = nil)
  if valid_619091 != nil:
    section.add "X-Amz-Signature", valid_619091
  var valid_619092 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619092 = validateParameter(valid_619092, JString, required = false,
                                 default = nil)
  if valid_619092 != nil:
    section.add "X-Amz-SignedHeaders", valid_619092
  var valid_619093 = header.getOrDefault("X-Amz-Credential")
  valid_619093 = validateParameter(valid_619093, JString, required = false,
                                 default = nil)
  if valid_619093 != nil:
    section.add "X-Amz-Credential", valid_619093
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619094: Call_GetDescribeEventCategories_619081;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_619094.validator(path, query, header, formData, body, _)
  let scheme = call_619094.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619094.url(scheme.get, call_619094.host, call_619094.base,
                         call_619094.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619094, url, valid, _)

proc call*(call_619095: Call_GetDescribeEventCategories_619081;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, cluster-security-group, and scheduled-action.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_619096 = newJObject()
  add(query_619096, "SourceType", newJString(SourceType))
  add(query_619096, "Action", newJString(Action))
  add(query_619096, "Version", newJString(Version))
  result = call_619095.call(nil, query_619096, nil, nil, nil)

var getDescribeEventCategories* = Call_GetDescribeEventCategories_619081(
    name: "getDescribeEventCategories", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_GetDescribeEventCategories_619082, base: "/",
    url: url_GetDescribeEventCategories_619083,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventSubscriptions_619134 = ref object of OpenApiRestCall_616850
proc url_PostDescribeEventSubscriptions_619136(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventSubscriptions_619135(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619137 = query.getOrDefault("Action")
  valid_619137 = validateParameter(valid_619137, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_619137 != nil:
    section.add "Action", valid_619137
  var valid_619138 = query.getOrDefault("Version")
  valid_619138 = validateParameter(valid_619138, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619138 != nil:
    section.add "Version", valid_619138
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619139 = header.getOrDefault("X-Amz-Date")
  valid_619139 = validateParameter(valid_619139, JString, required = false,
                                 default = nil)
  if valid_619139 != nil:
    section.add "X-Amz-Date", valid_619139
  var valid_619140 = header.getOrDefault("X-Amz-Security-Token")
  valid_619140 = validateParameter(valid_619140, JString, required = false,
                                 default = nil)
  if valid_619140 != nil:
    section.add "X-Amz-Security-Token", valid_619140
  var valid_619141 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619141 = validateParameter(valid_619141, JString, required = false,
                                 default = nil)
  if valid_619141 != nil:
    section.add "X-Amz-Content-Sha256", valid_619141
  var valid_619142 = header.getOrDefault("X-Amz-Algorithm")
  valid_619142 = validateParameter(valid_619142, JString, required = false,
                                 default = nil)
  if valid_619142 != nil:
    section.add "X-Amz-Algorithm", valid_619142
  var valid_619143 = header.getOrDefault("X-Amz-Signature")
  valid_619143 = validateParameter(valid_619143, JString, required = false,
                                 default = nil)
  if valid_619143 != nil:
    section.add "X-Amz-Signature", valid_619143
  var valid_619144 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619144 = validateParameter(valid_619144, JString, required = false,
                                 default = nil)
  if valid_619144 != nil:
    section.add "X-Amz-SignedHeaders", valid_619144
  var valid_619145 = header.getOrDefault("X-Amz-Credential")
  valid_619145 = validateParameter(valid_619145, JString, required = false,
                                 default = nil)
  if valid_619145 != nil:
    section.add "X-Amz-Credential", valid_619145
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_619146 = formData.getOrDefault("SubscriptionName")
  valid_619146 = validateParameter(valid_619146, JString, required = false,
                                 default = nil)
  if valid_619146 != nil:
    section.add "SubscriptionName", valid_619146
  var valid_619147 = formData.getOrDefault("TagKeys")
  valid_619147 = validateParameter(valid_619147, JArray, required = false,
                                 default = nil)
  if valid_619147 != nil:
    section.add "TagKeys", valid_619147
  var valid_619148 = formData.getOrDefault("Marker")
  valid_619148 = validateParameter(valid_619148, JString, required = false,
                                 default = nil)
  if valid_619148 != nil:
    section.add "Marker", valid_619148
  var valid_619149 = formData.getOrDefault("MaxRecords")
  valid_619149 = validateParameter(valid_619149, JInt, required = false, default = nil)
  if valid_619149 != nil:
    section.add "MaxRecords", valid_619149
  var valid_619150 = formData.getOrDefault("TagValues")
  valid_619150 = validateParameter(valid_619150, JArray, required = false,
                                 default = nil)
  if valid_619150 != nil:
    section.add "TagValues", valid_619150
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619151: Call_PostDescribeEventSubscriptions_619134;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_619151.validator(path, query, header, formData, body, _)
  let scheme = call_619151.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619151.url(scheme.get, call_619151.host, call_619151.base,
                         call_619151.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619151, url, valid, _)

proc call*(call_619152: Call_PostDescribeEventSubscriptions_619134;
          SubscriptionName: string = "";
          Action: string = "DescribeEventSubscriptions"; TagKeys: JsonNode = nil;
          Marker: string = ""; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_619153 = newJObject()
  var formData_619154 = newJObject()
  add(formData_619154, "SubscriptionName", newJString(SubscriptionName))
  add(query_619153, "Action", newJString(Action))
  if TagKeys != nil:
    formData_619154.add "TagKeys", TagKeys
  add(formData_619154, "Marker", newJString(Marker))
  add(formData_619154, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_619154.add "TagValues", TagValues
  add(query_619153, "Version", newJString(Version))
  result = call_619152.call(nil, query_619153, nil, formData_619154, nil)

var postDescribeEventSubscriptions* = Call_PostDescribeEventSubscriptions_619134(
    name: "postDescribeEventSubscriptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_PostDescribeEventSubscriptions_619135, base: "/",
    url: url_PostDescribeEventSubscriptions_619136,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventSubscriptions_619114 = ref object of OpenApiRestCall_616850
proc url_GetDescribeEventSubscriptions_619116(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventSubscriptions_619115(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_619117 = query.getOrDefault("TagValues")
  valid_619117 = validateParameter(valid_619117, JArray, required = false,
                                 default = nil)
  if valid_619117 != nil:
    section.add "TagValues", valid_619117
  var valid_619118 = query.getOrDefault("MaxRecords")
  valid_619118 = validateParameter(valid_619118, JInt, required = false, default = nil)
  if valid_619118 != nil:
    section.add "MaxRecords", valid_619118
  var valid_619119 = query.getOrDefault("Action")
  valid_619119 = validateParameter(valid_619119, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_619119 != nil:
    section.add "Action", valid_619119
  var valid_619120 = query.getOrDefault("Marker")
  valid_619120 = validateParameter(valid_619120, JString, required = false,
                                 default = nil)
  if valid_619120 != nil:
    section.add "Marker", valid_619120
  var valid_619121 = query.getOrDefault("SubscriptionName")
  valid_619121 = validateParameter(valid_619121, JString, required = false,
                                 default = nil)
  if valid_619121 != nil:
    section.add "SubscriptionName", valid_619121
  var valid_619122 = query.getOrDefault("TagKeys")
  valid_619122 = validateParameter(valid_619122, JArray, required = false,
                                 default = nil)
  if valid_619122 != nil:
    section.add "TagKeys", valid_619122
  var valid_619123 = query.getOrDefault("Version")
  valid_619123 = validateParameter(valid_619123, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619123 != nil:
    section.add "Version", valid_619123
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619124 = header.getOrDefault("X-Amz-Date")
  valid_619124 = validateParameter(valid_619124, JString, required = false,
                                 default = nil)
  if valid_619124 != nil:
    section.add "X-Amz-Date", valid_619124
  var valid_619125 = header.getOrDefault("X-Amz-Security-Token")
  valid_619125 = validateParameter(valid_619125, JString, required = false,
                                 default = nil)
  if valid_619125 != nil:
    section.add "X-Amz-Security-Token", valid_619125
  var valid_619126 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619126 = validateParameter(valid_619126, JString, required = false,
                                 default = nil)
  if valid_619126 != nil:
    section.add "X-Amz-Content-Sha256", valid_619126
  var valid_619127 = header.getOrDefault("X-Amz-Algorithm")
  valid_619127 = validateParameter(valid_619127, JString, required = false,
                                 default = nil)
  if valid_619127 != nil:
    section.add "X-Amz-Algorithm", valid_619127
  var valid_619128 = header.getOrDefault("X-Amz-Signature")
  valid_619128 = validateParameter(valid_619128, JString, required = false,
                                 default = nil)
  if valid_619128 != nil:
    section.add "X-Amz-Signature", valid_619128
  var valid_619129 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619129 = validateParameter(valid_619129, JString, required = false,
                                 default = nil)
  if valid_619129 != nil:
    section.add "X-Amz-SignedHeaders", valid_619129
  var valid_619130 = header.getOrDefault("X-Amz-Credential")
  valid_619130 = validateParameter(valid_619130, JString, required = false,
                                 default = nil)
  if valid_619130 != nil:
    section.add "X-Amz-Credential", valid_619130
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619131: Call_GetDescribeEventSubscriptions_619114;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_619131.validator(path, query, header, formData, body, _)
  let scheme = call_619131.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619131.url(scheme.get, call_619131.host, call_619131.base,
                         call_619131.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619131, url, valid, _)

proc call*(call_619132: Call_GetDescribeEventSubscriptions_619114;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeEventSubscriptions"; Marker: string = "";
          SubscriptionName: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_619133 = newJObject()
  if TagValues != nil:
    query_619133.add "TagValues", TagValues
  add(query_619133, "MaxRecords", newJInt(MaxRecords))
  add(query_619133, "Action", newJString(Action))
  add(query_619133, "Marker", newJString(Marker))
  add(query_619133, "SubscriptionName", newJString(SubscriptionName))
  if TagKeys != nil:
    query_619133.add "TagKeys", TagKeys
  add(query_619133, "Version", newJString(Version))
  result = call_619132.call(nil, query_619133, nil, nil, nil)

var getDescribeEventSubscriptions* = Call_GetDescribeEventSubscriptions_619114(
    name: "getDescribeEventSubscriptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_GetDescribeEventSubscriptions_619115, base: "/",
    url: url_GetDescribeEventSubscriptions_619116,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEvents_619177 = ref object of OpenApiRestCall_616850
proc url_PostDescribeEvents_619179(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEvents_619178(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619180 = query.getOrDefault("Action")
  valid_619180 = validateParameter(valid_619180, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_619180 != nil:
    section.add "Action", valid_619180
  var valid_619181 = query.getOrDefault("Version")
  valid_619181 = validateParameter(valid_619181, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619181 != nil:
    section.add "Version", valid_619181
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619182 = header.getOrDefault("X-Amz-Date")
  valid_619182 = validateParameter(valid_619182, JString, required = false,
                                 default = nil)
  if valid_619182 != nil:
    section.add "X-Amz-Date", valid_619182
  var valid_619183 = header.getOrDefault("X-Amz-Security-Token")
  valid_619183 = validateParameter(valid_619183, JString, required = false,
                                 default = nil)
  if valid_619183 != nil:
    section.add "X-Amz-Security-Token", valid_619183
  var valid_619184 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619184 = validateParameter(valid_619184, JString, required = false,
                                 default = nil)
  if valid_619184 != nil:
    section.add "X-Amz-Content-Sha256", valid_619184
  var valid_619185 = header.getOrDefault("X-Amz-Algorithm")
  valid_619185 = validateParameter(valid_619185, JString, required = false,
                                 default = nil)
  if valid_619185 != nil:
    section.add "X-Amz-Algorithm", valid_619185
  var valid_619186 = header.getOrDefault("X-Amz-Signature")
  valid_619186 = validateParameter(valid_619186, JString, required = false,
                                 default = nil)
  if valid_619186 != nil:
    section.add "X-Amz-Signature", valid_619186
  var valid_619187 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619187 = validateParameter(valid_619187, JString, required = false,
                                 default = nil)
  if valid_619187 != nil:
    section.add "X-Amz-SignedHeaders", valid_619187
  var valid_619188 = header.getOrDefault("X-Amz-Credential")
  valid_619188 = validateParameter(valid_619188, JString, required = false,
                                 default = nil)
  if valid_619188 != nil:
    section.add "X-Amz-Credential", valid_619188
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  section = newJObject()
  var valid_619189 = formData.getOrDefault("Marker")
  valid_619189 = validateParameter(valid_619189, JString, required = false,
                                 default = nil)
  if valid_619189 != nil:
    section.add "Marker", valid_619189
  var valid_619190 = formData.getOrDefault("StartTime")
  valid_619190 = validateParameter(valid_619190, JString, required = false,
                                 default = nil)
  if valid_619190 != nil:
    section.add "StartTime", valid_619190
  var valid_619191 = formData.getOrDefault("Duration")
  valid_619191 = validateParameter(valid_619191, JInt, required = false, default = nil)
  if valid_619191 != nil:
    section.add "Duration", valid_619191
  var valid_619192 = formData.getOrDefault("EndTime")
  valid_619192 = validateParameter(valid_619192, JString, required = false,
                                 default = nil)
  if valid_619192 != nil:
    section.add "EndTime", valid_619192
  var valid_619193 = formData.getOrDefault("SourceIdentifier")
  valid_619193 = validateParameter(valid_619193, JString, required = false,
                                 default = nil)
  if valid_619193 != nil:
    section.add "SourceIdentifier", valid_619193
  var valid_619194 = formData.getOrDefault("MaxRecords")
  valid_619194 = validateParameter(valid_619194, JInt, required = false, default = nil)
  if valid_619194 != nil:
    section.add "MaxRecords", valid_619194
  var valid_619195 = formData.getOrDefault("SourceType")
  valid_619195 = validateParameter(valid_619195, JString, required = false,
                                 default = newJString("cluster"))
  if valid_619195 != nil:
    section.add "SourceType", valid_619195
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619196: Call_PostDescribeEvents_619177; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_619196.validator(path, query, header, formData, body, _)
  let scheme = call_619196.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619196.url(scheme.get, call_619196.host, call_619196.base,
                         call_619196.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619196, url, valid, _)

proc call*(call_619197: Call_PostDescribeEvents_619177; Marker: string = "";
          StartTime: string = ""; Action: string = "DescribeEvents"; Duration: int = 0;
          EndTime: string = ""; SourceIdentifier: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"; SourceType: string = "cluster"): Recallable =
  ## postDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  var query_619198 = newJObject()
  var formData_619199 = newJObject()
  add(formData_619199, "Marker", newJString(Marker))
  add(formData_619199, "StartTime", newJString(StartTime))
  add(query_619198, "Action", newJString(Action))
  add(formData_619199, "Duration", newJInt(Duration))
  add(formData_619199, "EndTime", newJString(EndTime))
  add(formData_619199, "SourceIdentifier", newJString(SourceIdentifier))
  add(formData_619199, "MaxRecords", newJInt(MaxRecords))
  add(query_619198, "Version", newJString(Version))
  add(formData_619199, "SourceType", newJString(SourceType))
  result = call_619197.call(nil, query_619198, nil, formData_619199, nil)

var postDescribeEvents* = Call_PostDescribeEvents_619177(
    name: "postDescribeEvents", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEvents",
    validator: validate_PostDescribeEvents_619178, base: "/",
    url: url_PostDescribeEvents_619179, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEvents_619155 = ref object of OpenApiRestCall_616850
proc url_GetDescribeEvents_619157(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEvents_619156(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: JString (required)
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_619158 = query.getOrDefault("SourceType")
  valid_619158 = validateParameter(valid_619158, JString, required = false,
                                 default = newJString("cluster"))
  if valid_619158 != nil:
    section.add "SourceType", valid_619158
  var valid_619159 = query.getOrDefault("MaxRecords")
  valid_619159 = validateParameter(valid_619159, JInt, required = false, default = nil)
  if valid_619159 != nil:
    section.add "MaxRecords", valid_619159
  var valid_619160 = query.getOrDefault("StartTime")
  valid_619160 = validateParameter(valid_619160, JString, required = false,
                                 default = nil)
  if valid_619160 != nil:
    section.add "StartTime", valid_619160
  var valid_619161 = query.getOrDefault("Action")
  valid_619161 = validateParameter(valid_619161, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_619161 != nil:
    section.add "Action", valid_619161
  var valid_619162 = query.getOrDefault("SourceIdentifier")
  valid_619162 = validateParameter(valid_619162, JString, required = false,
                                 default = nil)
  if valid_619162 != nil:
    section.add "SourceIdentifier", valid_619162
  var valid_619163 = query.getOrDefault("Marker")
  valid_619163 = validateParameter(valid_619163, JString, required = false,
                                 default = nil)
  if valid_619163 != nil:
    section.add "Marker", valid_619163
  var valid_619164 = query.getOrDefault("Duration")
  valid_619164 = validateParameter(valid_619164, JInt, required = false, default = nil)
  if valid_619164 != nil:
    section.add "Duration", valid_619164
  var valid_619165 = query.getOrDefault("EndTime")
  valid_619165 = validateParameter(valid_619165, JString, required = false,
                                 default = nil)
  if valid_619165 != nil:
    section.add "EndTime", valid_619165
  var valid_619166 = query.getOrDefault("Version")
  valid_619166 = validateParameter(valid_619166, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619166 != nil:
    section.add "Version", valid_619166
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619167 = header.getOrDefault("X-Amz-Date")
  valid_619167 = validateParameter(valid_619167, JString, required = false,
                                 default = nil)
  if valid_619167 != nil:
    section.add "X-Amz-Date", valid_619167
  var valid_619168 = header.getOrDefault("X-Amz-Security-Token")
  valid_619168 = validateParameter(valid_619168, JString, required = false,
                                 default = nil)
  if valid_619168 != nil:
    section.add "X-Amz-Security-Token", valid_619168
  var valid_619169 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619169 = validateParameter(valid_619169, JString, required = false,
                                 default = nil)
  if valid_619169 != nil:
    section.add "X-Amz-Content-Sha256", valid_619169
  var valid_619170 = header.getOrDefault("X-Amz-Algorithm")
  valid_619170 = validateParameter(valid_619170, JString, required = false,
                                 default = nil)
  if valid_619170 != nil:
    section.add "X-Amz-Algorithm", valid_619170
  var valid_619171 = header.getOrDefault("X-Amz-Signature")
  valid_619171 = validateParameter(valid_619171, JString, required = false,
                                 default = nil)
  if valid_619171 != nil:
    section.add "X-Amz-Signature", valid_619171
  var valid_619172 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619172 = validateParameter(valid_619172, JString, required = false,
                                 default = nil)
  if valid_619172 != nil:
    section.add "X-Amz-SignedHeaders", valid_619172
  var valid_619173 = header.getOrDefault("X-Amz-Credential")
  valid_619173 = validateParameter(valid_619173, JString, required = false,
                                 default = nil)
  if valid_619173 != nil:
    section.add "X-Amz-Credential", valid_619173
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619174: Call_GetDescribeEvents_619155; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_619174.validator(path, query, header, formData, body, _)
  let scheme = call_619174.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619174.url(scheme.get, call_619174.host, call_619174.base,
                         call_619174.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619174, url, valid, _)

proc call*(call_619175: Call_GetDescribeEvents_619155;
          SourceType: string = "cluster"; MaxRecords: int = 0; StartTime: string = "";
          Action: string = "DescribeEvents"; SourceIdentifier: string = "";
          Marker: string = ""; Duration: int = 0; EndTime: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: string (required)
  var query_619176 = newJObject()
  add(query_619176, "SourceType", newJString(SourceType))
  add(query_619176, "MaxRecords", newJInt(MaxRecords))
  add(query_619176, "StartTime", newJString(StartTime))
  add(query_619176, "Action", newJString(Action))
  add(query_619176, "SourceIdentifier", newJString(SourceIdentifier))
  add(query_619176, "Marker", newJString(Marker))
  add(query_619176, "Duration", newJInt(Duration))
  add(query_619176, "EndTime", newJString(EndTime))
  add(query_619176, "Version", newJString(Version))
  result = call_619175.call(nil, query_619176, nil, nil, nil)

var getDescribeEvents* = Call_GetDescribeEvents_619155(name: "getDescribeEvents",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeEvents", validator: validate_GetDescribeEvents_619156,
    base: "/", url: url_GetDescribeEvents_619157,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmClientCertificates_619220 = ref object of OpenApiRestCall_616850
proc url_PostDescribeHsmClientCertificates_619222(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmClientCertificates_619221(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619223 = query.getOrDefault("Action")
  valid_619223 = validateParameter(valid_619223, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_619223 != nil:
    section.add "Action", valid_619223
  var valid_619224 = query.getOrDefault("Version")
  valid_619224 = validateParameter(valid_619224, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619224 != nil:
    section.add "Version", valid_619224
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619225 = header.getOrDefault("X-Amz-Date")
  valid_619225 = validateParameter(valid_619225, JString, required = false,
                                 default = nil)
  if valid_619225 != nil:
    section.add "X-Amz-Date", valid_619225
  var valid_619226 = header.getOrDefault("X-Amz-Security-Token")
  valid_619226 = validateParameter(valid_619226, JString, required = false,
                                 default = nil)
  if valid_619226 != nil:
    section.add "X-Amz-Security-Token", valid_619226
  var valid_619227 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619227 = validateParameter(valid_619227, JString, required = false,
                                 default = nil)
  if valid_619227 != nil:
    section.add "X-Amz-Content-Sha256", valid_619227
  var valid_619228 = header.getOrDefault("X-Amz-Algorithm")
  valid_619228 = validateParameter(valid_619228, JString, required = false,
                                 default = nil)
  if valid_619228 != nil:
    section.add "X-Amz-Algorithm", valid_619228
  var valid_619229 = header.getOrDefault("X-Amz-Signature")
  valid_619229 = validateParameter(valid_619229, JString, required = false,
                                 default = nil)
  if valid_619229 != nil:
    section.add "X-Amz-Signature", valid_619229
  var valid_619230 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619230 = validateParameter(valid_619230, JString, required = false,
                                 default = nil)
  if valid_619230 != nil:
    section.add "X-Amz-SignedHeaders", valid_619230
  var valid_619231 = header.getOrDefault("X-Amz-Credential")
  valid_619231 = validateParameter(valid_619231, JString, required = false,
                                 default = nil)
  if valid_619231 != nil:
    section.add "X-Amz-Credential", valid_619231
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_619232 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_619232 = validateParameter(valid_619232, JString, required = false,
                                 default = nil)
  if valid_619232 != nil:
    section.add "HsmClientCertificateIdentifier", valid_619232
  var valid_619233 = formData.getOrDefault("TagKeys")
  valid_619233 = validateParameter(valid_619233, JArray, required = false,
                                 default = nil)
  if valid_619233 != nil:
    section.add "TagKeys", valid_619233
  var valid_619234 = formData.getOrDefault("Marker")
  valid_619234 = validateParameter(valid_619234, JString, required = false,
                                 default = nil)
  if valid_619234 != nil:
    section.add "Marker", valid_619234
  var valid_619235 = formData.getOrDefault("MaxRecords")
  valid_619235 = validateParameter(valid_619235, JInt, required = false, default = nil)
  if valid_619235 != nil:
    section.add "MaxRecords", valid_619235
  var valid_619236 = formData.getOrDefault("TagValues")
  valid_619236 = validateParameter(valid_619236, JArray, required = false,
                                 default = nil)
  if valid_619236 != nil:
    section.add "TagValues", valid_619236
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619237: Call_PostDescribeHsmClientCertificates_619220;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_619237.validator(path, query, header, formData, body, _)
  let scheme = call_619237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619237.url(scheme.get, call_619237.host, call_619237.base,
                         call_619237.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619237, url, valid, _)

proc call*(call_619238: Call_PostDescribeHsmClientCertificates_619220;
          Action: string = "DescribeHsmClientCertificates";
          HsmClientCertificateIdentifier: string = ""; TagKeys: JsonNode = nil;
          Marker: string = ""; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_619239 = newJObject()
  var formData_619240 = newJObject()
  add(query_619239, "Action", newJString(Action))
  add(formData_619240, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if TagKeys != nil:
    formData_619240.add "TagKeys", TagKeys
  add(formData_619240, "Marker", newJString(Marker))
  add(formData_619240, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_619240.add "TagValues", TagValues
  add(query_619239, "Version", newJString(Version))
  result = call_619238.call(nil, query_619239, nil, formData_619240, nil)

var postDescribeHsmClientCertificates* = Call_PostDescribeHsmClientCertificates_619220(
    name: "postDescribeHsmClientCertificates", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_PostDescribeHsmClientCertificates_619221, base: "/",
    url: url_PostDescribeHsmClientCertificates_619222,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmClientCertificates_619200 = ref object of OpenApiRestCall_616850
proc url_GetDescribeHsmClientCertificates_619202(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmClientCertificates_619201(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_619203 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_619203 = validateParameter(valid_619203, JString, required = false,
                                 default = nil)
  if valid_619203 != nil:
    section.add "HsmClientCertificateIdentifier", valid_619203
  var valid_619204 = query.getOrDefault("TagValues")
  valid_619204 = validateParameter(valid_619204, JArray, required = false,
                                 default = nil)
  if valid_619204 != nil:
    section.add "TagValues", valid_619204
  var valid_619205 = query.getOrDefault("MaxRecords")
  valid_619205 = validateParameter(valid_619205, JInt, required = false, default = nil)
  if valid_619205 != nil:
    section.add "MaxRecords", valid_619205
  var valid_619206 = query.getOrDefault("Action")
  valid_619206 = validateParameter(valid_619206, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_619206 != nil:
    section.add "Action", valid_619206
  var valid_619207 = query.getOrDefault("Marker")
  valid_619207 = validateParameter(valid_619207, JString, required = false,
                                 default = nil)
  if valid_619207 != nil:
    section.add "Marker", valid_619207
  var valid_619208 = query.getOrDefault("TagKeys")
  valid_619208 = validateParameter(valid_619208, JArray, required = false,
                                 default = nil)
  if valid_619208 != nil:
    section.add "TagKeys", valid_619208
  var valid_619209 = query.getOrDefault("Version")
  valid_619209 = validateParameter(valid_619209, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619209 != nil:
    section.add "Version", valid_619209
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619210 = header.getOrDefault("X-Amz-Date")
  valid_619210 = validateParameter(valid_619210, JString, required = false,
                                 default = nil)
  if valid_619210 != nil:
    section.add "X-Amz-Date", valid_619210
  var valid_619211 = header.getOrDefault("X-Amz-Security-Token")
  valid_619211 = validateParameter(valid_619211, JString, required = false,
                                 default = nil)
  if valid_619211 != nil:
    section.add "X-Amz-Security-Token", valid_619211
  var valid_619212 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619212 = validateParameter(valid_619212, JString, required = false,
                                 default = nil)
  if valid_619212 != nil:
    section.add "X-Amz-Content-Sha256", valid_619212
  var valid_619213 = header.getOrDefault("X-Amz-Algorithm")
  valid_619213 = validateParameter(valid_619213, JString, required = false,
                                 default = nil)
  if valid_619213 != nil:
    section.add "X-Amz-Algorithm", valid_619213
  var valid_619214 = header.getOrDefault("X-Amz-Signature")
  valid_619214 = validateParameter(valid_619214, JString, required = false,
                                 default = nil)
  if valid_619214 != nil:
    section.add "X-Amz-Signature", valid_619214
  var valid_619215 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619215 = validateParameter(valid_619215, JString, required = false,
                                 default = nil)
  if valid_619215 != nil:
    section.add "X-Amz-SignedHeaders", valid_619215
  var valid_619216 = header.getOrDefault("X-Amz-Credential")
  valid_619216 = validateParameter(valid_619216, JString, required = false,
                                 default = nil)
  if valid_619216 != nil:
    section.add "X-Amz-Credential", valid_619216
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619217: Call_GetDescribeHsmClientCertificates_619200;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_619217.validator(path, query, header, formData, body, _)
  let scheme = call_619217.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619217.url(scheme.get, call_619217.host, call_619217.base,
                         call_619217.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619217, url, valid, _)

proc call*(call_619218: Call_GetDescribeHsmClientCertificates_619200;
          HsmClientCertificateIdentifier: string = ""; TagValues: JsonNode = nil;
          MaxRecords: int = 0; Action: string = "DescribeHsmClientCertificates";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_619219 = newJObject()
  add(query_619219, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if TagValues != nil:
    query_619219.add "TagValues", TagValues
  add(query_619219, "MaxRecords", newJInt(MaxRecords))
  add(query_619219, "Action", newJString(Action))
  add(query_619219, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_619219.add "TagKeys", TagKeys
  add(query_619219, "Version", newJString(Version))
  result = call_619218.call(nil, query_619219, nil, nil, nil)

var getDescribeHsmClientCertificates* = Call_GetDescribeHsmClientCertificates_619200(
    name: "getDescribeHsmClientCertificates", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_GetDescribeHsmClientCertificates_619201, base: "/",
    url: url_GetDescribeHsmClientCertificates_619202,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmConfigurations_619261 = ref object of OpenApiRestCall_616850
proc url_PostDescribeHsmConfigurations_619263(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmConfigurations_619262(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619264 = query.getOrDefault("Action")
  valid_619264 = validateParameter(valid_619264, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_619264 != nil:
    section.add "Action", valid_619264
  var valid_619265 = query.getOrDefault("Version")
  valid_619265 = validateParameter(valid_619265, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619265 != nil:
    section.add "Version", valid_619265
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619266 = header.getOrDefault("X-Amz-Date")
  valid_619266 = validateParameter(valid_619266, JString, required = false,
                                 default = nil)
  if valid_619266 != nil:
    section.add "X-Amz-Date", valid_619266
  var valid_619267 = header.getOrDefault("X-Amz-Security-Token")
  valid_619267 = validateParameter(valid_619267, JString, required = false,
                                 default = nil)
  if valid_619267 != nil:
    section.add "X-Amz-Security-Token", valid_619267
  var valid_619268 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619268 = validateParameter(valid_619268, JString, required = false,
                                 default = nil)
  if valid_619268 != nil:
    section.add "X-Amz-Content-Sha256", valid_619268
  var valid_619269 = header.getOrDefault("X-Amz-Algorithm")
  valid_619269 = validateParameter(valid_619269, JString, required = false,
                                 default = nil)
  if valid_619269 != nil:
    section.add "X-Amz-Algorithm", valid_619269
  var valid_619270 = header.getOrDefault("X-Amz-Signature")
  valid_619270 = validateParameter(valid_619270, JString, required = false,
                                 default = nil)
  if valid_619270 != nil:
    section.add "X-Amz-Signature", valid_619270
  var valid_619271 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619271 = validateParameter(valid_619271, JString, required = false,
                                 default = nil)
  if valid_619271 != nil:
    section.add "X-Amz-SignedHeaders", valid_619271
  var valid_619272 = header.getOrDefault("X-Amz-Credential")
  valid_619272 = validateParameter(valid_619272, JString, required = false,
                                 default = nil)
  if valid_619272 != nil:
    section.add "X-Amz-Credential", valid_619272
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_619273 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_619273 = validateParameter(valid_619273, JString, required = false,
                                 default = nil)
  if valid_619273 != nil:
    section.add "HsmConfigurationIdentifier", valid_619273
  var valid_619274 = formData.getOrDefault("TagKeys")
  valid_619274 = validateParameter(valid_619274, JArray, required = false,
                                 default = nil)
  if valid_619274 != nil:
    section.add "TagKeys", valid_619274
  var valid_619275 = formData.getOrDefault("Marker")
  valid_619275 = validateParameter(valid_619275, JString, required = false,
                                 default = nil)
  if valid_619275 != nil:
    section.add "Marker", valid_619275
  var valid_619276 = formData.getOrDefault("MaxRecords")
  valid_619276 = validateParameter(valid_619276, JInt, required = false, default = nil)
  if valid_619276 != nil:
    section.add "MaxRecords", valid_619276
  var valid_619277 = formData.getOrDefault("TagValues")
  valid_619277 = validateParameter(valid_619277, JArray, required = false,
                                 default = nil)
  if valid_619277 != nil:
    section.add "TagValues", valid_619277
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619278: Call_PostDescribeHsmConfigurations_619261;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_619278.validator(path, query, header, formData, body, _)
  let scheme = call_619278.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619278.url(scheme.get, call_619278.host, call_619278.base,
                         call_619278.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619278, url, valid, _)

proc call*(call_619279: Call_PostDescribeHsmConfigurations_619261;
          HsmConfigurationIdentifier: string = "";
          Action: string = "DescribeHsmConfigurations"; TagKeys: JsonNode = nil;
          Marker: string = ""; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_619280 = newJObject()
  var formData_619281 = newJObject()
  add(formData_619281, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_619280, "Action", newJString(Action))
  if TagKeys != nil:
    formData_619281.add "TagKeys", TagKeys
  add(formData_619281, "Marker", newJString(Marker))
  add(formData_619281, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_619281.add "TagValues", TagValues
  add(query_619280, "Version", newJString(Version))
  result = call_619279.call(nil, query_619280, nil, formData_619281, nil)

var postDescribeHsmConfigurations* = Call_PostDescribeHsmConfigurations_619261(
    name: "postDescribeHsmConfigurations", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_PostDescribeHsmConfigurations_619262, base: "/",
    url: url_PostDescribeHsmConfigurations_619263,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmConfigurations_619241 = ref object of OpenApiRestCall_616850
proc url_GetDescribeHsmConfigurations_619243(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmConfigurations_619242(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_619244 = query.getOrDefault("TagValues")
  valid_619244 = validateParameter(valid_619244, JArray, required = false,
                                 default = nil)
  if valid_619244 != nil:
    section.add "TagValues", valid_619244
  var valid_619245 = query.getOrDefault("MaxRecords")
  valid_619245 = validateParameter(valid_619245, JInt, required = false, default = nil)
  if valid_619245 != nil:
    section.add "MaxRecords", valid_619245
  var valid_619246 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_619246 = validateParameter(valid_619246, JString, required = false,
                                 default = nil)
  if valid_619246 != nil:
    section.add "HsmConfigurationIdentifier", valid_619246
  var valid_619247 = query.getOrDefault("Action")
  valid_619247 = validateParameter(valid_619247, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_619247 != nil:
    section.add "Action", valid_619247
  var valid_619248 = query.getOrDefault("Marker")
  valid_619248 = validateParameter(valid_619248, JString, required = false,
                                 default = nil)
  if valid_619248 != nil:
    section.add "Marker", valid_619248
  var valid_619249 = query.getOrDefault("TagKeys")
  valid_619249 = validateParameter(valid_619249, JArray, required = false,
                                 default = nil)
  if valid_619249 != nil:
    section.add "TagKeys", valid_619249
  var valid_619250 = query.getOrDefault("Version")
  valid_619250 = validateParameter(valid_619250, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619250 != nil:
    section.add "Version", valid_619250
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619251 = header.getOrDefault("X-Amz-Date")
  valid_619251 = validateParameter(valid_619251, JString, required = false,
                                 default = nil)
  if valid_619251 != nil:
    section.add "X-Amz-Date", valid_619251
  var valid_619252 = header.getOrDefault("X-Amz-Security-Token")
  valid_619252 = validateParameter(valid_619252, JString, required = false,
                                 default = nil)
  if valid_619252 != nil:
    section.add "X-Amz-Security-Token", valid_619252
  var valid_619253 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619253 = validateParameter(valid_619253, JString, required = false,
                                 default = nil)
  if valid_619253 != nil:
    section.add "X-Amz-Content-Sha256", valid_619253
  var valid_619254 = header.getOrDefault("X-Amz-Algorithm")
  valid_619254 = validateParameter(valid_619254, JString, required = false,
                                 default = nil)
  if valid_619254 != nil:
    section.add "X-Amz-Algorithm", valid_619254
  var valid_619255 = header.getOrDefault("X-Amz-Signature")
  valid_619255 = validateParameter(valid_619255, JString, required = false,
                                 default = nil)
  if valid_619255 != nil:
    section.add "X-Amz-Signature", valid_619255
  var valid_619256 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619256 = validateParameter(valid_619256, JString, required = false,
                                 default = nil)
  if valid_619256 != nil:
    section.add "X-Amz-SignedHeaders", valid_619256
  var valid_619257 = header.getOrDefault("X-Amz-Credential")
  valid_619257 = validateParameter(valid_619257, JString, required = false,
                                 default = nil)
  if valid_619257 != nil:
    section.add "X-Amz-Credential", valid_619257
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619258: Call_GetDescribeHsmConfigurations_619241;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_619258.validator(path, query, header, formData, body, _)
  let scheme = call_619258.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619258.url(scheme.get, call_619258.host, call_619258.base,
                         call_619258.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619258, url, valid, _)

proc call*(call_619259: Call_GetDescribeHsmConfigurations_619241;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          HsmConfigurationIdentifier: string = "";
          Action: string = "DescribeHsmConfigurations"; Marker: string = "";
          TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_619260 = newJObject()
  if TagValues != nil:
    query_619260.add "TagValues", TagValues
  add(query_619260, "MaxRecords", newJInt(MaxRecords))
  add(query_619260, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_619260, "Action", newJString(Action))
  add(query_619260, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_619260.add "TagKeys", TagKeys
  add(query_619260, "Version", newJString(Version))
  result = call_619259.call(nil, query_619260, nil, nil, nil)

var getDescribeHsmConfigurations* = Call_GetDescribeHsmConfigurations_619241(
    name: "getDescribeHsmConfigurations", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_GetDescribeHsmConfigurations_619242, base: "/",
    url: url_GetDescribeHsmConfigurations_619243,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeLoggingStatus_619298 = ref object of OpenApiRestCall_616850
proc url_PostDescribeLoggingStatus_619300(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeLoggingStatus_619299(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619301 = query.getOrDefault("Action")
  valid_619301 = validateParameter(valid_619301, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_619301 != nil:
    section.add "Action", valid_619301
  var valid_619302 = query.getOrDefault("Version")
  valid_619302 = validateParameter(valid_619302, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619302 != nil:
    section.add "Version", valid_619302
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619303 = header.getOrDefault("X-Amz-Date")
  valid_619303 = validateParameter(valid_619303, JString, required = false,
                                 default = nil)
  if valid_619303 != nil:
    section.add "X-Amz-Date", valid_619303
  var valid_619304 = header.getOrDefault("X-Amz-Security-Token")
  valid_619304 = validateParameter(valid_619304, JString, required = false,
                                 default = nil)
  if valid_619304 != nil:
    section.add "X-Amz-Security-Token", valid_619304
  var valid_619305 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619305 = validateParameter(valid_619305, JString, required = false,
                                 default = nil)
  if valid_619305 != nil:
    section.add "X-Amz-Content-Sha256", valid_619305
  var valid_619306 = header.getOrDefault("X-Amz-Algorithm")
  valid_619306 = validateParameter(valid_619306, JString, required = false,
                                 default = nil)
  if valid_619306 != nil:
    section.add "X-Amz-Algorithm", valid_619306
  var valid_619307 = header.getOrDefault("X-Amz-Signature")
  valid_619307 = validateParameter(valid_619307, JString, required = false,
                                 default = nil)
  if valid_619307 != nil:
    section.add "X-Amz-Signature", valid_619307
  var valid_619308 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619308 = validateParameter(valid_619308, JString, required = false,
                                 default = nil)
  if valid_619308 != nil:
    section.add "X-Amz-SignedHeaders", valid_619308
  var valid_619309 = header.getOrDefault("X-Amz-Credential")
  valid_619309 = validateParameter(valid_619309, JString, required = false,
                                 default = nil)
  if valid_619309 != nil:
    section.add "X-Amz-Credential", valid_619309
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_619310 = formData.getOrDefault("ClusterIdentifier")
  valid_619310 = validateParameter(valid_619310, JString, required = true,
                                 default = nil)
  if valid_619310 != nil:
    section.add "ClusterIdentifier", valid_619310
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619311: Call_PostDescribeLoggingStatus_619298;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_619311.validator(path, query, header, formData, body, _)
  let scheme = call_619311.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619311.url(scheme.get, call_619311.host, call_619311.base,
                         call_619311.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619311, url, valid, _)

proc call*(call_619312: Call_PostDescribeLoggingStatus_619298;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_619313 = newJObject()
  var formData_619314 = newJObject()
  add(query_619313, "Action", newJString(Action))
  add(formData_619314, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619313, "Version", newJString(Version))
  result = call_619312.call(nil, query_619313, nil, formData_619314, nil)

var postDescribeLoggingStatus* = Call_PostDescribeLoggingStatus_619298(
    name: "postDescribeLoggingStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_PostDescribeLoggingStatus_619299, base: "/",
    url: url_PostDescribeLoggingStatus_619300,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeLoggingStatus_619282 = ref object of OpenApiRestCall_616850
proc url_GetDescribeLoggingStatus_619284(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeLoggingStatus_619283(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_619285 = query.getOrDefault("Action")
  valid_619285 = validateParameter(valid_619285, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_619285 != nil:
    section.add "Action", valid_619285
  var valid_619286 = query.getOrDefault("ClusterIdentifier")
  valid_619286 = validateParameter(valid_619286, JString, required = true,
                                 default = nil)
  if valid_619286 != nil:
    section.add "ClusterIdentifier", valid_619286
  var valid_619287 = query.getOrDefault("Version")
  valid_619287 = validateParameter(valid_619287, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619287 != nil:
    section.add "Version", valid_619287
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619288 = header.getOrDefault("X-Amz-Date")
  valid_619288 = validateParameter(valid_619288, JString, required = false,
                                 default = nil)
  if valid_619288 != nil:
    section.add "X-Amz-Date", valid_619288
  var valid_619289 = header.getOrDefault("X-Amz-Security-Token")
  valid_619289 = validateParameter(valid_619289, JString, required = false,
                                 default = nil)
  if valid_619289 != nil:
    section.add "X-Amz-Security-Token", valid_619289
  var valid_619290 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619290 = validateParameter(valid_619290, JString, required = false,
                                 default = nil)
  if valid_619290 != nil:
    section.add "X-Amz-Content-Sha256", valid_619290
  var valid_619291 = header.getOrDefault("X-Amz-Algorithm")
  valid_619291 = validateParameter(valid_619291, JString, required = false,
                                 default = nil)
  if valid_619291 != nil:
    section.add "X-Amz-Algorithm", valid_619291
  var valid_619292 = header.getOrDefault("X-Amz-Signature")
  valid_619292 = validateParameter(valid_619292, JString, required = false,
                                 default = nil)
  if valid_619292 != nil:
    section.add "X-Amz-Signature", valid_619292
  var valid_619293 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619293 = validateParameter(valid_619293, JString, required = false,
                                 default = nil)
  if valid_619293 != nil:
    section.add "X-Amz-SignedHeaders", valid_619293
  var valid_619294 = header.getOrDefault("X-Amz-Credential")
  valid_619294 = validateParameter(valid_619294, JString, required = false,
                                 default = nil)
  if valid_619294 != nil:
    section.add "X-Amz-Credential", valid_619294
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619295: Call_GetDescribeLoggingStatus_619282; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_619295.validator(path, query, header, formData, body, _)
  let scheme = call_619295.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619295.url(scheme.get, call_619295.host, call_619295.base,
                         call_619295.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619295, url, valid, _)

proc call*(call_619296: Call_GetDescribeLoggingStatus_619282;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_619297 = newJObject()
  add(query_619297, "Action", newJString(Action))
  add(query_619297, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619297, "Version", newJString(Version))
  result = call_619296.call(nil, query_619297, nil, nil, nil)

var getDescribeLoggingStatus* = Call_GetDescribeLoggingStatus_619282(
    name: "getDescribeLoggingStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_GetDescribeLoggingStatus_619283, base: "/",
    url: url_GetDescribeLoggingStatus_619284, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeNodeConfigurationOptions_619337 = ref object of OpenApiRestCall_616850
proc url_PostDescribeNodeConfigurationOptions_619339(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeNodeConfigurationOptions_619338(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619340 = query.getOrDefault("Action")
  valid_619340 = validateParameter(valid_619340, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_619340 != nil:
    section.add "Action", valid_619340
  var valid_619341 = query.getOrDefault("Version")
  valid_619341 = validateParameter(valid_619341, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619341 != nil:
    section.add "Version", valid_619341
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619342 = header.getOrDefault("X-Amz-Date")
  valid_619342 = validateParameter(valid_619342, JString, required = false,
                                 default = nil)
  if valid_619342 != nil:
    section.add "X-Amz-Date", valid_619342
  var valid_619343 = header.getOrDefault("X-Amz-Security-Token")
  valid_619343 = validateParameter(valid_619343, JString, required = false,
                                 default = nil)
  if valid_619343 != nil:
    section.add "X-Amz-Security-Token", valid_619343
  var valid_619344 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619344 = validateParameter(valid_619344, JString, required = false,
                                 default = nil)
  if valid_619344 != nil:
    section.add "X-Amz-Content-Sha256", valid_619344
  var valid_619345 = header.getOrDefault("X-Amz-Algorithm")
  valid_619345 = validateParameter(valid_619345, JString, required = false,
                                 default = nil)
  if valid_619345 != nil:
    section.add "X-Amz-Algorithm", valid_619345
  var valid_619346 = header.getOrDefault("X-Amz-Signature")
  valid_619346 = validateParameter(valid_619346, JString, required = false,
                                 default = nil)
  if valid_619346 != nil:
    section.add "X-Amz-Signature", valid_619346
  var valid_619347 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619347 = validateParameter(valid_619347, JString, required = false,
                                 default = nil)
  if valid_619347 != nil:
    section.add "X-Amz-SignedHeaders", valid_619347
  var valid_619348 = header.getOrDefault("X-Amz-Credential")
  valid_619348 = validateParameter(valid_619348, JString, required = false,
                                 default = nil)
  if valid_619348 != nil:
    section.add "X-Amz-Credential", valid_619348
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. Specify "resize-cluster" to get configuration combinations for elastic resize based on an existing cluster. 
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  section = newJObject()
  var valid_619349 = formData.getOrDefault("SnapshotIdentifier")
  valid_619349 = validateParameter(valid_619349, JString, required = false,
                                 default = nil)
  if valid_619349 != nil:
    section.add "SnapshotIdentifier", valid_619349
  var valid_619350 = formData.getOrDefault("Filter")
  valid_619350 = validateParameter(valid_619350, JArray, required = false,
                                 default = nil)
  if valid_619350 != nil:
    section.add "Filter", valid_619350
  var valid_619351 = formData.getOrDefault("OwnerAccount")
  valid_619351 = validateParameter(valid_619351, JString, required = false,
                                 default = nil)
  if valid_619351 != nil:
    section.add "OwnerAccount", valid_619351
  var valid_619352 = formData.getOrDefault("ActionType")
  valid_619352 = validateParameter(valid_619352, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_619352 != nil:
    section.add "ActionType", valid_619352
  var valid_619353 = formData.getOrDefault("ClusterIdentifier")
  valid_619353 = validateParameter(valid_619353, JString, required = false,
                                 default = nil)
  if valid_619353 != nil:
    section.add "ClusterIdentifier", valid_619353
  var valid_619354 = formData.getOrDefault("Marker")
  valid_619354 = validateParameter(valid_619354, JString, required = false,
                                 default = nil)
  if valid_619354 != nil:
    section.add "Marker", valid_619354
  var valid_619355 = formData.getOrDefault("MaxRecords")
  valid_619355 = validateParameter(valid_619355, JInt, required = false, default = nil)
  if valid_619355 != nil:
    section.add "MaxRecords", valid_619355
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619356: Call_PostDescribeNodeConfigurationOptions_619337;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_619356.validator(path, query, header, formData, body, _)
  let scheme = call_619356.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619356.url(scheme.get, call_619356.host, call_619356.base,
                         call_619356.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619356, url, valid, _)

proc call*(call_619357: Call_PostDescribeNodeConfigurationOptions_619337;
          SnapshotIdentifier: string = ""; Filter: JsonNode = nil;
          Action: string = "DescribeNodeConfigurationOptions";
          OwnerAccount: string = ""; ActionType: string = "restore-cluster";
          ClusterIdentifier: string = ""; Marker: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. Specify "resize-cluster" to get configuration combinations for elastic resize based on an existing cluster. 
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Version: string (required)
  var query_619358 = newJObject()
  var formData_619359 = newJObject()
  add(formData_619359, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  if Filter != nil:
    formData_619359.add "Filter", Filter
  add(query_619358, "Action", newJString(Action))
  add(formData_619359, "OwnerAccount", newJString(OwnerAccount))
  add(formData_619359, "ActionType", newJString(ActionType))
  add(formData_619359, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_619359, "Marker", newJString(Marker))
  add(formData_619359, "MaxRecords", newJInt(MaxRecords))
  add(query_619358, "Version", newJString(Version))
  result = call_619357.call(nil, query_619358, nil, formData_619359, nil)

var postDescribeNodeConfigurationOptions* = Call_PostDescribeNodeConfigurationOptions_619337(
    name: "postDescribeNodeConfigurationOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_PostDescribeNodeConfigurationOptions_619338, base: "/",
    url: url_PostDescribeNodeConfigurationOptions_619339,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeNodeConfigurationOptions_619315 = ref object of OpenApiRestCall_616850
proc url_GetDescribeNodeConfigurationOptions_619317(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeNodeConfigurationOptions_619316(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. Specify "resize-cluster" to get configuration combinations for elastic resize based on an existing cluster. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Version: JString (required)
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  section = newJObject()
  var valid_619318 = query.getOrDefault("MaxRecords")
  valid_619318 = validateParameter(valid_619318, JInt, required = false, default = nil)
  if valid_619318 != nil:
    section.add "MaxRecords", valid_619318
  var valid_619319 = query.getOrDefault("Filter")
  valid_619319 = validateParameter(valid_619319, JArray, required = false,
                                 default = nil)
  if valid_619319 != nil:
    section.add "Filter", valid_619319
  var valid_619320 = query.getOrDefault("ActionType")
  valid_619320 = validateParameter(valid_619320, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_619320 != nil:
    section.add "ActionType", valid_619320
  var valid_619321 = query.getOrDefault("Action")
  valid_619321 = validateParameter(valid_619321, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_619321 != nil:
    section.add "Action", valid_619321
  var valid_619322 = query.getOrDefault("ClusterIdentifier")
  valid_619322 = validateParameter(valid_619322, JString, required = false,
                                 default = nil)
  if valid_619322 != nil:
    section.add "ClusterIdentifier", valid_619322
  var valid_619323 = query.getOrDefault("Marker")
  valid_619323 = validateParameter(valid_619323, JString, required = false,
                                 default = nil)
  if valid_619323 != nil:
    section.add "Marker", valid_619323
  var valid_619324 = query.getOrDefault("SnapshotIdentifier")
  valid_619324 = validateParameter(valid_619324, JString, required = false,
                                 default = nil)
  if valid_619324 != nil:
    section.add "SnapshotIdentifier", valid_619324
  var valid_619325 = query.getOrDefault("Version")
  valid_619325 = validateParameter(valid_619325, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619325 != nil:
    section.add "Version", valid_619325
  var valid_619326 = query.getOrDefault("OwnerAccount")
  valid_619326 = validateParameter(valid_619326, JString, required = false,
                                 default = nil)
  if valid_619326 != nil:
    section.add "OwnerAccount", valid_619326
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619327 = header.getOrDefault("X-Amz-Date")
  valid_619327 = validateParameter(valid_619327, JString, required = false,
                                 default = nil)
  if valid_619327 != nil:
    section.add "X-Amz-Date", valid_619327
  var valid_619328 = header.getOrDefault("X-Amz-Security-Token")
  valid_619328 = validateParameter(valid_619328, JString, required = false,
                                 default = nil)
  if valid_619328 != nil:
    section.add "X-Amz-Security-Token", valid_619328
  var valid_619329 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619329 = validateParameter(valid_619329, JString, required = false,
                                 default = nil)
  if valid_619329 != nil:
    section.add "X-Amz-Content-Sha256", valid_619329
  var valid_619330 = header.getOrDefault("X-Amz-Algorithm")
  valid_619330 = validateParameter(valid_619330, JString, required = false,
                                 default = nil)
  if valid_619330 != nil:
    section.add "X-Amz-Algorithm", valid_619330
  var valid_619331 = header.getOrDefault("X-Amz-Signature")
  valid_619331 = validateParameter(valid_619331, JString, required = false,
                                 default = nil)
  if valid_619331 != nil:
    section.add "X-Amz-Signature", valid_619331
  var valid_619332 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619332 = validateParameter(valid_619332, JString, required = false,
                                 default = nil)
  if valid_619332 != nil:
    section.add "X-Amz-SignedHeaders", valid_619332
  var valid_619333 = header.getOrDefault("X-Amz-Credential")
  valid_619333 = validateParameter(valid_619333, JString, required = false,
                                 default = nil)
  if valid_619333 != nil:
    section.add "X-Amz-Credential", valid_619333
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619334: Call_GetDescribeNodeConfigurationOptions_619315;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_619334.validator(path, query, header, formData, body, _)
  let scheme = call_619334.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619334.url(scheme.get, call_619334.host, call_619334.base,
                         call_619334.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619334, url, valid, _)

proc call*(call_619335: Call_GetDescribeNodeConfigurationOptions_619315;
          MaxRecords: int = 0; Filter: JsonNode = nil;
          ActionType: string = "restore-cluster";
          Action: string = "DescribeNodeConfigurationOptions";
          ClusterIdentifier: string = ""; Marker: string = "";
          SnapshotIdentifier: string = ""; Version: string = "2012-12-01";
          OwnerAccount: string = ""): Recallable =
  ## getDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. Specify "resize-cluster" to get configuration combinations for elastic resize based on an existing cluster. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Version: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  var query_619336 = newJObject()
  add(query_619336, "MaxRecords", newJInt(MaxRecords))
  if Filter != nil:
    query_619336.add "Filter", Filter
  add(query_619336, "ActionType", newJString(ActionType))
  add(query_619336, "Action", newJString(Action))
  add(query_619336, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619336, "Marker", newJString(Marker))
  add(query_619336, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_619336, "Version", newJString(Version))
  add(query_619336, "OwnerAccount", newJString(OwnerAccount))
  result = call_619335.call(nil, query_619336, nil, nil, nil)

var getDescribeNodeConfigurationOptions* = Call_GetDescribeNodeConfigurationOptions_619315(
    name: "getDescribeNodeConfigurationOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_GetDescribeNodeConfigurationOptions_619316, base: "/",
    url: url_GetDescribeNodeConfigurationOptions_619317,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeOrderableClusterOptions_619379 = ref object of OpenApiRestCall_616850
proc url_PostDescribeOrderableClusterOptions_619381(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeOrderableClusterOptions_619380(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619382 = query.getOrDefault("Action")
  valid_619382 = validateParameter(valid_619382, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_619382 != nil:
    section.add "Action", valid_619382
  var valid_619383 = query.getOrDefault("Version")
  valid_619383 = validateParameter(valid_619383, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619383 != nil:
    section.add "Version", valid_619383
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619384 = header.getOrDefault("X-Amz-Date")
  valid_619384 = validateParameter(valid_619384, JString, required = false,
                                 default = nil)
  if valid_619384 != nil:
    section.add "X-Amz-Date", valid_619384
  var valid_619385 = header.getOrDefault("X-Amz-Security-Token")
  valid_619385 = validateParameter(valid_619385, JString, required = false,
                                 default = nil)
  if valid_619385 != nil:
    section.add "X-Amz-Security-Token", valid_619385
  var valid_619386 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619386 = validateParameter(valid_619386, JString, required = false,
                                 default = nil)
  if valid_619386 != nil:
    section.add "X-Amz-Content-Sha256", valid_619386
  var valid_619387 = header.getOrDefault("X-Amz-Algorithm")
  valid_619387 = validateParameter(valid_619387, JString, required = false,
                                 default = nil)
  if valid_619387 != nil:
    section.add "X-Amz-Algorithm", valid_619387
  var valid_619388 = header.getOrDefault("X-Amz-Signature")
  valid_619388 = validateParameter(valid_619388, JString, required = false,
                                 default = nil)
  if valid_619388 != nil:
    section.add "X-Amz-Signature", valid_619388
  var valid_619389 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619389 = validateParameter(valid_619389, JString, required = false,
                                 default = nil)
  if valid_619389 != nil:
    section.add "X-Amz-SignedHeaders", valid_619389
  var valid_619390 = header.getOrDefault("X-Amz-Credential")
  valid_619390 = validateParameter(valid_619390, JString, required = false,
                                 default = nil)
  if valid_619390 != nil:
    section.add "X-Amz-Credential", valid_619390
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  section = newJObject()
  var valid_619391 = formData.getOrDefault("ClusterVersion")
  valid_619391 = validateParameter(valid_619391, JString, required = false,
                                 default = nil)
  if valid_619391 != nil:
    section.add "ClusterVersion", valid_619391
  var valid_619392 = formData.getOrDefault("Marker")
  valid_619392 = validateParameter(valid_619392, JString, required = false,
                                 default = nil)
  if valid_619392 != nil:
    section.add "Marker", valid_619392
  var valid_619393 = formData.getOrDefault("MaxRecords")
  valid_619393 = validateParameter(valid_619393, JInt, required = false, default = nil)
  if valid_619393 != nil:
    section.add "MaxRecords", valid_619393
  var valid_619394 = formData.getOrDefault("NodeType")
  valid_619394 = validateParameter(valid_619394, JString, required = false,
                                 default = nil)
  if valid_619394 != nil:
    section.add "NodeType", valid_619394
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619395: Call_PostDescribeOrderableClusterOptions_619379;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_619395.validator(path, query, header, formData, body, _)
  let scheme = call_619395.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619395.url(scheme.get, call_619395.host, call_619395.base,
                         call_619395.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619395, url, valid, _)

proc call*(call_619396: Call_PostDescribeOrderableClusterOptions_619379;
          ClusterVersion: string = "";
          Action: string = "DescribeOrderableClusterOptions"; Marker: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01"; NodeType: string = ""): Recallable =
  ## postDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  var query_619397 = newJObject()
  var formData_619398 = newJObject()
  add(formData_619398, "ClusterVersion", newJString(ClusterVersion))
  add(query_619397, "Action", newJString(Action))
  add(formData_619398, "Marker", newJString(Marker))
  add(formData_619398, "MaxRecords", newJInt(MaxRecords))
  add(query_619397, "Version", newJString(Version))
  add(formData_619398, "NodeType", newJString(NodeType))
  result = call_619396.call(nil, query_619397, nil, formData_619398, nil)

var postDescribeOrderableClusterOptions* = Call_PostDescribeOrderableClusterOptions_619379(
    name: "postDescribeOrderableClusterOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_PostDescribeOrderableClusterOptions_619380, base: "/",
    url: url_PostDescribeOrderableClusterOptions_619381,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeOrderableClusterOptions_619360 = ref object of OpenApiRestCall_616850
proc url_GetDescribeOrderableClusterOptions_619362(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeOrderableClusterOptions_619361(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_619363 = query.getOrDefault("MaxRecords")
  valid_619363 = validateParameter(valid_619363, JInt, required = false, default = nil)
  if valid_619363 != nil:
    section.add "MaxRecords", valid_619363
  var valid_619364 = query.getOrDefault("Action")
  valid_619364 = validateParameter(valid_619364, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_619364 != nil:
    section.add "Action", valid_619364
  var valid_619365 = query.getOrDefault("Marker")
  valid_619365 = validateParameter(valid_619365, JString, required = false,
                                 default = nil)
  if valid_619365 != nil:
    section.add "Marker", valid_619365
  var valid_619366 = query.getOrDefault("NodeType")
  valid_619366 = validateParameter(valid_619366, JString, required = false,
                                 default = nil)
  if valid_619366 != nil:
    section.add "NodeType", valid_619366
  var valid_619367 = query.getOrDefault("ClusterVersion")
  valid_619367 = validateParameter(valid_619367, JString, required = false,
                                 default = nil)
  if valid_619367 != nil:
    section.add "ClusterVersion", valid_619367
  var valid_619368 = query.getOrDefault("Version")
  valid_619368 = validateParameter(valid_619368, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619368 != nil:
    section.add "Version", valid_619368
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619369 = header.getOrDefault("X-Amz-Date")
  valid_619369 = validateParameter(valid_619369, JString, required = false,
                                 default = nil)
  if valid_619369 != nil:
    section.add "X-Amz-Date", valid_619369
  var valid_619370 = header.getOrDefault("X-Amz-Security-Token")
  valid_619370 = validateParameter(valid_619370, JString, required = false,
                                 default = nil)
  if valid_619370 != nil:
    section.add "X-Amz-Security-Token", valid_619370
  var valid_619371 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619371 = validateParameter(valid_619371, JString, required = false,
                                 default = nil)
  if valid_619371 != nil:
    section.add "X-Amz-Content-Sha256", valid_619371
  var valid_619372 = header.getOrDefault("X-Amz-Algorithm")
  valid_619372 = validateParameter(valid_619372, JString, required = false,
                                 default = nil)
  if valid_619372 != nil:
    section.add "X-Amz-Algorithm", valid_619372
  var valid_619373 = header.getOrDefault("X-Amz-Signature")
  valid_619373 = validateParameter(valid_619373, JString, required = false,
                                 default = nil)
  if valid_619373 != nil:
    section.add "X-Amz-Signature", valid_619373
  var valid_619374 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619374 = validateParameter(valid_619374, JString, required = false,
                                 default = nil)
  if valid_619374 != nil:
    section.add "X-Amz-SignedHeaders", valid_619374
  var valid_619375 = header.getOrDefault("X-Amz-Credential")
  valid_619375 = validateParameter(valid_619375, JString, required = false,
                                 default = nil)
  if valid_619375 != nil:
    section.add "X-Amz-Credential", valid_619375
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619376: Call_GetDescribeOrderableClusterOptions_619360;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_619376.validator(path, query, header, formData, body, _)
  let scheme = call_619376.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619376.url(scheme.get, call_619376.host, call_619376.base,
                         call_619376.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619376, url, valid, _)

proc call*(call_619377: Call_GetDescribeOrderableClusterOptions_619360;
          MaxRecords: int = 0; Action: string = "DescribeOrderableClusterOptions";
          Marker: string = ""; NodeType: string = ""; ClusterVersion: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: string (required)
  var query_619378 = newJObject()
  add(query_619378, "MaxRecords", newJInt(MaxRecords))
  add(query_619378, "Action", newJString(Action))
  add(query_619378, "Marker", newJString(Marker))
  add(query_619378, "NodeType", newJString(NodeType))
  add(query_619378, "ClusterVersion", newJString(ClusterVersion))
  add(query_619378, "Version", newJString(Version))
  result = call_619377.call(nil, query_619378, nil, nil, nil)

var getDescribeOrderableClusterOptions* = Call_GetDescribeOrderableClusterOptions_619360(
    name: "getDescribeOrderableClusterOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_GetDescribeOrderableClusterOptions_619361, base: "/",
    url: url_GetDescribeOrderableClusterOptions_619362,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodeOfferings_619417 = ref object of OpenApiRestCall_616850
proc url_PostDescribeReservedNodeOfferings_619419(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodeOfferings_619418(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619420 = query.getOrDefault("Action")
  valid_619420 = validateParameter(valid_619420, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_619420 != nil:
    section.add "Action", valid_619420
  var valid_619421 = query.getOrDefault("Version")
  valid_619421 = validateParameter(valid_619421, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619421 != nil:
    section.add "Version", valid_619421
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619422 = header.getOrDefault("X-Amz-Date")
  valid_619422 = validateParameter(valid_619422, JString, required = false,
                                 default = nil)
  if valid_619422 != nil:
    section.add "X-Amz-Date", valid_619422
  var valid_619423 = header.getOrDefault("X-Amz-Security-Token")
  valid_619423 = validateParameter(valid_619423, JString, required = false,
                                 default = nil)
  if valid_619423 != nil:
    section.add "X-Amz-Security-Token", valid_619423
  var valid_619424 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619424 = validateParameter(valid_619424, JString, required = false,
                                 default = nil)
  if valid_619424 != nil:
    section.add "X-Amz-Content-Sha256", valid_619424
  var valid_619425 = header.getOrDefault("X-Amz-Algorithm")
  valid_619425 = validateParameter(valid_619425, JString, required = false,
                                 default = nil)
  if valid_619425 != nil:
    section.add "X-Amz-Algorithm", valid_619425
  var valid_619426 = header.getOrDefault("X-Amz-Signature")
  valid_619426 = validateParameter(valid_619426, JString, required = false,
                                 default = nil)
  if valid_619426 != nil:
    section.add "X-Amz-Signature", valid_619426
  var valid_619427 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619427 = validateParameter(valid_619427, JString, required = false,
                                 default = nil)
  if valid_619427 != nil:
    section.add "X-Amz-SignedHeaders", valid_619427
  var valid_619428 = header.getOrDefault("X-Amz-Credential")
  valid_619428 = validateParameter(valid_619428, JString, required = false,
                                 default = nil)
  if valid_619428 != nil:
    section.add "X-Amz-Credential", valid_619428
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_619429 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_619429 = validateParameter(valid_619429, JString, required = false,
                                 default = nil)
  if valid_619429 != nil:
    section.add "ReservedNodeOfferingId", valid_619429
  var valid_619430 = formData.getOrDefault("Marker")
  valid_619430 = validateParameter(valid_619430, JString, required = false,
                                 default = nil)
  if valid_619430 != nil:
    section.add "Marker", valid_619430
  var valid_619431 = formData.getOrDefault("MaxRecords")
  valid_619431 = validateParameter(valid_619431, JInt, required = false, default = nil)
  if valid_619431 != nil:
    section.add "MaxRecords", valid_619431
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619432: Call_PostDescribeReservedNodeOfferings_619417;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_619432.validator(path, query, header, formData, body, _)
  let scheme = call_619432.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619432.url(scheme.get, call_619432.host, call_619432.base,
                         call_619432.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619432, url, valid, _)

proc call*(call_619433: Call_PostDescribeReservedNodeOfferings_619417;
          ReservedNodeOfferingId: string = "";
          Action: string = "DescribeReservedNodeOfferings"; Marker: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_619434 = newJObject()
  var formData_619435 = newJObject()
  add(formData_619435, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(query_619434, "Action", newJString(Action))
  add(formData_619435, "Marker", newJString(Marker))
  add(formData_619435, "MaxRecords", newJInt(MaxRecords))
  add(query_619434, "Version", newJString(Version))
  result = call_619433.call(nil, query_619434, nil, formData_619435, nil)

var postDescribeReservedNodeOfferings* = Call_PostDescribeReservedNodeOfferings_619417(
    name: "postDescribeReservedNodeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_PostDescribeReservedNodeOfferings_619418, base: "/",
    url: url_PostDescribeReservedNodeOfferings_619419,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodeOfferings_619399 = ref object of OpenApiRestCall_616850
proc url_GetDescribeReservedNodeOfferings_619401(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodeOfferings_619400(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_619402 = query.getOrDefault("MaxRecords")
  valid_619402 = validateParameter(valid_619402, JInt, required = false, default = nil)
  if valid_619402 != nil:
    section.add "MaxRecords", valid_619402
  var valid_619403 = query.getOrDefault("ReservedNodeOfferingId")
  valid_619403 = validateParameter(valid_619403, JString, required = false,
                                 default = nil)
  if valid_619403 != nil:
    section.add "ReservedNodeOfferingId", valid_619403
  var valid_619404 = query.getOrDefault("Action")
  valid_619404 = validateParameter(valid_619404, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_619404 != nil:
    section.add "Action", valid_619404
  var valid_619405 = query.getOrDefault("Marker")
  valid_619405 = validateParameter(valid_619405, JString, required = false,
                                 default = nil)
  if valid_619405 != nil:
    section.add "Marker", valid_619405
  var valid_619406 = query.getOrDefault("Version")
  valid_619406 = validateParameter(valid_619406, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619406 != nil:
    section.add "Version", valid_619406
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619407 = header.getOrDefault("X-Amz-Date")
  valid_619407 = validateParameter(valid_619407, JString, required = false,
                                 default = nil)
  if valid_619407 != nil:
    section.add "X-Amz-Date", valid_619407
  var valid_619408 = header.getOrDefault("X-Amz-Security-Token")
  valid_619408 = validateParameter(valid_619408, JString, required = false,
                                 default = nil)
  if valid_619408 != nil:
    section.add "X-Amz-Security-Token", valid_619408
  var valid_619409 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619409 = validateParameter(valid_619409, JString, required = false,
                                 default = nil)
  if valid_619409 != nil:
    section.add "X-Amz-Content-Sha256", valid_619409
  var valid_619410 = header.getOrDefault("X-Amz-Algorithm")
  valid_619410 = validateParameter(valid_619410, JString, required = false,
                                 default = nil)
  if valid_619410 != nil:
    section.add "X-Amz-Algorithm", valid_619410
  var valid_619411 = header.getOrDefault("X-Amz-Signature")
  valid_619411 = validateParameter(valid_619411, JString, required = false,
                                 default = nil)
  if valid_619411 != nil:
    section.add "X-Amz-Signature", valid_619411
  var valid_619412 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619412 = validateParameter(valid_619412, JString, required = false,
                                 default = nil)
  if valid_619412 != nil:
    section.add "X-Amz-SignedHeaders", valid_619412
  var valid_619413 = header.getOrDefault("X-Amz-Credential")
  valid_619413 = validateParameter(valid_619413, JString, required = false,
                                 default = nil)
  if valid_619413 != nil:
    section.add "X-Amz-Credential", valid_619413
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619414: Call_GetDescribeReservedNodeOfferings_619399;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_619414.validator(path, query, header, formData, body, _)
  let scheme = call_619414.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619414.url(scheme.get, call_619414.host, call_619414.base,
                         call_619414.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619414, url, valid, _)

proc call*(call_619415: Call_GetDescribeReservedNodeOfferings_619399;
          MaxRecords: int = 0; ReservedNodeOfferingId: string = "";
          Action: string = "DescribeReservedNodeOfferings"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  var query_619416 = newJObject()
  add(query_619416, "MaxRecords", newJInt(MaxRecords))
  add(query_619416, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_619416, "Action", newJString(Action))
  add(query_619416, "Marker", newJString(Marker))
  add(query_619416, "Version", newJString(Version))
  result = call_619415.call(nil, query_619416, nil, nil, nil)

var getDescribeReservedNodeOfferings* = Call_GetDescribeReservedNodeOfferings_619399(
    name: "getDescribeReservedNodeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_GetDescribeReservedNodeOfferings_619400, base: "/",
    url: url_GetDescribeReservedNodeOfferings_619401,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodes_619454 = ref object of OpenApiRestCall_616850
proc url_PostDescribeReservedNodes_619456(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodes_619455(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619457 = query.getOrDefault("Action")
  valid_619457 = validateParameter(valid_619457, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_619457 != nil:
    section.add "Action", valid_619457
  var valid_619458 = query.getOrDefault("Version")
  valid_619458 = validateParameter(valid_619458, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619458 != nil:
    section.add "Version", valid_619458
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619459 = header.getOrDefault("X-Amz-Date")
  valid_619459 = validateParameter(valid_619459, JString, required = false,
                                 default = nil)
  if valid_619459 != nil:
    section.add "X-Amz-Date", valid_619459
  var valid_619460 = header.getOrDefault("X-Amz-Security-Token")
  valid_619460 = validateParameter(valid_619460, JString, required = false,
                                 default = nil)
  if valid_619460 != nil:
    section.add "X-Amz-Security-Token", valid_619460
  var valid_619461 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619461 = validateParameter(valid_619461, JString, required = false,
                                 default = nil)
  if valid_619461 != nil:
    section.add "X-Amz-Content-Sha256", valid_619461
  var valid_619462 = header.getOrDefault("X-Amz-Algorithm")
  valid_619462 = validateParameter(valid_619462, JString, required = false,
                                 default = nil)
  if valid_619462 != nil:
    section.add "X-Amz-Algorithm", valid_619462
  var valid_619463 = header.getOrDefault("X-Amz-Signature")
  valid_619463 = validateParameter(valid_619463, JString, required = false,
                                 default = nil)
  if valid_619463 != nil:
    section.add "X-Amz-Signature", valid_619463
  var valid_619464 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619464 = validateParameter(valid_619464, JString, required = false,
                                 default = nil)
  if valid_619464 != nil:
    section.add "X-Amz-SignedHeaders", valid_619464
  var valid_619465 = header.getOrDefault("X-Amz-Credential")
  valid_619465 = validateParameter(valid_619465, JString, required = false,
                                 default = nil)
  if valid_619465 != nil:
    section.add "X-Amz-Credential", valid_619465
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_619466 = formData.getOrDefault("ReservedNodeId")
  valid_619466 = validateParameter(valid_619466, JString, required = false,
                                 default = nil)
  if valid_619466 != nil:
    section.add "ReservedNodeId", valid_619466
  var valid_619467 = formData.getOrDefault("Marker")
  valid_619467 = validateParameter(valid_619467, JString, required = false,
                                 default = nil)
  if valid_619467 != nil:
    section.add "Marker", valid_619467
  var valid_619468 = formData.getOrDefault("MaxRecords")
  valid_619468 = validateParameter(valid_619468, JInt, required = false, default = nil)
  if valid_619468 != nil:
    section.add "MaxRecords", valid_619468
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619469: Call_PostDescribeReservedNodes_619454;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_619469.validator(path, query, header, formData, body, _)
  let scheme = call_619469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619469.url(scheme.get, call_619469.host, call_619469.base,
                         call_619469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619469, url, valid, _)

proc call*(call_619470: Call_PostDescribeReservedNodes_619454;
          ReservedNodeId: string = ""; Action: string = "DescribeReservedNodes";
          Marker: string = ""; MaxRecords: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_619471 = newJObject()
  var formData_619472 = newJObject()
  add(formData_619472, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_619471, "Action", newJString(Action))
  add(formData_619472, "Marker", newJString(Marker))
  add(formData_619472, "MaxRecords", newJInt(MaxRecords))
  add(query_619471, "Version", newJString(Version))
  result = call_619470.call(nil, query_619471, nil, formData_619472, nil)

var postDescribeReservedNodes* = Call_PostDescribeReservedNodes_619454(
    name: "postDescribeReservedNodes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_PostDescribeReservedNodes_619455, base: "/",
    url: url_PostDescribeReservedNodes_619456,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodes_619436 = ref object of OpenApiRestCall_616850
proc url_GetDescribeReservedNodes_619438(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodes_619437(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  section = newJObject()
  var valid_619439 = query.getOrDefault("MaxRecords")
  valid_619439 = validateParameter(valid_619439, JInt, required = false, default = nil)
  if valid_619439 != nil:
    section.add "MaxRecords", valid_619439
  var valid_619440 = query.getOrDefault("Action")
  valid_619440 = validateParameter(valid_619440, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_619440 != nil:
    section.add "Action", valid_619440
  var valid_619441 = query.getOrDefault("Marker")
  valid_619441 = validateParameter(valid_619441, JString, required = false,
                                 default = nil)
  if valid_619441 != nil:
    section.add "Marker", valid_619441
  var valid_619442 = query.getOrDefault("Version")
  valid_619442 = validateParameter(valid_619442, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619442 != nil:
    section.add "Version", valid_619442
  var valid_619443 = query.getOrDefault("ReservedNodeId")
  valid_619443 = validateParameter(valid_619443, JString, required = false,
                                 default = nil)
  if valid_619443 != nil:
    section.add "ReservedNodeId", valid_619443
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619444 = header.getOrDefault("X-Amz-Date")
  valid_619444 = validateParameter(valid_619444, JString, required = false,
                                 default = nil)
  if valid_619444 != nil:
    section.add "X-Amz-Date", valid_619444
  var valid_619445 = header.getOrDefault("X-Amz-Security-Token")
  valid_619445 = validateParameter(valid_619445, JString, required = false,
                                 default = nil)
  if valid_619445 != nil:
    section.add "X-Amz-Security-Token", valid_619445
  var valid_619446 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619446 = validateParameter(valid_619446, JString, required = false,
                                 default = nil)
  if valid_619446 != nil:
    section.add "X-Amz-Content-Sha256", valid_619446
  var valid_619447 = header.getOrDefault("X-Amz-Algorithm")
  valid_619447 = validateParameter(valid_619447, JString, required = false,
                                 default = nil)
  if valid_619447 != nil:
    section.add "X-Amz-Algorithm", valid_619447
  var valid_619448 = header.getOrDefault("X-Amz-Signature")
  valid_619448 = validateParameter(valid_619448, JString, required = false,
                                 default = nil)
  if valid_619448 != nil:
    section.add "X-Amz-Signature", valid_619448
  var valid_619449 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619449 = validateParameter(valid_619449, JString, required = false,
                                 default = nil)
  if valid_619449 != nil:
    section.add "X-Amz-SignedHeaders", valid_619449
  var valid_619450 = header.getOrDefault("X-Amz-Credential")
  valid_619450 = validateParameter(valid_619450, JString, required = false,
                                 default = nil)
  if valid_619450 != nil:
    section.add "X-Amz-Credential", valid_619450
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619451: Call_GetDescribeReservedNodes_619436; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_619451.validator(path, query, header, formData, body, _)
  let scheme = call_619451.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619451.url(scheme.get, call_619451.host, call_619451.base,
                         call_619451.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619451, url, valid, _)

proc call*(call_619452: Call_GetDescribeReservedNodes_619436; MaxRecords: int = 0;
          Action: string = "DescribeReservedNodes"; Marker: string = "";
          Version: string = "2012-12-01"; ReservedNodeId: string = ""): Recallable =
  ## getDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  var query_619453 = newJObject()
  add(query_619453, "MaxRecords", newJInt(MaxRecords))
  add(query_619453, "Action", newJString(Action))
  add(query_619453, "Marker", newJString(Marker))
  add(query_619453, "Version", newJString(Version))
  add(query_619453, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_619452.call(nil, query_619453, nil, nil, nil)

var getDescribeReservedNodes* = Call_GetDescribeReservedNodes_619436(
    name: "getDescribeReservedNodes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_GetDescribeReservedNodes_619437, base: "/",
    url: url_GetDescribeReservedNodes_619438, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeResize_619489 = ref object of OpenApiRestCall_616850
proc url_PostDescribeResize_619491(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeResize_619490(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619492 = query.getOrDefault("Action")
  valid_619492 = validateParameter(valid_619492, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_619492 != nil:
    section.add "Action", valid_619492
  var valid_619493 = query.getOrDefault("Version")
  valid_619493 = validateParameter(valid_619493, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619493 != nil:
    section.add "Version", valid_619493
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619494 = header.getOrDefault("X-Amz-Date")
  valid_619494 = validateParameter(valid_619494, JString, required = false,
                                 default = nil)
  if valid_619494 != nil:
    section.add "X-Amz-Date", valid_619494
  var valid_619495 = header.getOrDefault("X-Amz-Security-Token")
  valid_619495 = validateParameter(valid_619495, JString, required = false,
                                 default = nil)
  if valid_619495 != nil:
    section.add "X-Amz-Security-Token", valid_619495
  var valid_619496 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619496 = validateParameter(valid_619496, JString, required = false,
                                 default = nil)
  if valid_619496 != nil:
    section.add "X-Amz-Content-Sha256", valid_619496
  var valid_619497 = header.getOrDefault("X-Amz-Algorithm")
  valid_619497 = validateParameter(valid_619497, JString, required = false,
                                 default = nil)
  if valid_619497 != nil:
    section.add "X-Amz-Algorithm", valid_619497
  var valid_619498 = header.getOrDefault("X-Amz-Signature")
  valid_619498 = validateParameter(valid_619498, JString, required = false,
                                 default = nil)
  if valid_619498 != nil:
    section.add "X-Amz-Signature", valid_619498
  var valid_619499 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619499 = validateParameter(valid_619499, JString, required = false,
                                 default = nil)
  if valid_619499 != nil:
    section.add "X-Amz-SignedHeaders", valid_619499
  var valid_619500 = header.getOrDefault("X-Amz-Credential")
  valid_619500 = validateParameter(valid_619500, JString, required = false,
                                 default = nil)
  if valid_619500 != nil:
    section.add "X-Amz-Credential", valid_619500
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_619501 = formData.getOrDefault("ClusterIdentifier")
  valid_619501 = validateParameter(valid_619501, JString, required = true,
                                 default = nil)
  if valid_619501 != nil:
    section.add "ClusterIdentifier", valid_619501
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619502: Call_PostDescribeResize_619489; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_619502.validator(path, query, header, formData, body, _)
  let scheme = call_619502.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619502.url(scheme.get, call_619502.host, call_619502.base,
                         call_619502.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619502, url, valid, _)

proc call*(call_619503: Call_PostDescribeResize_619489; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_619504 = newJObject()
  var formData_619505 = newJObject()
  add(query_619504, "Action", newJString(Action))
  add(formData_619505, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619504, "Version", newJString(Version))
  result = call_619503.call(nil, query_619504, nil, formData_619505, nil)

var postDescribeResize* = Call_PostDescribeResize_619489(
    name: "postDescribeResize", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeResize",
    validator: validate_PostDescribeResize_619490, base: "/",
    url: url_PostDescribeResize_619491, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeResize_619473 = ref object of OpenApiRestCall_616850
proc url_GetDescribeResize_619475(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeResize_619474(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_619476 = query.getOrDefault("Action")
  valid_619476 = validateParameter(valid_619476, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_619476 != nil:
    section.add "Action", valid_619476
  var valid_619477 = query.getOrDefault("ClusterIdentifier")
  valid_619477 = validateParameter(valid_619477, JString, required = true,
                                 default = nil)
  if valid_619477 != nil:
    section.add "ClusterIdentifier", valid_619477
  var valid_619478 = query.getOrDefault("Version")
  valid_619478 = validateParameter(valid_619478, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619478 != nil:
    section.add "Version", valid_619478
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619479 = header.getOrDefault("X-Amz-Date")
  valid_619479 = validateParameter(valid_619479, JString, required = false,
                                 default = nil)
  if valid_619479 != nil:
    section.add "X-Amz-Date", valid_619479
  var valid_619480 = header.getOrDefault("X-Amz-Security-Token")
  valid_619480 = validateParameter(valid_619480, JString, required = false,
                                 default = nil)
  if valid_619480 != nil:
    section.add "X-Amz-Security-Token", valid_619480
  var valid_619481 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619481 = validateParameter(valid_619481, JString, required = false,
                                 default = nil)
  if valid_619481 != nil:
    section.add "X-Amz-Content-Sha256", valid_619481
  var valid_619482 = header.getOrDefault("X-Amz-Algorithm")
  valid_619482 = validateParameter(valid_619482, JString, required = false,
                                 default = nil)
  if valid_619482 != nil:
    section.add "X-Amz-Algorithm", valid_619482
  var valid_619483 = header.getOrDefault("X-Amz-Signature")
  valid_619483 = validateParameter(valid_619483, JString, required = false,
                                 default = nil)
  if valid_619483 != nil:
    section.add "X-Amz-Signature", valid_619483
  var valid_619484 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619484 = validateParameter(valid_619484, JString, required = false,
                                 default = nil)
  if valid_619484 != nil:
    section.add "X-Amz-SignedHeaders", valid_619484
  var valid_619485 = header.getOrDefault("X-Amz-Credential")
  valid_619485 = validateParameter(valid_619485, JString, required = false,
                                 default = nil)
  if valid_619485 != nil:
    section.add "X-Amz-Credential", valid_619485
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619486: Call_GetDescribeResize_619473; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_619486.validator(path, query, header, formData, body, _)
  let scheme = call_619486.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619486.url(scheme.get, call_619486.host, call_619486.base,
                         call_619486.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619486, url, valid, _)

proc call*(call_619487: Call_GetDescribeResize_619473; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_619488 = newJObject()
  add(query_619488, "Action", newJString(Action))
  add(query_619488, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619488, "Version", newJString(Version))
  result = call_619487.call(nil, query_619488, nil, nil, nil)

var getDescribeResize* = Call_GetDescribeResize_619473(name: "getDescribeResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeResize", validator: validate_GetDescribeResize_619474,
    base: "/", url: url_GetDescribeResize_619475,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeScheduledActions_619529 = ref object of OpenApiRestCall_616850
proc url_PostDescribeScheduledActions_619531(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeScheduledActions_619530(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619532 = query.getOrDefault("Action")
  valid_619532 = validateParameter(valid_619532, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_619532 != nil:
    section.add "Action", valid_619532
  var valid_619533 = query.getOrDefault("Version")
  valid_619533 = validateParameter(valid_619533, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619533 != nil:
    section.add "Version", valid_619533
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619534 = header.getOrDefault("X-Amz-Date")
  valid_619534 = validateParameter(valid_619534, JString, required = false,
                                 default = nil)
  if valid_619534 != nil:
    section.add "X-Amz-Date", valid_619534
  var valid_619535 = header.getOrDefault("X-Amz-Security-Token")
  valid_619535 = validateParameter(valid_619535, JString, required = false,
                                 default = nil)
  if valid_619535 != nil:
    section.add "X-Amz-Security-Token", valid_619535
  var valid_619536 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619536 = validateParameter(valid_619536, JString, required = false,
                                 default = nil)
  if valid_619536 != nil:
    section.add "X-Amz-Content-Sha256", valid_619536
  var valid_619537 = header.getOrDefault("X-Amz-Algorithm")
  valid_619537 = validateParameter(valid_619537, JString, required = false,
                                 default = nil)
  if valid_619537 != nil:
    section.add "X-Amz-Algorithm", valid_619537
  var valid_619538 = header.getOrDefault("X-Amz-Signature")
  valid_619538 = validateParameter(valid_619538, JString, required = false,
                                 default = nil)
  if valid_619538 != nil:
    section.add "X-Amz-Signature", valid_619538
  var valid_619539 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619539 = validateParameter(valid_619539, JString, required = false,
                                 default = nil)
  if valid_619539 != nil:
    section.add "X-Amz-SignedHeaders", valid_619539
  var valid_619540 = header.getOrDefault("X-Amz-Credential")
  valid_619540 = validateParameter(valid_619540, JString, required = false,
                                 default = nil)
  if valid_619540 != nil:
    section.add "X-Amz-Credential", valid_619540
  result.add "header", section
  ## parameters in `formData` object:
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  section = newJObject()
  var valid_619541 = formData.getOrDefault("Active")
  valid_619541 = validateParameter(valid_619541, JBool, required = false, default = nil)
  if valid_619541 != nil:
    section.add "Active", valid_619541
  var valid_619542 = formData.getOrDefault("StartTime")
  valid_619542 = validateParameter(valid_619542, JString, required = false,
                                 default = nil)
  if valid_619542 != nil:
    section.add "StartTime", valid_619542
  var valid_619543 = formData.getOrDefault("ScheduledActionName")
  valid_619543 = validateParameter(valid_619543, JString, required = false,
                                 default = nil)
  if valid_619543 != nil:
    section.add "ScheduledActionName", valid_619543
  var valid_619544 = formData.getOrDefault("Filters")
  valid_619544 = validateParameter(valid_619544, JArray, required = false,
                                 default = nil)
  if valid_619544 != nil:
    section.add "Filters", valid_619544
  var valid_619545 = formData.getOrDefault("EndTime")
  valid_619545 = validateParameter(valid_619545, JString, required = false,
                                 default = nil)
  if valid_619545 != nil:
    section.add "EndTime", valid_619545
  var valid_619546 = formData.getOrDefault("Marker")
  valid_619546 = validateParameter(valid_619546, JString, required = false,
                                 default = nil)
  if valid_619546 != nil:
    section.add "Marker", valid_619546
  var valid_619547 = formData.getOrDefault("MaxRecords")
  valid_619547 = validateParameter(valid_619547, JInt, required = false, default = nil)
  if valid_619547 != nil:
    section.add "MaxRecords", valid_619547
  var valid_619548 = formData.getOrDefault("TargetActionType")
  valid_619548 = validateParameter(valid_619548, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_619548 != nil:
    section.add "TargetActionType", valid_619548
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619549: Call_PostDescribeScheduledActions_619529;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_619549.validator(path, query, header, formData, body, _)
  let scheme = call_619549.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619549.url(scheme.get, call_619549.host, call_619549.base,
                         call_619549.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619549, url, valid, _)

proc call*(call_619550: Call_PostDescribeScheduledActions_619529;
          Active: bool = false; StartTime: string = "";
          Action: string = "DescribeScheduledActions";
          ScheduledActionName: string = ""; Filters: JsonNode = nil;
          EndTime: string = ""; Marker: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"; TargetActionType: string = "ResizeCluster"): Recallable =
  ## postDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Action: string (required)
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  var query_619551 = newJObject()
  var formData_619552 = newJObject()
  add(formData_619552, "Active", newJBool(Active))
  add(formData_619552, "StartTime", newJString(StartTime))
  add(query_619551, "Action", newJString(Action))
  add(formData_619552, "ScheduledActionName", newJString(ScheduledActionName))
  if Filters != nil:
    formData_619552.add "Filters", Filters
  add(formData_619552, "EndTime", newJString(EndTime))
  add(formData_619552, "Marker", newJString(Marker))
  add(formData_619552, "MaxRecords", newJInt(MaxRecords))
  add(query_619551, "Version", newJString(Version))
  add(formData_619552, "TargetActionType", newJString(TargetActionType))
  result = call_619550.call(nil, query_619551, nil, formData_619552, nil)

var postDescribeScheduledActions* = Call_PostDescribeScheduledActions_619529(
    name: "postDescribeScheduledActions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_PostDescribeScheduledActions_619530, base: "/",
    url: url_PostDescribeScheduledActions_619531,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeScheduledActions_619506 = ref object of OpenApiRestCall_616850
proc url_GetDescribeScheduledActions_619508(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeScheduledActions_619507(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: JString (required)
  section = newJObject()
  var valid_619509 = query.getOrDefault("TargetActionType")
  valid_619509 = validateParameter(valid_619509, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_619509 != nil:
    section.add "TargetActionType", valid_619509
  var valid_619510 = query.getOrDefault("MaxRecords")
  valid_619510 = validateParameter(valid_619510, JInt, required = false, default = nil)
  if valid_619510 != nil:
    section.add "MaxRecords", valid_619510
  var valid_619511 = query.getOrDefault("ScheduledActionName")
  valid_619511 = validateParameter(valid_619511, JString, required = false,
                                 default = nil)
  if valid_619511 != nil:
    section.add "ScheduledActionName", valid_619511
  var valid_619512 = query.getOrDefault("StartTime")
  valid_619512 = validateParameter(valid_619512, JString, required = false,
                                 default = nil)
  if valid_619512 != nil:
    section.add "StartTime", valid_619512
  var valid_619513 = query.getOrDefault("Filters")
  valid_619513 = validateParameter(valid_619513, JArray, required = false,
                                 default = nil)
  if valid_619513 != nil:
    section.add "Filters", valid_619513
  var valid_619514 = query.getOrDefault("Action")
  valid_619514 = validateParameter(valid_619514, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_619514 != nil:
    section.add "Action", valid_619514
  var valid_619515 = query.getOrDefault("Marker")
  valid_619515 = validateParameter(valid_619515, JString, required = false,
                                 default = nil)
  if valid_619515 != nil:
    section.add "Marker", valid_619515
  var valid_619516 = query.getOrDefault("Active")
  valid_619516 = validateParameter(valid_619516, JBool, required = false, default = nil)
  if valid_619516 != nil:
    section.add "Active", valid_619516
  var valid_619517 = query.getOrDefault("EndTime")
  valid_619517 = validateParameter(valid_619517, JString, required = false,
                                 default = nil)
  if valid_619517 != nil:
    section.add "EndTime", valid_619517
  var valid_619518 = query.getOrDefault("Version")
  valid_619518 = validateParameter(valid_619518, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619518 != nil:
    section.add "Version", valid_619518
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619519 = header.getOrDefault("X-Amz-Date")
  valid_619519 = validateParameter(valid_619519, JString, required = false,
                                 default = nil)
  if valid_619519 != nil:
    section.add "X-Amz-Date", valid_619519
  var valid_619520 = header.getOrDefault("X-Amz-Security-Token")
  valid_619520 = validateParameter(valid_619520, JString, required = false,
                                 default = nil)
  if valid_619520 != nil:
    section.add "X-Amz-Security-Token", valid_619520
  var valid_619521 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619521 = validateParameter(valid_619521, JString, required = false,
                                 default = nil)
  if valid_619521 != nil:
    section.add "X-Amz-Content-Sha256", valid_619521
  var valid_619522 = header.getOrDefault("X-Amz-Algorithm")
  valid_619522 = validateParameter(valid_619522, JString, required = false,
                                 default = nil)
  if valid_619522 != nil:
    section.add "X-Amz-Algorithm", valid_619522
  var valid_619523 = header.getOrDefault("X-Amz-Signature")
  valid_619523 = validateParameter(valid_619523, JString, required = false,
                                 default = nil)
  if valid_619523 != nil:
    section.add "X-Amz-Signature", valid_619523
  var valid_619524 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619524 = validateParameter(valid_619524, JString, required = false,
                                 default = nil)
  if valid_619524 != nil:
    section.add "X-Amz-SignedHeaders", valid_619524
  var valid_619525 = header.getOrDefault("X-Amz-Credential")
  valid_619525 = validateParameter(valid_619525, JString, required = false,
                                 default = nil)
  if valid_619525 != nil:
    section.add "X-Amz-Credential", valid_619525
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619526: Call_GetDescribeScheduledActions_619506;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_619526.validator(path, query, header, formData, body, _)
  let scheme = call_619526.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619526.url(scheme.get, call_619526.host, call_619526.base,
                         call_619526.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619526, url, valid, _)

proc call*(call_619527: Call_GetDescribeScheduledActions_619506;
          TargetActionType: string = "ResizeCluster"; MaxRecords: int = 0;
          ScheduledActionName: string = ""; StartTime: string = "";
          Filters: JsonNode = nil; Action: string = "DescribeScheduledActions";
          Marker: string = ""; Active: bool = false; EndTime: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: string (required)
  var query_619528 = newJObject()
  add(query_619528, "TargetActionType", newJString(TargetActionType))
  add(query_619528, "MaxRecords", newJInt(MaxRecords))
  add(query_619528, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_619528, "StartTime", newJString(StartTime))
  if Filters != nil:
    query_619528.add "Filters", Filters
  add(query_619528, "Action", newJString(Action))
  add(query_619528, "Marker", newJString(Marker))
  add(query_619528, "Active", newJBool(Active))
  add(query_619528, "EndTime", newJString(EndTime))
  add(query_619528, "Version", newJString(Version))
  result = call_619527.call(nil, query_619528, nil, nil, nil)

var getDescribeScheduledActions* = Call_GetDescribeScheduledActions_619506(
    name: "getDescribeScheduledActions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_GetDescribeScheduledActions_619507, base: "/",
    url: url_GetDescribeScheduledActions_619508,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotCopyGrants_619573 = ref object of OpenApiRestCall_616850
proc url_PostDescribeSnapshotCopyGrants_619575(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotCopyGrants_619574(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619576 = query.getOrDefault("Action")
  valid_619576 = validateParameter(valid_619576, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_619576 != nil:
    section.add "Action", valid_619576
  var valid_619577 = query.getOrDefault("Version")
  valid_619577 = validateParameter(valid_619577, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619577 != nil:
    section.add "Version", valid_619577
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619578 = header.getOrDefault("X-Amz-Date")
  valid_619578 = validateParameter(valid_619578, JString, required = false,
                                 default = nil)
  if valid_619578 != nil:
    section.add "X-Amz-Date", valid_619578
  var valid_619579 = header.getOrDefault("X-Amz-Security-Token")
  valid_619579 = validateParameter(valid_619579, JString, required = false,
                                 default = nil)
  if valid_619579 != nil:
    section.add "X-Amz-Security-Token", valid_619579
  var valid_619580 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619580 = validateParameter(valid_619580, JString, required = false,
                                 default = nil)
  if valid_619580 != nil:
    section.add "X-Amz-Content-Sha256", valid_619580
  var valid_619581 = header.getOrDefault("X-Amz-Algorithm")
  valid_619581 = validateParameter(valid_619581, JString, required = false,
                                 default = nil)
  if valid_619581 != nil:
    section.add "X-Amz-Algorithm", valid_619581
  var valid_619582 = header.getOrDefault("X-Amz-Signature")
  valid_619582 = validateParameter(valid_619582, JString, required = false,
                                 default = nil)
  if valid_619582 != nil:
    section.add "X-Amz-Signature", valid_619582
  var valid_619583 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619583 = validateParameter(valid_619583, JString, required = false,
                                 default = nil)
  if valid_619583 != nil:
    section.add "X-Amz-SignedHeaders", valid_619583
  var valid_619584 = header.getOrDefault("X-Amz-Credential")
  valid_619584 = validateParameter(valid_619584, JString, required = false,
                                 default = nil)
  if valid_619584 != nil:
    section.add "X-Amz-Credential", valid_619584
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_619585 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_619585 = validateParameter(valid_619585, JString, required = false,
                                 default = nil)
  if valid_619585 != nil:
    section.add "SnapshotCopyGrantName", valid_619585
  var valid_619586 = formData.getOrDefault("TagKeys")
  valid_619586 = validateParameter(valid_619586, JArray, required = false,
                                 default = nil)
  if valid_619586 != nil:
    section.add "TagKeys", valid_619586
  var valid_619587 = formData.getOrDefault("Marker")
  valid_619587 = validateParameter(valid_619587, JString, required = false,
                                 default = nil)
  if valid_619587 != nil:
    section.add "Marker", valid_619587
  var valid_619588 = formData.getOrDefault("MaxRecords")
  valid_619588 = validateParameter(valid_619588, JInt, required = false, default = nil)
  if valid_619588 != nil:
    section.add "MaxRecords", valid_619588
  var valid_619589 = formData.getOrDefault("TagValues")
  valid_619589 = validateParameter(valid_619589, JArray, required = false,
                                 default = nil)
  if valid_619589 != nil:
    section.add "TagValues", valid_619589
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619590: Call_PostDescribeSnapshotCopyGrants_619573;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_619590.validator(path, query, header, formData, body, _)
  let scheme = call_619590.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619590.url(scheme.get, call_619590.host, call_619590.base,
                         call_619590.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619590, url, valid, _)

proc call*(call_619591: Call_PostDescribeSnapshotCopyGrants_619573;
          Action: string = "DescribeSnapshotCopyGrants";
          SnapshotCopyGrantName: string = ""; TagKeys: JsonNode = nil;
          Marker: string = ""; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_619592 = newJObject()
  var formData_619593 = newJObject()
  add(query_619592, "Action", newJString(Action))
  add(formData_619593, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  if TagKeys != nil:
    formData_619593.add "TagKeys", TagKeys
  add(formData_619593, "Marker", newJString(Marker))
  add(formData_619593, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_619593.add "TagValues", TagValues
  add(query_619592, "Version", newJString(Version))
  result = call_619591.call(nil, query_619592, nil, formData_619593, nil)

var postDescribeSnapshotCopyGrants* = Call_PostDescribeSnapshotCopyGrants_619573(
    name: "postDescribeSnapshotCopyGrants", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_PostDescribeSnapshotCopyGrants_619574, base: "/",
    url: url_PostDescribeSnapshotCopyGrants_619575,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotCopyGrants_619553 = ref object of OpenApiRestCall_616850
proc url_GetDescribeSnapshotCopyGrants_619555(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotCopyGrants_619554(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_619556 = query.getOrDefault("TagValues")
  valid_619556 = validateParameter(valid_619556, JArray, required = false,
                                 default = nil)
  if valid_619556 != nil:
    section.add "TagValues", valid_619556
  var valid_619557 = query.getOrDefault("MaxRecords")
  valid_619557 = validateParameter(valid_619557, JInt, required = false, default = nil)
  if valid_619557 != nil:
    section.add "MaxRecords", valid_619557
  var valid_619558 = query.getOrDefault("Action")
  valid_619558 = validateParameter(valid_619558, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_619558 != nil:
    section.add "Action", valid_619558
  var valid_619559 = query.getOrDefault("Marker")
  valid_619559 = validateParameter(valid_619559, JString, required = false,
                                 default = nil)
  if valid_619559 != nil:
    section.add "Marker", valid_619559
  var valid_619560 = query.getOrDefault("SnapshotCopyGrantName")
  valid_619560 = validateParameter(valid_619560, JString, required = false,
                                 default = nil)
  if valid_619560 != nil:
    section.add "SnapshotCopyGrantName", valid_619560
  var valid_619561 = query.getOrDefault("TagKeys")
  valid_619561 = validateParameter(valid_619561, JArray, required = false,
                                 default = nil)
  if valid_619561 != nil:
    section.add "TagKeys", valid_619561
  var valid_619562 = query.getOrDefault("Version")
  valid_619562 = validateParameter(valid_619562, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619562 != nil:
    section.add "Version", valid_619562
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619563 = header.getOrDefault("X-Amz-Date")
  valid_619563 = validateParameter(valid_619563, JString, required = false,
                                 default = nil)
  if valid_619563 != nil:
    section.add "X-Amz-Date", valid_619563
  var valid_619564 = header.getOrDefault("X-Amz-Security-Token")
  valid_619564 = validateParameter(valid_619564, JString, required = false,
                                 default = nil)
  if valid_619564 != nil:
    section.add "X-Amz-Security-Token", valid_619564
  var valid_619565 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619565 = validateParameter(valid_619565, JString, required = false,
                                 default = nil)
  if valid_619565 != nil:
    section.add "X-Amz-Content-Sha256", valid_619565
  var valid_619566 = header.getOrDefault("X-Amz-Algorithm")
  valid_619566 = validateParameter(valid_619566, JString, required = false,
                                 default = nil)
  if valid_619566 != nil:
    section.add "X-Amz-Algorithm", valid_619566
  var valid_619567 = header.getOrDefault("X-Amz-Signature")
  valid_619567 = validateParameter(valid_619567, JString, required = false,
                                 default = nil)
  if valid_619567 != nil:
    section.add "X-Amz-Signature", valid_619567
  var valid_619568 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619568 = validateParameter(valid_619568, JString, required = false,
                                 default = nil)
  if valid_619568 != nil:
    section.add "X-Amz-SignedHeaders", valid_619568
  var valid_619569 = header.getOrDefault("X-Amz-Credential")
  valid_619569 = validateParameter(valid_619569, JString, required = false,
                                 default = nil)
  if valid_619569 != nil:
    section.add "X-Amz-Credential", valid_619569
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619570: Call_GetDescribeSnapshotCopyGrants_619553;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_619570.validator(path, query, header, formData, body, _)
  let scheme = call_619570.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619570.url(scheme.get, call_619570.host, call_619570.base,
                         call_619570.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619570, url, valid, _)

proc call*(call_619571: Call_GetDescribeSnapshotCopyGrants_619553;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeSnapshotCopyGrants"; Marker: string = "";
          SnapshotCopyGrantName: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_619572 = newJObject()
  if TagValues != nil:
    query_619572.add "TagValues", TagValues
  add(query_619572, "MaxRecords", newJInt(MaxRecords))
  add(query_619572, "Action", newJString(Action))
  add(query_619572, "Marker", newJString(Marker))
  add(query_619572, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  if TagKeys != nil:
    query_619572.add "TagKeys", TagKeys
  add(query_619572, "Version", newJString(Version))
  result = call_619571.call(nil, query_619572, nil, nil, nil)

var getDescribeSnapshotCopyGrants* = Call_GetDescribeSnapshotCopyGrants_619553(
    name: "getDescribeSnapshotCopyGrants", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_GetDescribeSnapshotCopyGrants_619554, base: "/",
    url: url_GetDescribeSnapshotCopyGrants_619555,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotSchedules_619615 = ref object of OpenApiRestCall_616850
proc url_PostDescribeSnapshotSchedules_619617(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotSchedules_619616(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619618 = query.getOrDefault("Action")
  valid_619618 = validateParameter(valid_619618, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_619618 != nil:
    section.add "Action", valid_619618
  var valid_619619 = query.getOrDefault("Version")
  valid_619619 = validateParameter(valid_619619, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619619 != nil:
    section.add "Version", valid_619619
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619620 = header.getOrDefault("X-Amz-Date")
  valid_619620 = validateParameter(valid_619620, JString, required = false,
                                 default = nil)
  if valid_619620 != nil:
    section.add "X-Amz-Date", valid_619620
  var valid_619621 = header.getOrDefault("X-Amz-Security-Token")
  valid_619621 = validateParameter(valid_619621, JString, required = false,
                                 default = nil)
  if valid_619621 != nil:
    section.add "X-Amz-Security-Token", valid_619621
  var valid_619622 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619622 = validateParameter(valid_619622, JString, required = false,
                                 default = nil)
  if valid_619622 != nil:
    section.add "X-Amz-Content-Sha256", valid_619622
  var valid_619623 = header.getOrDefault("X-Amz-Algorithm")
  valid_619623 = validateParameter(valid_619623, JString, required = false,
                                 default = nil)
  if valid_619623 != nil:
    section.add "X-Amz-Algorithm", valid_619623
  var valid_619624 = header.getOrDefault("X-Amz-Signature")
  valid_619624 = validateParameter(valid_619624, JString, required = false,
                                 default = nil)
  if valid_619624 != nil:
    section.add "X-Amz-Signature", valid_619624
  var valid_619625 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619625 = validateParameter(valid_619625, JString, required = false,
                                 default = nil)
  if valid_619625 != nil:
    section.add "X-Amz-SignedHeaders", valid_619625
  var valid_619626 = header.getOrDefault("X-Amz-Credential")
  valid_619626 = validateParameter(valid_619626, JString, required = false,
                                 default = nil)
  if valid_619626 != nil:
    section.add "X-Amz-Credential", valid_619626
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  section = newJObject()
  var valid_619627 = formData.getOrDefault("ClusterIdentifier")
  valid_619627 = validateParameter(valid_619627, JString, required = false,
                                 default = nil)
  if valid_619627 != nil:
    section.add "ClusterIdentifier", valid_619627
  var valid_619628 = formData.getOrDefault("ScheduleIdentifier")
  valid_619628 = validateParameter(valid_619628, JString, required = false,
                                 default = nil)
  if valid_619628 != nil:
    section.add "ScheduleIdentifier", valid_619628
  var valid_619629 = formData.getOrDefault("TagKeys")
  valid_619629 = validateParameter(valid_619629, JArray, required = false,
                                 default = nil)
  if valid_619629 != nil:
    section.add "TagKeys", valid_619629
  var valid_619630 = formData.getOrDefault("Marker")
  valid_619630 = validateParameter(valid_619630, JString, required = false,
                                 default = nil)
  if valid_619630 != nil:
    section.add "Marker", valid_619630
  var valid_619631 = formData.getOrDefault("MaxRecords")
  valid_619631 = validateParameter(valid_619631, JInt, required = false, default = nil)
  if valid_619631 != nil:
    section.add "MaxRecords", valid_619631
  var valid_619632 = formData.getOrDefault("TagValues")
  valid_619632 = validateParameter(valid_619632, JArray, required = false,
                                 default = nil)
  if valid_619632 != nil:
    section.add "TagValues", valid_619632
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619633: Call_PostDescribeSnapshotSchedules_619615;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_619633.validator(path, query, header, formData, body, _)
  let scheme = call_619633.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619633.url(scheme.get, call_619633.host, call_619633.base,
                         call_619633.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619633, url, valid, _)

proc call*(call_619634: Call_PostDescribeSnapshotSchedules_619615;
          Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; ScheduleIdentifier: string = "";
          TagKeys: JsonNode = nil; Marker: string = ""; MaxRecords: int = 0;
          TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   Version: string (required)
  var query_619635 = newJObject()
  var formData_619636 = newJObject()
  add(query_619635, "Action", newJString(Action))
  add(formData_619636, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_619636, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if TagKeys != nil:
    formData_619636.add "TagKeys", TagKeys
  add(formData_619636, "Marker", newJString(Marker))
  add(formData_619636, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_619636.add "TagValues", TagValues
  add(query_619635, "Version", newJString(Version))
  result = call_619634.call(nil, query_619635, nil, formData_619636, nil)

var postDescribeSnapshotSchedules* = Call_PostDescribeSnapshotSchedules_619615(
    name: "postDescribeSnapshotSchedules", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_PostDescribeSnapshotSchedules_619616, base: "/",
    url: url_PostDescribeSnapshotSchedules_619617,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotSchedules_619594 = ref object of OpenApiRestCall_616850
proc url_GetDescribeSnapshotSchedules_619596(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotSchedules_619595(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Version: JString (required)
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  section = newJObject()
  var valid_619597 = query.getOrDefault("TagValues")
  valid_619597 = validateParameter(valid_619597, JArray, required = false,
                                 default = nil)
  if valid_619597 != nil:
    section.add "TagValues", valid_619597
  var valid_619598 = query.getOrDefault("MaxRecords")
  valid_619598 = validateParameter(valid_619598, JInt, required = false, default = nil)
  if valid_619598 != nil:
    section.add "MaxRecords", valid_619598
  var valid_619599 = query.getOrDefault("Action")
  valid_619599 = validateParameter(valid_619599, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_619599 != nil:
    section.add "Action", valid_619599
  var valid_619600 = query.getOrDefault("ClusterIdentifier")
  valid_619600 = validateParameter(valid_619600, JString, required = false,
                                 default = nil)
  if valid_619600 != nil:
    section.add "ClusterIdentifier", valid_619600
  var valid_619601 = query.getOrDefault("Marker")
  valid_619601 = validateParameter(valid_619601, JString, required = false,
                                 default = nil)
  if valid_619601 != nil:
    section.add "Marker", valid_619601
  var valid_619602 = query.getOrDefault("TagKeys")
  valid_619602 = validateParameter(valid_619602, JArray, required = false,
                                 default = nil)
  if valid_619602 != nil:
    section.add "TagKeys", valid_619602
  var valid_619603 = query.getOrDefault("Version")
  valid_619603 = validateParameter(valid_619603, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619603 != nil:
    section.add "Version", valid_619603
  var valid_619604 = query.getOrDefault("ScheduleIdentifier")
  valid_619604 = validateParameter(valid_619604, JString, required = false,
                                 default = nil)
  if valid_619604 != nil:
    section.add "ScheduleIdentifier", valid_619604
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619605 = header.getOrDefault("X-Amz-Date")
  valid_619605 = validateParameter(valid_619605, JString, required = false,
                                 default = nil)
  if valid_619605 != nil:
    section.add "X-Amz-Date", valid_619605
  var valid_619606 = header.getOrDefault("X-Amz-Security-Token")
  valid_619606 = validateParameter(valid_619606, JString, required = false,
                                 default = nil)
  if valid_619606 != nil:
    section.add "X-Amz-Security-Token", valid_619606
  var valid_619607 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619607 = validateParameter(valid_619607, JString, required = false,
                                 default = nil)
  if valid_619607 != nil:
    section.add "X-Amz-Content-Sha256", valid_619607
  var valid_619608 = header.getOrDefault("X-Amz-Algorithm")
  valid_619608 = validateParameter(valid_619608, JString, required = false,
                                 default = nil)
  if valid_619608 != nil:
    section.add "X-Amz-Algorithm", valid_619608
  var valid_619609 = header.getOrDefault("X-Amz-Signature")
  valid_619609 = validateParameter(valid_619609, JString, required = false,
                                 default = nil)
  if valid_619609 != nil:
    section.add "X-Amz-Signature", valid_619609
  var valid_619610 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619610 = validateParameter(valid_619610, JString, required = false,
                                 default = nil)
  if valid_619610 != nil:
    section.add "X-Amz-SignedHeaders", valid_619610
  var valid_619611 = header.getOrDefault("X-Amz-Credential")
  valid_619611 = validateParameter(valid_619611, JString, required = false,
                                 default = nil)
  if valid_619611 != nil:
    section.add "X-Amz-Credential", valid_619611
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619612: Call_GetDescribeSnapshotSchedules_619594;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_619612.validator(path, query, header, formData, body, _)
  let scheme = call_619612.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619612.url(scheme.get, call_619612.host, call_619612.base,
                         call_619612.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619612, url, valid, _)

proc call*(call_619613: Call_GetDescribeSnapshotSchedules_619594;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; Marker: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"; ScheduleIdentifier: string = ""): Recallable =
  ## getDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Version: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  var query_619614 = newJObject()
  if TagValues != nil:
    query_619614.add "TagValues", TagValues
  add(query_619614, "MaxRecords", newJInt(MaxRecords))
  add(query_619614, "Action", newJString(Action))
  add(query_619614, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619614, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_619614.add "TagKeys", TagKeys
  add(query_619614, "Version", newJString(Version))
  add(query_619614, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  result = call_619613.call(nil, query_619614, nil, nil, nil)

var getDescribeSnapshotSchedules* = Call_GetDescribeSnapshotSchedules_619594(
    name: "getDescribeSnapshotSchedules", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_GetDescribeSnapshotSchedules_619595, base: "/",
    url: url_GetDescribeSnapshotSchedules_619596,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeStorage_619652 = ref object of OpenApiRestCall_616850
proc url_PostDescribeStorage_619654(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeStorage_619653(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode; _: string = ""): JsonNode =
  ## Returns account level backups storage size and provisional storage.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619655 = query.getOrDefault("Action")
  valid_619655 = validateParameter(valid_619655, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_619655 != nil:
    section.add "Action", valid_619655
  var valid_619656 = query.getOrDefault("Version")
  valid_619656 = validateParameter(valid_619656, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619656 != nil:
    section.add "Version", valid_619656
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619657 = header.getOrDefault("X-Amz-Date")
  valid_619657 = validateParameter(valid_619657, JString, required = false,
                                 default = nil)
  if valid_619657 != nil:
    section.add "X-Amz-Date", valid_619657
  var valid_619658 = header.getOrDefault("X-Amz-Security-Token")
  valid_619658 = validateParameter(valid_619658, JString, required = false,
                                 default = nil)
  if valid_619658 != nil:
    section.add "X-Amz-Security-Token", valid_619658
  var valid_619659 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619659 = validateParameter(valid_619659, JString, required = false,
                                 default = nil)
  if valid_619659 != nil:
    section.add "X-Amz-Content-Sha256", valid_619659
  var valid_619660 = header.getOrDefault("X-Amz-Algorithm")
  valid_619660 = validateParameter(valid_619660, JString, required = false,
                                 default = nil)
  if valid_619660 != nil:
    section.add "X-Amz-Algorithm", valid_619660
  var valid_619661 = header.getOrDefault("X-Amz-Signature")
  valid_619661 = validateParameter(valid_619661, JString, required = false,
                                 default = nil)
  if valid_619661 != nil:
    section.add "X-Amz-Signature", valid_619661
  var valid_619662 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619662 = validateParameter(valid_619662, JString, required = false,
                                 default = nil)
  if valid_619662 != nil:
    section.add "X-Amz-SignedHeaders", valid_619662
  var valid_619663 = header.getOrDefault("X-Amz-Credential")
  valid_619663 = validateParameter(valid_619663, JString, required = false,
                                 default = nil)
  if valid_619663 != nil:
    section.add "X-Amz-Credential", valid_619663
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619664: Call_PostDescribeStorage_619652; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns account level backups storage size and provisional storage.
  ## 
  let valid = call_619664.validator(path, query, header, formData, body, _)
  let scheme = call_619664.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619664.url(scheme.get, call_619664.host, call_619664.base,
                         call_619664.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619664, url, valid, _)

proc call*(call_619665: Call_PostDescribeStorage_619652;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeStorage
  ## Returns account level backups storage size and provisional storage.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_619666 = newJObject()
  add(query_619666, "Action", newJString(Action))
  add(query_619666, "Version", newJString(Version))
  result = call_619665.call(nil, query_619666, nil, nil, nil)

var postDescribeStorage* = Call_PostDescribeStorage_619652(
    name: "postDescribeStorage", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_PostDescribeStorage_619653, base: "/",
    url: url_PostDescribeStorage_619654, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeStorage_619637 = ref object of OpenApiRestCall_616850
proc url_GetDescribeStorage_619639(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeStorage_619638(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode =
  ## Returns account level backups storage size and provisional storage.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619640 = query.getOrDefault("Action")
  valid_619640 = validateParameter(valid_619640, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_619640 != nil:
    section.add "Action", valid_619640
  var valid_619641 = query.getOrDefault("Version")
  valid_619641 = validateParameter(valid_619641, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619641 != nil:
    section.add "Version", valid_619641
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619642 = header.getOrDefault("X-Amz-Date")
  valid_619642 = validateParameter(valid_619642, JString, required = false,
                                 default = nil)
  if valid_619642 != nil:
    section.add "X-Amz-Date", valid_619642
  var valid_619643 = header.getOrDefault("X-Amz-Security-Token")
  valid_619643 = validateParameter(valid_619643, JString, required = false,
                                 default = nil)
  if valid_619643 != nil:
    section.add "X-Amz-Security-Token", valid_619643
  var valid_619644 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619644 = validateParameter(valid_619644, JString, required = false,
                                 default = nil)
  if valid_619644 != nil:
    section.add "X-Amz-Content-Sha256", valid_619644
  var valid_619645 = header.getOrDefault("X-Amz-Algorithm")
  valid_619645 = validateParameter(valid_619645, JString, required = false,
                                 default = nil)
  if valid_619645 != nil:
    section.add "X-Amz-Algorithm", valid_619645
  var valid_619646 = header.getOrDefault("X-Amz-Signature")
  valid_619646 = validateParameter(valid_619646, JString, required = false,
                                 default = nil)
  if valid_619646 != nil:
    section.add "X-Amz-Signature", valid_619646
  var valid_619647 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619647 = validateParameter(valid_619647, JString, required = false,
                                 default = nil)
  if valid_619647 != nil:
    section.add "X-Amz-SignedHeaders", valid_619647
  var valid_619648 = header.getOrDefault("X-Amz-Credential")
  valid_619648 = validateParameter(valid_619648, JString, required = false,
                                 default = nil)
  if valid_619648 != nil:
    section.add "X-Amz-Credential", valid_619648
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619649: Call_GetDescribeStorage_619637; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns account level backups storage size and provisional storage.
  ## 
  let valid = call_619649.validator(path, query, header, formData, body, _)
  let scheme = call_619649.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619649.url(scheme.get, call_619649.host, call_619649.base,
                         call_619649.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619649, url, valid, _)

proc call*(call_619650: Call_GetDescribeStorage_619637;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeStorage
  ## Returns account level backups storage size and provisional storage.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_619651 = newJObject()
  add(query_619651, "Action", newJString(Action))
  add(query_619651, "Version", newJString(Version))
  result = call_619650.call(nil, query_619651, nil, nil, nil)

var getDescribeStorage* = Call_GetDescribeStorage_619637(
    name: "getDescribeStorage", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_GetDescribeStorage_619638, base: "/",
    url: url_GetDescribeStorage_619639, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTableRestoreStatus_619686 = ref object of OpenApiRestCall_616850
proc url_PostDescribeTableRestoreStatus_619688(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTableRestoreStatus_619687(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619689 = query.getOrDefault("Action")
  valid_619689 = validateParameter(valid_619689, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_619689 != nil:
    section.add "Action", valid_619689
  var valid_619690 = query.getOrDefault("Version")
  valid_619690 = validateParameter(valid_619690, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619690 != nil:
    section.add "Version", valid_619690
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619691 = header.getOrDefault("X-Amz-Date")
  valid_619691 = validateParameter(valid_619691, JString, required = false,
                                 default = nil)
  if valid_619691 != nil:
    section.add "X-Amz-Date", valid_619691
  var valid_619692 = header.getOrDefault("X-Amz-Security-Token")
  valid_619692 = validateParameter(valid_619692, JString, required = false,
                                 default = nil)
  if valid_619692 != nil:
    section.add "X-Amz-Security-Token", valid_619692
  var valid_619693 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619693 = validateParameter(valid_619693, JString, required = false,
                                 default = nil)
  if valid_619693 != nil:
    section.add "X-Amz-Content-Sha256", valid_619693
  var valid_619694 = header.getOrDefault("X-Amz-Algorithm")
  valid_619694 = validateParameter(valid_619694, JString, required = false,
                                 default = nil)
  if valid_619694 != nil:
    section.add "X-Amz-Algorithm", valid_619694
  var valid_619695 = header.getOrDefault("X-Amz-Signature")
  valid_619695 = validateParameter(valid_619695, JString, required = false,
                                 default = nil)
  if valid_619695 != nil:
    section.add "X-Amz-Signature", valid_619695
  var valid_619696 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619696 = validateParameter(valid_619696, JString, required = false,
                                 default = nil)
  if valid_619696 != nil:
    section.add "X-Amz-SignedHeaders", valid_619696
  var valid_619697 = header.getOrDefault("X-Amz-Credential")
  valid_619697 = validateParameter(valid_619697, JString, required = false,
                                 default = nil)
  if valid_619697 != nil:
    section.add "X-Amz-Credential", valid_619697
  result.add "header", section
  ## parameters in `formData` object:
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  section = newJObject()
  var valid_619698 = formData.getOrDefault("TableRestoreRequestId")
  valid_619698 = validateParameter(valid_619698, JString, required = false,
                                 default = nil)
  if valid_619698 != nil:
    section.add "TableRestoreRequestId", valid_619698
  var valid_619699 = formData.getOrDefault("ClusterIdentifier")
  valid_619699 = validateParameter(valid_619699, JString, required = false,
                                 default = nil)
  if valid_619699 != nil:
    section.add "ClusterIdentifier", valid_619699
  var valid_619700 = formData.getOrDefault("Marker")
  valid_619700 = validateParameter(valid_619700, JString, required = false,
                                 default = nil)
  if valid_619700 != nil:
    section.add "Marker", valid_619700
  var valid_619701 = formData.getOrDefault("MaxRecords")
  valid_619701 = validateParameter(valid_619701, JInt, required = false, default = nil)
  if valid_619701 != nil:
    section.add "MaxRecords", valid_619701
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619702: Call_PostDescribeTableRestoreStatus_619686;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_619702.validator(path, query, header, formData, body, _)
  let scheme = call_619702.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619702.url(scheme.get, call_619702.host, call_619702.base,
                         call_619702.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619702, url, valid, _)

proc call*(call_619703: Call_PostDescribeTableRestoreStatus_619686;
          TableRestoreRequestId: string = "";
          Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; Marker: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Version: string (required)
  var query_619704 = newJObject()
  var formData_619705 = newJObject()
  add(formData_619705, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(query_619704, "Action", newJString(Action))
  add(formData_619705, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_619705, "Marker", newJString(Marker))
  add(formData_619705, "MaxRecords", newJInt(MaxRecords))
  add(query_619704, "Version", newJString(Version))
  result = call_619703.call(nil, query_619704, nil, formData_619705, nil)

var postDescribeTableRestoreStatus* = Call_PostDescribeTableRestoreStatus_619686(
    name: "postDescribeTableRestoreStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_PostDescribeTableRestoreStatus_619687, base: "/",
    url: url_PostDescribeTableRestoreStatus_619688,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTableRestoreStatus_619667 = ref object of OpenApiRestCall_616850
proc url_GetDescribeTableRestoreStatus_619669(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTableRestoreStatus_619668(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Version: JString (required)
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  section = newJObject()
  var valid_619670 = query.getOrDefault("MaxRecords")
  valid_619670 = validateParameter(valid_619670, JInt, required = false, default = nil)
  if valid_619670 != nil:
    section.add "MaxRecords", valid_619670
  var valid_619671 = query.getOrDefault("Action")
  valid_619671 = validateParameter(valid_619671, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_619671 != nil:
    section.add "Action", valid_619671
  var valid_619672 = query.getOrDefault("ClusterIdentifier")
  valid_619672 = validateParameter(valid_619672, JString, required = false,
                                 default = nil)
  if valid_619672 != nil:
    section.add "ClusterIdentifier", valid_619672
  var valid_619673 = query.getOrDefault("Marker")
  valid_619673 = validateParameter(valid_619673, JString, required = false,
                                 default = nil)
  if valid_619673 != nil:
    section.add "Marker", valid_619673
  var valid_619674 = query.getOrDefault("Version")
  valid_619674 = validateParameter(valid_619674, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619674 != nil:
    section.add "Version", valid_619674
  var valid_619675 = query.getOrDefault("TableRestoreRequestId")
  valid_619675 = validateParameter(valid_619675, JString, required = false,
                                 default = nil)
  if valid_619675 != nil:
    section.add "TableRestoreRequestId", valid_619675
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619676 = header.getOrDefault("X-Amz-Date")
  valid_619676 = validateParameter(valid_619676, JString, required = false,
                                 default = nil)
  if valid_619676 != nil:
    section.add "X-Amz-Date", valid_619676
  var valid_619677 = header.getOrDefault("X-Amz-Security-Token")
  valid_619677 = validateParameter(valid_619677, JString, required = false,
                                 default = nil)
  if valid_619677 != nil:
    section.add "X-Amz-Security-Token", valid_619677
  var valid_619678 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619678 = validateParameter(valid_619678, JString, required = false,
                                 default = nil)
  if valid_619678 != nil:
    section.add "X-Amz-Content-Sha256", valid_619678
  var valid_619679 = header.getOrDefault("X-Amz-Algorithm")
  valid_619679 = validateParameter(valid_619679, JString, required = false,
                                 default = nil)
  if valid_619679 != nil:
    section.add "X-Amz-Algorithm", valid_619679
  var valid_619680 = header.getOrDefault("X-Amz-Signature")
  valid_619680 = validateParameter(valid_619680, JString, required = false,
                                 default = nil)
  if valid_619680 != nil:
    section.add "X-Amz-Signature", valid_619680
  var valid_619681 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619681 = validateParameter(valid_619681, JString, required = false,
                                 default = nil)
  if valid_619681 != nil:
    section.add "X-Amz-SignedHeaders", valid_619681
  var valid_619682 = header.getOrDefault("X-Amz-Credential")
  valid_619682 = validateParameter(valid_619682, JString, required = false,
                                 default = nil)
  if valid_619682 != nil:
    section.add "X-Amz-Credential", valid_619682
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619683: Call_GetDescribeTableRestoreStatus_619667;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_619683.validator(path, query, header, formData, body, _)
  let scheme = call_619683.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619683.url(scheme.get, call_619683.host, call_619683.base,
                         call_619683.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619683, url, valid, _)

proc call*(call_619684: Call_GetDescribeTableRestoreStatus_619667;
          MaxRecords: int = 0; Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; Marker: string = "";
          Version: string = "2012-12-01"; TableRestoreRequestId: string = ""): Recallable =
  ## getDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Version: string (required)
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  var query_619685 = newJObject()
  add(query_619685, "MaxRecords", newJInt(MaxRecords))
  add(query_619685, "Action", newJString(Action))
  add(query_619685, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619685, "Marker", newJString(Marker))
  add(query_619685, "Version", newJString(Version))
  add(query_619685, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  result = call_619684.call(nil, query_619685, nil, nil, nil)

var getDescribeTableRestoreStatus* = Call_GetDescribeTableRestoreStatus_619667(
    name: "getDescribeTableRestoreStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_GetDescribeTableRestoreStatus_619668, base: "/",
    url: url_GetDescribeTableRestoreStatus_619669,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTags_619727 = ref object of OpenApiRestCall_616850
proc url_PostDescribeTags_619729(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTags_619728(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619730 = query.getOrDefault("Action")
  valid_619730 = validateParameter(valid_619730, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_619730 != nil:
    section.add "Action", valid_619730
  var valid_619731 = query.getOrDefault("Version")
  valid_619731 = validateParameter(valid_619731, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619731 != nil:
    section.add "Version", valid_619731
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619732 = header.getOrDefault("X-Amz-Date")
  valid_619732 = validateParameter(valid_619732, JString, required = false,
                                 default = nil)
  if valid_619732 != nil:
    section.add "X-Amz-Date", valid_619732
  var valid_619733 = header.getOrDefault("X-Amz-Security-Token")
  valid_619733 = validateParameter(valid_619733, JString, required = false,
                                 default = nil)
  if valid_619733 != nil:
    section.add "X-Amz-Security-Token", valid_619733
  var valid_619734 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619734 = validateParameter(valid_619734, JString, required = false,
                                 default = nil)
  if valid_619734 != nil:
    section.add "X-Amz-Content-Sha256", valid_619734
  var valid_619735 = header.getOrDefault("X-Amz-Algorithm")
  valid_619735 = validateParameter(valid_619735, JString, required = false,
                                 default = nil)
  if valid_619735 != nil:
    section.add "X-Amz-Algorithm", valid_619735
  var valid_619736 = header.getOrDefault("X-Amz-Signature")
  valid_619736 = validateParameter(valid_619736, JString, required = false,
                                 default = nil)
  if valid_619736 != nil:
    section.add "X-Amz-Signature", valid_619736
  var valid_619737 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619737 = validateParameter(valid_619737, JString, required = false,
                                 default = nil)
  if valid_619737 != nil:
    section.add "X-Amz-SignedHeaders", valid_619737
  var valid_619738 = header.getOrDefault("X-Amz-Credential")
  valid_619738 = validateParameter(valid_619738, JString, required = false,
                                 default = nil)
  if valid_619738 != nil:
    section.add "X-Amz-Credential", valid_619738
  result.add "header", section
  ## parameters in `formData` object:
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_619739 = formData.getOrDefault("ResourceType")
  valid_619739 = validateParameter(valid_619739, JString, required = false,
                                 default = nil)
  if valid_619739 != nil:
    section.add "ResourceType", valid_619739
  var valid_619740 = formData.getOrDefault("TagKeys")
  valid_619740 = validateParameter(valid_619740, JArray, required = false,
                                 default = nil)
  if valid_619740 != nil:
    section.add "TagKeys", valid_619740
  var valid_619741 = formData.getOrDefault("ResourceName")
  valid_619741 = validateParameter(valid_619741, JString, required = false,
                                 default = nil)
  if valid_619741 != nil:
    section.add "ResourceName", valid_619741
  var valid_619742 = formData.getOrDefault("Marker")
  valid_619742 = validateParameter(valid_619742, JString, required = false,
                                 default = nil)
  if valid_619742 != nil:
    section.add "Marker", valid_619742
  var valid_619743 = formData.getOrDefault("MaxRecords")
  valid_619743 = validateParameter(valid_619743, JInt, required = false, default = nil)
  if valid_619743 != nil:
    section.add "MaxRecords", valid_619743
  var valid_619744 = formData.getOrDefault("TagValues")
  valid_619744 = validateParameter(valid_619744, JArray, required = false,
                                 default = nil)
  if valid_619744 != nil:
    section.add "TagValues", valid_619744
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619745: Call_PostDescribeTags_619727; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_619745.validator(path, query, header, formData, body, _)
  let scheme = call_619745.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619745.url(scheme.get, call_619745.host, call_619745.base,
                         call_619745.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619745, url, valid, _)

proc call*(call_619746: Call_PostDescribeTags_619727;
          Action: string = "DescribeTags"; ResourceType: string = "";
          TagKeys: JsonNode = nil; ResourceName: string = ""; Marker: string = "";
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Action: string (required)
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_619747 = newJObject()
  var formData_619748 = newJObject()
  add(query_619747, "Action", newJString(Action))
  add(formData_619748, "ResourceType", newJString(ResourceType))
  if TagKeys != nil:
    formData_619748.add "TagKeys", TagKeys
  add(formData_619748, "ResourceName", newJString(ResourceName))
  add(formData_619748, "Marker", newJString(Marker))
  add(formData_619748, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_619748.add "TagValues", TagValues
  add(query_619747, "Version", newJString(Version))
  result = call_619746.call(nil, query_619747, nil, formData_619748, nil)

var postDescribeTags* = Call_PostDescribeTags_619727(name: "postDescribeTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_PostDescribeTags_619728,
    base: "/", url: url_PostDescribeTags_619729,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTags_619706 = ref object of OpenApiRestCall_616850
proc url_GetDescribeTags_619708(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTags_619707(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_619709 = query.getOrDefault("TagValues")
  valid_619709 = validateParameter(valid_619709, JArray, required = false,
                                 default = nil)
  if valid_619709 != nil:
    section.add "TagValues", valid_619709
  var valid_619710 = query.getOrDefault("MaxRecords")
  valid_619710 = validateParameter(valid_619710, JInt, required = false, default = nil)
  if valid_619710 != nil:
    section.add "MaxRecords", valid_619710
  var valid_619711 = query.getOrDefault("Action")
  valid_619711 = validateParameter(valid_619711, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_619711 != nil:
    section.add "Action", valid_619711
  var valid_619712 = query.getOrDefault("Marker")
  valid_619712 = validateParameter(valid_619712, JString, required = false,
                                 default = nil)
  if valid_619712 != nil:
    section.add "Marker", valid_619712
  var valid_619713 = query.getOrDefault("ResourceName")
  valid_619713 = validateParameter(valid_619713, JString, required = false,
                                 default = nil)
  if valid_619713 != nil:
    section.add "ResourceName", valid_619713
  var valid_619714 = query.getOrDefault("TagKeys")
  valid_619714 = validateParameter(valid_619714, JArray, required = false,
                                 default = nil)
  if valid_619714 != nil:
    section.add "TagKeys", valid_619714
  var valid_619715 = query.getOrDefault("ResourceType")
  valid_619715 = validateParameter(valid_619715, JString, required = false,
                                 default = nil)
  if valid_619715 != nil:
    section.add "ResourceType", valid_619715
  var valid_619716 = query.getOrDefault("Version")
  valid_619716 = validateParameter(valid_619716, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619716 != nil:
    section.add "Version", valid_619716
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619717 = header.getOrDefault("X-Amz-Date")
  valid_619717 = validateParameter(valid_619717, JString, required = false,
                                 default = nil)
  if valid_619717 != nil:
    section.add "X-Amz-Date", valid_619717
  var valid_619718 = header.getOrDefault("X-Amz-Security-Token")
  valid_619718 = validateParameter(valid_619718, JString, required = false,
                                 default = nil)
  if valid_619718 != nil:
    section.add "X-Amz-Security-Token", valid_619718
  var valid_619719 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619719 = validateParameter(valid_619719, JString, required = false,
                                 default = nil)
  if valid_619719 != nil:
    section.add "X-Amz-Content-Sha256", valid_619719
  var valid_619720 = header.getOrDefault("X-Amz-Algorithm")
  valid_619720 = validateParameter(valid_619720, JString, required = false,
                                 default = nil)
  if valid_619720 != nil:
    section.add "X-Amz-Algorithm", valid_619720
  var valid_619721 = header.getOrDefault("X-Amz-Signature")
  valid_619721 = validateParameter(valid_619721, JString, required = false,
                                 default = nil)
  if valid_619721 != nil:
    section.add "X-Amz-Signature", valid_619721
  var valid_619722 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619722 = validateParameter(valid_619722, JString, required = false,
                                 default = nil)
  if valid_619722 != nil:
    section.add "X-Amz-SignedHeaders", valid_619722
  var valid_619723 = header.getOrDefault("X-Amz-Credential")
  valid_619723 = validateParameter(valid_619723, JString, required = false,
                                 default = nil)
  if valid_619723 != nil:
    section.add "X-Amz-Credential", valid_619723
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619724: Call_GetDescribeTags_619706; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_619724.validator(path, query, header, formData, body, _)
  let scheme = call_619724.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619724.url(scheme.get, call_619724.host, call_619724.base,
                         call_619724.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619724, url, valid, _)

proc call*(call_619725: Call_GetDescribeTags_619706; TagValues: JsonNode = nil;
          MaxRecords: int = 0; Action: string = "DescribeTags"; Marker: string = "";
          ResourceName: string = ""; TagKeys: JsonNode = nil; ResourceType: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   Action: string (required)
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-2:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Version: string (required)
  var query_619726 = newJObject()
  if TagValues != nil:
    query_619726.add "TagValues", TagValues
  add(query_619726, "MaxRecords", newJInt(MaxRecords))
  add(query_619726, "Action", newJString(Action))
  add(query_619726, "Marker", newJString(Marker))
  add(query_619726, "ResourceName", newJString(ResourceName))
  if TagKeys != nil:
    query_619726.add "TagKeys", TagKeys
  add(query_619726, "ResourceType", newJString(ResourceType))
  add(query_619726, "Version", newJString(Version))
  result = call_619725.call(nil, query_619726, nil, nil, nil)

var getDescribeTags* = Call_GetDescribeTags_619706(name: "getDescribeTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_GetDescribeTags_619707,
    base: "/", url: url_GetDescribeTags_619708, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableLogging_619765 = ref object of OpenApiRestCall_616850
proc url_PostDisableLogging_619767(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableLogging_619766(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode; _: string = ""): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619768 = query.getOrDefault("Action")
  valid_619768 = validateParameter(valid_619768, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_619768 != nil:
    section.add "Action", valid_619768
  var valid_619769 = query.getOrDefault("Version")
  valid_619769 = validateParameter(valid_619769, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619769 != nil:
    section.add "Version", valid_619769
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619770 = header.getOrDefault("X-Amz-Date")
  valid_619770 = validateParameter(valid_619770, JString, required = false,
                                 default = nil)
  if valid_619770 != nil:
    section.add "X-Amz-Date", valid_619770
  var valid_619771 = header.getOrDefault("X-Amz-Security-Token")
  valid_619771 = validateParameter(valid_619771, JString, required = false,
                                 default = nil)
  if valid_619771 != nil:
    section.add "X-Amz-Security-Token", valid_619771
  var valid_619772 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619772 = validateParameter(valid_619772, JString, required = false,
                                 default = nil)
  if valid_619772 != nil:
    section.add "X-Amz-Content-Sha256", valid_619772
  var valid_619773 = header.getOrDefault("X-Amz-Algorithm")
  valid_619773 = validateParameter(valid_619773, JString, required = false,
                                 default = nil)
  if valid_619773 != nil:
    section.add "X-Amz-Algorithm", valid_619773
  var valid_619774 = header.getOrDefault("X-Amz-Signature")
  valid_619774 = validateParameter(valid_619774, JString, required = false,
                                 default = nil)
  if valid_619774 != nil:
    section.add "X-Amz-Signature", valid_619774
  var valid_619775 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619775 = validateParameter(valid_619775, JString, required = false,
                                 default = nil)
  if valid_619775 != nil:
    section.add "X-Amz-SignedHeaders", valid_619775
  var valid_619776 = header.getOrDefault("X-Amz-Credential")
  valid_619776 = validateParameter(valid_619776, JString, required = false,
                                 default = nil)
  if valid_619776 != nil:
    section.add "X-Amz-Credential", valid_619776
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_619777 = formData.getOrDefault("ClusterIdentifier")
  valid_619777 = validateParameter(valid_619777, JString, required = true,
                                 default = nil)
  if valid_619777 != nil:
    section.add "ClusterIdentifier", valid_619777
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619778: Call_PostDisableLogging_619765; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_619778.validator(path, query, header, formData, body, _)
  let scheme = call_619778.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619778.url(scheme.get, call_619778.host, call_619778.base,
                         call_619778.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619778, url, valid, _)

proc call*(call_619779: Call_PostDisableLogging_619765; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_619780 = newJObject()
  var formData_619781 = newJObject()
  add(query_619780, "Action", newJString(Action))
  add(formData_619781, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619780, "Version", newJString(Version))
  result = call_619779.call(nil, query_619780, nil, formData_619781, nil)

var postDisableLogging* = Call_PostDisableLogging_619765(
    name: "postDisableLogging", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableLogging",
    validator: validate_PostDisableLogging_619766, base: "/",
    url: url_PostDisableLogging_619767, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableLogging_619749 = ref object of OpenApiRestCall_616850
proc url_GetDisableLogging_619751(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableLogging_619750(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_619752 = query.getOrDefault("Action")
  valid_619752 = validateParameter(valid_619752, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_619752 != nil:
    section.add "Action", valid_619752
  var valid_619753 = query.getOrDefault("ClusterIdentifier")
  valid_619753 = validateParameter(valid_619753, JString, required = true,
                                 default = nil)
  if valid_619753 != nil:
    section.add "ClusterIdentifier", valid_619753
  var valid_619754 = query.getOrDefault("Version")
  valid_619754 = validateParameter(valid_619754, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619754 != nil:
    section.add "Version", valid_619754
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619755 = header.getOrDefault("X-Amz-Date")
  valid_619755 = validateParameter(valid_619755, JString, required = false,
                                 default = nil)
  if valid_619755 != nil:
    section.add "X-Amz-Date", valid_619755
  var valid_619756 = header.getOrDefault("X-Amz-Security-Token")
  valid_619756 = validateParameter(valid_619756, JString, required = false,
                                 default = nil)
  if valid_619756 != nil:
    section.add "X-Amz-Security-Token", valid_619756
  var valid_619757 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619757 = validateParameter(valid_619757, JString, required = false,
                                 default = nil)
  if valid_619757 != nil:
    section.add "X-Amz-Content-Sha256", valid_619757
  var valid_619758 = header.getOrDefault("X-Amz-Algorithm")
  valid_619758 = validateParameter(valid_619758, JString, required = false,
                                 default = nil)
  if valid_619758 != nil:
    section.add "X-Amz-Algorithm", valid_619758
  var valid_619759 = header.getOrDefault("X-Amz-Signature")
  valid_619759 = validateParameter(valid_619759, JString, required = false,
                                 default = nil)
  if valid_619759 != nil:
    section.add "X-Amz-Signature", valid_619759
  var valid_619760 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619760 = validateParameter(valid_619760, JString, required = false,
                                 default = nil)
  if valid_619760 != nil:
    section.add "X-Amz-SignedHeaders", valid_619760
  var valid_619761 = header.getOrDefault("X-Amz-Credential")
  valid_619761 = validateParameter(valid_619761, JString, required = false,
                                 default = nil)
  if valid_619761 != nil:
    section.add "X-Amz-Credential", valid_619761
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619762: Call_GetDisableLogging_619749; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_619762.validator(path, query, header, formData, body, _)
  let scheme = call_619762.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619762.url(scheme.get, call_619762.host, call_619762.base,
                         call_619762.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619762, url, valid, _)

proc call*(call_619763: Call_GetDisableLogging_619749; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_619764 = newJObject()
  add(query_619764, "Action", newJString(Action))
  add(query_619764, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619764, "Version", newJString(Version))
  result = call_619763.call(nil, query_619764, nil, nil, nil)

var getDisableLogging* = Call_GetDisableLogging_619749(name: "getDisableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DisableLogging", validator: validate_GetDisableLogging_619750,
    base: "/", url: url_GetDisableLogging_619751,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableSnapshotCopy_619798 = ref object of OpenApiRestCall_616850
proc url_PostDisableSnapshotCopy_619800(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableSnapshotCopy_619799(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619801 = query.getOrDefault("Action")
  valid_619801 = validateParameter(valid_619801, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_619801 != nil:
    section.add "Action", valid_619801
  var valid_619802 = query.getOrDefault("Version")
  valid_619802 = validateParameter(valid_619802, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619802 != nil:
    section.add "Version", valid_619802
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619803 = header.getOrDefault("X-Amz-Date")
  valid_619803 = validateParameter(valid_619803, JString, required = false,
                                 default = nil)
  if valid_619803 != nil:
    section.add "X-Amz-Date", valid_619803
  var valid_619804 = header.getOrDefault("X-Amz-Security-Token")
  valid_619804 = validateParameter(valid_619804, JString, required = false,
                                 default = nil)
  if valid_619804 != nil:
    section.add "X-Amz-Security-Token", valid_619804
  var valid_619805 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619805 = validateParameter(valid_619805, JString, required = false,
                                 default = nil)
  if valid_619805 != nil:
    section.add "X-Amz-Content-Sha256", valid_619805
  var valid_619806 = header.getOrDefault("X-Amz-Algorithm")
  valid_619806 = validateParameter(valid_619806, JString, required = false,
                                 default = nil)
  if valid_619806 != nil:
    section.add "X-Amz-Algorithm", valid_619806
  var valid_619807 = header.getOrDefault("X-Amz-Signature")
  valid_619807 = validateParameter(valid_619807, JString, required = false,
                                 default = nil)
  if valid_619807 != nil:
    section.add "X-Amz-Signature", valid_619807
  var valid_619808 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619808 = validateParameter(valid_619808, JString, required = false,
                                 default = nil)
  if valid_619808 != nil:
    section.add "X-Amz-SignedHeaders", valid_619808
  var valid_619809 = header.getOrDefault("X-Amz-Credential")
  valid_619809 = validateParameter(valid_619809, JString, required = false,
                                 default = nil)
  if valid_619809 != nil:
    section.add "X-Amz-Credential", valid_619809
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_619810 = formData.getOrDefault("ClusterIdentifier")
  valid_619810 = validateParameter(valid_619810, JString, required = true,
                                 default = nil)
  if valid_619810 != nil:
    section.add "ClusterIdentifier", valid_619810
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619811: Call_PostDisableSnapshotCopy_619798; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_619811.validator(path, query, header, formData, body, _)
  let scheme = call_619811.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619811.url(scheme.get, call_619811.host, call_619811.base,
                         call_619811.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619811, url, valid, _)

proc call*(call_619812: Call_PostDisableSnapshotCopy_619798;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## postDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_619813 = newJObject()
  var formData_619814 = newJObject()
  add(query_619813, "Action", newJString(Action))
  add(formData_619814, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619813, "Version", newJString(Version))
  result = call_619812.call(nil, query_619813, nil, formData_619814, nil)

var postDisableSnapshotCopy* = Call_PostDisableSnapshotCopy_619798(
    name: "postDisableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_PostDisableSnapshotCopy_619799, base: "/",
    url: url_PostDisableSnapshotCopy_619800, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableSnapshotCopy_619782 = ref object of OpenApiRestCall_616850
proc url_GetDisableSnapshotCopy_619784(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableSnapshotCopy_619783(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_619785 = query.getOrDefault("Action")
  valid_619785 = validateParameter(valid_619785, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_619785 != nil:
    section.add "Action", valid_619785
  var valid_619786 = query.getOrDefault("ClusterIdentifier")
  valid_619786 = validateParameter(valid_619786, JString, required = true,
                                 default = nil)
  if valid_619786 != nil:
    section.add "ClusterIdentifier", valid_619786
  var valid_619787 = query.getOrDefault("Version")
  valid_619787 = validateParameter(valid_619787, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619787 != nil:
    section.add "Version", valid_619787
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619788 = header.getOrDefault("X-Amz-Date")
  valid_619788 = validateParameter(valid_619788, JString, required = false,
                                 default = nil)
  if valid_619788 != nil:
    section.add "X-Amz-Date", valid_619788
  var valid_619789 = header.getOrDefault("X-Amz-Security-Token")
  valid_619789 = validateParameter(valid_619789, JString, required = false,
                                 default = nil)
  if valid_619789 != nil:
    section.add "X-Amz-Security-Token", valid_619789
  var valid_619790 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619790 = validateParameter(valid_619790, JString, required = false,
                                 default = nil)
  if valid_619790 != nil:
    section.add "X-Amz-Content-Sha256", valid_619790
  var valid_619791 = header.getOrDefault("X-Amz-Algorithm")
  valid_619791 = validateParameter(valid_619791, JString, required = false,
                                 default = nil)
  if valid_619791 != nil:
    section.add "X-Amz-Algorithm", valid_619791
  var valid_619792 = header.getOrDefault("X-Amz-Signature")
  valid_619792 = validateParameter(valid_619792, JString, required = false,
                                 default = nil)
  if valid_619792 != nil:
    section.add "X-Amz-Signature", valid_619792
  var valid_619793 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619793 = validateParameter(valid_619793, JString, required = false,
                                 default = nil)
  if valid_619793 != nil:
    section.add "X-Amz-SignedHeaders", valid_619793
  var valid_619794 = header.getOrDefault("X-Amz-Credential")
  valid_619794 = validateParameter(valid_619794, JString, required = false,
                                 default = nil)
  if valid_619794 != nil:
    section.add "X-Amz-Credential", valid_619794
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619795: Call_GetDisableSnapshotCopy_619782; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_619795.validator(path, query, header, formData, body, _)
  let scheme = call_619795.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619795.url(scheme.get, call_619795.host, call_619795.base,
                         call_619795.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619795, url, valid, _)

proc call*(call_619796: Call_GetDisableSnapshotCopy_619782;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## getDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_619797 = newJObject()
  add(query_619797, "Action", newJString(Action))
  add(query_619797, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619797, "Version", newJString(Version))
  result = call_619796.call(nil, query_619797, nil, nil, nil)

var getDisableSnapshotCopy* = Call_GetDisableSnapshotCopy_619782(
    name: "getDisableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_GetDisableSnapshotCopy_619783, base: "/",
    url: url_GetDisableSnapshotCopy_619784, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableLogging_619833 = ref object of OpenApiRestCall_616850
proc url_PostEnableLogging_619835(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableLogging_619834(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619836 = query.getOrDefault("Action")
  valid_619836 = validateParameter(valid_619836, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_619836 != nil:
    section.add "Action", valid_619836
  var valid_619837 = query.getOrDefault("Version")
  valid_619837 = validateParameter(valid_619837, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619837 != nil:
    section.add "Version", valid_619837
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619838 = header.getOrDefault("X-Amz-Date")
  valid_619838 = validateParameter(valid_619838, JString, required = false,
                                 default = nil)
  if valid_619838 != nil:
    section.add "X-Amz-Date", valid_619838
  var valid_619839 = header.getOrDefault("X-Amz-Security-Token")
  valid_619839 = validateParameter(valid_619839, JString, required = false,
                                 default = nil)
  if valid_619839 != nil:
    section.add "X-Amz-Security-Token", valid_619839
  var valid_619840 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619840 = validateParameter(valid_619840, JString, required = false,
                                 default = nil)
  if valid_619840 != nil:
    section.add "X-Amz-Content-Sha256", valid_619840
  var valid_619841 = header.getOrDefault("X-Amz-Algorithm")
  valid_619841 = validateParameter(valid_619841, JString, required = false,
                                 default = nil)
  if valid_619841 != nil:
    section.add "X-Amz-Algorithm", valid_619841
  var valid_619842 = header.getOrDefault("X-Amz-Signature")
  valid_619842 = validateParameter(valid_619842, JString, required = false,
                                 default = nil)
  if valid_619842 != nil:
    section.add "X-Amz-Signature", valid_619842
  var valid_619843 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619843 = validateParameter(valid_619843, JString, required = false,
                                 default = nil)
  if valid_619843 != nil:
    section.add "X-Amz-SignedHeaders", valid_619843
  var valid_619844 = header.getOrDefault("X-Amz-Credential")
  valid_619844 = validateParameter(valid_619844, JString, required = false,
                                 default = nil)
  if valid_619844 != nil:
    section.add "X-Amz-Credential", valid_619844
  result.add "header", section
  ## parameters in `formData` object:
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  var valid_619845 = formData.getOrDefault("S3KeyPrefix")
  valid_619845 = validateParameter(valid_619845, JString, required = false,
                                 default = nil)
  if valid_619845 != nil:
    section.add "S3KeyPrefix", valid_619845
  assert formData != nil,
        "formData argument is necessary due to required `BucketName` field"
  var valid_619846 = formData.getOrDefault("BucketName")
  valid_619846 = validateParameter(valid_619846, JString, required = true,
                                 default = nil)
  if valid_619846 != nil:
    section.add "BucketName", valid_619846
  var valid_619847 = formData.getOrDefault("ClusterIdentifier")
  valid_619847 = validateParameter(valid_619847, JString, required = true,
                                 default = nil)
  if valid_619847 != nil:
    section.add "ClusterIdentifier", valid_619847
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619848: Call_PostEnableLogging_619833; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_619848.validator(path, query, header, formData, body, _)
  let scheme = call_619848.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619848.url(scheme.get, call_619848.host, call_619848.base,
                         call_619848.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619848, url, valid, _)

proc call*(call_619849: Call_PostEnableLogging_619833; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_619850 = newJObject()
  var formData_619851 = newJObject()
  add(formData_619851, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(formData_619851, "BucketName", newJString(BucketName))
  add(query_619850, "Action", newJString(Action))
  add(formData_619851, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619850, "Version", newJString(Version))
  result = call_619849.call(nil, query_619850, nil, formData_619851, nil)

var postEnableLogging* = Call_PostEnableLogging_619833(name: "postEnableLogging",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_PostEnableLogging_619834,
    base: "/", url: url_PostEnableLogging_619835,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableLogging_619815 = ref object of OpenApiRestCall_616850
proc url_GetEnableLogging_619817(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableLogging_619816(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_619818 = query.getOrDefault("S3KeyPrefix")
  valid_619818 = validateParameter(valid_619818, JString, required = false,
                                 default = nil)
  if valid_619818 != nil:
    section.add "S3KeyPrefix", valid_619818
  assert query != nil,
        "query argument is necessary due to required `BucketName` field"
  var valid_619819 = query.getOrDefault("BucketName")
  valid_619819 = validateParameter(valid_619819, JString, required = true,
                                 default = nil)
  if valid_619819 != nil:
    section.add "BucketName", valid_619819
  var valid_619820 = query.getOrDefault("Action")
  valid_619820 = validateParameter(valid_619820, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_619820 != nil:
    section.add "Action", valid_619820
  var valid_619821 = query.getOrDefault("ClusterIdentifier")
  valid_619821 = validateParameter(valid_619821, JString, required = true,
                                 default = nil)
  if valid_619821 != nil:
    section.add "ClusterIdentifier", valid_619821
  var valid_619822 = query.getOrDefault("Version")
  valid_619822 = validateParameter(valid_619822, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619822 != nil:
    section.add "Version", valid_619822
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619823 = header.getOrDefault("X-Amz-Date")
  valid_619823 = validateParameter(valid_619823, JString, required = false,
                                 default = nil)
  if valid_619823 != nil:
    section.add "X-Amz-Date", valid_619823
  var valid_619824 = header.getOrDefault("X-Amz-Security-Token")
  valid_619824 = validateParameter(valid_619824, JString, required = false,
                                 default = nil)
  if valid_619824 != nil:
    section.add "X-Amz-Security-Token", valid_619824
  var valid_619825 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619825 = validateParameter(valid_619825, JString, required = false,
                                 default = nil)
  if valid_619825 != nil:
    section.add "X-Amz-Content-Sha256", valid_619825
  var valid_619826 = header.getOrDefault("X-Amz-Algorithm")
  valid_619826 = validateParameter(valid_619826, JString, required = false,
                                 default = nil)
  if valid_619826 != nil:
    section.add "X-Amz-Algorithm", valid_619826
  var valid_619827 = header.getOrDefault("X-Amz-Signature")
  valid_619827 = validateParameter(valid_619827, JString, required = false,
                                 default = nil)
  if valid_619827 != nil:
    section.add "X-Amz-Signature", valid_619827
  var valid_619828 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619828 = validateParameter(valid_619828, JString, required = false,
                                 default = nil)
  if valid_619828 != nil:
    section.add "X-Amz-SignedHeaders", valid_619828
  var valid_619829 = header.getOrDefault("X-Amz-Credential")
  valid_619829 = validateParameter(valid_619829, JString, required = false,
                                 default = nil)
  if valid_619829 != nil:
    section.add "X-Amz-Credential", valid_619829
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619830: Call_GetEnableLogging_619815; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_619830.validator(path, query, header, formData, body, _)
  let scheme = call_619830.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619830.url(scheme.get, call_619830.host, call_619830.base,
                         call_619830.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619830, url, valid, _)

proc call*(call_619831: Call_GetEnableLogging_619815; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_619832 = newJObject()
  add(query_619832, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(query_619832, "BucketName", newJString(BucketName))
  add(query_619832, "Action", newJString(Action))
  add(query_619832, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619832, "Version", newJString(Version))
  result = call_619831.call(nil, query_619832, nil, nil, nil)

var getEnableLogging* = Call_GetEnableLogging_619815(name: "getEnableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_GetEnableLogging_619816,
    base: "/", url: url_GetEnableLogging_619817,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableSnapshotCopy_619872 = ref object of OpenApiRestCall_616850
proc url_PostEnableSnapshotCopy_619874(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableSnapshotCopy_619873(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619875 = query.getOrDefault("Action")
  valid_619875 = validateParameter(valid_619875, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_619875 != nil:
    section.add "Action", valid_619875
  var valid_619876 = query.getOrDefault("Version")
  valid_619876 = validateParameter(valid_619876, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619876 != nil:
    section.add "Version", valid_619876
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619877 = header.getOrDefault("X-Amz-Date")
  valid_619877 = validateParameter(valid_619877, JString, required = false,
                                 default = nil)
  if valid_619877 != nil:
    section.add "X-Amz-Date", valid_619877
  var valid_619878 = header.getOrDefault("X-Amz-Security-Token")
  valid_619878 = validateParameter(valid_619878, JString, required = false,
                                 default = nil)
  if valid_619878 != nil:
    section.add "X-Amz-Security-Token", valid_619878
  var valid_619879 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619879 = validateParameter(valid_619879, JString, required = false,
                                 default = nil)
  if valid_619879 != nil:
    section.add "X-Amz-Content-Sha256", valid_619879
  var valid_619880 = header.getOrDefault("X-Amz-Algorithm")
  valid_619880 = validateParameter(valid_619880, JString, required = false,
                                 default = nil)
  if valid_619880 != nil:
    section.add "X-Amz-Algorithm", valid_619880
  var valid_619881 = header.getOrDefault("X-Amz-Signature")
  valid_619881 = validateParameter(valid_619881, JString, required = false,
                                 default = nil)
  if valid_619881 != nil:
    section.add "X-Amz-Signature", valid_619881
  var valid_619882 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619882 = validateParameter(valid_619882, JString, required = false,
                                 default = nil)
  if valid_619882 != nil:
    section.add "X-Amz-SignedHeaders", valid_619882
  var valid_619883 = header.getOrDefault("X-Amz-Credential")
  valid_619883 = validateParameter(valid_619883, JString, required = false,
                                 default = nil)
  if valid_619883 != nil:
    section.add "X-Amz-Credential", valid_619883
  result.add "header", section
  ## parameters in `formData` object:
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_619884 = formData.getOrDefault("RetentionPeriod")
  valid_619884 = validateParameter(valid_619884, JInt, required = false, default = nil)
  if valid_619884 != nil:
    section.add "RetentionPeriod", valid_619884
  var valid_619885 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_619885 = validateParameter(valid_619885, JString, required = false,
                                 default = nil)
  if valid_619885 != nil:
    section.add "SnapshotCopyGrantName", valid_619885
  assert formData != nil, "formData argument is necessary due to required `DestinationRegion` field"
  var valid_619886 = formData.getOrDefault("DestinationRegion")
  valid_619886 = validateParameter(valid_619886, JString, required = true,
                                 default = nil)
  if valid_619886 != nil:
    section.add "DestinationRegion", valid_619886
  var valid_619887 = formData.getOrDefault("ClusterIdentifier")
  valid_619887 = validateParameter(valid_619887, JString, required = true,
                                 default = nil)
  if valid_619887 != nil:
    section.add "ClusterIdentifier", valid_619887
  var valid_619888 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_619888 = validateParameter(valid_619888, JInt, required = false, default = nil)
  if valid_619888 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_619888
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619889: Call_PostEnableSnapshotCopy_619872; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_619889.validator(path, query, header, formData, body, _)
  let scheme = call_619889.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619889.url(scheme.get, call_619889.host, call_619889.base,
                         call_619889.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619889, url, valid, _)

proc call*(call_619890: Call_PostEnableSnapshotCopy_619872;
          DestinationRegion: string; ClusterIdentifier: string;
          RetentionPeriod: int = 0; Action: string = "EnableSnapshotCopy";
          SnapshotCopyGrantName: string = "";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Version: string (required)
  var query_619891 = newJObject()
  var formData_619892 = newJObject()
  add(formData_619892, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_619891, "Action", newJString(Action))
  add(formData_619892, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(formData_619892, "DestinationRegion", newJString(DestinationRegion))
  add(formData_619892, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_619892, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_619891, "Version", newJString(Version))
  result = call_619890.call(nil, query_619891, nil, formData_619892, nil)

var postEnableSnapshotCopy* = Call_PostEnableSnapshotCopy_619872(
    name: "postEnableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_PostEnableSnapshotCopy_619873, base: "/",
    url: url_PostEnableSnapshotCopy_619874, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableSnapshotCopy_619852 = ref object of OpenApiRestCall_616850
proc url_GetEnableSnapshotCopy_619854(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableSnapshotCopy_619853(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `DestinationRegion` field"
  var valid_619855 = query.getOrDefault("DestinationRegion")
  valid_619855 = validateParameter(valid_619855, JString, required = true,
                                 default = nil)
  if valid_619855 != nil:
    section.add "DestinationRegion", valid_619855
  var valid_619856 = query.getOrDefault("Action")
  valid_619856 = validateParameter(valid_619856, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_619856 != nil:
    section.add "Action", valid_619856
  var valid_619857 = query.getOrDefault("ClusterIdentifier")
  valid_619857 = validateParameter(valid_619857, JString, required = true,
                                 default = nil)
  if valid_619857 != nil:
    section.add "ClusterIdentifier", valid_619857
  var valid_619858 = query.getOrDefault("SnapshotCopyGrantName")
  valid_619858 = validateParameter(valid_619858, JString, required = false,
                                 default = nil)
  if valid_619858 != nil:
    section.add "SnapshotCopyGrantName", valid_619858
  var valid_619859 = query.getOrDefault("RetentionPeriod")
  valid_619859 = validateParameter(valid_619859, JInt, required = false, default = nil)
  if valid_619859 != nil:
    section.add "RetentionPeriod", valid_619859
  var valid_619860 = query.getOrDefault("Version")
  valid_619860 = validateParameter(valid_619860, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619860 != nil:
    section.add "Version", valid_619860
  var valid_619861 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_619861 = validateParameter(valid_619861, JInt, required = false, default = nil)
  if valid_619861 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_619861
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619862 = header.getOrDefault("X-Amz-Date")
  valid_619862 = validateParameter(valid_619862, JString, required = false,
                                 default = nil)
  if valid_619862 != nil:
    section.add "X-Amz-Date", valid_619862
  var valid_619863 = header.getOrDefault("X-Amz-Security-Token")
  valid_619863 = validateParameter(valid_619863, JString, required = false,
                                 default = nil)
  if valid_619863 != nil:
    section.add "X-Amz-Security-Token", valid_619863
  var valid_619864 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619864 = validateParameter(valid_619864, JString, required = false,
                                 default = nil)
  if valid_619864 != nil:
    section.add "X-Amz-Content-Sha256", valid_619864
  var valid_619865 = header.getOrDefault("X-Amz-Algorithm")
  valid_619865 = validateParameter(valid_619865, JString, required = false,
                                 default = nil)
  if valid_619865 != nil:
    section.add "X-Amz-Algorithm", valid_619865
  var valid_619866 = header.getOrDefault("X-Amz-Signature")
  valid_619866 = validateParameter(valid_619866, JString, required = false,
                                 default = nil)
  if valid_619866 != nil:
    section.add "X-Amz-Signature", valid_619866
  var valid_619867 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619867 = validateParameter(valid_619867, JString, required = false,
                                 default = nil)
  if valid_619867 != nil:
    section.add "X-Amz-SignedHeaders", valid_619867
  var valid_619868 = header.getOrDefault("X-Amz-Credential")
  valid_619868 = validateParameter(valid_619868, JString, required = false,
                                 default = nil)
  if valid_619868 != nil:
    section.add "X-Amz-Credential", valid_619868
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619869: Call_GetEnableSnapshotCopy_619852; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_619869.validator(path, query, header, formData, body, _)
  let scheme = call_619869.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619869.url(scheme.get, call_619869.host, call_619869.base,
                         call_619869.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619869, url, valid, _)

proc call*(call_619870: Call_GetEnableSnapshotCopy_619852;
          DestinationRegion: string; ClusterIdentifier: string;
          Action: string = "EnableSnapshotCopy"; SnapshotCopyGrantName: string = "";
          RetentionPeriod: int = 0; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_619871 = newJObject()
  add(query_619871, "DestinationRegion", newJString(DestinationRegion))
  add(query_619871, "Action", newJString(Action))
  add(query_619871, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619871, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_619871, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_619871, "Version", newJString(Version))
  add(query_619871, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_619870.call(nil, query_619871, nil, nil, nil)

var getEnableSnapshotCopy* = Call_GetEnableSnapshotCopy_619852(
    name: "getEnableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_GetEnableSnapshotCopy_619853, base: "/",
    url: url_GetEnableSnapshotCopy_619854, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetClusterCredentials_619914 = ref object of OpenApiRestCall_616850
proc url_PostGetClusterCredentials_619916(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetClusterCredentials_619915(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619917 = query.getOrDefault("Action")
  valid_619917 = validateParameter(valid_619917, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_619917 != nil:
    section.add "Action", valid_619917
  var valid_619918 = query.getOrDefault("Version")
  valid_619918 = validateParameter(valid_619918, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619918 != nil:
    section.add "Version", valid_619918
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619919 = header.getOrDefault("X-Amz-Date")
  valid_619919 = validateParameter(valid_619919, JString, required = false,
                                 default = nil)
  if valid_619919 != nil:
    section.add "X-Amz-Date", valid_619919
  var valid_619920 = header.getOrDefault("X-Amz-Security-Token")
  valid_619920 = validateParameter(valid_619920, JString, required = false,
                                 default = nil)
  if valid_619920 != nil:
    section.add "X-Amz-Security-Token", valid_619920
  var valid_619921 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619921 = validateParameter(valid_619921, JString, required = false,
                                 default = nil)
  if valid_619921 != nil:
    section.add "X-Amz-Content-Sha256", valid_619921
  var valid_619922 = header.getOrDefault("X-Amz-Algorithm")
  valid_619922 = validateParameter(valid_619922, JString, required = false,
                                 default = nil)
  if valid_619922 != nil:
    section.add "X-Amz-Algorithm", valid_619922
  var valid_619923 = header.getOrDefault("X-Amz-Signature")
  valid_619923 = validateParameter(valid_619923, JString, required = false,
                                 default = nil)
  if valid_619923 != nil:
    section.add "X-Amz-Signature", valid_619923
  var valid_619924 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619924 = validateParameter(valid_619924, JString, required = false,
                                 default = nil)
  if valid_619924 != nil:
    section.add "X-Amz-SignedHeaders", valid_619924
  var valid_619925 = header.getOrDefault("X-Amz-Credential")
  valid_619925 = validateParameter(valid_619925, JString, required = false,
                                 default = nil)
  if valid_619925 != nil:
    section.add "X-Amz-Credential", valid_619925
  result.add "header", section
  ## parameters in `formData` object:
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `DbUser` field"
  var valid_619926 = formData.getOrDefault("DbUser")
  valid_619926 = validateParameter(valid_619926, JString, required = true,
                                 default = nil)
  if valid_619926 != nil:
    section.add "DbUser", valid_619926
  var valid_619927 = formData.getOrDefault("AutoCreate")
  valid_619927 = validateParameter(valid_619927, JBool, required = false, default = nil)
  if valid_619927 != nil:
    section.add "AutoCreate", valid_619927
  var valid_619928 = formData.getOrDefault("ClusterIdentifier")
  valid_619928 = validateParameter(valid_619928, JString, required = true,
                                 default = nil)
  if valid_619928 != nil:
    section.add "ClusterIdentifier", valid_619928
  var valid_619929 = formData.getOrDefault("DbName")
  valid_619929 = validateParameter(valid_619929, JString, required = false,
                                 default = nil)
  if valid_619929 != nil:
    section.add "DbName", valid_619929
  var valid_619930 = formData.getOrDefault("DbGroups")
  valid_619930 = validateParameter(valid_619930, JArray, required = false,
                                 default = nil)
  if valid_619930 != nil:
    section.add "DbGroups", valid_619930
  var valid_619931 = formData.getOrDefault("DurationSeconds")
  valid_619931 = validateParameter(valid_619931, JInt, required = false, default = nil)
  if valid_619931 != nil:
    section.add "DurationSeconds", valid_619931
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619932: Call_PostGetClusterCredentials_619914;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_619932.validator(path, query, header, formData, body, _)
  let scheme = call_619932.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619932.url(scheme.get, call_619932.host, call_619932.base,
                         call_619932.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619932, url, valid, _)

proc call*(call_619933: Call_PostGetClusterCredentials_619914; DbUser: string;
          ClusterIdentifier: string; Action: string = "GetClusterCredentials";
          AutoCreate: bool = false; DbName: string = ""; DbGroups: JsonNode = nil;
          Version: string = "2012-12-01"; DurationSeconds: int = 0): Recallable =
  ## postGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: string (required)
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  var query_619934 = newJObject()
  var formData_619935 = newJObject()
  add(formData_619935, "DbUser", newJString(DbUser))
  add(query_619934, "Action", newJString(Action))
  add(formData_619935, "AutoCreate", newJBool(AutoCreate))
  add(formData_619935, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_619935, "DbName", newJString(DbName))
  if DbGroups != nil:
    formData_619935.add "DbGroups", DbGroups
  add(query_619934, "Version", newJString(Version))
  add(formData_619935, "DurationSeconds", newJInt(DurationSeconds))
  result = call_619933.call(nil, query_619934, nil, formData_619935, nil)

var postGetClusterCredentials* = Call_PostGetClusterCredentials_619914(
    name: "postGetClusterCredentials", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_PostGetClusterCredentials_619915, base: "/",
    url: url_PostGetClusterCredentials_619916,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetClusterCredentials_619893 = ref object of OpenApiRestCall_616850
proc url_GetGetClusterCredentials_619895(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetClusterCredentials_619894(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: JString (required)
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  section = newJObject()
  var valid_619896 = query.getOrDefault("DbGroups")
  valid_619896 = validateParameter(valid_619896, JArray, required = false,
                                 default = nil)
  if valid_619896 != nil:
    section.add "DbGroups", valid_619896
  var valid_619897 = query.getOrDefault("Version")
  valid_619897 = validateParameter(valid_619897, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619897 != nil:
    section.add "Version", valid_619897
  var valid_619898 = query.getOrDefault("DurationSeconds")
  valid_619898 = validateParameter(valid_619898, JInt, required = false, default = nil)
  if valid_619898 != nil:
    section.add "DurationSeconds", valid_619898
  var valid_619899 = query.getOrDefault("DbName")
  valid_619899 = validateParameter(valid_619899, JString, required = false,
                                 default = nil)
  if valid_619899 != nil:
    section.add "DbName", valid_619899
  var valid_619900 = query.getOrDefault("Action")
  valid_619900 = validateParameter(valid_619900, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_619900 != nil:
    section.add "Action", valid_619900
  var valid_619901 = query.getOrDefault("ClusterIdentifier")
  valid_619901 = validateParameter(valid_619901, JString, required = true,
                                 default = nil)
  if valid_619901 != nil:
    section.add "ClusterIdentifier", valid_619901
  var valid_619902 = query.getOrDefault("DbUser")
  valid_619902 = validateParameter(valid_619902, JString, required = true,
                                 default = nil)
  if valid_619902 != nil:
    section.add "DbUser", valid_619902
  var valid_619903 = query.getOrDefault("AutoCreate")
  valid_619903 = validateParameter(valid_619903, JBool, required = false, default = nil)
  if valid_619903 != nil:
    section.add "AutoCreate", valid_619903
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619904 = header.getOrDefault("X-Amz-Date")
  valid_619904 = validateParameter(valid_619904, JString, required = false,
                                 default = nil)
  if valid_619904 != nil:
    section.add "X-Amz-Date", valid_619904
  var valid_619905 = header.getOrDefault("X-Amz-Security-Token")
  valid_619905 = validateParameter(valid_619905, JString, required = false,
                                 default = nil)
  if valid_619905 != nil:
    section.add "X-Amz-Security-Token", valid_619905
  var valid_619906 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619906 = validateParameter(valid_619906, JString, required = false,
                                 default = nil)
  if valid_619906 != nil:
    section.add "X-Amz-Content-Sha256", valid_619906
  var valid_619907 = header.getOrDefault("X-Amz-Algorithm")
  valid_619907 = validateParameter(valid_619907, JString, required = false,
                                 default = nil)
  if valid_619907 != nil:
    section.add "X-Amz-Algorithm", valid_619907
  var valid_619908 = header.getOrDefault("X-Amz-Signature")
  valid_619908 = validateParameter(valid_619908, JString, required = false,
                                 default = nil)
  if valid_619908 != nil:
    section.add "X-Amz-Signature", valid_619908
  var valid_619909 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619909 = validateParameter(valid_619909, JString, required = false,
                                 default = nil)
  if valid_619909 != nil:
    section.add "X-Amz-SignedHeaders", valid_619909
  var valid_619910 = header.getOrDefault("X-Amz-Credential")
  valid_619910 = validateParameter(valid_619910, JString, required = false,
                                 default = nil)
  if valid_619910 != nil:
    section.add "X-Amz-Credential", valid_619910
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619911: Call_GetGetClusterCredentials_619893; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_619911.validator(path, query, header, formData, body, _)
  let scheme = call_619911.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619911.url(scheme.get, call_619911.host, call_619911.base,
                         call_619911.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619911, url, valid, _)

proc call*(call_619912: Call_GetGetClusterCredentials_619893;
          ClusterIdentifier: string; DbUser: string; DbGroups: JsonNode = nil;
          Version: string = "2012-12-01"; DurationSeconds: int = 0; DbName: string = "";
          Action: string = "GetClusterCredentials"; AutoCreate: bool = false): Recallable =
  ## getGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: string (required)
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  var query_619913 = newJObject()
  if DbGroups != nil:
    query_619913.add "DbGroups", DbGroups
  add(query_619913, "Version", newJString(Version))
  add(query_619913, "DurationSeconds", newJInt(DurationSeconds))
  add(query_619913, "DbName", newJString(DbName))
  add(query_619913, "Action", newJString(Action))
  add(query_619913, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_619913, "DbUser", newJString(DbUser))
  add(query_619913, "AutoCreate", newJBool(AutoCreate))
  result = call_619912.call(nil, query_619913, nil, nil, nil)

var getGetClusterCredentials* = Call_GetGetClusterCredentials_619893(
    name: "getGetClusterCredentials", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_GetGetClusterCredentials_619894, base: "/",
    url: url_GetGetClusterCredentials_619895, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetReservedNodeExchangeOfferings_619954 = ref object of OpenApiRestCall_616850
proc url_PostGetReservedNodeExchangeOfferings_619956(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetReservedNodeExchangeOfferings_619955(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_619957 = query.getOrDefault("Action")
  valid_619957 = validateParameter(valid_619957, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_619957 != nil:
    section.add "Action", valid_619957
  var valid_619958 = query.getOrDefault("Version")
  valid_619958 = validateParameter(valid_619958, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619958 != nil:
    section.add "Version", valid_619958
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619959 = header.getOrDefault("X-Amz-Date")
  valid_619959 = validateParameter(valid_619959, JString, required = false,
                                 default = nil)
  if valid_619959 != nil:
    section.add "X-Amz-Date", valid_619959
  var valid_619960 = header.getOrDefault("X-Amz-Security-Token")
  valid_619960 = validateParameter(valid_619960, JString, required = false,
                                 default = nil)
  if valid_619960 != nil:
    section.add "X-Amz-Security-Token", valid_619960
  var valid_619961 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619961 = validateParameter(valid_619961, JString, required = false,
                                 default = nil)
  if valid_619961 != nil:
    section.add "X-Amz-Content-Sha256", valid_619961
  var valid_619962 = header.getOrDefault("X-Amz-Algorithm")
  valid_619962 = validateParameter(valid_619962, JString, required = false,
                                 default = nil)
  if valid_619962 != nil:
    section.add "X-Amz-Algorithm", valid_619962
  var valid_619963 = header.getOrDefault("X-Amz-Signature")
  valid_619963 = validateParameter(valid_619963, JString, required = false,
                                 default = nil)
  if valid_619963 != nil:
    section.add "X-Amz-Signature", valid_619963
  var valid_619964 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619964 = validateParameter(valid_619964, JString, required = false,
                                 default = nil)
  if valid_619964 != nil:
    section.add "X-Amz-SignedHeaders", valid_619964
  var valid_619965 = header.getOrDefault("X-Amz-Credential")
  valid_619965 = validateParameter(valid_619965, JString, required = false,
                                 default = nil)
  if valid_619965 != nil:
    section.add "X-Amz-Credential", valid_619965
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_619966 = formData.getOrDefault("ReservedNodeId")
  valid_619966 = validateParameter(valid_619966, JString, required = true,
                                 default = nil)
  if valid_619966 != nil:
    section.add "ReservedNodeId", valid_619966
  var valid_619967 = formData.getOrDefault("Marker")
  valid_619967 = validateParameter(valid_619967, JString, required = false,
                                 default = nil)
  if valid_619967 != nil:
    section.add "Marker", valid_619967
  var valid_619968 = formData.getOrDefault("MaxRecords")
  valid_619968 = validateParameter(valid_619968, JInt, required = false, default = nil)
  if valid_619968 != nil:
    section.add "MaxRecords", valid_619968
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619969: Call_PostGetReservedNodeExchangeOfferings_619954;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_619969.validator(path, query, header, formData, body, _)
  let scheme = call_619969.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619969.url(scheme.get, call_619969.host, call_619969.base,
                         call_619969.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619969, url, valid, _)

proc call*(call_619970: Call_PostGetReservedNodeExchangeOfferings_619954;
          ReservedNodeId: string;
          Action: string = "GetReservedNodeExchangeOfferings"; Marker: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Action: string (required)
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Version: string (required)
  var query_619971 = newJObject()
  var formData_619972 = newJObject()
  add(formData_619972, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_619971, "Action", newJString(Action))
  add(formData_619972, "Marker", newJString(Marker))
  add(formData_619972, "MaxRecords", newJInt(MaxRecords))
  add(query_619971, "Version", newJString(Version))
  result = call_619970.call(nil, query_619971, nil, formData_619972, nil)

var postGetReservedNodeExchangeOfferings* = Call_PostGetReservedNodeExchangeOfferings_619954(
    name: "postGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_PostGetReservedNodeExchangeOfferings_619955, base: "/",
    url: url_PostGetReservedNodeExchangeOfferings_619956,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetReservedNodeExchangeOfferings_619936 = ref object of OpenApiRestCall_616850
proc url_GetGetReservedNodeExchangeOfferings_619938(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetReservedNodeExchangeOfferings_619937(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Version: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  section = newJObject()
  var valid_619939 = query.getOrDefault("MaxRecords")
  valid_619939 = validateParameter(valid_619939, JInt, required = false, default = nil)
  if valid_619939 != nil:
    section.add "MaxRecords", valid_619939
  var valid_619940 = query.getOrDefault("Action")
  valid_619940 = validateParameter(valid_619940, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_619940 != nil:
    section.add "Action", valid_619940
  var valid_619941 = query.getOrDefault("Marker")
  valid_619941 = validateParameter(valid_619941, JString, required = false,
                                 default = nil)
  if valid_619941 != nil:
    section.add "Marker", valid_619941
  var valid_619942 = query.getOrDefault("Version")
  valid_619942 = validateParameter(valid_619942, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619942 != nil:
    section.add "Version", valid_619942
  var valid_619943 = query.getOrDefault("ReservedNodeId")
  valid_619943 = validateParameter(valid_619943, JString, required = true,
                                 default = nil)
  if valid_619943 != nil:
    section.add "ReservedNodeId", valid_619943
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_619944 = header.getOrDefault("X-Amz-Date")
  valid_619944 = validateParameter(valid_619944, JString, required = false,
                                 default = nil)
  if valid_619944 != nil:
    section.add "X-Amz-Date", valid_619944
  var valid_619945 = header.getOrDefault("X-Amz-Security-Token")
  valid_619945 = validateParameter(valid_619945, JString, required = false,
                                 default = nil)
  if valid_619945 != nil:
    section.add "X-Amz-Security-Token", valid_619945
  var valid_619946 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_619946 = validateParameter(valid_619946, JString, required = false,
                                 default = nil)
  if valid_619946 != nil:
    section.add "X-Amz-Content-Sha256", valid_619946
  var valid_619947 = header.getOrDefault("X-Amz-Algorithm")
  valid_619947 = validateParameter(valid_619947, JString, required = false,
                                 default = nil)
  if valid_619947 != nil:
    section.add "X-Amz-Algorithm", valid_619947
  var valid_619948 = header.getOrDefault("X-Amz-Signature")
  valid_619948 = validateParameter(valid_619948, JString, required = false,
                                 default = nil)
  if valid_619948 != nil:
    section.add "X-Amz-Signature", valid_619948
  var valid_619949 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_619949 = validateParameter(valid_619949, JString, required = false,
                                 default = nil)
  if valid_619949 != nil:
    section.add "X-Amz-SignedHeaders", valid_619949
  var valid_619950 = header.getOrDefault("X-Amz-Credential")
  valid_619950 = validateParameter(valid_619950, JString, required = false,
                                 default = nil)
  if valid_619950 != nil:
    section.add "X-Amz-Credential", valid_619950
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_619951: Call_GetGetReservedNodeExchangeOfferings_619936;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_619951.validator(path, query, header, formData, body, _)
  let scheme = call_619951.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_619951.url(scheme.get, call_619951.host, call_619951.base,
                         call_619951.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_619951, url, valid, _)

proc call*(call_619952: Call_GetGetReservedNodeExchangeOfferings_619936;
          ReservedNodeId: string; MaxRecords: int = 0;
          Action: string = "GetReservedNodeExchangeOfferings"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Action: string (required)
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Version: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  var query_619953 = newJObject()
  add(query_619953, "MaxRecords", newJInt(MaxRecords))
  add(query_619953, "Action", newJString(Action))
  add(query_619953, "Marker", newJString(Marker))
  add(query_619953, "Version", newJString(Version))
  add(query_619953, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_619952.call(nil, query_619953, nil, nil, nil)

var getGetReservedNodeExchangeOfferings* = Call_GetGetReservedNodeExchangeOfferings_619936(
    name: "getGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_GetGetReservedNodeExchangeOfferings_619937, base: "/",
    url: url_GetGetReservedNodeExchangeOfferings_619938,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyCluster_620010 = ref object of OpenApiRestCall_616850
proc url_PostModifyCluster_620012(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyCluster_620011(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620013 = query.getOrDefault("Action")
  valid_620013 = validateParameter(valid_620013, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_620013 != nil:
    section.add "Action", valid_620013
  var valid_620014 = query.getOrDefault("Version")
  valid_620014 = validateParameter(valid_620014, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620014 != nil:
    section.add "Version", valid_620014
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620015 = header.getOrDefault("X-Amz-Date")
  valid_620015 = validateParameter(valid_620015, JString, required = false,
                                 default = nil)
  if valid_620015 != nil:
    section.add "X-Amz-Date", valid_620015
  var valid_620016 = header.getOrDefault("X-Amz-Security-Token")
  valid_620016 = validateParameter(valid_620016, JString, required = false,
                                 default = nil)
  if valid_620016 != nil:
    section.add "X-Amz-Security-Token", valid_620016
  var valid_620017 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620017 = validateParameter(valid_620017, JString, required = false,
                                 default = nil)
  if valid_620017 != nil:
    section.add "X-Amz-Content-Sha256", valid_620017
  var valid_620018 = header.getOrDefault("X-Amz-Algorithm")
  valid_620018 = validateParameter(valid_620018, JString, required = false,
                                 default = nil)
  if valid_620018 != nil:
    section.add "X-Amz-Algorithm", valid_620018
  var valid_620019 = header.getOrDefault("X-Amz-Signature")
  valid_620019 = validateParameter(valid_620019, JString, required = false,
                                 default = nil)
  if valid_620019 != nil:
    section.add "X-Amz-Signature", valid_620019
  var valid_620020 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620020 = validateParameter(valid_620020, JString, required = false,
                                 default = nil)
  if valid_620020 != nil:
    section.add "X-Amz-SignedHeaders", valid_620020
  var valid_620021 = header.getOrDefault("X-Amz-Credential")
  valid_620021 = validateParameter(valid_620021, JString, required = false,
                                 default = nil)
  if valid_620021 != nil:
    section.add "X-Amz-Credential", valid_620021
  result.add "header", section
  ## parameters in `formData` object:
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   Encrypted: JBool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  section = newJObject()
  var valid_620022 = formData.getOrDefault("EnhancedVpcRouting")
  valid_620022 = validateParameter(valid_620022, JBool, required = false, default = nil)
  if valid_620022 != nil:
    section.add "EnhancedVpcRouting", valid_620022
  var valid_620023 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_620023 = validateParameter(valid_620023, JArray, required = false,
                                 default = nil)
  if valid_620023 != nil:
    section.add "VpcSecurityGroupIds", valid_620023
  var valid_620024 = formData.getOrDefault("ClusterVersion")
  valid_620024 = validateParameter(valid_620024, JString, required = false,
                                 default = nil)
  if valid_620024 != nil:
    section.add "ClusterVersion", valid_620024
  var valid_620025 = formData.getOrDefault("ClusterType")
  valid_620025 = validateParameter(valid_620025, JString, required = false,
                                 default = nil)
  if valid_620025 != nil:
    section.add "ClusterType", valid_620025
  var valid_620026 = formData.getOrDefault("MasterUserPassword")
  valid_620026 = validateParameter(valid_620026, JString, required = false,
                                 default = nil)
  if valid_620026 != nil:
    section.add "MasterUserPassword", valid_620026
  var valid_620027 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_620027 = validateParameter(valid_620027, JString, required = false,
                                 default = nil)
  if valid_620027 != nil:
    section.add "HsmConfigurationIdentifier", valid_620027
  var valid_620028 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_620028 = validateParameter(valid_620028, JString, required = false,
                                 default = nil)
  if valid_620028 != nil:
    section.add "HsmClientCertificateIdentifier", valid_620028
  var valid_620029 = formData.getOrDefault("PubliclyAccessible")
  valid_620029 = validateParameter(valid_620029, JBool, required = false, default = nil)
  if valid_620029 != nil:
    section.add "PubliclyAccessible", valid_620029
  var valid_620030 = formData.getOrDefault("NumberOfNodes")
  valid_620030 = validateParameter(valid_620030, JInt, required = false, default = nil)
  if valid_620030 != nil:
    section.add "NumberOfNodes", valid_620030
  var valid_620031 = formData.getOrDefault("Encrypted")
  valid_620031 = validateParameter(valid_620031, JBool, required = false, default = nil)
  if valid_620031 != nil:
    section.add "Encrypted", valid_620031
  var valid_620032 = formData.getOrDefault("ClusterParameterGroupName")
  valid_620032 = validateParameter(valid_620032, JString, required = false,
                                 default = nil)
  if valid_620032 != nil:
    section.add "ClusterParameterGroupName", valid_620032
  var valid_620033 = formData.getOrDefault("KmsKeyId")
  valid_620033 = validateParameter(valid_620033, JString, required = false,
                                 default = nil)
  if valid_620033 != nil:
    section.add "KmsKeyId", valid_620033
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_620034 = formData.getOrDefault("ClusterIdentifier")
  valid_620034 = validateParameter(valid_620034, JString, required = true,
                                 default = nil)
  if valid_620034 != nil:
    section.add "ClusterIdentifier", valid_620034
  var valid_620035 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_620035 = validateParameter(valid_620035, JInt, required = false, default = nil)
  if valid_620035 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_620035
  var valid_620036 = formData.getOrDefault("ElasticIp")
  valid_620036 = validateParameter(valid_620036, JString, required = false,
                                 default = nil)
  if valid_620036 != nil:
    section.add "ElasticIp", valid_620036
  var valid_620037 = formData.getOrDefault("NewClusterIdentifier")
  valid_620037 = validateParameter(valid_620037, JString, required = false,
                                 default = nil)
  if valid_620037 != nil:
    section.add "NewClusterIdentifier", valid_620037
  var valid_620038 = formData.getOrDefault("AllowVersionUpgrade")
  valid_620038 = validateParameter(valid_620038, JBool, required = false, default = nil)
  if valid_620038 != nil:
    section.add "AllowVersionUpgrade", valid_620038
  var valid_620039 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_620039 = validateParameter(valid_620039, JInt, required = false, default = nil)
  if valid_620039 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_620039
  var valid_620040 = formData.getOrDefault("NodeType")
  valid_620040 = validateParameter(valid_620040, JString, required = false,
                                 default = nil)
  if valid_620040 != nil:
    section.add "NodeType", valid_620040
  var valid_620041 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_620041 = validateParameter(valid_620041, JString, required = false,
                                 default = nil)
  if valid_620041 != nil:
    section.add "PreferredMaintenanceWindow", valid_620041
  var valid_620042 = formData.getOrDefault("MaintenanceTrackName")
  valid_620042 = validateParameter(valid_620042, JString, required = false,
                                 default = nil)
  if valid_620042 != nil:
    section.add "MaintenanceTrackName", valid_620042
  var valid_620043 = formData.getOrDefault("ClusterSecurityGroups")
  valid_620043 = validateParameter(valid_620043, JArray, required = false,
                                 default = nil)
  if valid_620043 != nil:
    section.add "ClusterSecurityGroups", valid_620043
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620044: Call_PostModifyCluster_620010; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_620044.validator(path, query, header, formData, body, _)
  let scheme = call_620044.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620044.url(scheme.get, call_620044.host, call_620044.base,
                         call_620044.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620044, url, valid, _)

proc call*(call_620045: Call_PostModifyCluster_620010; ClusterIdentifier: string;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterVersion: string = ""; ClusterType: string = "";
          MasterUserPassword: string = ""; HsmConfigurationIdentifier: string = "";
          Action: string = "ModifyCluster";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          Encrypted: bool = false; ClusterParameterGroupName: string = "";
          KmsKeyId: string = ""; ManualSnapshotRetentionPeriod: int = 0;
          ElasticIp: string = ""; NewClusterIdentifier: string = "";
          AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          NodeType: string = ""; PreferredMaintenanceWindow: string = "";
          MaintenanceTrackName: string = ""; ClusterSecurityGroups: JsonNode = nil): Recallable =
  ## postModifyCluster
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   Encrypted: bool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  var query_620046 = newJObject()
  var formData_620047 = newJObject()
  add(formData_620047, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    formData_620047.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_620047, "ClusterVersion", newJString(ClusterVersion))
  add(formData_620047, "ClusterType", newJString(ClusterType))
  add(formData_620047, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_620047, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_620046, "Action", newJString(Action))
  add(formData_620047, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_620047, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_620047, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_620047, "Encrypted", newJBool(Encrypted))
  add(formData_620047, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_620047, "KmsKeyId", newJString(KmsKeyId))
  add(formData_620047, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_620047, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_620047, "ElasticIp", newJString(ElasticIp))
  add(formData_620047, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(formData_620047, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_620047, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_620046, "Version", newJString(Version))
  add(formData_620047, "NodeType", newJString(NodeType))
  add(formData_620047, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_620047, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if ClusterSecurityGroups != nil:
    formData_620047.add "ClusterSecurityGroups", ClusterSecurityGroups
  result = call_620045.call(nil, query_620046, nil, formData_620047, nil)

var postModifyCluster* = Call_PostModifyCluster_620010(name: "postModifyCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_PostModifyCluster_620011,
    base: "/", url: url_PostModifyCluster_620012,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyCluster_619973 = ref object of OpenApiRestCall_616850
proc url_GetModifyCluster_619975(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyCluster_619974(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   Action: JString (required)
  ##   Encrypted: JBool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_619976 = query.getOrDefault("ClusterSecurityGroups")
  valid_619976 = validateParameter(valid_619976, JArray, required = false,
                                 default = nil)
  if valid_619976 != nil:
    section.add "ClusterSecurityGroups", valid_619976
  var valid_619977 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_619977 = validateParameter(valid_619977, JString, required = false,
                                 default = nil)
  if valid_619977 != nil:
    section.add "HsmClientCertificateIdentifier", valid_619977
  var valid_619978 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_619978 = validateParameter(valid_619978, JString, required = false,
                                 default = nil)
  if valid_619978 != nil:
    section.add "PreferredMaintenanceWindow", valid_619978
  var valid_619979 = query.getOrDefault("NewClusterIdentifier")
  valid_619979 = validateParameter(valid_619979, JString, required = false,
                                 default = nil)
  if valid_619979 != nil:
    section.add "NewClusterIdentifier", valid_619979
  var valid_619980 = query.getOrDefault("MaintenanceTrackName")
  valid_619980 = validateParameter(valid_619980, JString, required = false,
                                 default = nil)
  if valid_619980 != nil:
    section.add "MaintenanceTrackName", valid_619980
  var valid_619981 = query.getOrDefault("MasterUserPassword")
  valid_619981 = validateParameter(valid_619981, JString, required = false,
                                 default = nil)
  if valid_619981 != nil:
    section.add "MasterUserPassword", valid_619981
  var valid_619982 = query.getOrDefault("AllowVersionUpgrade")
  valid_619982 = validateParameter(valid_619982, JBool, required = false, default = nil)
  if valid_619982 != nil:
    section.add "AllowVersionUpgrade", valid_619982
  var valid_619983 = query.getOrDefault("VpcSecurityGroupIds")
  valid_619983 = validateParameter(valid_619983, JArray, required = false,
                                 default = nil)
  if valid_619983 != nil:
    section.add "VpcSecurityGroupIds", valid_619983
  var valid_619984 = query.getOrDefault("ClusterParameterGroupName")
  valid_619984 = validateParameter(valid_619984, JString, required = false,
                                 default = nil)
  if valid_619984 != nil:
    section.add "ClusterParameterGroupName", valid_619984
  var valid_619985 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_619985 = validateParameter(valid_619985, JString, required = false,
                                 default = nil)
  if valid_619985 != nil:
    section.add "HsmConfigurationIdentifier", valid_619985
  var valid_619986 = query.getOrDefault("EnhancedVpcRouting")
  valid_619986 = validateParameter(valid_619986, JBool, required = false, default = nil)
  if valid_619986 != nil:
    section.add "EnhancedVpcRouting", valid_619986
  var valid_619987 = query.getOrDefault("ElasticIp")
  valid_619987 = validateParameter(valid_619987, JString, required = false,
                                 default = nil)
  if valid_619987 != nil:
    section.add "ElasticIp", valid_619987
  assert query != nil,
        "query argument is necessary due to required `ClusterIdentifier` field"
  var valid_619988 = query.getOrDefault("ClusterIdentifier")
  valid_619988 = validateParameter(valid_619988, JString, required = true,
                                 default = nil)
  if valid_619988 != nil:
    section.add "ClusterIdentifier", valid_619988
  var valid_619989 = query.getOrDefault("KmsKeyId")
  valid_619989 = validateParameter(valid_619989, JString, required = false,
                                 default = nil)
  if valid_619989 != nil:
    section.add "KmsKeyId", valid_619989
  var valid_619990 = query.getOrDefault("PubliclyAccessible")
  valid_619990 = validateParameter(valid_619990, JBool, required = false, default = nil)
  if valid_619990 != nil:
    section.add "PubliclyAccessible", valid_619990
  var valid_619991 = query.getOrDefault("Action")
  valid_619991 = validateParameter(valid_619991, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_619991 != nil:
    section.add "Action", valid_619991
  var valid_619992 = query.getOrDefault("Encrypted")
  valid_619992 = validateParameter(valid_619992, JBool, required = false, default = nil)
  if valid_619992 != nil:
    section.add "Encrypted", valid_619992
  var valid_619993 = query.getOrDefault("NumberOfNodes")
  valid_619993 = validateParameter(valid_619993, JInt, required = false, default = nil)
  if valid_619993 != nil:
    section.add "NumberOfNodes", valid_619993
  var valid_619994 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_619994 = validateParameter(valid_619994, JInt, required = false, default = nil)
  if valid_619994 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_619994
  var valid_619995 = query.getOrDefault("NodeType")
  valid_619995 = validateParameter(valid_619995, JString, required = false,
                                 default = nil)
  if valid_619995 != nil:
    section.add "NodeType", valid_619995
  var valid_619996 = query.getOrDefault("ClusterVersion")
  valid_619996 = validateParameter(valid_619996, JString, required = false,
                                 default = nil)
  if valid_619996 != nil:
    section.add "ClusterVersion", valid_619996
  var valid_619997 = query.getOrDefault("Version")
  valid_619997 = validateParameter(valid_619997, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_619997 != nil:
    section.add "Version", valid_619997
  var valid_619998 = query.getOrDefault("ClusterType")
  valid_619998 = validateParameter(valid_619998, JString, required = false,
                                 default = nil)
  if valid_619998 != nil:
    section.add "ClusterType", valid_619998
  var valid_619999 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_619999 = validateParameter(valid_619999, JInt, required = false, default = nil)
  if valid_619999 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_619999
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620000 = header.getOrDefault("X-Amz-Date")
  valid_620000 = validateParameter(valid_620000, JString, required = false,
                                 default = nil)
  if valid_620000 != nil:
    section.add "X-Amz-Date", valid_620000
  var valid_620001 = header.getOrDefault("X-Amz-Security-Token")
  valid_620001 = validateParameter(valid_620001, JString, required = false,
                                 default = nil)
  if valid_620001 != nil:
    section.add "X-Amz-Security-Token", valid_620001
  var valid_620002 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620002 = validateParameter(valid_620002, JString, required = false,
                                 default = nil)
  if valid_620002 != nil:
    section.add "X-Amz-Content-Sha256", valid_620002
  var valid_620003 = header.getOrDefault("X-Amz-Algorithm")
  valid_620003 = validateParameter(valid_620003, JString, required = false,
                                 default = nil)
  if valid_620003 != nil:
    section.add "X-Amz-Algorithm", valid_620003
  var valid_620004 = header.getOrDefault("X-Amz-Signature")
  valid_620004 = validateParameter(valid_620004, JString, required = false,
                                 default = nil)
  if valid_620004 != nil:
    section.add "X-Amz-Signature", valid_620004
  var valid_620005 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620005 = validateParameter(valid_620005, JString, required = false,
                                 default = nil)
  if valid_620005 != nil:
    section.add "X-Amz-SignedHeaders", valid_620005
  var valid_620006 = header.getOrDefault("X-Amz-Credential")
  valid_620006 = validateParameter(valid_620006, JString, required = false,
                                 default = nil)
  if valid_620006 != nil:
    section.add "X-Amz-Credential", valid_620006
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620007: Call_GetModifyCluster_619973; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_620007.validator(path, query, header, formData, body, _)
  let scheme = call_620007.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620007.url(scheme.get, call_620007.host, call_620007.base,
                         call_620007.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620007, url, valid, _)

proc call*(call_620008: Call_GetModifyCluster_619973; ClusterIdentifier: string;
          ClusterSecurityGroups: JsonNode = nil;
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = "";
          NewClusterIdentifier: string = ""; MaintenanceTrackName: string = "";
          MasterUserPassword: string = ""; AllowVersionUpgrade: bool = false;
          VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = ""; EnhancedVpcRouting: bool = false;
          ElasticIp: string = ""; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; Action: string = "ModifyCluster";
          Encrypted: bool = false; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; NodeType: string = "";
          ClusterVersion: string = ""; Version: string = "2012-12-01";
          ClusterType: string = ""; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getModifyCluster
  ## <p>Modifies the settings for a cluster.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p> <p>You can add another security or parameter group, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   Action: string (required)
  ##   Encrypted: bool
  ##            : <p>Indicates whether the cluster is encrypted. If the value is encrypted (true) and you provide a value for the <code>KmsKeyId</code> parameter, we encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we encrypt with the default key. In the China region we use legacy encryption if you specify that the cluster is encrypted.</p> <p>If the value is not encrypted (false), then the cluster is decrypted. </p>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p> For more information about resizing clusters, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/rs-resize-tutorial.html">Resizing Clusters in Amazon Redshift</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> | <code>ra3.16xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_620009 = newJObject()
  if ClusterSecurityGroups != nil:
    query_620009.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_620009, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_620009, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_620009, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(query_620009, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_620009, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_620009, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  if VpcSecurityGroupIds != nil:
    query_620009.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_620009, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_620009, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_620009, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_620009, "ElasticIp", newJString(ElasticIp))
  add(query_620009, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620009, "KmsKeyId", newJString(KmsKeyId))
  add(query_620009, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_620009, "Action", newJString(Action))
  add(query_620009, "Encrypted", newJBool(Encrypted))
  add(query_620009, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_620009, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_620009, "NodeType", newJString(NodeType))
  add(query_620009, "ClusterVersion", newJString(ClusterVersion))
  add(query_620009, "Version", newJString(Version))
  add(query_620009, "ClusterType", newJString(ClusterType))
  add(query_620009, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_620008.call(nil, query_620009, nil, nil, nil)

var getModifyCluster* = Call_GetModifyCluster_619973(name: "getModifyCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_GetModifyCluster_619974,
    base: "/", url: url_GetModifyCluster_619975,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterDbRevision_620065 = ref object of OpenApiRestCall_616850
proc url_PostModifyClusterDbRevision_620067(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterDbRevision_620066(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620068 = query.getOrDefault("Action")
  valid_620068 = validateParameter(valid_620068, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_620068 != nil:
    section.add "Action", valid_620068
  var valid_620069 = query.getOrDefault("Version")
  valid_620069 = validateParameter(valid_620069, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620069 != nil:
    section.add "Version", valid_620069
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620070 = header.getOrDefault("X-Amz-Date")
  valid_620070 = validateParameter(valid_620070, JString, required = false,
                                 default = nil)
  if valid_620070 != nil:
    section.add "X-Amz-Date", valid_620070
  var valid_620071 = header.getOrDefault("X-Amz-Security-Token")
  valid_620071 = validateParameter(valid_620071, JString, required = false,
                                 default = nil)
  if valid_620071 != nil:
    section.add "X-Amz-Security-Token", valid_620071
  var valid_620072 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620072 = validateParameter(valid_620072, JString, required = false,
                                 default = nil)
  if valid_620072 != nil:
    section.add "X-Amz-Content-Sha256", valid_620072
  var valid_620073 = header.getOrDefault("X-Amz-Algorithm")
  valid_620073 = validateParameter(valid_620073, JString, required = false,
                                 default = nil)
  if valid_620073 != nil:
    section.add "X-Amz-Algorithm", valid_620073
  var valid_620074 = header.getOrDefault("X-Amz-Signature")
  valid_620074 = validateParameter(valid_620074, JString, required = false,
                                 default = nil)
  if valid_620074 != nil:
    section.add "X-Amz-Signature", valid_620074
  var valid_620075 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620075 = validateParameter(valid_620075, JString, required = false,
                                 default = nil)
  if valid_620075 != nil:
    section.add "X-Amz-SignedHeaders", valid_620075
  var valid_620076 = header.getOrDefault("X-Amz-Credential")
  valid_620076 = validateParameter(valid_620076, JString, required = false,
                                 default = nil)
  if valid_620076 != nil:
    section.add "X-Amz-Credential", valid_620076
  result.add "header", section
  ## parameters in `formData` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `RevisionTarget` field"
  var valid_620077 = formData.getOrDefault("RevisionTarget")
  valid_620077 = validateParameter(valid_620077, JString, required = true,
                                 default = nil)
  if valid_620077 != nil:
    section.add "RevisionTarget", valid_620077
  var valid_620078 = formData.getOrDefault("ClusterIdentifier")
  valid_620078 = validateParameter(valid_620078, JString, required = true,
                                 default = nil)
  if valid_620078 != nil:
    section.add "ClusterIdentifier", valid_620078
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620079: Call_PostModifyClusterDbRevision_620065;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_620079.validator(path, query, header, formData, body, _)
  let scheme = call_620079.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620079.url(scheme.get, call_620079.host, call_620079.base,
                         call_620079.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620079, url, valid, _)

proc call*(call_620080: Call_PostModifyClusterDbRevision_620065;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_620081 = newJObject()
  var formData_620082 = newJObject()
  add(formData_620082, "RevisionTarget", newJString(RevisionTarget))
  add(query_620081, "Action", newJString(Action))
  add(formData_620082, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620081, "Version", newJString(Version))
  result = call_620080.call(nil, query_620081, nil, formData_620082, nil)

var postModifyClusterDbRevision* = Call_PostModifyClusterDbRevision_620065(
    name: "postModifyClusterDbRevision", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_PostModifyClusterDbRevision_620066, base: "/",
    url: url_PostModifyClusterDbRevision_620067,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterDbRevision_620048 = ref object of OpenApiRestCall_616850
proc url_GetModifyClusterDbRevision_620050(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterDbRevision_620049(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `RevisionTarget` field"
  var valid_620051 = query.getOrDefault("RevisionTarget")
  valid_620051 = validateParameter(valid_620051, JString, required = true,
                                 default = nil)
  if valid_620051 != nil:
    section.add "RevisionTarget", valid_620051
  var valid_620052 = query.getOrDefault("Action")
  valid_620052 = validateParameter(valid_620052, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_620052 != nil:
    section.add "Action", valid_620052
  var valid_620053 = query.getOrDefault("ClusterIdentifier")
  valid_620053 = validateParameter(valid_620053, JString, required = true,
                                 default = nil)
  if valid_620053 != nil:
    section.add "ClusterIdentifier", valid_620053
  var valid_620054 = query.getOrDefault("Version")
  valid_620054 = validateParameter(valid_620054, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620054 != nil:
    section.add "Version", valid_620054
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620055 = header.getOrDefault("X-Amz-Date")
  valid_620055 = validateParameter(valid_620055, JString, required = false,
                                 default = nil)
  if valid_620055 != nil:
    section.add "X-Amz-Date", valid_620055
  var valid_620056 = header.getOrDefault("X-Amz-Security-Token")
  valid_620056 = validateParameter(valid_620056, JString, required = false,
                                 default = nil)
  if valid_620056 != nil:
    section.add "X-Amz-Security-Token", valid_620056
  var valid_620057 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620057 = validateParameter(valid_620057, JString, required = false,
                                 default = nil)
  if valid_620057 != nil:
    section.add "X-Amz-Content-Sha256", valid_620057
  var valid_620058 = header.getOrDefault("X-Amz-Algorithm")
  valid_620058 = validateParameter(valid_620058, JString, required = false,
                                 default = nil)
  if valid_620058 != nil:
    section.add "X-Amz-Algorithm", valid_620058
  var valid_620059 = header.getOrDefault("X-Amz-Signature")
  valid_620059 = validateParameter(valid_620059, JString, required = false,
                                 default = nil)
  if valid_620059 != nil:
    section.add "X-Amz-Signature", valid_620059
  var valid_620060 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620060 = validateParameter(valid_620060, JString, required = false,
                                 default = nil)
  if valid_620060 != nil:
    section.add "X-Amz-SignedHeaders", valid_620060
  var valid_620061 = header.getOrDefault("X-Amz-Credential")
  valid_620061 = validateParameter(valid_620061, JString, required = false,
                                 default = nil)
  if valid_620061 != nil:
    section.add "X-Amz-Credential", valid_620061
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620062: Call_GetModifyClusterDbRevision_620048;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_620062.validator(path, query, header, formData, body, _)
  let scheme = call_620062.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620062.url(scheme.get, call_620062.host, call_620062.base,
                         call_620062.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620062, url, valid, _)

proc call*(call_620063: Call_GetModifyClusterDbRevision_620048;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_620064 = newJObject()
  add(query_620064, "RevisionTarget", newJString(RevisionTarget))
  add(query_620064, "Action", newJString(Action))
  add(query_620064, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620064, "Version", newJString(Version))
  result = call_620063.call(nil, query_620064, nil, nil, nil)

var getModifyClusterDbRevision* = Call_GetModifyClusterDbRevision_620048(
    name: "getModifyClusterDbRevision", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_GetModifyClusterDbRevision_620049, base: "/",
    url: url_GetModifyClusterDbRevision_620050,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterIamRoles_620101 = ref object of OpenApiRestCall_616850
proc url_PostModifyClusterIamRoles_620103(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterIamRoles_620102(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620104 = query.getOrDefault("Action")
  valid_620104 = validateParameter(valid_620104, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_620104 != nil:
    section.add "Action", valid_620104
  var valid_620105 = query.getOrDefault("Version")
  valid_620105 = validateParameter(valid_620105, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620105 != nil:
    section.add "Version", valid_620105
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620106 = header.getOrDefault("X-Amz-Date")
  valid_620106 = validateParameter(valid_620106, JString, required = false,
                                 default = nil)
  if valid_620106 != nil:
    section.add "X-Amz-Date", valid_620106
  var valid_620107 = header.getOrDefault("X-Amz-Security-Token")
  valid_620107 = validateParameter(valid_620107, JString, required = false,
                                 default = nil)
  if valid_620107 != nil:
    section.add "X-Amz-Security-Token", valid_620107
  var valid_620108 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620108 = validateParameter(valid_620108, JString, required = false,
                                 default = nil)
  if valid_620108 != nil:
    section.add "X-Amz-Content-Sha256", valid_620108
  var valid_620109 = header.getOrDefault("X-Amz-Algorithm")
  valid_620109 = validateParameter(valid_620109, JString, required = false,
                                 default = nil)
  if valid_620109 != nil:
    section.add "X-Amz-Algorithm", valid_620109
  var valid_620110 = header.getOrDefault("X-Amz-Signature")
  valid_620110 = validateParameter(valid_620110, JString, required = false,
                                 default = nil)
  if valid_620110 != nil:
    section.add "X-Amz-Signature", valid_620110
  var valid_620111 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620111 = validateParameter(valid_620111, JString, required = false,
                                 default = nil)
  if valid_620111 != nil:
    section.add "X-Amz-SignedHeaders", valid_620111
  var valid_620112 = header.getOrDefault("X-Amz-Credential")
  valid_620112 = validateParameter(valid_620112, JString, required = false,
                                 default = nil)
  if valid_620112 != nil:
    section.add "X-Amz-Credential", valid_620112
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_620113 = formData.getOrDefault("ClusterIdentifier")
  valid_620113 = validateParameter(valid_620113, JString, required = true,
                                 default = nil)
  if valid_620113 != nil:
    section.add "ClusterIdentifier", valid_620113
  var valid_620114 = formData.getOrDefault("RemoveIamRoles")
  valid_620114 = validateParameter(valid_620114, JArray, required = false,
                                 default = nil)
  if valid_620114 != nil:
    section.add "RemoveIamRoles", valid_620114
  var valid_620115 = formData.getOrDefault("AddIamRoles")
  valid_620115 = validateParameter(valid_620115, JArray, required = false,
                                 default = nil)
  if valid_620115 != nil:
    section.add "AddIamRoles", valid_620115
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620116: Call_PostModifyClusterIamRoles_620101;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_620116.validator(path, query, header, formData, body, _)
  let scheme = call_620116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620116.url(scheme.get, call_620116.host, call_620116.base,
                         call_620116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620116, url, valid, _)

proc call*(call_620117: Call_PostModifyClusterIamRoles_620101;
          ClusterIdentifier: string; Action: string = "ModifyClusterIamRoles";
          RemoveIamRoles: JsonNode = nil; Version: string = "2012-12-01";
          AddIamRoles: JsonNode = nil): Recallable =
  ## postModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: string (required)
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  var query_620118 = newJObject()
  var formData_620119 = newJObject()
  add(query_620118, "Action", newJString(Action))
  add(formData_620119, "ClusterIdentifier", newJString(ClusterIdentifier))
  if RemoveIamRoles != nil:
    formData_620119.add "RemoveIamRoles", RemoveIamRoles
  add(query_620118, "Version", newJString(Version))
  if AddIamRoles != nil:
    formData_620119.add "AddIamRoles", AddIamRoles
  result = call_620117.call(nil, query_620118, nil, formData_620119, nil)

var postModifyClusterIamRoles* = Call_PostModifyClusterIamRoles_620101(
    name: "postModifyClusterIamRoles", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_PostModifyClusterIamRoles_620102, base: "/",
    url: url_PostModifyClusterIamRoles_620103,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterIamRoles_620083 = ref object of OpenApiRestCall_616850
proc url_GetModifyClusterIamRoles_620085(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterIamRoles_620084(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Version: JString (required)
  section = newJObject()
  var valid_620086 = query.getOrDefault("RemoveIamRoles")
  valid_620086 = validateParameter(valid_620086, JArray, required = false,
                                 default = nil)
  if valid_620086 != nil:
    section.add "RemoveIamRoles", valid_620086
  var valid_620087 = query.getOrDefault("Action")
  valid_620087 = validateParameter(valid_620087, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_620087 != nil:
    section.add "Action", valid_620087
  var valid_620088 = query.getOrDefault("ClusterIdentifier")
  valid_620088 = validateParameter(valid_620088, JString, required = true,
                                 default = nil)
  if valid_620088 != nil:
    section.add "ClusterIdentifier", valid_620088
  var valid_620089 = query.getOrDefault("AddIamRoles")
  valid_620089 = validateParameter(valid_620089, JArray, required = false,
                                 default = nil)
  if valid_620089 != nil:
    section.add "AddIamRoles", valid_620089
  var valid_620090 = query.getOrDefault("Version")
  valid_620090 = validateParameter(valid_620090, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620090 != nil:
    section.add "Version", valid_620090
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620091 = header.getOrDefault("X-Amz-Date")
  valid_620091 = validateParameter(valid_620091, JString, required = false,
                                 default = nil)
  if valid_620091 != nil:
    section.add "X-Amz-Date", valid_620091
  var valid_620092 = header.getOrDefault("X-Amz-Security-Token")
  valid_620092 = validateParameter(valid_620092, JString, required = false,
                                 default = nil)
  if valid_620092 != nil:
    section.add "X-Amz-Security-Token", valid_620092
  var valid_620093 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620093 = validateParameter(valid_620093, JString, required = false,
                                 default = nil)
  if valid_620093 != nil:
    section.add "X-Amz-Content-Sha256", valid_620093
  var valid_620094 = header.getOrDefault("X-Amz-Algorithm")
  valid_620094 = validateParameter(valid_620094, JString, required = false,
                                 default = nil)
  if valid_620094 != nil:
    section.add "X-Amz-Algorithm", valid_620094
  var valid_620095 = header.getOrDefault("X-Amz-Signature")
  valid_620095 = validateParameter(valid_620095, JString, required = false,
                                 default = nil)
  if valid_620095 != nil:
    section.add "X-Amz-Signature", valid_620095
  var valid_620096 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620096 = validateParameter(valid_620096, JString, required = false,
                                 default = nil)
  if valid_620096 != nil:
    section.add "X-Amz-SignedHeaders", valid_620096
  var valid_620097 = header.getOrDefault("X-Amz-Credential")
  valid_620097 = validateParameter(valid_620097, JString, required = false,
                                 default = nil)
  if valid_620097 != nil:
    section.add "X-Amz-Credential", valid_620097
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620098: Call_GetModifyClusterIamRoles_620083; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_620098.validator(path, query, header, formData, body, _)
  let scheme = call_620098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620098.url(scheme.get, call_620098.host, call_620098.base,
                         call_620098.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620098, url, valid, _)

proc call*(call_620099: Call_GetModifyClusterIamRoles_620083;
          ClusterIdentifier: string; RemoveIamRoles: JsonNode = nil;
          Action: string = "ModifyClusterIamRoles"; AddIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Version: string (required)
  var query_620100 = newJObject()
  if RemoveIamRoles != nil:
    query_620100.add "RemoveIamRoles", RemoveIamRoles
  add(query_620100, "Action", newJString(Action))
  add(query_620100, "ClusterIdentifier", newJString(ClusterIdentifier))
  if AddIamRoles != nil:
    query_620100.add "AddIamRoles", AddIamRoles
  add(query_620100, "Version", newJString(Version))
  result = call_620099.call(nil, query_620100, nil, nil, nil)

var getModifyClusterIamRoles* = Call_GetModifyClusterIamRoles_620083(
    name: "getModifyClusterIamRoles", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_GetModifyClusterIamRoles_620084, base: "/",
    url: url_GetModifyClusterIamRoles_620085, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterMaintenance_620141 = ref object of OpenApiRestCall_616850
proc url_PostModifyClusterMaintenance_620143(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterMaintenance_620142(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies the maintenance settings of a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620144 = query.getOrDefault("Action")
  valid_620144 = validateParameter(valid_620144, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_620144 != nil:
    section.add "Action", valid_620144
  var valid_620145 = query.getOrDefault("Version")
  valid_620145 = validateParameter(valid_620145, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620145 != nil:
    section.add "Version", valid_620145
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620146 = header.getOrDefault("X-Amz-Date")
  valid_620146 = validateParameter(valid_620146, JString, required = false,
                                 default = nil)
  if valid_620146 != nil:
    section.add "X-Amz-Date", valid_620146
  var valid_620147 = header.getOrDefault("X-Amz-Security-Token")
  valid_620147 = validateParameter(valid_620147, JString, required = false,
                                 default = nil)
  if valid_620147 != nil:
    section.add "X-Amz-Security-Token", valid_620147
  var valid_620148 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620148 = validateParameter(valid_620148, JString, required = false,
                                 default = nil)
  if valid_620148 != nil:
    section.add "X-Amz-Content-Sha256", valid_620148
  var valid_620149 = header.getOrDefault("X-Amz-Algorithm")
  valid_620149 = validateParameter(valid_620149, JString, required = false,
                                 default = nil)
  if valid_620149 != nil:
    section.add "X-Amz-Algorithm", valid_620149
  var valid_620150 = header.getOrDefault("X-Amz-Signature")
  valid_620150 = validateParameter(valid_620150, JString, required = false,
                                 default = nil)
  if valid_620150 != nil:
    section.add "X-Amz-Signature", valid_620150
  var valid_620151 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620151 = validateParameter(valid_620151, JString, required = false,
                                 default = nil)
  if valid_620151 != nil:
    section.add "X-Amz-SignedHeaders", valid_620151
  var valid_620152 = header.getOrDefault("X-Amz-Credential")
  valid_620152 = validateParameter(valid_620152, JString, required = false,
                                 default = nil)
  if valid_620152 != nil:
    section.add "X-Amz-Credential", valid_620152
  result.add "header", section
  ## parameters in `formData` object:
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  section = newJObject()
  var valid_620153 = formData.getOrDefault("DeferMaintenanceDuration")
  valid_620153 = validateParameter(valid_620153, JInt, required = false, default = nil)
  if valid_620153 != nil:
    section.add "DeferMaintenanceDuration", valid_620153
  var valid_620154 = formData.getOrDefault("DeferMaintenanceIdentifier")
  valid_620154 = validateParameter(valid_620154, JString, required = false,
                                 default = nil)
  if valid_620154 != nil:
    section.add "DeferMaintenanceIdentifier", valid_620154
  var valid_620155 = formData.getOrDefault("DeferMaintenanceStartTime")
  valid_620155 = validateParameter(valid_620155, JString, required = false,
                                 default = nil)
  if valid_620155 != nil:
    section.add "DeferMaintenanceStartTime", valid_620155
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_620156 = formData.getOrDefault("ClusterIdentifier")
  valid_620156 = validateParameter(valid_620156, JString, required = true,
                                 default = nil)
  if valid_620156 != nil:
    section.add "ClusterIdentifier", valid_620156
  var valid_620157 = formData.getOrDefault("DeferMaintenanceEndTime")
  valid_620157 = validateParameter(valid_620157, JString, required = false,
                                 default = nil)
  if valid_620157 != nil:
    section.add "DeferMaintenanceEndTime", valid_620157
  var valid_620158 = formData.getOrDefault("DeferMaintenance")
  valid_620158 = validateParameter(valid_620158, JBool, required = false, default = nil)
  if valid_620158 != nil:
    section.add "DeferMaintenance", valid_620158
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620159: Call_PostModifyClusterMaintenance_620141;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies the maintenance settings of a cluster.
  ## 
  let valid = call_620159.validator(path, query, header, formData, body, _)
  let scheme = call_620159.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620159.url(scheme.get, call_620159.host, call_620159.base,
                         call_620159.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620159, url, valid, _)

proc call*(call_620160: Call_PostModifyClusterMaintenance_620141;
          ClusterIdentifier: string; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceIdentifier: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenanceStartTime: string = "";
          DeferMaintenanceEndTime: string = ""; DeferMaintenance: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster.
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   Action: string (required)
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Version: string (required)
  var query_620161 = newJObject()
  var formData_620162 = newJObject()
  add(formData_620162, "DeferMaintenanceDuration",
      newJInt(DeferMaintenanceDuration))
  add(formData_620162, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_620161, "Action", newJString(Action))
  add(formData_620162, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(formData_620162, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_620162, "DeferMaintenanceEndTime",
      newJString(DeferMaintenanceEndTime))
  add(formData_620162, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_620161, "Version", newJString(Version))
  result = call_620160.call(nil, query_620161, nil, formData_620162, nil)

var postModifyClusterMaintenance* = Call_PostModifyClusterMaintenance_620141(
    name: "postModifyClusterMaintenance", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_PostModifyClusterMaintenance_620142, base: "/",
    url: url_PostModifyClusterMaintenance_620143,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterMaintenance_620120 = ref object of OpenApiRestCall_616850
proc url_GetModifyClusterMaintenance_620122(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterMaintenance_620121(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies the maintenance settings of a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   Version: JString (required)
  section = newJObject()
  var valid_620123 = query.getOrDefault("DeferMaintenanceDuration")
  valid_620123 = validateParameter(valid_620123, JInt, required = false, default = nil)
  if valid_620123 != nil:
    section.add "DeferMaintenanceDuration", valid_620123
  var valid_620124 = query.getOrDefault("DeferMaintenanceEndTime")
  valid_620124 = validateParameter(valid_620124, JString, required = false,
                                 default = nil)
  if valid_620124 != nil:
    section.add "DeferMaintenanceEndTime", valid_620124
  var valid_620125 = query.getOrDefault("DeferMaintenanceIdentifier")
  valid_620125 = validateParameter(valid_620125, JString, required = false,
                                 default = nil)
  if valid_620125 != nil:
    section.add "DeferMaintenanceIdentifier", valid_620125
  var valid_620126 = query.getOrDefault("DeferMaintenance")
  valid_620126 = validateParameter(valid_620126, JBool, required = false, default = nil)
  if valid_620126 != nil:
    section.add "DeferMaintenance", valid_620126
  var valid_620127 = query.getOrDefault("Action")
  valid_620127 = validateParameter(valid_620127, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_620127 != nil:
    section.add "Action", valid_620127
  var valid_620128 = query.getOrDefault("ClusterIdentifier")
  valid_620128 = validateParameter(valid_620128, JString, required = true,
                                 default = nil)
  if valid_620128 != nil:
    section.add "ClusterIdentifier", valid_620128
  var valid_620129 = query.getOrDefault("DeferMaintenanceStartTime")
  valid_620129 = validateParameter(valid_620129, JString, required = false,
                                 default = nil)
  if valid_620129 != nil:
    section.add "DeferMaintenanceStartTime", valid_620129
  var valid_620130 = query.getOrDefault("Version")
  valid_620130 = validateParameter(valid_620130, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620130 != nil:
    section.add "Version", valid_620130
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620131 = header.getOrDefault("X-Amz-Date")
  valid_620131 = validateParameter(valid_620131, JString, required = false,
                                 default = nil)
  if valid_620131 != nil:
    section.add "X-Amz-Date", valid_620131
  var valid_620132 = header.getOrDefault("X-Amz-Security-Token")
  valid_620132 = validateParameter(valid_620132, JString, required = false,
                                 default = nil)
  if valid_620132 != nil:
    section.add "X-Amz-Security-Token", valid_620132
  var valid_620133 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620133 = validateParameter(valid_620133, JString, required = false,
                                 default = nil)
  if valid_620133 != nil:
    section.add "X-Amz-Content-Sha256", valid_620133
  var valid_620134 = header.getOrDefault("X-Amz-Algorithm")
  valid_620134 = validateParameter(valid_620134, JString, required = false,
                                 default = nil)
  if valid_620134 != nil:
    section.add "X-Amz-Algorithm", valid_620134
  var valid_620135 = header.getOrDefault("X-Amz-Signature")
  valid_620135 = validateParameter(valid_620135, JString, required = false,
                                 default = nil)
  if valid_620135 != nil:
    section.add "X-Amz-Signature", valid_620135
  var valid_620136 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620136 = validateParameter(valid_620136, JString, required = false,
                                 default = nil)
  if valid_620136 != nil:
    section.add "X-Amz-SignedHeaders", valid_620136
  var valid_620137 = header.getOrDefault("X-Amz-Credential")
  valid_620137 = validateParameter(valid_620137, JString, required = false,
                                 default = nil)
  if valid_620137 != nil:
    section.add "X-Amz-Credential", valid_620137
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620138: Call_GetModifyClusterMaintenance_620120;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies the maintenance settings of a cluster.
  ## 
  let valid = call_620138.validator(path, query, header, formData, body, _)
  let scheme = call_620138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620138.url(scheme.get, call_620138.host, call_620138.base,
                         call_620138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620138, url, valid, _)

proc call*(call_620139: Call_GetModifyClusterMaintenance_620120;
          ClusterIdentifier: string; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceEndTime: string = "";
          DeferMaintenanceIdentifier: string = ""; DeferMaintenance: bool = false;
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenanceStartTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster.
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   Version: string (required)
  var query_620140 = newJObject()
  add(query_620140, "DeferMaintenanceDuration", newJInt(DeferMaintenanceDuration))
  add(query_620140, "DeferMaintenanceEndTime", newJString(DeferMaintenanceEndTime))
  add(query_620140, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_620140, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_620140, "Action", newJString(Action))
  add(query_620140, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620140, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(query_620140, "Version", newJString(Version))
  result = call_620139.call(nil, query_620140, nil, nil, nil)

var getModifyClusterMaintenance* = Call_GetModifyClusterMaintenance_620120(
    name: "getModifyClusterMaintenance", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_GetModifyClusterMaintenance_620121, base: "/",
    url: url_GetModifyClusterMaintenance_620122,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterParameterGroup_620180 = ref object of OpenApiRestCall_616850
proc url_PostModifyClusterParameterGroup_620182(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterParameterGroup_620181(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620183 = query.getOrDefault("Action")
  valid_620183 = validateParameter(valid_620183, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_620183 != nil:
    section.add "Action", valid_620183
  var valid_620184 = query.getOrDefault("Version")
  valid_620184 = validateParameter(valid_620184, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620184 != nil:
    section.add "Version", valid_620184
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620185 = header.getOrDefault("X-Amz-Date")
  valid_620185 = validateParameter(valid_620185, JString, required = false,
                                 default = nil)
  if valid_620185 != nil:
    section.add "X-Amz-Date", valid_620185
  var valid_620186 = header.getOrDefault("X-Amz-Security-Token")
  valid_620186 = validateParameter(valid_620186, JString, required = false,
                                 default = nil)
  if valid_620186 != nil:
    section.add "X-Amz-Security-Token", valid_620186
  var valid_620187 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620187 = validateParameter(valid_620187, JString, required = false,
                                 default = nil)
  if valid_620187 != nil:
    section.add "X-Amz-Content-Sha256", valid_620187
  var valid_620188 = header.getOrDefault("X-Amz-Algorithm")
  valid_620188 = validateParameter(valid_620188, JString, required = false,
                                 default = nil)
  if valid_620188 != nil:
    section.add "X-Amz-Algorithm", valid_620188
  var valid_620189 = header.getOrDefault("X-Amz-Signature")
  valid_620189 = validateParameter(valid_620189, JString, required = false,
                                 default = nil)
  if valid_620189 != nil:
    section.add "X-Amz-Signature", valid_620189
  var valid_620190 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620190 = validateParameter(valid_620190, JString, required = false,
                                 default = nil)
  if valid_620190 != nil:
    section.add "X-Amz-SignedHeaders", valid_620190
  var valid_620191 = header.getOrDefault("X-Amz-Credential")
  valid_620191 = validateParameter(valid_620191, JString, required = false,
                                 default = nil)
  if valid_620191 != nil:
    section.add "X-Amz-Credential", valid_620191
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_620192 = formData.getOrDefault("ParameterGroupName")
  valid_620192 = validateParameter(valid_620192, JString, required = true,
                                 default = nil)
  if valid_620192 != nil:
    section.add "ParameterGroupName", valid_620192
  var valid_620193 = formData.getOrDefault("Parameters")
  valid_620193 = validateParameter(valid_620193, JArray, required = true, default = nil)
  if valid_620193 != nil:
    section.add "Parameters", valid_620193
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620194: Call_PostModifyClusterParameterGroup_620180;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_620194.validator(path, query, header, formData, body, _)
  let scheme = call_620194.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620194.url(scheme.get, call_620194.host, call_620194.base,
                         call_620194.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620194, url, valid, _)

proc call*(call_620195: Call_PostModifyClusterParameterGroup_620180;
          ParameterGroupName: string; Parameters: JsonNode;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_620196 = newJObject()
  var formData_620197 = newJObject()
  add(formData_620197, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    formData_620197.add "Parameters", Parameters
  add(query_620196, "Action", newJString(Action))
  add(query_620196, "Version", newJString(Version))
  result = call_620195.call(nil, query_620196, nil, formData_620197, nil)

var postModifyClusterParameterGroup* = Call_PostModifyClusterParameterGroup_620180(
    name: "postModifyClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_PostModifyClusterParameterGroup_620181, base: "/",
    url: url_PostModifyClusterParameterGroup_620182,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterParameterGroup_620163 = ref object of OpenApiRestCall_616850
proc url_GetModifyClusterParameterGroup_620165(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterParameterGroup_620164(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_620166 = query.getOrDefault("ParameterGroupName")
  valid_620166 = validateParameter(valid_620166, JString, required = true,
                                 default = nil)
  if valid_620166 != nil:
    section.add "ParameterGroupName", valid_620166
  var valid_620167 = query.getOrDefault("Parameters")
  valid_620167 = validateParameter(valid_620167, JArray, required = true, default = nil)
  if valid_620167 != nil:
    section.add "Parameters", valid_620167
  var valid_620168 = query.getOrDefault("Action")
  valid_620168 = validateParameter(valid_620168, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_620168 != nil:
    section.add "Action", valid_620168
  var valid_620169 = query.getOrDefault("Version")
  valid_620169 = validateParameter(valid_620169, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620169 != nil:
    section.add "Version", valid_620169
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620170 = header.getOrDefault("X-Amz-Date")
  valid_620170 = validateParameter(valid_620170, JString, required = false,
                                 default = nil)
  if valid_620170 != nil:
    section.add "X-Amz-Date", valid_620170
  var valid_620171 = header.getOrDefault("X-Amz-Security-Token")
  valid_620171 = validateParameter(valid_620171, JString, required = false,
                                 default = nil)
  if valid_620171 != nil:
    section.add "X-Amz-Security-Token", valid_620171
  var valid_620172 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620172 = validateParameter(valid_620172, JString, required = false,
                                 default = nil)
  if valid_620172 != nil:
    section.add "X-Amz-Content-Sha256", valid_620172
  var valid_620173 = header.getOrDefault("X-Amz-Algorithm")
  valid_620173 = validateParameter(valid_620173, JString, required = false,
                                 default = nil)
  if valid_620173 != nil:
    section.add "X-Amz-Algorithm", valid_620173
  var valid_620174 = header.getOrDefault("X-Amz-Signature")
  valid_620174 = validateParameter(valid_620174, JString, required = false,
                                 default = nil)
  if valid_620174 != nil:
    section.add "X-Amz-Signature", valid_620174
  var valid_620175 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620175 = validateParameter(valid_620175, JString, required = false,
                                 default = nil)
  if valid_620175 != nil:
    section.add "X-Amz-SignedHeaders", valid_620175
  var valid_620176 = header.getOrDefault("X-Amz-Credential")
  valid_620176 = validateParameter(valid_620176, JString, required = false,
                                 default = nil)
  if valid_620176 != nil:
    section.add "X-Amz-Credential", valid_620176
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620177: Call_GetModifyClusterParameterGroup_620163;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_620177.validator(path, query, header, formData, body, _)
  let scheme = call_620177.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620177.url(scheme.get, call_620177.host, call_620177.base,
                         call_620177.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620177, url, valid, _)

proc call*(call_620178: Call_GetModifyClusterParameterGroup_620163;
          ParameterGroupName: string; Parameters: JsonNode;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_620179 = newJObject()
  add(query_620179, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    query_620179.add "Parameters", Parameters
  add(query_620179, "Action", newJString(Action))
  add(query_620179, "Version", newJString(Version))
  result = call_620178.call(nil, query_620179, nil, nil, nil)

var getModifyClusterParameterGroup* = Call_GetModifyClusterParameterGroup_620163(
    name: "getModifyClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_GetModifyClusterParameterGroup_620164, base: "/",
    url: url_GetModifyClusterParameterGroup_620165,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshot_620216 = ref object of OpenApiRestCall_616850
proc url_PostModifyClusterSnapshot_620218(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshot_620217(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620219 = query.getOrDefault("Action")
  valid_620219 = validateParameter(valid_620219, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_620219 != nil:
    section.add "Action", valid_620219
  var valid_620220 = query.getOrDefault("Version")
  valid_620220 = validateParameter(valid_620220, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620220 != nil:
    section.add "Version", valid_620220
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620221 = header.getOrDefault("X-Amz-Date")
  valid_620221 = validateParameter(valid_620221, JString, required = false,
                                 default = nil)
  if valid_620221 != nil:
    section.add "X-Amz-Date", valid_620221
  var valid_620222 = header.getOrDefault("X-Amz-Security-Token")
  valid_620222 = validateParameter(valid_620222, JString, required = false,
                                 default = nil)
  if valid_620222 != nil:
    section.add "X-Amz-Security-Token", valid_620222
  var valid_620223 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620223 = validateParameter(valid_620223, JString, required = false,
                                 default = nil)
  if valid_620223 != nil:
    section.add "X-Amz-Content-Sha256", valid_620223
  var valid_620224 = header.getOrDefault("X-Amz-Algorithm")
  valid_620224 = validateParameter(valid_620224, JString, required = false,
                                 default = nil)
  if valid_620224 != nil:
    section.add "X-Amz-Algorithm", valid_620224
  var valid_620225 = header.getOrDefault("X-Amz-Signature")
  valid_620225 = validateParameter(valid_620225, JString, required = false,
                                 default = nil)
  if valid_620225 != nil:
    section.add "X-Amz-Signature", valid_620225
  var valid_620226 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620226 = validateParameter(valid_620226, JString, required = false,
                                 default = nil)
  if valid_620226 != nil:
    section.add "X-Amz-SignedHeaders", valid_620226
  var valid_620227 = header.getOrDefault("X-Amz-Credential")
  valid_620227 = validateParameter(valid_620227, JString, required = false,
                                 default = nil)
  if valid_620227 != nil:
    section.add "X-Amz-Credential", valid_620227
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_620228 = formData.getOrDefault("SnapshotIdentifier")
  valid_620228 = validateParameter(valid_620228, JString, required = true,
                                 default = nil)
  if valid_620228 != nil:
    section.add "SnapshotIdentifier", valid_620228
  var valid_620229 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_620229 = validateParameter(valid_620229, JInt, required = false, default = nil)
  if valid_620229 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_620229
  var valid_620230 = formData.getOrDefault("Force")
  valid_620230 = validateParameter(valid_620230, JBool, required = false, default = nil)
  if valid_620230 != nil:
    section.add "Force", valid_620230
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620231: Call_PostModifyClusterSnapshot_620216;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  let valid = call_620231.validator(path, query, header, formData, body, _)
  let scheme = call_620231.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620231.url(scheme.get, call_620231.host, call_620231.base,
                         call_620231.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620231, url, valid, _)

proc call*(call_620232: Call_PostModifyClusterSnapshot_620216;
          SnapshotIdentifier: string; Action: string = "ModifyClusterSnapshot";
          ManualSnapshotRetentionPeriod: int = 0; Force: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshot
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Version: string (required)
  var query_620233 = newJObject()
  var formData_620234 = newJObject()
  add(query_620233, "Action", newJString(Action))
  add(formData_620234, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_620234, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_620234, "Force", newJBool(Force))
  add(query_620233, "Version", newJString(Version))
  result = call_620232.call(nil, query_620233, nil, formData_620234, nil)

var postModifyClusterSnapshot* = Call_PostModifyClusterSnapshot_620216(
    name: "postModifyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_PostModifyClusterSnapshot_620217, base: "/",
    url: url_PostModifyClusterSnapshot_620218,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshot_620198 = ref object of OpenApiRestCall_616850
proc url_GetModifyClusterSnapshot_620200(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshot_620199(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Version: JString (required)
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_620201 = query.getOrDefault("Action")
  valid_620201 = validateParameter(valid_620201, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_620201 != nil:
    section.add "Action", valid_620201
  var valid_620202 = query.getOrDefault("SnapshotIdentifier")
  valid_620202 = validateParameter(valid_620202, JString, required = true,
                                 default = nil)
  if valid_620202 != nil:
    section.add "SnapshotIdentifier", valid_620202
  var valid_620203 = query.getOrDefault("Version")
  valid_620203 = validateParameter(valid_620203, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620203 != nil:
    section.add "Version", valid_620203
  var valid_620204 = query.getOrDefault("Force")
  valid_620204 = validateParameter(valid_620204, JBool, required = false, default = nil)
  if valid_620204 != nil:
    section.add "Force", valid_620204
  var valid_620205 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_620205 = validateParameter(valid_620205, JInt, required = false, default = nil)
  if valid_620205 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_620205
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620206 = header.getOrDefault("X-Amz-Date")
  valid_620206 = validateParameter(valid_620206, JString, required = false,
                                 default = nil)
  if valid_620206 != nil:
    section.add "X-Amz-Date", valid_620206
  var valid_620207 = header.getOrDefault("X-Amz-Security-Token")
  valid_620207 = validateParameter(valid_620207, JString, required = false,
                                 default = nil)
  if valid_620207 != nil:
    section.add "X-Amz-Security-Token", valid_620207
  var valid_620208 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620208 = validateParameter(valid_620208, JString, required = false,
                                 default = nil)
  if valid_620208 != nil:
    section.add "X-Amz-Content-Sha256", valid_620208
  var valid_620209 = header.getOrDefault("X-Amz-Algorithm")
  valid_620209 = validateParameter(valid_620209, JString, required = false,
                                 default = nil)
  if valid_620209 != nil:
    section.add "X-Amz-Algorithm", valid_620209
  var valid_620210 = header.getOrDefault("X-Amz-Signature")
  valid_620210 = validateParameter(valid_620210, JString, required = false,
                                 default = nil)
  if valid_620210 != nil:
    section.add "X-Amz-Signature", valid_620210
  var valid_620211 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620211 = validateParameter(valid_620211, JString, required = false,
                                 default = nil)
  if valid_620211 != nil:
    section.add "X-Amz-SignedHeaders", valid_620211
  var valid_620212 = header.getOrDefault("X-Amz-Credential")
  valid_620212 = validateParameter(valid_620212, JString, required = false,
                                 default = nil)
  if valid_620212 != nil:
    section.add "X-Amz-Credential", valid_620212
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620213: Call_GetModifyClusterSnapshot_620198; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ## 
  let valid = call_620213.validator(path, query, header, formData, body, _)
  let scheme = call_620213.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620213.url(scheme.get, call_620213.host, call_620213.base,
                         call_620213.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620213, url, valid, _)

proc call*(call_620214: Call_GetModifyClusterSnapshot_620198;
          SnapshotIdentifier: string; Action: string = "ModifyClusterSnapshot";
          Version: string = "2012-12-01"; Force: bool = false;
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getModifyClusterSnapshot
  ## <p>Modifies the settings for a snapshot.</p> <p>This exanmple modifies the manual retention period setting for a cluster snapshot.</p>
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Version: string (required)
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_620215 = newJObject()
  add(query_620215, "Action", newJString(Action))
  add(query_620215, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_620215, "Version", newJString(Version))
  add(query_620215, "Force", newJBool(Force))
  add(query_620215, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_620214.call(nil, query_620215, nil, nil, nil)

var getModifyClusterSnapshot* = Call_GetModifyClusterSnapshot_620198(
    name: "getModifyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_GetModifyClusterSnapshot_620199, base: "/",
    url: url_GetModifyClusterSnapshot_620200, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshotSchedule_620253 = ref object of OpenApiRestCall_616850
proc url_PostModifyClusterSnapshotSchedule_620255(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshotSchedule_620254(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620256 = query.getOrDefault("Action")
  valid_620256 = validateParameter(valid_620256, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_620256 != nil:
    section.add "Action", valid_620256
  var valid_620257 = query.getOrDefault("Version")
  valid_620257 = validateParameter(valid_620257, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620257 != nil:
    section.add "Version", valid_620257
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620258 = header.getOrDefault("X-Amz-Date")
  valid_620258 = validateParameter(valid_620258, JString, required = false,
                                 default = nil)
  if valid_620258 != nil:
    section.add "X-Amz-Date", valid_620258
  var valid_620259 = header.getOrDefault("X-Amz-Security-Token")
  valid_620259 = validateParameter(valid_620259, JString, required = false,
                                 default = nil)
  if valid_620259 != nil:
    section.add "X-Amz-Security-Token", valid_620259
  var valid_620260 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620260 = validateParameter(valid_620260, JString, required = false,
                                 default = nil)
  if valid_620260 != nil:
    section.add "X-Amz-Content-Sha256", valid_620260
  var valid_620261 = header.getOrDefault("X-Amz-Algorithm")
  valid_620261 = validateParameter(valid_620261, JString, required = false,
                                 default = nil)
  if valid_620261 != nil:
    section.add "X-Amz-Algorithm", valid_620261
  var valid_620262 = header.getOrDefault("X-Amz-Signature")
  valid_620262 = validateParameter(valid_620262, JString, required = false,
                                 default = nil)
  if valid_620262 != nil:
    section.add "X-Amz-Signature", valid_620262
  var valid_620263 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620263 = validateParameter(valid_620263, JString, required = false,
                                 default = nil)
  if valid_620263 != nil:
    section.add "X-Amz-SignedHeaders", valid_620263
  var valid_620264 = header.getOrDefault("X-Amz-Credential")
  valid_620264 = validateParameter(valid_620264, JString, required = false,
                                 default = nil)
  if valid_620264 != nil:
    section.add "X-Amz-Credential", valid_620264
  result.add "header", section
  ## parameters in `formData` object:
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  section = newJObject()
  var valid_620265 = formData.getOrDefault("DisassociateSchedule")
  valid_620265 = validateParameter(valid_620265, JBool, required = false, default = nil)
  if valid_620265 != nil:
    section.add "DisassociateSchedule", valid_620265
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_620266 = formData.getOrDefault("ClusterIdentifier")
  valid_620266 = validateParameter(valid_620266, JString, required = true,
                                 default = nil)
  if valid_620266 != nil:
    section.add "ClusterIdentifier", valid_620266
  var valid_620267 = formData.getOrDefault("ScheduleIdentifier")
  valid_620267 = validateParameter(valid_620267, JString, required = false,
                                 default = nil)
  if valid_620267 != nil:
    section.add "ScheduleIdentifier", valid_620267
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620268: Call_PostModifyClusterSnapshotSchedule_620253;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_620268.validator(path, query, header, formData, body, _)
  let scheme = call_620268.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620268.url(scheme.get, call_620268.host, call_620268.base,
                         call_620268.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620268, url, valid, _)

proc call*(call_620269: Call_PostModifyClusterSnapshotSchedule_620253;
          ClusterIdentifier: string; DisassociateSchedule: bool = false;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Version: string (required)
  var query_620270 = newJObject()
  var formData_620271 = newJObject()
  add(formData_620271, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_620270, "Action", newJString(Action))
  add(formData_620271, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_620271, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_620270, "Version", newJString(Version))
  result = call_620269.call(nil, query_620270, nil, formData_620271, nil)

var postModifyClusterSnapshotSchedule* = Call_PostModifyClusterSnapshotSchedule_620253(
    name: "postModifyClusterSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_PostModifyClusterSnapshotSchedule_620254, base: "/",
    url: url_PostModifyClusterSnapshotSchedule_620255,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshotSchedule_620235 = ref object of OpenApiRestCall_616850
proc url_GetModifyClusterSnapshotSchedule_620237(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshotSchedule_620236(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: JString (required)
  section = newJObject()
  var valid_620238 = query.getOrDefault("Action")
  valid_620238 = validateParameter(valid_620238, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_620238 != nil:
    section.add "Action", valid_620238
  var valid_620239 = query.getOrDefault("ClusterIdentifier")
  valid_620239 = validateParameter(valid_620239, JString, required = true,
                                 default = nil)
  if valid_620239 != nil:
    section.add "ClusterIdentifier", valid_620239
  var valid_620240 = query.getOrDefault("ScheduleIdentifier")
  valid_620240 = validateParameter(valid_620240, JString, required = false,
                                 default = nil)
  if valid_620240 != nil:
    section.add "ScheduleIdentifier", valid_620240
  var valid_620241 = query.getOrDefault("DisassociateSchedule")
  valid_620241 = validateParameter(valid_620241, JBool, required = false, default = nil)
  if valid_620241 != nil:
    section.add "DisassociateSchedule", valid_620241
  var valid_620242 = query.getOrDefault("Version")
  valid_620242 = validateParameter(valid_620242, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620242 != nil:
    section.add "Version", valid_620242
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620243 = header.getOrDefault("X-Amz-Date")
  valid_620243 = validateParameter(valid_620243, JString, required = false,
                                 default = nil)
  if valid_620243 != nil:
    section.add "X-Amz-Date", valid_620243
  var valid_620244 = header.getOrDefault("X-Amz-Security-Token")
  valid_620244 = validateParameter(valid_620244, JString, required = false,
                                 default = nil)
  if valid_620244 != nil:
    section.add "X-Amz-Security-Token", valid_620244
  var valid_620245 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620245 = validateParameter(valid_620245, JString, required = false,
                                 default = nil)
  if valid_620245 != nil:
    section.add "X-Amz-Content-Sha256", valid_620245
  var valid_620246 = header.getOrDefault("X-Amz-Algorithm")
  valid_620246 = validateParameter(valid_620246, JString, required = false,
                                 default = nil)
  if valid_620246 != nil:
    section.add "X-Amz-Algorithm", valid_620246
  var valid_620247 = header.getOrDefault("X-Amz-Signature")
  valid_620247 = validateParameter(valid_620247, JString, required = false,
                                 default = nil)
  if valid_620247 != nil:
    section.add "X-Amz-Signature", valid_620247
  var valid_620248 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620248 = validateParameter(valid_620248, JString, required = false,
                                 default = nil)
  if valid_620248 != nil:
    section.add "X-Amz-SignedHeaders", valid_620248
  var valid_620249 = header.getOrDefault("X-Amz-Credential")
  valid_620249 = validateParameter(valid_620249, JString, required = false,
                                 default = nil)
  if valid_620249 != nil:
    section.add "X-Amz-Credential", valid_620249
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620250: Call_GetModifyClusterSnapshotSchedule_620235;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_620250.validator(path, query, header, formData, body, _)
  let scheme = call_620250.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620250.url(scheme.get, call_620250.host, call_620250.base,
                         call_620250.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620250, url, valid, _)

proc call*(call_620251: Call_GetModifyClusterSnapshotSchedule_620235;
          ClusterIdentifier: string;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; DisassociateSchedule: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: string (required)
  var query_620252 = newJObject()
  add(query_620252, "Action", newJString(Action))
  add(query_620252, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620252, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_620252, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_620252, "Version", newJString(Version))
  result = call_620251.call(nil, query_620252, nil, nil, nil)

var getModifyClusterSnapshotSchedule* = Call_GetModifyClusterSnapshotSchedule_620235(
    name: "getModifyClusterSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_GetModifyClusterSnapshotSchedule_620236, base: "/",
    url: url_GetModifyClusterSnapshotSchedule_620237,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSubnetGroup_620290 = ref object of OpenApiRestCall_616850
proc url_PostModifyClusterSubnetGroup_620292(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSubnetGroup_620291(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620293 = query.getOrDefault("Action")
  valid_620293 = validateParameter(valid_620293, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_620293 != nil:
    section.add "Action", valid_620293
  var valid_620294 = query.getOrDefault("Version")
  valid_620294 = validateParameter(valid_620294, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620294 != nil:
    section.add "Version", valid_620294
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620295 = header.getOrDefault("X-Amz-Date")
  valid_620295 = validateParameter(valid_620295, JString, required = false,
                                 default = nil)
  if valid_620295 != nil:
    section.add "X-Amz-Date", valid_620295
  var valid_620296 = header.getOrDefault("X-Amz-Security-Token")
  valid_620296 = validateParameter(valid_620296, JString, required = false,
                                 default = nil)
  if valid_620296 != nil:
    section.add "X-Amz-Security-Token", valid_620296
  var valid_620297 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620297 = validateParameter(valid_620297, JString, required = false,
                                 default = nil)
  if valid_620297 != nil:
    section.add "X-Amz-Content-Sha256", valid_620297
  var valid_620298 = header.getOrDefault("X-Amz-Algorithm")
  valid_620298 = validateParameter(valid_620298, JString, required = false,
                                 default = nil)
  if valid_620298 != nil:
    section.add "X-Amz-Algorithm", valid_620298
  var valid_620299 = header.getOrDefault("X-Amz-Signature")
  valid_620299 = validateParameter(valid_620299, JString, required = false,
                                 default = nil)
  if valid_620299 != nil:
    section.add "X-Amz-Signature", valid_620299
  var valid_620300 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620300 = validateParameter(valid_620300, JString, required = false,
                                 default = nil)
  if valid_620300 != nil:
    section.add "X-Amz-SignedHeaders", valid_620300
  var valid_620301 = header.getOrDefault("X-Amz-Credential")
  valid_620301 = validateParameter(valid_620301, JString, required = false,
                                 default = nil)
  if valid_620301 != nil:
    section.add "X-Amz-Credential", valid_620301
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `SubnetIds` field"
  var valid_620302 = formData.getOrDefault("SubnetIds")
  valid_620302 = validateParameter(valid_620302, JArray, required = true, default = nil)
  if valid_620302 != nil:
    section.add "SubnetIds", valid_620302
  var valid_620303 = formData.getOrDefault("Description")
  valid_620303 = validateParameter(valid_620303, JString, required = false,
                                 default = nil)
  if valid_620303 != nil:
    section.add "Description", valid_620303
  var valid_620304 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_620304 = validateParameter(valid_620304, JString, required = true,
                                 default = nil)
  if valid_620304 != nil:
    section.add "ClusterSubnetGroupName", valid_620304
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620305: Call_PostModifyClusterSubnetGroup_620290;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_620305.validator(path, query, header, formData, body, _)
  let scheme = call_620305.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620305.url(scheme.get, call_620305.host, call_620305.base,
                         call_620305.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620305, url, valid, _)

proc call*(call_620306: Call_PostModifyClusterSubnetGroup_620290;
          SubnetIds: JsonNode; ClusterSubnetGroupName: string;
          Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"; Description: string = ""): Recallable =
  ## postModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  var query_620307 = newJObject()
  var formData_620308 = newJObject()
  if SubnetIds != nil:
    formData_620308.add "SubnetIds", SubnetIds
  add(query_620307, "Action", newJString(Action))
  add(query_620307, "Version", newJString(Version))
  add(formData_620308, "Description", newJString(Description))
  add(formData_620308, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_620306.call(nil, query_620307, nil, formData_620308, nil)

var postModifyClusterSubnetGroup* = Call_PostModifyClusterSubnetGroup_620290(
    name: "postModifyClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_PostModifyClusterSubnetGroup_620291, base: "/",
    url: url_PostModifyClusterSubnetGroup_620292,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSubnetGroup_620272 = ref object of OpenApiRestCall_616850
proc url_GetModifyClusterSubnetGroup_620274(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSubnetGroup_620273(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   Action: JString (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_620275 = query.getOrDefault("ClusterSubnetGroupName")
  valid_620275 = validateParameter(valid_620275, JString, required = true,
                                 default = nil)
  if valid_620275 != nil:
    section.add "ClusterSubnetGroupName", valid_620275
  var valid_620276 = query.getOrDefault("Description")
  valid_620276 = validateParameter(valid_620276, JString, required = false,
                                 default = nil)
  if valid_620276 != nil:
    section.add "Description", valid_620276
  var valid_620277 = query.getOrDefault("Action")
  valid_620277 = validateParameter(valid_620277, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_620277 != nil:
    section.add "Action", valid_620277
  var valid_620278 = query.getOrDefault("SubnetIds")
  valid_620278 = validateParameter(valid_620278, JArray, required = true, default = nil)
  if valid_620278 != nil:
    section.add "SubnetIds", valid_620278
  var valid_620279 = query.getOrDefault("Version")
  valid_620279 = validateParameter(valid_620279, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620279 != nil:
    section.add "Version", valid_620279
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620280 = header.getOrDefault("X-Amz-Date")
  valid_620280 = validateParameter(valid_620280, JString, required = false,
                                 default = nil)
  if valid_620280 != nil:
    section.add "X-Amz-Date", valid_620280
  var valid_620281 = header.getOrDefault("X-Amz-Security-Token")
  valid_620281 = validateParameter(valid_620281, JString, required = false,
                                 default = nil)
  if valid_620281 != nil:
    section.add "X-Amz-Security-Token", valid_620281
  var valid_620282 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620282 = validateParameter(valid_620282, JString, required = false,
                                 default = nil)
  if valid_620282 != nil:
    section.add "X-Amz-Content-Sha256", valid_620282
  var valid_620283 = header.getOrDefault("X-Amz-Algorithm")
  valid_620283 = validateParameter(valid_620283, JString, required = false,
                                 default = nil)
  if valid_620283 != nil:
    section.add "X-Amz-Algorithm", valid_620283
  var valid_620284 = header.getOrDefault("X-Amz-Signature")
  valid_620284 = validateParameter(valid_620284, JString, required = false,
                                 default = nil)
  if valid_620284 != nil:
    section.add "X-Amz-Signature", valid_620284
  var valid_620285 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620285 = validateParameter(valid_620285, JString, required = false,
                                 default = nil)
  if valid_620285 != nil:
    section.add "X-Amz-SignedHeaders", valid_620285
  var valid_620286 = header.getOrDefault("X-Amz-Credential")
  valid_620286 = validateParameter(valid_620286, JString, required = false,
                                 default = nil)
  if valid_620286 != nil:
    section.add "X-Amz-Credential", valid_620286
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620287: Call_GetModifyClusterSubnetGroup_620272;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_620287.validator(path, query, header, formData, body, _)
  let scheme = call_620287.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620287.url(scheme.get, call_620287.host, call_620287.base,
                         call_620287.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620287, url, valid, _)

proc call*(call_620288: Call_GetModifyClusterSubnetGroup_620272;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Description: string = ""; Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   Action: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: string (required)
  var query_620289 = newJObject()
  add(query_620289, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_620289, "Description", newJString(Description))
  add(query_620289, "Action", newJString(Action))
  if SubnetIds != nil:
    query_620289.add "SubnetIds", SubnetIds
  add(query_620289, "Version", newJString(Version))
  result = call_620288.call(nil, query_620289, nil, nil, nil)

var getModifyClusterSubnetGroup* = Call_GetModifyClusterSubnetGroup_620272(
    name: "getModifyClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_GetModifyClusterSubnetGroup_620273, base: "/",
    url: url_GetModifyClusterSubnetGroup_620274,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyEventSubscription_620331 = ref object of OpenApiRestCall_616850
proc url_PostModifyEventSubscription_620333(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyEventSubscription_620332(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620334 = query.getOrDefault("Action")
  valid_620334 = validateParameter(valid_620334, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_620334 != nil:
    section.add "Action", valid_620334
  var valid_620335 = query.getOrDefault("Version")
  valid_620335 = validateParameter(valid_620335, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620335 != nil:
    section.add "Version", valid_620335
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620336 = header.getOrDefault("X-Amz-Date")
  valid_620336 = validateParameter(valid_620336, JString, required = false,
                                 default = nil)
  if valid_620336 != nil:
    section.add "X-Amz-Date", valid_620336
  var valid_620337 = header.getOrDefault("X-Amz-Security-Token")
  valid_620337 = validateParameter(valid_620337, JString, required = false,
                                 default = nil)
  if valid_620337 != nil:
    section.add "X-Amz-Security-Token", valid_620337
  var valid_620338 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620338 = validateParameter(valid_620338, JString, required = false,
                                 default = nil)
  if valid_620338 != nil:
    section.add "X-Amz-Content-Sha256", valid_620338
  var valid_620339 = header.getOrDefault("X-Amz-Algorithm")
  valid_620339 = validateParameter(valid_620339, JString, required = false,
                                 default = nil)
  if valid_620339 != nil:
    section.add "X-Amz-Algorithm", valid_620339
  var valid_620340 = header.getOrDefault("X-Amz-Signature")
  valid_620340 = validateParameter(valid_620340, JString, required = false,
                                 default = nil)
  if valid_620340 != nil:
    section.add "X-Amz-Signature", valid_620340
  var valid_620341 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620341 = validateParameter(valid_620341, JString, required = false,
                                 default = nil)
  if valid_620341 != nil:
    section.add "X-Amz-SignedHeaders", valid_620341
  var valid_620342 = header.getOrDefault("X-Amz-Credential")
  valid_620342 = validateParameter(valid_620342, JString, required = false,
                                 default = nil)
  if valid_620342 != nil:
    section.add "X-Amz-Credential", valid_620342
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  section = newJObject()
  var valid_620343 = formData.getOrDefault("Enabled")
  valid_620343 = validateParameter(valid_620343, JBool, required = false, default = nil)
  if valid_620343 != nil:
    section.add "Enabled", valid_620343
  var valid_620344 = formData.getOrDefault("EventCategories")
  valid_620344 = validateParameter(valid_620344, JArray, required = false,
                                 default = nil)
  if valid_620344 != nil:
    section.add "EventCategories", valid_620344
  var valid_620345 = formData.getOrDefault("SnsTopicArn")
  valid_620345 = validateParameter(valid_620345, JString, required = false,
                                 default = nil)
  if valid_620345 != nil:
    section.add "SnsTopicArn", valid_620345
  var valid_620346 = formData.getOrDefault("Severity")
  valid_620346 = validateParameter(valid_620346, JString, required = false,
                                 default = nil)
  if valid_620346 != nil:
    section.add "Severity", valid_620346
  var valid_620347 = formData.getOrDefault("SourceIds")
  valid_620347 = validateParameter(valid_620347, JArray, required = false,
                                 default = nil)
  if valid_620347 != nil:
    section.add "SourceIds", valid_620347
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_620348 = formData.getOrDefault("SubscriptionName")
  valid_620348 = validateParameter(valid_620348, JString, required = true,
                                 default = nil)
  if valid_620348 != nil:
    section.add "SubscriptionName", valid_620348
  var valid_620349 = formData.getOrDefault("SourceType")
  valid_620349 = validateParameter(valid_620349, JString, required = false,
                                 default = nil)
  if valid_620349 != nil:
    section.add "SourceType", valid_620349
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620350: Call_PostModifyEventSubscription_620331;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_620350.validator(path, query, header, formData, body, _)
  let scheme = call_620350.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620350.url(scheme.get, call_620350.host, call_620350.base,
                         call_620350.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620350, url, valid, _)

proc call*(call_620351: Call_PostModifyEventSubscription_620331;
          SubscriptionName: string; Enabled: bool = false;
          EventCategories: JsonNode = nil; SnsTopicArn: string = "";
          Severity: string = ""; SourceIds: JsonNode = nil;
          Action: string = "ModifyEventSubscription";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  var query_620352 = newJObject()
  var formData_620353 = newJObject()
  add(formData_620353, "Enabled", newJBool(Enabled))
  if EventCategories != nil:
    formData_620353.add "EventCategories", EventCategories
  add(formData_620353, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_620353, "Severity", newJString(Severity))
  if SourceIds != nil:
    formData_620353.add "SourceIds", SourceIds
  add(formData_620353, "SubscriptionName", newJString(SubscriptionName))
  add(query_620352, "Action", newJString(Action))
  add(query_620352, "Version", newJString(Version))
  add(formData_620353, "SourceType", newJString(SourceType))
  result = call_620351.call(nil, query_620352, nil, formData_620353, nil)

var postModifyEventSubscription* = Call_PostModifyEventSubscription_620331(
    name: "postModifyEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_PostModifyEventSubscription_620332, base: "/",
    url: url_PostModifyEventSubscription_620333,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyEventSubscription_620309 = ref object of OpenApiRestCall_616850
proc url_GetModifyEventSubscription_620311(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyEventSubscription_620310(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Action: JString (required)
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_620312 = query.getOrDefault("SourceType")
  valid_620312 = validateParameter(valid_620312, JString, required = false,
                                 default = nil)
  if valid_620312 != nil:
    section.add "SourceType", valid_620312
  var valid_620313 = query.getOrDefault("SourceIds")
  valid_620313 = validateParameter(valid_620313, JArray, required = false,
                                 default = nil)
  if valid_620313 != nil:
    section.add "SourceIds", valid_620313
  var valid_620314 = query.getOrDefault("Enabled")
  valid_620314 = validateParameter(valid_620314, JBool, required = false, default = nil)
  if valid_620314 != nil:
    section.add "Enabled", valid_620314
  var valid_620315 = query.getOrDefault("Action")
  valid_620315 = validateParameter(valid_620315, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_620315 != nil:
    section.add "Action", valid_620315
  var valid_620316 = query.getOrDefault("SnsTopicArn")
  valid_620316 = validateParameter(valid_620316, JString, required = false,
                                 default = nil)
  if valid_620316 != nil:
    section.add "SnsTopicArn", valid_620316
  var valid_620317 = query.getOrDefault("EventCategories")
  valid_620317 = validateParameter(valid_620317, JArray, required = false,
                                 default = nil)
  if valid_620317 != nil:
    section.add "EventCategories", valid_620317
  var valid_620318 = query.getOrDefault("SubscriptionName")
  valid_620318 = validateParameter(valid_620318, JString, required = true,
                                 default = nil)
  if valid_620318 != nil:
    section.add "SubscriptionName", valid_620318
  var valid_620319 = query.getOrDefault("Severity")
  valid_620319 = validateParameter(valid_620319, JString, required = false,
                                 default = nil)
  if valid_620319 != nil:
    section.add "Severity", valid_620319
  var valid_620320 = query.getOrDefault("Version")
  valid_620320 = validateParameter(valid_620320, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620320 != nil:
    section.add "Version", valid_620320
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620321 = header.getOrDefault("X-Amz-Date")
  valid_620321 = validateParameter(valid_620321, JString, required = false,
                                 default = nil)
  if valid_620321 != nil:
    section.add "X-Amz-Date", valid_620321
  var valid_620322 = header.getOrDefault("X-Amz-Security-Token")
  valid_620322 = validateParameter(valid_620322, JString, required = false,
                                 default = nil)
  if valid_620322 != nil:
    section.add "X-Amz-Security-Token", valid_620322
  var valid_620323 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620323 = validateParameter(valid_620323, JString, required = false,
                                 default = nil)
  if valid_620323 != nil:
    section.add "X-Amz-Content-Sha256", valid_620323
  var valid_620324 = header.getOrDefault("X-Amz-Algorithm")
  valid_620324 = validateParameter(valid_620324, JString, required = false,
                                 default = nil)
  if valid_620324 != nil:
    section.add "X-Amz-Algorithm", valid_620324
  var valid_620325 = header.getOrDefault("X-Amz-Signature")
  valid_620325 = validateParameter(valid_620325, JString, required = false,
                                 default = nil)
  if valid_620325 != nil:
    section.add "X-Amz-Signature", valid_620325
  var valid_620326 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620326 = validateParameter(valid_620326, JString, required = false,
                                 default = nil)
  if valid_620326 != nil:
    section.add "X-Amz-SignedHeaders", valid_620326
  var valid_620327 = header.getOrDefault("X-Amz-Credential")
  valid_620327 = validateParameter(valid_620327, JString, required = false,
                                 default = nil)
  if valid_620327 != nil:
    section.add "X-Amz-Credential", valid_620327
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620328: Call_GetModifyEventSubscription_620309;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_620328.validator(path, query, header, formData, body, _)
  let scheme = call_620328.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620328.url(scheme.get, call_620328.host, call_620328.base,
                         call_620328.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620328, url, valid, _)

proc call*(call_620329: Call_GetModifyEventSubscription_620309;
          SubscriptionName: string; SourceType: string = "";
          SourceIds: JsonNode = nil; Enabled: bool = false;
          Action: string = "ModifyEventSubscription"; SnsTopicArn: string = "";
          EventCategories: JsonNode = nil; Severity: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, cluster-snapshot, and scheduled-action.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Action: string (required)
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: string (required)
  var query_620330 = newJObject()
  add(query_620330, "SourceType", newJString(SourceType))
  if SourceIds != nil:
    query_620330.add "SourceIds", SourceIds
  add(query_620330, "Enabled", newJBool(Enabled))
  add(query_620330, "Action", newJString(Action))
  add(query_620330, "SnsTopicArn", newJString(SnsTopicArn))
  if EventCategories != nil:
    query_620330.add "EventCategories", EventCategories
  add(query_620330, "SubscriptionName", newJString(SubscriptionName))
  add(query_620330, "Severity", newJString(Severity))
  add(query_620330, "Version", newJString(Version))
  result = call_620329.call(nil, query_620330, nil, nil, nil)

var getModifyEventSubscription* = Call_GetModifyEventSubscription_620309(
    name: "getModifyEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_GetModifyEventSubscription_620310, base: "/",
    url: url_GetModifyEventSubscription_620311,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyScheduledAction_620377 = ref object of OpenApiRestCall_616850
proc url_PostModifyScheduledAction_620379(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyScheduledAction_620378(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620380 = query.getOrDefault("Action")
  valid_620380 = validateParameter(valid_620380, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_620380 != nil:
    section.add "Action", valid_620380
  var valid_620381 = query.getOrDefault("Version")
  valid_620381 = validateParameter(valid_620381, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620381 != nil:
    section.add "Version", valid_620381
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620382 = header.getOrDefault("X-Amz-Date")
  valid_620382 = validateParameter(valid_620382, JString, required = false,
                                 default = nil)
  if valid_620382 != nil:
    section.add "X-Amz-Date", valid_620382
  var valid_620383 = header.getOrDefault("X-Amz-Security-Token")
  valid_620383 = validateParameter(valid_620383, JString, required = false,
                                 default = nil)
  if valid_620383 != nil:
    section.add "X-Amz-Security-Token", valid_620383
  var valid_620384 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620384 = validateParameter(valid_620384, JString, required = false,
                                 default = nil)
  if valid_620384 != nil:
    section.add "X-Amz-Content-Sha256", valid_620384
  var valid_620385 = header.getOrDefault("X-Amz-Algorithm")
  valid_620385 = validateParameter(valid_620385, JString, required = false,
                                 default = nil)
  if valid_620385 != nil:
    section.add "X-Amz-Algorithm", valid_620385
  var valid_620386 = header.getOrDefault("X-Amz-Signature")
  valid_620386 = validateParameter(valid_620386, JString, required = false,
                                 default = nil)
  if valid_620386 != nil:
    section.add "X-Amz-Signature", valid_620386
  var valid_620387 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620387 = validateParameter(valid_620387, JString, required = false,
                                 default = nil)
  if valid_620387 != nil:
    section.add "X-Amz-SignedHeaders", valid_620387
  var valid_620388 = header.getOrDefault("X-Amz-Credential")
  valid_620388 = validateParameter(valid_620388, JString, required = false,
                                 default = nil)
  if valid_620388 != nil:
    section.add "X-Amz-Credential", valid_620388
  result.add "header", section
  ## parameters in `formData` object:
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  section = newJObject()
  var valid_620389 = formData.getOrDefault("Schedule")
  valid_620389 = validateParameter(valid_620389, JString, required = false,
                                 default = nil)
  if valid_620389 != nil:
    section.add "Schedule", valid_620389
  var valid_620390 = formData.getOrDefault("ScheduledActionDescription")
  valid_620390 = validateParameter(valid_620390, JString, required = false,
                                 default = nil)
  if valid_620390 != nil:
    section.add "ScheduledActionDescription", valid_620390
  var valid_620391 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_620391 = validateParameter(valid_620391, JString, required = false,
                                 default = nil)
  if valid_620391 != nil:
    section.add "TargetAction.ResizeCluster", valid_620391
  var valid_620392 = formData.getOrDefault("StartTime")
  valid_620392 = validateParameter(valid_620392, JString, required = false,
                                 default = nil)
  if valid_620392 != nil:
    section.add "StartTime", valid_620392
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_620393 = formData.getOrDefault("ScheduledActionName")
  valid_620393 = validateParameter(valid_620393, JString, required = true,
                                 default = nil)
  if valid_620393 != nil:
    section.add "ScheduledActionName", valid_620393
  var valid_620394 = formData.getOrDefault("Enable")
  valid_620394 = validateParameter(valid_620394, JBool, required = false, default = nil)
  if valid_620394 != nil:
    section.add "Enable", valid_620394
  var valid_620395 = formData.getOrDefault("IamRole")
  valid_620395 = validateParameter(valid_620395, JString, required = false,
                                 default = nil)
  if valid_620395 != nil:
    section.add "IamRole", valid_620395
  var valid_620396 = formData.getOrDefault("EndTime")
  valid_620396 = validateParameter(valid_620396, JString, required = false,
                                 default = nil)
  if valid_620396 != nil:
    section.add "EndTime", valid_620396
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620397: Call_PostModifyScheduledAction_620377;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies a scheduled action. 
  ## 
  let valid = call_620397.validator(path, query, header, formData, body, _)
  let scheme = call_620397.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620397.url(scheme.get, call_620397.host, call_620397.base,
                         call_620397.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620397, url, valid, _)

proc call*(call_620398: Call_PostModifyScheduledAction_620377;
          ScheduledActionName: string; Schedule: string = "";
          ScheduledActionDescription: string = "";
          TargetActionResizeCluster: string = ""; StartTime: string = "";
          Action: string = "ModifyScheduledAction"; Enable: bool = false;
          IamRole: string = ""; EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyScheduledAction
  ## Modifies a scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Action: string (required)
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_620399 = newJObject()
  var formData_620400 = newJObject()
  add(formData_620400, "Schedule", newJString(Schedule))
  add(formData_620400, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_620400, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_620400, "StartTime", newJString(StartTime))
  add(query_620399, "Action", newJString(Action))
  add(formData_620400, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_620400, "Enable", newJBool(Enable))
  add(formData_620400, "IamRole", newJString(IamRole))
  add(formData_620400, "EndTime", newJString(EndTime))
  add(query_620399, "Version", newJString(Version))
  result = call_620398.call(nil, query_620399, nil, formData_620400, nil)

var postModifyScheduledAction* = Call_PostModifyScheduledAction_620377(
    name: "postModifyScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_PostModifyScheduledAction_620378, base: "/",
    url: url_PostModifyScheduledAction_620379,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyScheduledAction_620354 = ref object of OpenApiRestCall_616850
proc url_GetModifyScheduledAction_620356(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyScheduledAction_620355(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   Action: JString (required)
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  section = newJObject()
  var valid_620357 = query.getOrDefault("Schedule")
  valid_620357 = validateParameter(valid_620357, JString, required = false,
                                 default = nil)
  if valid_620357 != nil:
    section.add "Schedule", valid_620357
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_620358 = query.getOrDefault("ScheduledActionName")
  valid_620358 = validateParameter(valid_620358, JString, required = true,
                                 default = nil)
  if valid_620358 != nil:
    section.add "ScheduledActionName", valid_620358
  var valid_620359 = query.getOrDefault("StartTime")
  valid_620359 = validateParameter(valid_620359, JString, required = false,
                                 default = nil)
  if valid_620359 != nil:
    section.add "StartTime", valid_620359
  var valid_620360 = query.getOrDefault("IamRole")
  valid_620360 = validateParameter(valid_620360, JString, required = false,
                                 default = nil)
  if valid_620360 != nil:
    section.add "IamRole", valid_620360
  var valid_620361 = query.getOrDefault("Enable")
  valid_620361 = validateParameter(valid_620361, JBool, required = false, default = nil)
  if valid_620361 != nil:
    section.add "Enable", valid_620361
  var valid_620362 = query.getOrDefault("Action")
  valid_620362 = validateParameter(valid_620362, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_620362 != nil:
    section.add "Action", valid_620362
  var valid_620363 = query.getOrDefault("EndTime")
  valid_620363 = validateParameter(valid_620363, JString, required = false,
                                 default = nil)
  if valid_620363 != nil:
    section.add "EndTime", valid_620363
  var valid_620364 = query.getOrDefault("Version")
  valid_620364 = validateParameter(valid_620364, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620364 != nil:
    section.add "Version", valid_620364
  var valid_620365 = query.getOrDefault("ScheduledActionDescription")
  valid_620365 = validateParameter(valid_620365, JString, required = false,
                                 default = nil)
  if valid_620365 != nil:
    section.add "ScheduledActionDescription", valid_620365
  var valid_620366 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_620366 = validateParameter(valid_620366, JString, required = false,
                                 default = nil)
  if valid_620366 != nil:
    section.add "TargetAction.ResizeCluster", valid_620366
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620367 = header.getOrDefault("X-Amz-Date")
  valid_620367 = validateParameter(valid_620367, JString, required = false,
                                 default = nil)
  if valid_620367 != nil:
    section.add "X-Amz-Date", valid_620367
  var valid_620368 = header.getOrDefault("X-Amz-Security-Token")
  valid_620368 = validateParameter(valid_620368, JString, required = false,
                                 default = nil)
  if valid_620368 != nil:
    section.add "X-Amz-Security-Token", valid_620368
  var valid_620369 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620369 = validateParameter(valid_620369, JString, required = false,
                                 default = nil)
  if valid_620369 != nil:
    section.add "X-Amz-Content-Sha256", valid_620369
  var valid_620370 = header.getOrDefault("X-Amz-Algorithm")
  valid_620370 = validateParameter(valid_620370, JString, required = false,
                                 default = nil)
  if valid_620370 != nil:
    section.add "X-Amz-Algorithm", valid_620370
  var valid_620371 = header.getOrDefault("X-Amz-Signature")
  valid_620371 = validateParameter(valid_620371, JString, required = false,
                                 default = nil)
  if valid_620371 != nil:
    section.add "X-Amz-Signature", valid_620371
  var valid_620372 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620372 = validateParameter(valid_620372, JString, required = false,
                                 default = nil)
  if valid_620372 != nil:
    section.add "X-Amz-SignedHeaders", valid_620372
  var valid_620373 = header.getOrDefault("X-Amz-Credential")
  valid_620373 = validateParameter(valid_620373, JString, required = false,
                                 default = nil)
  if valid_620373 != nil:
    section.add "X-Amz-Credential", valid_620373
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620374: Call_GetModifyScheduledAction_620354; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies a scheduled action. 
  ## 
  let valid = call_620374.validator(path, query, header, formData, body, _)
  let scheme = call_620374.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620374.url(scheme.get, call_620374.host, call_620374.base,
                         call_620374.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620374, url, valid, _)

proc call*(call_620375: Call_GetModifyScheduledAction_620354;
          ScheduledActionName: string; Schedule: string = ""; StartTime: string = "";
          IamRole: string = ""; Enable: bool = false;
          Action: string = "ModifyScheduledAction"; EndTime: string = "";
          Version: string = "2012-12-01"; ScheduledActionDescription: string = "";
          TargetActionResizeCluster: string = ""): Recallable =
  ## getModifyScheduledAction
  ## Modifies a scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   Action: string (required)
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  var query_620376 = newJObject()
  add(query_620376, "Schedule", newJString(Schedule))
  add(query_620376, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_620376, "StartTime", newJString(StartTime))
  add(query_620376, "IamRole", newJString(IamRole))
  add(query_620376, "Enable", newJBool(Enable))
  add(query_620376, "Action", newJString(Action))
  add(query_620376, "EndTime", newJString(EndTime))
  add(query_620376, "Version", newJString(Version))
  add(query_620376, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_620376, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  result = call_620375.call(nil, query_620376, nil, nil, nil)

var getModifyScheduledAction* = Call_GetModifyScheduledAction_620354(
    name: "getModifyScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_GetModifyScheduledAction_620355, base: "/",
    url: url_GetModifyScheduledAction_620356, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotCopyRetentionPeriod_620419 = ref object of OpenApiRestCall_616850
proc url_PostModifySnapshotCopyRetentionPeriod_620421(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotCopyRetentionPeriod_620420(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620422 = query.getOrDefault("Action")
  valid_620422 = validateParameter(valid_620422, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_620422 != nil:
    section.add "Action", valid_620422
  var valid_620423 = query.getOrDefault("Version")
  valid_620423 = validateParameter(valid_620423, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620423 != nil:
    section.add "Version", valid_620423
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620424 = header.getOrDefault("X-Amz-Date")
  valid_620424 = validateParameter(valid_620424, JString, required = false,
                                 default = nil)
  if valid_620424 != nil:
    section.add "X-Amz-Date", valid_620424
  var valid_620425 = header.getOrDefault("X-Amz-Security-Token")
  valid_620425 = validateParameter(valid_620425, JString, required = false,
                                 default = nil)
  if valid_620425 != nil:
    section.add "X-Amz-Security-Token", valid_620425
  var valid_620426 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620426 = validateParameter(valid_620426, JString, required = false,
                                 default = nil)
  if valid_620426 != nil:
    section.add "X-Amz-Content-Sha256", valid_620426
  var valid_620427 = header.getOrDefault("X-Amz-Algorithm")
  valid_620427 = validateParameter(valid_620427, JString, required = false,
                                 default = nil)
  if valid_620427 != nil:
    section.add "X-Amz-Algorithm", valid_620427
  var valid_620428 = header.getOrDefault("X-Amz-Signature")
  valid_620428 = validateParameter(valid_620428, JString, required = false,
                                 default = nil)
  if valid_620428 != nil:
    section.add "X-Amz-Signature", valid_620428
  var valid_620429 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620429 = validateParameter(valid_620429, JString, required = false,
                                 default = nil)
  if valid_620429 != nil:
    section.add "X-Amz-SignedHeaders", valid_620429
  var valid_620430 = header.getOrDefault("X-Amz-Credential")
  valid_620430 = validateParameter(valid_620430, JString, required = false,
                                 default = nil)
  if valid_620430 != nil:
    section.add "X-Amz-Credential", valid_620430
  result.add "header", section
  ## parameters in `formData` object:
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `RetentionPeriod` field"
  var valid_620431 = formData.getOrDefault("RetentionPeriod")
  valid_620431 = validateParameter(valid_620431, JInt, required = true, default = nil)
  if valid_620431 != nil:
    section.add "RetentionPeriod", valid_620431
  var valid_620432 = formData.getOrDefault("Manual")
  valid_620432 = validateParameter(valid_620432, JBool, required = false, default = nil)
  if valid_620432 != nil:
    section.add "Manual", valid_620432
  var valid_620433 = formData.getOrDefault("ClusterIdentifier")
  valid_620433 = validateParameter(valid_620433, JString, required = true,
                                 default = nil)
  if valid_620433 != nil:
    section.add "ClusterIdentifier", valid_620433
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620434: Call_PostModifySnapshotCopyRetentionPeriod_620419;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_620434.validator(path, query, header, formData, body, _)
  let scheme = call_620434.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620434.url(scheme.get, call_620434.host, call_620434.base,
                         call_620434.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620434, url, valid, _)

proc call*(call_620435: Call_PostModifySnapshotCopyRetentionPeriod_620419;
          RetentionPeriod: int; ClusterIdentifier: string; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_620436 = newJObject()
  var formData_620437 = newJObject()
  add(formData_620437, "RetentionPeriod", newJInt(RetentionPeriod))
  add(formData_620437, "Manual", newJBool(Manual))
  add(query_620436, "Action", newJString(Action))
  add(formData_620437, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620436, "Version", newJString(Version))
  result = call_620435.call(nil, query_620436, nil, formData_620437, nil)

var postModifySnapshotCopyRetentionPeriod* = Call_PostModifySnapshotCopyRetentionPeriod_620419(
    name: "postModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_PostModifySnapshotCopyRetentionPeriod_620420, base: "/",
    url: url_PostModifySnapshotCopyRetentionPeriod_620421,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotCopyRetentionPeriod_620401 = ref object of OpenApiRestCall_616850
proc url_GetModifySnapshotCopyRetentionPeriod_620403(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotCopyRetentionPeriod_620402(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_620404 = query.getOrDefault("Manual")
  valid_620404 = validateParameter(valid_620404, JBool, required = false, default = nil)
  if valid_620404 != nil:
    section.add "Manual", valid_620404
  var valid_620405 = query.getOrDefault("Action")
  valid_620405 = validateParameter(valid_620405, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_620405 != nil:
    section.add "Action", valid_620405
  var valid_620406 = query.getOrDefault("ClusterIdentifier")
  valid_620406 = validateParameter(valid_620406, JString, required = true,
                                 default = nil)
  if valid_620406 != nil:
    section.add "ClusterIdentifier", valid_620406
  var valid_620407 = query.getOrDefault("RetentionPeriod")
  valid_620407 = validateParameter(valid_620407, JInt, required = true, default = nil)
  if valid_620407 != nil:
    section.add "RetentionPeriod", valid_620407
  var valid_620408 = query.getOrDefault("Version")
  valid_620408 = validateParameter(valid_620408, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620408 != nil:
    section.add "Version", valid_620408
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620409 = header.getOrDefault("X-Amz-Date")
  valid_620409 = validateParameter(valid_620409, JString, required = false,
                                 default = nil)
  if valid_620409 != nil:
    section.add "X-Amz-Date", valid_620409
  var valid_620410 = header.getOrDefault("X-Amz-Security-Token")
  valid_620410 = validateParameter(valid_620410, JString, required = false,
                                 default = nil)
  if valid_620410 != nil:
    section.add "X-Amz-Security-Token", valid_620410
  var valid_620411 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620411 = validateParameter(valid_620411, JString, required = false,
                                 default = nil)
  if valid_620411 != nil:
    section.add "X-Amz-Content-Sha256", valid_620411
  var valid_620412 = header.getOrDefault("X-Amz-Algorithm")
  valid_620412 = validateParameter(valid_620412, JString, required = false,
                                 default = nil)
  if valid_620412 != nil:
    section.add "X-Amz-Algorithm", valid_620412
  var valid_620413 = header.getOrDefault("X-Amz-Signature")
  valid_620413 = validateParameter(valid_620413, JString, required = false,
                                 default = nil)
  if valid_620413 != nil:
    section.add "X-Amz-Signature", valid_620413
  var valid_620414 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620414 = validateParameter(valid_620414, JString, required = false,
                                 default = nil)
  if valid_620414 != nil:
    section.add "X-Amz-SignedHeaders", valid_620414
  var valid_620415 = header.getOrDefault("X-Amz-Credential")
  valid_620415 = validateParameter(valid_620415, JString, required = false,
                                 default = nil)
  if valid_620415 != nil:
    section.add "X-Amz-Credential", valid_620415
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620416: Call_GetModifySnapshotCopyRetentionPeriod_620401;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_620416.validator(path, query, header, formData, body, _)
  let scheme = call_620416.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620416.url(scheme.get, call_620416.host, call_620416.base,
                         call_620416.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620416, url, valid, _)

proc call*(call_620417: Call_GetModifySnapshotCopyRetentionPeriod_620401;
          ClusterIdentifier: string; RetentionPeriod: int; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Version: string (required)
  var query_620418 = newJObject()
  add(query_620418, "Manual", newJBool(Manual))
  add(query_620418, "Action", newJString(Action))
  add(query_620418, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620418, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_620418, "Version", newJString(Version))
  result = call_620417.call(nil, query_620418, nil, nil, nil)

var getModifySnapshotCopyRetentionPeriod* = Call_GetModifySnapshotCopyRetentionPeriod_620401(
    name: "getModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_GetModifySnapshotCopyRetentionPeriod_620402, base: "/",
    url: url_GetModifySnapshotCopyRetentionPeriod_620403,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotSchedule_620455 = ref object of OpenApiRestCall_616850
proc url_PostModifySnapshotSchedule_620457(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotSchedule_620456(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620458 = query.getOrDefault("Action")
  valid_620458 = validateParameter(valid_620458, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_620458 != nil:
    section.add "Action", valid_620458
  var valid_620459 = query.getOrDefault("Version")
  valid_620459 = validateParameter(valid_620459, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620459 != nil:
    section.add "Version", valid_620459
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620460 = header.getOrDefault("X-Amz-Date")
  valid_620460 = validateParameter(valid_620460, JString, required = false,
                                 default = nil)
  if valid_620460 != nil:
    section.add "X-Amz-Date", valid_620460
  var valid_620461 = header.getOrDefault("X-Amz-Security-Token")
  valid_620461 = validateParameter(valid_620461, JString, required = false,
                                 default = nil)
  if valid_620461 != nil:
    section.add "X-Amz-Security-Token", valid_620461
  var valid_620462 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620462 = validateParameter(valid_620462, JString, required = false,
                                 default = nil)
  if valid_620462 != nil:
    section.add "X-Amz-Content-Sha256", valid_620462
  var valid_620463 = header.getOrDefault("X-Amz-Algorithm")
  valid_620463 = validateParameter(valid_620463, JString, required = false,
                                 default = nil)
  if valid_620463 != nil:
    section.add "X-Amz-Algorithm", valid_620463
  var valid_620464 = header.getOrDefault("X-Amz-Signature")
  valid_620464 = validateParameter(valid_620464, JString, required = false,
                                 default = nil)
  if valid_620464 != nil:
    section.add "X-Amz-Signature", valid_620464
  var valid_620465 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620465 = validateParameter(valid_620465, JString, required = false,
                                 default = nil)
  if valid_620465 != nil:
    section.add "X-Amz-SignedHeaders", valid_620465
  var valid_620466 = header.getOrDefault("X-Amz-Credential")
  valid_620466 = validateParameter(valid_620466, JString, required = false,
                                 default = nil)
  if valid_620466 != nil:
    section.add "X-Amz-Credential", valid_620466
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleIdentifier` field"
  var valid_620467 = formData.getOrDefault("ScheduleIdentifier")
  valid_620467 = validateParameter(valid_620467, JString, required = true,
                                 default = nil)
  if valid_620467 != nil:
    section.add "ScheduleIdentifier", valid_620467
  var valid_620468 = formData.getOrDefault("ScheduleDefinitions")
  valid_620468 = validateParameter(valid_620468, JArray, required = true, default = nil)
  if valid_620468 != nil:
    section.add "ScheduleDefinitions", valid_620468
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620469: Call_PostModifySnapshotSchedule_620455;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_620469.validator(path, query, header, formData, body, _)
  let scheme = call_620469.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620469.url(scheme.get, call_620469.host, call_620469.base,
                         call_620469.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620469, url, valid, _)

proc call*(call_620470: Call_PostModifySnapshotSchedule_620455;
          ScheduleIdentifier: string; ScheduleDefinitions: JsonNode;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Version: string (required)
  var query_620471 = newJObject()
  var formData_620472 = newJObject()
  add(query_620471, "Action", newJString(Action))
  add(formData_620472, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if ScheduleDefinitions != nil:
    formData_620472.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_620471, "Version", newJString(Version))
  result = call_620470.call(nil, query_620471, nil, formData_620472, nil)

var postModifySnapshotSchedule* = Call_PostModifySnapshotSchedule_620455(
    name: "postModifySnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_PostModifySnapshotSchedule_620456, base: "/",
    url: url_PostModifySnapshotSchedule_620457,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotSchedule_620438 = ref object of OpenApiRestCall_616850
proc url_GetModifySnapshotSchedule_620440(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotSchedule_620439(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleDefinitions` field"
  var valid_620441 = query.getOrDefault("ScheduleDefinitions")
  valid_620441 = validateParameter(valid_620441, JArray, required = true, default = nil)
  if valid_620441 != nil:
    section.add "ScheduleDefinitions", valid_620441
  var valid_620442 = query.getOrDefault("Action")
  valid_620442 = validateParameter(valid_620442, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_620442 != nil:
    section.add "Action", valid_620442
  var valid_620443 = query.getOrDefault("ScheduleIdentifier")
  valid_620443 = validateParameter(valid_620443, JString, required = true,
                                 default = nil)
  if valid_620443 != nil:
    section.add "ScheduleIdentifier", valid_620443
  var valid_620444 = query.getOrDefault("Version")
  valid_620444 = validateParameter(valid_620444, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620444 != nil:
    section.add "Version", valid_620444
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620445 = header.getOrDefault("X-Amz-Date")
  valid_620445 = validateParameter(valid_620445, JString, required = false,
                                 default = nil)
  if valid_620445 != nil:
    section.add "X-Amz-Date", valid_620445
  var valid_620446 = header.getOrDefault("X-Amz-Security-Token")
  valid_620446 = validateParameter(valid_620446, JString, required = false,
                                 default = nil)
  if valid_620446 != nil:
    section.add "X-Amz-Security-Token", valid_620446
  var valid_620447 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620447 = validateParameter(valid_620447, JString, required = false,
                                 default = nil)
  if valid_620447 != nil:
    section.add "X-Amz-Content-Sha256", valid_620447
  var valid_620448 = header.getOrDefault("X-Amz-Algorithm")
  valid_620448 = validateParameter(valid_620448, JString, required = false,
                                 default = nil)
  if valid_620448 != nil:
    section.add "X-Amz-Algorithm", valid_620448
  var valid_620449 = header.getOrDefault("X-Amz-Signature")
  valid_620449 = validateParameter(valid_620449, JString, required = false,
                                 default = nil)
  if valid_620449 != nil:
    section.add "X-Amz-Signature", valid_620449
  var valid_620450 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620450 = validateParameter(valid_620450, JString, required = false,
                                 default = nil)
  if valid_620450 != nil:
    section.add "X-Amz-SignedHeaders", valid_620450
  var valid_620451 = header.getOrDefault("X-Amz-Credential")
  valid_620451 = validateParameter(valid_620451, JString, required = false,
                                 default = nil)
  if valid_620451 != nil:
    section.add "X-Amz-Credential", valid_620451
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620452: Call_GetModifySnapshotSchedule_620438;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_620452.validator(path, query, header, formData, body, _)
  let scheme = call_620452.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620452.url(scheme.get, call_620452.host, call_620452.base,
                         call_620452.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620452, url, valid, _)

proc call*(call_620453: Call_GetModifySnapshotSchedule_620438;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_620454 = newJObject()
  if ScheduleDefinitions != nil:
    query_620454.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_620454, "Action", newJString(Action))
  add(query_620454, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_620454, "Version", newJString(Version))
  result = call_620453.call(nil, query_620454, nil, nil, nil)

var getModifySnapshotSchedule* = Call_GetModifySnapshotSchedule_620438(
    name: "getModifySnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_GetModifySnapshotSchedule_620439, base: "/",
    url: url_GetModifySnapshotSchedule_620440,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostPurchaseReservedNodeOffering_620490 = ref object of OpenApiRestCall_616850
proc url_PostPurchaseReservedNodeOffering_620492(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostPurchaseReservedNodeOffering_620491(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620493 = query.getOrDefault("Action")
  valid_620493 = validateParameter(valid_620493, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_620493 != nil:
    section.add "Action", valid_620493
  var valid_620494 = query.getOrDefault("Version")
  valid_620494 = validateParameter(valid_620494, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620494 != nil:
    section.add "Version", valid_620494
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620495 = header.getOrDefault("X-Amz-Date")
  valid_620495 = validateParameter(valid_620495, JString, required = false,
                                 default = nil)
  if valid_620495 != nil:
    section.add "X-Amz-Date", valid_620495
  var valid_620496 = header.getOrDefault("X-Amz-Security-Token")
  valid_620496 = validateParameter(valid_620496, JString, required = false,
                                 default = nil)
  if valid_620496 != nil:
    section.add "X-Amz-Security-Token", valid_620496
  var valid_620497 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620497 = validateParameter(valid_620497, JString, required = false,
                                 default = nil)
  if valid_620497 != nil:
    section.add "X-Amz-Content-Sha256", valid_620497
  var valid_620498 = header.getOrDefault("X-Amz-Algorithm")
  valid_620498 = validateParameter(valid_620498, JString, required = false,
                                 default = nil)
  if valid_620498 != nil:
    section.add "X-Amz-Algorithm", valid_620498
  var valid_620499 = header.getOrDefault("X-Amz-Signature")
  valid_620499 = validateParameter(valid_620499, JString, required = false,
                                 default = nil)
  if valid_620499 != nil:
    section.add "X-Amz-Signature", valid_620499
  var valid_620500 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620500 = validateParameter(valid_620500, JString, required = false,
                                 default = nil)
  if valid_620500 != nil:
    section.add "X-Amz-SignedHeaders", valid_620500
  var valid_620501 = header.getOrDefault("X-Amz-Credential")
  valid_620501 = validateParameter(valid_620501, JString, required = false,
                                 default = nil)
  if valid_620501 != nil:
    section.add "X-Amz-Credential", valid_620501
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_620502 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_620502 = validateParameter(valid_620502, JString, required = true,
                                 default = nil)
  if valid_620502 != nil:
    section.add "ReservedNodeOfferingId", valid_620502
  var valid_620503 = formData.getOrDefault("NodeCount")
  valid_620503 = validateParameter(valid_620503, JInt, required = false, default = nil)
  if valid_620503 != nil:
    section.add "NodeCount", valid_620503
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620504: Call_PostPurchaseReservedNodeOffering_620490;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_620504.validator(path, query, header, formData, body, _)
  let scheme = call_620504.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620504.url(scheme.get, call_620504.host, call_620504.base,
                         call_620504.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620504, url, valid, _)

proc call*(call_620505: Call_PostPurchaseReservedNodeOffering_620490;
          ReservedNodeOfferingId: string; NodeCount: int = 0;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"): Recallable =
  ## postPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_620506 = newJObject()
  var formData_620507 = newJObject()
  add(formData_620507, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_620507, "NodeCount", newJInt(NodeCount))
  add(query_620506, "Action", newJString(Action))
  add(query_620506, "Version", newJString(Version))
  result = call_620505.call(nil, query_620506, nil, formData_620507, nil)

var postPurchaseReservedNodeOffering* = Call_PostPurchaseReservedNodeOffering_620490(
    name: "postPurchaseReservedNodeOffering", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_PostPurchaseReservedNodeOffering_620491, base: "/",
    url: url_PostPurchaseReservedNodeOffering_620492,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPurchaseReservedNodeOffering_620473 = ref object of OpenApiRestCall_616850
proc url_GetPurchaseReservedNodeOffering_620475(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetPurchaseReservedNodeOffering_620474(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: JString (required)
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_620476 = query.getOrDefault("ReservedNodeOfferingId")
  valid_620476 = validateParameter(valid_620476, JString, required = true,
                                 default = nil)
  if valid_620476 != nil:
    section.add "ReservedNodeOfferingId", valid_620476
  var valid_620477 = query.getOrDefault("Action")
  valid_620477 = validateParameter(valid_620477, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_620477 != nil:
    section.add "Action", valid_620477
  var valid_620478 = query.getOrDefault("NodeCount")
  valid_620478 = validateParameter(valid_620478, JInt, required = false, default = nil)
  if valid_620478 != nil:
    section.add "NodeCount", valid_620478
  var valid_620479 = query.getOrDefault("Version")
  valid_620479 = validateParameter(valid_620479, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620479 != nil:
    section.add "Version", valid_620479
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620480 = header.getOrDefault("X-Amz-Date")
  valid_620480 = validateParameter(valid_620480, JString, required = false,
                                 default = nil)
  if valid_620480 != nil:
    section.add "X-Amz-Date", valid_620480
  var valid_620481 = header.getOrDefault("X-Amz-Security-Token")
  valid_620481 = validateParameter(valid_620481, JString, required = false,
                                 default = nil)
  if valid_620481 != nil:
    section.add "X-Amz-Security-Token", valid_620481
  var valid_620482 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620482 = validateParameter(valid_620482, JString, required = false,
                                 default = nil)
  if valid_620482 != nil:
    section.add "X-Amz-Content-Sha256", valid_620482
  var valid_620483 = header.getOrDefault("X-Amz-Algorithm")
  valid_620483 = validateParameter(valid_620483, JString, required = false,
                                 default = nil)
  if valid_620483 != nil:
    section.add "X-Amz-Algorithm", valid_620483
  var valid_620484 = header.getOrDefault("X-Amz-Signature")
  valid_620484 = validateParameter(valid_620484, JString, required = false,
                                 default = nil)
  if valid_620484 != nil:
    section.add "X-Amz-Signature", valid_620484
  var valid_620485 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620485 = validateParameter(valid_620485, JString, required = false,
                                 default = nil)
  if valid_620485 != nil:
    section.add "X-Amz-SignedHeaders", valid_620485
  var valid_620486 = header.getOrDefault("X-Amz-Credential")
  valid_620486 = validateParameter(valid_620486, JString, required = false,
                                 default = nil)
  if valid_620486 != nil:
    section.add "X-Amz-Credential", valid_620486
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620487: Call_GetPurchaseReservedNodeOffering_620473;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_620487.validator(path, query, header, formData, body, _)
  let scheme = call_620487.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620487.url(scheme.get, call_620487.host, call_620487.base,
                         call_620487.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620487, url, valid, _)

proc call*(call_620488: Call_GetPurchaseReservedNodeOffering_620473;
          ReservedNodeOfferingId: string;
          Action: string = "PurchaseReservedNodeOffering"; NodeCount: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## getPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Version: string (required)
  var query_620489 = newJObject()
  add(query_620489, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_620489, "Action", newJString(Action))
  add(query_620489, "NodeCount", newJInt(NodeCount))
  add(query_620489, "Version", newJString(Version))
  result = call_620488.call(nil, query_620489, nil, nil, nil)

var getPurchaseReservedNodeOffering* = Call_GetPurchaseReservedNodeOffering_620473(
    name: "getPurchaseReservedNodeOffering", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_GetPurchaseReservedNodeOffering_620474, base: "/",
    url: url_GetPurchaseReservedNodeOffering_620475,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRebootCluster_620524 = ref object of OpenApiRestCall_616850
proc url_PostRebootCluster_620526(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRebootCluster_620525(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620527 = query.getOrDefault("Action")
  valid_620527 = validateParameter(valid_620527, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_620527 != nil:
    section.add "Action", valid_620527
  var valid_620528 = query.getOrDefault("Version")
  valid_620528 = validateParameter(valid_620528, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620528 != nil:
    section.add "Version", valid_620528
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620529 = header.getOrDefault("X-Amz-Date")
  valid_620529 = validateParameter(valid_620529, JString, required = false,
                                 default = nil)
  if valid_620529 != nil:
    section.add "X-Amz-Date", valid_620529
  var valid_620530 = header.getOrDefault("X-Amz-Security-Token")
  valid_620530 = validateParameter(valid_620530, JString, required = false,
                                 default = nil)
  if valid_620530 != nil:
    section.add "X-Amz-Security-Token", valid_620530
  var valid_620531 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620531 = validateParameter(valid_620531, JString, required = false,
                                 default = nil)
  if valid_620531 != nil:
    section.add "X-Amz-Content-Sha256", valid_620531
  var valid_620532 = header.getOrDefault("X-Amz-Algorithm")
  valid_620532 = validateParameter(valid_620532, JString, required = false,
                                 default = nil)
  if valid_620532 != nil:
    section.add "X-Amz-Algorithm", valid_620532
  var valid_620533 = header.getOrDefault("X-Amz-Signature")
  valid_620533 = validateParameter(valid_620533, JString, required = false,
                                 default = nil)
  if valid_620533 != nil:
    section.add "X-Amz-Signature", valid_620533
  var valid_620534 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620534 = validateParameter(valid_620534, JString, required = false,
                                 default = nil)
  if valid_620534 != nil:
    section.add "X-Amz-SignedHeaders", valid_620534
  var valid_620535 = header.getOrDefault("X-Amz-Credential")
  valid_620535 = validateParameter(valid_620535, JString, required = false,
                                 default = nil)
  if valid_620535 != nil:
    section.add "X-Amz-Credential", valid_620535
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_620536 = formData.getOrDefault("ClusterIdentifier")
  valid_620536 = validateParameter(valid_620536, JString, required = true,
                                 default = nil)
  if valid_620536 != nil:
    section.add "ClusterIdentifier", valid_620536
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620537: Call_PostRebootCluster_620524; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_620537.validator(path, query, header, formData, body, _)
  let scheme = call_620537.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620537.url(scheme.get, call_620537.host, call_620537.base,
                         call_620537.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620537, url, valid, _)

proc call*(call_620538: Call_PostRebootCluster_620524; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## postRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_620539 = newJObject()
  var formData_620540 = newJObject()
  add(query_620539, "Action", newJString(Action))
  add(formData_620540, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620539, "Version", newJString(Version))
  result = call_620538.call(nil, query_620539, nil, formData_620540, nil)

var postRebootCluster* = Call_PostRebootCluster_620524(name: "postRebootCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_PostRebootCluster_620525,
    base: "/", url: url_PostRebootCluster_620526,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRebootCluster_620508 = ref object of OpenApiRestCall_616850
proc url_GetRebootCluster_620510(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRebootCluster_620509(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  ##   Version: JString (required)
  section = newJObject()
  var valid_620511 = query.getOrDefault("Action")
  valid_620511 = validateParameter(valid_620511, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_620511 != nil:
    section.add "Action", valid_620511
  var valid_620512 = query.getOrDefault("ClusterIdentifier")
  valid_620512 = validateParameter(valid_620512, JString, required = true,
                                 default = nil)
  if valid_620512 != nil:
    section.add "ClusterIdentifier", valid_620512
  var valid_620513 = query.getOrDefault("Version")
  valid_620513 = validateParameter(valid_620513, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620513 != nil:
    section.add "Version", valid_620513
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620514 = header.getOrDefault("X-Amz-Date")
  valid_620514 = validateParameter(valid_620514, JString, required = false,
                                 default = nil)
  if valid_620514 != nil:
    section.add "X-Amz-Date", valid_620514
  var valid_620515 = header.getOrDefault("X-Amz-Security-Token")
  valid_620515 = validateParameter(valid_620515, JString, required = false,
                                 default = nil)
  if valid_620515 != nil:
    section.add "X-Amz-Security-Token", valid_620515
  var valid_620516 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620516 = validateParameter(valid_620516, JString, required = false,
                                 default = nil)
  if valid_620516 != nil:
    section.add "X-Amz-Content-Sha256", valid_620516
  var valid_620517 = header.getOrDefault("X-Amz-Algorithm")
  valid_620517 = validateParameter(valid_620517, JString, required = false,
                                 default = nil)
  if valid_620517 != nil:
    section.add "X-Amz-Algorithm", valid_620517
  var valid_620518 = header.getOrDefault("X-Amz-Signature")
  valid_620518 = validateParameter(valid_620518, JString, required = false,
                                 default = nil)
  if valid_620518 != nil:
    section.add "X-Amz-Signature", valid_620518
  var valid_620519 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620519 = validateParameter(valid_620519, JString, required = false,
                                 default = nil)
  if valid_620519 != nil:
    section.add "X-Amz-SignedHeaders", valid_620519
  var valid_620520 = header.getOrDefault("X-Amz-Credential")
  valid_620520 = validateParameter(valid_620520, JString, required = false,
                                 default = nil)
  if valid_620520 != nil:
    section.add "X-Amz-Credential", valid_620520
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620521: Call_GetRebootCluster_620508; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_620521.validator(path, query, header, formData, body, _)
  let scheme = call_620521.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620521.url(scheme.get, call_620521.host, call_620521.base,
                         call_620521.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620521, url, valid, _)

proc call*(call_620522: Call_GetRebootCluster_620508; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## getRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_620523 = newJObject()
  add(query_620523, "Action", newJString(Action))
  add(query_620523, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620523, "Version", newJString(Version))
  result = call_620522.call(nil, query_620523, nil, nil, nil)

var getRebootCluster* = Call_GetRebootCluster_620508(name: "getRebootCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_GetRebootCluster_620509,
    base: "/", url: url_GetRebootCluster_620510,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResetClusterParameterGroup_620559 = ref object of OpenApiRestCall_616850
proc url_PostResetClusterParameterGroup_620561(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResetClusterParameterGroup_620560(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620562 = query.getOrDefault("Action")
  valid_620562 = validateParameter(valid_620562, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_620562 != nil:
    section.add "Action", valid_620562
  var valid_620563 = query.getOrDefault("Version")
  valid_620563 = validateParameter(valid_620563, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620563 != nil:
    section.add "Version", valid_620563
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620564 = header.getOrDefault("X-Amz-Date")
  valid_620564 = validateParameter(valid_620564, JString, required = false,
                                 default = nil)
  if valid_620564 != nil:
    section.add "X-Amz-Date", valid_620564
  var valid_620565 = header.getOrDefault("X-Amz-Security-Token")
  valid_620565 = validateParameter(valid_620565, JString, required = false,
                                 default = nil)
  if valid_620565 != nil:
    section.add "X-Amz-Security-Token", valid_620565
  var valid_620566 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620566 = validateParameter(valid_620566, JString, required = false,
                                 default = nil)
  if valid_620566 != nil:
    section.add "X-Amz-Content-Sha256", valid_620566
  var valid_620567 = header.getOrDefault("X-Amz-Algorithm")
  valid_620567 = validateParameter(valid_620567, JString, required = false,
                                 default = nil)
  if valid_620567 != nil:
    section.add "X-Amz-Algorithm", valid_620567
  var valid_620568 = header.getOrDefault("X-Amz-Signature")
  valid_620568 = validateParameter(valid_620568, JString, required = false,
                                 default = nil)
  if valid_620568 != nil:
    section.add "X-Amz-Signature", valid_620568
  var valid_620569 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620569 = validateParameter(valid_620569, JString, required = false,
                                 default = nil)
  if valid_620569 != nil:
    section.add "X-Amz-SignedHeaders", valid_620569
  var valid_620570 = header.getOrDefault("X-Amz-Credential")
  valid_620570 = validateParameter(valid_620570, JString, required = false,
                                 default = nil)
  if valid_620570 != nil:
    section.add "X-Amz-Credential", valid_620570
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_620571 = formData.getOrDefault("ParameterGroupName")
  valid_620571 = validateParameter(valid_620571, JString, required = true,
                                 default = nil)
  if valid_620571 != nil:
    section.add "ParameterGroupName", valid_620571
  var valid_620572 = formData.getOrDefault("Parameters")
  valid_620572 = validateParameter(valid_620572, JArray, required = false,
                                 default = nil)
  if valid_620572 != nil:
    section.add "Parameters", valid_620572
  var valid_620573 = formData.getOrDefault("ResetAllParameters")
  valid_620573 = validateParameter(valid_620573, JBool, required = false, default = nil)
  if valid_620573 != nil:
    section.add "ResetAllParameters", valid_620573
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620574: Call_PostResetClusterParameterGroup_620559;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_620574.validator(path, query, header, formData, body, _)
  let scheme = call_620574.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620574.url(scheme.get, call_620574.host, call_620574.base,
                         call_620574.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620574, url, valid, _)

proc call*(call_620575: Call_PostResetClusterParameterGroup_620559;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          Action: string = "ResetClusterParameterGroup";
          ResetAllParameters: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: string (required)
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: string (required)
  var query_620576 = newJObject()
  var formData_620577 = newJObject()
  add(formData_620577, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    formData_620577.add "Parameters", Parameters
  add(query_620576, "Action", newJString(Action))
  add(formData_620577, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_620576, "Version", newJString(Version))
  result = call_620575.call(nil, query_620576, nil, formData_620577, nil)

var postResetClusterParameterGroup* = Call_PostResetClusterParameterGroup_620559(
    name: "postResetClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_PostResetClusterParameterGroup_620560, base: "/",
    url: url_PostResetClusterParameterGroup_620561,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResetClusterParameterGroup_620541 = ref object of OpenApiRestCall_616850
proc url_GetResetClusterParameterGroup_620543(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResetClusterParameterGroup_620542(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: JString (required)
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_620544 = query.getOrDefault("ParameterGroupName")
  valid_620544 = validateParameter(valid_620544, JString, required = true,
                                 default = nil)
  if valid_620544 != nil:
    section.add "ParameterGroupName", valid_620544
  var valid_620545 = query.getOrDefault("Parameters")
  valid_620545 = validateParameter(valid_620545, JArray, required = false,
                                 default = nil)
  if valid_620545 != nil:
    section.add "Parameters", valid_620545
  var valid_620546 = query.getOrDefault("Action")
  valid_620546 = validateParameter(valid_620546, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_620546 != nil:
    section.add "Action", valid_620546
  var valid_620547 = query.getOrDefault("ResetAllParameters")
  valid_620547 = validateParameter(valid_620547, JBool, required = false, default = nil)
  if valid_620547 != nil:
    section.add "ResetAllParameters", valid_620547
  var valid_620548 = query.getOrDefault("Version")
  valid_620548 = validateParameter(valid_620548, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620548 != nil:
    section.add "Version", valid_620548
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620549 = header.getOrDefault("X-Amz-Date")
  valid_620549 = validateParameter(valid_620549, JString, required = false,
                                 default = nil)
  if valid_620549 != nil:
    section.add "X-Amz-Date", valid_620549
  var valid_620550 = header.getOrDefault("X-Amz-Security-Token")
  valid_620550 = validateParameter(valid_620550, JString, required = false,
                                 default = nil)
  if valid_620550 != nil:
    section.add "X-Amz-Security-Token", valid_620550
  var valid_620551 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620551 = validateParameter(valid_620551, JString, required = false,
                                 default = nil)
  if valid_620551 != nil:
    section.add "X-Amz-Content-Sha256", valid_620551
  var valid_620552 = header.getOrDefault("X-Amz-Algorithm")
  valid_620552 = validateParameter(valid_620552, JString, required = false,
                                 default = nil)
  if valid_620552 != nil:
    section.add "X-Amz-Algorithm", valid_620552
  var valid_620553 = header.getOrDefault("X-Amz-Signature")
  valid_620553 = validateParameter(valid_620553, JString, required = false,
                                 default = nil)
  if valid_620553 != nil:
    section.add "X-Amz-Signature", valid_620553
  var valid_620554 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620554 = validateParameter(valid_620554, JString, required = false,
                                 default = nil)
  if valid_620554 != nil:
    section.add "X-Amz-SignedHeaders", valid_620554
  var valid_620555 = header.getOrDefault("X-Amz-Credential")
  valid_620555 = validateParameter(valid_620555, JString, required = false,
                                 default = nil)
  if valid_620555 != nil:
    section.add "X-Amz-Credential", valid_620555
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620556: Call_GetResetClusterParameterGroup_620541;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_620556.validator(path, query, header, formData, body, _)
  let scheme = call_620556.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620556.url(scheme.get, call_620556.host, call_620556.base,
                         call_620556.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620556, url, valid, _)

proc call*(call_620557: Call_GetResetClusterParameterGroup_620541;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          Action: string = "ResetClusterParameterGroup";
          ResetAllParameters: bool = false; Version: string = "2012-12-01"): Recallable =
  ## getResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: string (required)
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: string (required)
  var query_620558 = newJObject()
  add(query_620558, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    query_620558.add "Parameters", Parameters
  add(query_620558, "Action", newJString(Action))
  add(query_620558, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_620558, "Version", newJString(Version))
  result = call_620557.call(nil, query_620558, nil, nil, nil)

var getResetClusterParameterGroup* = Call_GetResetClusterParameterGroup_620541(
    name: "getResetClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_GetResetClusterParameterGroup_620542, base: "/",
    url: url_GetResetClusterParameterGroup_620543,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResizeCluster_620598 = ref object of OpenApiRestCall_616850
proc url_PostResizeCluster_620600(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResizeCluster_620599(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode; _: string = ""): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620601 = query.getOrDefault("Action")
  valid_620601 = validateParameter(valid_620601, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_620601 != nil:
    section.add "Action", valid_620601
  var valid_620602 = query.getOrDefault("Version")
  valid_620602 = validateParameter(valid_620602, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620602 != nil:
    section.add "Version", valid_620602
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620603 = header.getOrDefault("X-Amz-Date")
  valid_620603 = validateParameter(valid_620603, JString, required = false,
                                 default = nil)
  if valid_620603 != nil:
    section.add "X-Amz-Date", valid_620603
  var valid_620604 = header.getOrDefault("X-Amz-Security-Token")
  valid_620604 = validateParameter(valid_620604, JString, required = false,
                                 default = nil)
  if valid_620604 != nil:
    section.add "X-Amz-Security-Token", valid_620604
  var valid_620605 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620605 = validateParameter(valid_620605, JString, required = false,
                                 default = nil)
  if valid_620605 != nil:
    section.add "X-Amz-Content-Sha256", valid_620605
  var valid_620606 = header.getOrDefault("X-Amz-Algorithm")
  valid_620606 = validateParameter(valid_620606, JString, required = false,
                                 default = nil)
  if valid_620606 != nil:
    section.add "X-Amz-Algorithm", valid_620606
  var valid_620607 = header.getOrDefault("X-Amz-Signature")
  valid_620607 = validateParameter(valid_620607, JString, required = false,
                                 default = nil)
  if valid_620607 != nil:
    section.add "X-Amz-Signature", valid_620607
  var valid_620608 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620608 = validateParameter(valid_620608, JString, required = false,
                                 default = nil)
  if valid_620608 != nil:
    section.add "X-Amz-SignedHeaders", valid_620608
  var valid_620609 = header.getOrDefault("X-Amz-Credential")
  valid_620609 = validateParameter(valid_620609, JString, required = false,
                                 default = nil)
  if valid_620609 != nil:
    section.add "X-Amz-Credential", valid_620609
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   NumberOfNodes: JInt
  ##                : The new number of nodes for the cluster.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  section = newJObject()
  var valid_620610 = formData.getOrDefault("ClusterType")
  valid_620610 = validateParameter(valid_620610, JString, required = false,
                                 default = nil)
  if valid_620610 != nil:
    section.add "ClusterType", valid_620610
  var valid_620611 = formData.getOrDefault("NumberOfNodes")
  valid_620611 = validateParameter(valid_620611, JInt, required = false, default = nil)
  if valid_620611 != nil:
    section.add "NumberOfNodes", valid_620611
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_620612 = formData.getOrDefault("ClusterIdentifier")
  valid_620612 = validateParameter(valid_620612, JString, required = true,
                                 default = nil)
  if valid_620612 != nil:
    section.add "ClusterIdentifier", valid_620612
  var valid_620613 = formData.getOrDefault("Classic")
  valid_620613 = validateParameter(valid_620613, JBool, required = false, default = nil)
  if valid_620613 != nil:
    section.add "Classic", valid_620613
  var valid_620614 = formData.getOrDefault("NodeType")
  valid_620614 = validateParameter(valid_620614, JString, required = false,
                                 default = nil)
  if valid_620614 != nil:
    section.add "NodeType", valid_620614
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620615: Call_PostResizeCluster_620598; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_620615.validator(path, query, header, formData, body, _)
  let scheme = call_620615.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620615.url(scheme.get, call_620615.host, call_620615.base,
                         call_620615.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620615, url, valid, _)

proc call*(call_620616: Call_PostResizeCluster_620598; ClusterIdentifier: string;
          ClusterType: string = ""; Action: string = "ResizeCluster";
          NumberOfNodes: int = 0; Classic: bool = false; Version: string = "2012-12-01";
          NodeType: string = ""): Recallable =
  ## postResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   Action: string (required)
  ##   NumberOfNodes: int
  ##                : The new number of nodes for the cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Version: string (required)
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  var query_620617 = newJObject()
  var formData_620618 = newJObject()
  add(formData_620618, "ClusterType", newJString(ClusterType))
  add(query_620617, "Action", newJString(Action))
  add(formData_620618, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_620618, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_620618, "Classic", newJBool(Classic))
  add(query_620617, "Version", newJString(Version))
  add(formData_620618, "NodeType", newJString(NodeType))
  result = call_620616.call(nil, query_620617, nil, formData_620618, nil)

var postResizeCluster* = Call_PostResizeCluster_620598(name: "postResizeCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_PostResizeCluster_620599,
    base: "/", url: url_PostResizeCluster_620600,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResizeCluster_620578 = ref object of OpenApiRestCall_616850
proc url_GetResizeCluster_620580(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResizeCluster_620579(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode; _: string = ""): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NumberOfNodes: JInt
  ##                : The new number of nodes for the cluster.
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  section = newJObject()
  var valid_620581 = query.getOrDefault("Action")
  valid_620581 = validateParameter(valid_620581, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_620581 != nil:
    section.add "Action", valid_620581
  var valid_620582 = query.getOrDefault("ClusterIdentifier")
  valid_620582 = validateParameter(valid_620582, JString, required = true,
                                 default = nil)
  if valid_620582 != nil:
    section.add "ClusterIdentifier", valid_620582
  var valid_620583 = query.getOrDefault("Classic")
  valid_620583 = validateParameter(valid_620583, JBool, required = false, default = nil)
  if valid_620583 != nil:
    section.add "Classic", valid_620583
  var valid_620584 = query.getOrDefault("NumberOfNodes")
  valid_620584 = validateParameter(valid_620584, JInt, required = false, default = nil)
  if valid_620584 != nil:
    section.add "NumberOfNodes", valid_620584
  var valid_620585 = query.getOrDefault("NodeType")
  valid_620585 = validateParameter(valid_620585, JString, required = false,
                                 default = nil)
  if valid_620585 != nil:
    section.add "NodeType", valid_620585
  var valid_620586 = query.getOrDefault("Version")
  valid_620586 = validateParameter(valid_620586, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620586 != nil:
    section.add "Version", valid_620586
  var valid_620587 = query.getOrDefault("ClusterType")
  valid_620587 = validateParameter(valid_620587, JString, required = false,
                                 default = nil)
  if valid_620587 != nil:
    section.add "ClusterType", valid_620587
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620588 = header.getOrDefault("X-Amz-Date")
  valid_620588 = validateParameter(valid_620588, JString, required = false,
                                 default = nil)
  if valid_620588 != nil:
    section.add "X-Amz-Date", valid_620588
  var valid_620589 = header.getOrDefault("X-Amz-Security-Token")
  valid_620589 = validateParameter(valid_620589, JString, required = false,
                                 default = nil)
  if valid_620589 != nil:
    section.add "X-Amz-Security-Token", valid_620589
  var valid_620590 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620590 = validateParameter(valid_620590, JString, required = false,
                                 default = nil)
  if valid_620590 != nil:
    section.add "X-Amz-Content-Sha256", valid_620590
  var valid_620591 = header.getOrDefault("X-Amz-Algorithm")
  valid_620591 = validateParameter(valid_620591, JString, required = false,
                                 default = nil)
  if valid_620591 != nil:
    section.add "X-Amz-Algorithm", valid_620591
  var valid_620592 = header.getOrDefault("X-Amz-Signature")
  valid_620592 = validateParameter(valid_620592, JString, required = false,
                                 default = nil)
  if valid_620592 != nil:
    section.add "X-Amz-Signature", valid_620592
  var valid_620593 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620593 = validateParameter(valid_620593, JString, required = false,
                                 default = nil)
  if valid_620593 != nil:
    section.add "X-Amz-SignedHeaders", valid_620593
  var valid_620594 = header.getOrDefault("X-Amz-Credential")
  valid_620594 = validateParameter(valid_620594, JString, required = false,
                                 default = nil)
  if valid_620594 != nil:
    section.add "X-Amz-Credential", valid_620594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620595: Call_GetResizeCluster_620578; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_620595.validator(path, query, header, formData, body, _)
  let scheme = call_620595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620595.url(scheme.get, call_620595.host, call_620595.base,
                         call_620595.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620595, url, valid, _)

proc call*(call_620596: Call_GetResizeCluster_620578; ClusterIdentifier: string;
          Action: string = "ResizeCluster"; Classic: bool = false;
          NumberOfNodes: int = 0; NodeType: string = ""; Version: string = "2012-12-01";
          ClusterType: string = ""): Recallable =
  ## getResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> <li> <p>ra3.16xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NumberOfNodes: int
  ##                : The new number of nodes for the cluster.
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  var query_620597 = newJObject()
  add(query_620597, "Action", newJString(Action))
  add(query_620597, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620597, "Classic", newJBool(Classic))
  add(query_620597, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_620597, "NodeType", newJString(NodeType))
  add(query_620597, "Version", newJString(Version))
  add(query_620597, "ClusterType", newJString(ClusterType))
  result = call_620596.call(nil, query_620597, nil, nil, nil)

var getResizeCluster* = Call_GetResizeCluster_620578(name: "getResizeCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_GetResizeCluster_620579,
    base: "/", url: url_GetResizeCluster_620580,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreFromClusterSnapshot_620660 = ref object of OpenApiRestCall_616850
proc url_PostRestoreFromClusterSnapshot_620662(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreFromClusterSnapshot_620661(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620663 = query.getOrDefault("Action")
  valid_620663 = validateParameter(valid_620663, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_620663 != nil:
    section.add "Action", valid_620663
  var valid_620664 = query.getOrDefault("Version")
  valid_620664 = validateParameter(valid_620664, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620664 != nil:
    section.add "Version", valid_620664
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620665 = header.getOrDefault("X-Amz-Date")
  valid_620665 = validateParameter(valid_620665, JString, required = false,
                                 default = nil)
  if valid_620665 != nil:
    section.add "X-Amz-Date", valid_620665
  var valid_620666 = header.getOrDefault("X-Amz-Security-Token")
  valid_620666 = validateParameter(valid_620666, JString, required = false,
                                 default = nil)
  if valid_620666 != nil:
    section.add "X-Amz-Security-Token", valid_620666
  var valid_620667 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620667 = validateParameter(valid_620667, JString, required = false,
                                 default = nil)
  if valid_620667 != nil:
    section.add "X-Amz-Content-Sha256", valid_620667
  var valid_620668 = header.getOrDefault("X-Amz-Algorithm")
  valid_620668 = validateParameter(valid_620668, JString, required = false,
                                 default = nil)
  if valid_620668 != nil:
    section.add "X-Amz-Algorithm", valid_620668
  var valid_620669 = header.getOrDefault("X-Amz-Signature")
  valid_620669 = validateParameter(valid_620669, JString, required = false,
                                 default = nil)
  if valid_620669 != nil:
    section.add "X-Amz-Signature", valid_620669
  var valid_620670 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620670 = validateParameter(valid_620670, JString, required = false,
                                 default = nil)
  if valid_620670 != nil:
    section.add "X-Amz-SignedHeaders", valid_620670
  var valid_620671 = header.getOrDefault("X-Amz-Credential")
  valid_620671 = validateParameter(valid_620671, JString, required = false,
                                 default = nil)
  if valid_620671 != nil:
    section.add "X-Amz-Credential", valid_620671
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  section = newJObject()
  var valid_620672 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_620672 = validateParameter(valid_620672, JString, required = false,
                                 default = nil)
  if valid_620672 != nil:
    section.add "SnapshotClusterIdentifier", valid_620672
  var valid_620673 = formData.getOrDefault("EnhancedVpcRouting")
  valid_620673 = validateParameter(valid_620673, JBool, required = false, default = nil)
  if valid_620673 != nil:
    section.add "EnhancedVpcRouting", valid_620673
  var valid_620674 = formData.getOrDefault("Port")
  valid_620674 = validateParameter(valid_620674, JInt, required = false, default = nil)
  if valid_620674 != nil:
    section.add "Port", valid_620674
  var valid_620675 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_620675 = validateParameter(valid_620675, JArray, required = false,
                                 default = nil)
  if valid_620675 != nil:
    section.add "VpcSecurityGroupIds", valid_620675
  var valid_620676 = formData.getOrDefault("PubliclyAccessible")
  valid_620676 = validateParameter(valid_620676, JBool, required = false, default = nil)
  if valid_620676 != nil:
    section.add "PubliclyAccessible", valid_620676
  var valid_620677 = formData.getOrDefault("ClusterSecurityGroups")
  valid_620677 = validateParameter(valid_620677, JArray, required = false,
                                 default = nil)
  if valid_620677 != nil:
    section.add "ClusterSecurityGroups", valid_620677
  var valid_620678 = formData.getOrDefault("AdditionalInfo")
  valid_620678 = validateParameter(valid_620678, JString, required = false,
                                 default = nil)
  if valid_620678 != nil:
    section.add "AdditionalInfo", valid_620678
  var valid_620679 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_620679 = validateParameter(valid_620679, JString, required = false,
                                 default = nil)
  if valid_620679 != nil:
    section.add "ClusterSubnetGroupName", valid_620679
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_620680 = formData.getOrDefault("SnapshotIdentifier")
  valid_620680 = validateParameter(valid_620680, JString, required = true,
                                 default = nil)
  if valid_620680 != nil:
    section.add "SnapshotIdentifier", valid_620680
  var valid_620681 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_620681 = validateParameter(valid_620681, JString, required = false,
                                 default = nil)
  if valid_620681 != nil:
    section.add "HsmConfigurationIdentifier", valid_620681
  var valid_620682 = formData.getOrDefault("OwnerAccount")
  valid_620682 = validateParameter(valid_620682, JString, required = false,
                                 default = nil)
  if valid_620682 != nil:
    section.add "OwnerAccount", valid_620682
  var valid_620683 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_620683 = validateParameter(valid_620683, JString, required = false,
                                 default = nil)
  if valid_620683 != nil:
    section.add "HsmClientCertificateIdentifier", valid_620683
  var valid_620684 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_620684 = validateParameter(valid_620684, JString, required = false,
                                 default = nil)
  if valid_620684 != nil:
    section.add "SnapshotScheduleIdentifier", valid_620684
  var valid_620685 = formData.getOrDefault("NumberOfNodes")
  valid_620685 = validateParameter(valid_620685, JInt, required = false, default = nil)
  if valid_620685 != nil:
    section.add "NumberOfNodes", valid_620685
  var valid_620686 = formData.getOrDefault("IamRoles")
  valid_620686 = validateParameter(valid_620686, JArray, required = false,
                                 default = nil)
  if valid_620686 != nil:
    section.add "IamRoles", valid_620686
  var valid_620687 = formData.getOrDefault("ClusterParameterGroupName")
  valid_620687 = validateParameter(valid_620687, JString, required = false,
                                 default = nil)
  if valid_620687 != nil:
    section.add "ClusterParameterGroupName", valid_620687
  var valid_620688 = formData.getOrDefault("AvailabilityZone")
  valid_620688 = validateParameter(valid_620688, JString, required = false,
                                 default = nil)
  if valid_620688 != nil:
    section.add "AvailabilityZone", valid_620688
  var valid_620689 = formData.getOrDefault("KmsKeyId")
  valid_620689 = validateParameter(valid_620689, JString, required = false,
                                 default = nil)
  if valid_620689 != nil:
    section.add "KmsKeyId", valid_620689
  var valid_620690 = formData.getOrDefault("ClusterIdentifier")
  valid_620690 = validateParameter(valid_620690, JString, required = true,
                                 default = nil)
  if valid_620690 != nil:
    section.add "ClusterIdentifier", valid_620690
  var valid_620691 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_620691 = validateParameter(valid_620691, JInt, required = false, default = nil)
  if valid_620691 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_620691
  var valid_620692 = formData.getOrDefault("ElasticIp")
  valid_620692 = validateParameter(valid_620692, JString, required = false,
                                 default = nil)
  if valid_620692 != nil:
    section.add "ElasticIp", valid_620692
  var valid_620693 = formData.getOrDefault("AllowVersionUpgrade")
  valid_620693 = validateParameter(valid_620693, JBool, required = false, default = nil)
  if valid_620693 != nil:
    section.add "AllowVersionUpgrade", valid_620693
  var valid_620694 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_620694 = validateParameter(valid_620694, JInt, required = false, default = nil)
  if valid_620694 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_620694
  var valid_620695 = formData.getOrDefault("NodeType")
  valid_620695 = validateParameter(valid_620695, JString, required = false,
                                 default = nil)
  if valid_620695 != nil:
    section.add "NodeType", valid_620695
  var valid_620696 = formData.getOrDefault("MaintenanceTrackName")
  valid_620696 = validateParameter(valid_620696, JString, required = false,
                                 default = nil)
  if valid_620696 != nil:
    section.add "MaintenanceTrackName", valid_620696
  var valid_620697 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_620697 = validateParameter(valid_620697, JString, required = false,
                                 default = nil)
  if valid_620697 != nil:
    section.add "PreferredMaintenanceWindow", valid_620697
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620698: Call_PostRestoreFromClusterSnapshot_620660;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_620698.validator(path, query, header, formData, body, _)
  let scheme = call_620698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620698.url(scheme.get, call_620698.host, call_620698.base,
                         call_620698.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620698, url, valid, _)

proc call*(call_620699: Call_PostRestoreFromClusterSnapshot_620660;
          SnapshotIdentifier: string; ClusterIdentifier: string;
          SnapshotClusterIdentifier: string = ""; EnhancedVpcRouting: bool = false;
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil;
          PubliclyAccessible: bool = false; ClusterSecurityGroups: JsonNode = nil;
          AdditionalInfo: string = ""; ClusterSubnetGroupName: string = "";
          HsmConfigurationIdentifier: string = "";
          Action: string = "RestoreFromClusterSnapshot"; OwnerAccount: string = "";
          HsmClientCertificateIdentifier: string = "";
          SnapshotScheduleIdentifier: string = ""; NumberOfNodes: int = 0;
          IamRoles: JsonNode = nil; ClusterParameterGroupName: string = "";
          AvailabilityZone: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          NodeType: string = ""; MaintenanceTrackName: string = "";
          PreferredMaintenanceWindow: string = ""): Recallable =
  ## postRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  var query_620700 = newJObject()
  var formData_620701 = newJObject()
  add(formData_620701, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(formData_620701, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_620701, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    formData_620701.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_620701, "PubliclyAccessible", newJBool(PubliclyAccessible))
  if ClusterSecurityGroups != nil:
    formData_620701.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_620701, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_620701, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_620701, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_620701, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_620700, "Action", newJString(Action))
  add(formData_620701, "OwnerAccount", newJString(OwnerAccount))
  add(formData_620701, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_620701, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(formData_620701, "NumberOfNodes", newJInt(NumberOfNodes))
  if IamRoles != nil:
    formData_620701.add "IamRoles", IamRoles
  add(formData_620701, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_620701, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_620701, "KmsKeyId", newJString(KmsKeyId))
  add(formData_620701, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_620701, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_620701, "ElasticIp", newJString(ElasticIp))
  add(formData_620701, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_620701, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_620700, "Version", newJString(Version))
  add(formData_620701, "NodeType", newJString(NodeType))
  add(formData_620701, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_620701, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  result = call_620699.call(nil, query_620700, nil, formData_620701, nil)

var postRestoreFromClusterSnapshot* = Call_PostRestoreFromClusterSnapshot_620660(
    name: "postRestoreFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_PostRestoreFromClusterSnapshot_620661, base: "/",
    url: url_PostRestoreFromClusterSnapshot_620662,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreFromClusterSnapshot_620619 = ref object of OpenApiRestCall_616850
proc url_GetRestoreFromClusterSnapshot_620621(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreFromClusterSnapshot_620620(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Version: JString (required)
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_620622 = query.getOrDefault("ClusterSecurityGroups")
  valid_620622 = validateParameter(valid_620622, JArray, required = false,
                                 default = nil)
  if valid_620622 != nil:
    section.add "ClusterSecurityGroups", valid_620622
  var valid_620623 = query.getOrDefault("ClusterSubnetGroupName")
  valid_620623 = validateParameter(valid_620623, JString, required = false,
                                 default = nil)
  if valid_620623 != nil:
    section.add "ClusterSubnetGroupName", valid_620623
  var valid_620624 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_620624 = validateParameter(valid_620624, JString, required = false,
                                 default = nil)
  if valid_620624 != nil:
    section.add "HsmClientCertificateIdentifier", valid_620624
  var valid_620625 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_620625 = validateParameter(valid_620625, JString, required = false,
                                 default = nil)
  if valid_620625 != nil:
    section.add "PreferredMaintenanceWindow", valid_620625
  var valid_620626 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_620626 = validateParameter(valid_620626, JString, required = false,
                                 default = nil)
  if valid_620626 != nil:
    section.add "HsmConfigurationIdentifier", valid_620626
  var valid_620627 = query.getOrDefault("MaintenanceTrackName")
  valid_620627 = validateParameter(valid_620627, JString, required = false,
                                 default = nil)
  if valid_620627 != nil:
    section.add "MaintenanceTrackName", valid_620627
  var valid_620628 = query.getOrDefault("IamRoles")
  valid_620628 = validateParameter(valid_620628, JArray, required = false,
                                 default = nil)
  if valid_620628 != nil:
    section.add "IamRoles", valid_620628
  var valid_620629 = query.getOrDefault("ElasticIp")
  valid_620629 = validateParameter(valid_620629, JString, required = false,
                                 default = nil)
  if valid_620629 != nil:
    section.add "ElasticIp", valid_620629
  var valid_620630 = query.getOrDefault("AvailabilityZone")
  valid_620630 = validateParameter(valid_620630, JString, required = false,
                                 default = nil)
  if valid_620630 != nil:
    section.add "AvailabilityZone", valid_620630
  var valid_620631 = query.getOrDefault("AllowVersionUpgrade")
  valid_620631 = validateParameter(valid_620631, JBool, required = false, default = nil)
  if valid_620631 != nil:
    section.add "AllowVersionUpgrade", valid_620631
  var valid_620632 = query.getOrDefault("VpcSecurityGroupIds")
  valid_620632 = validateParameter(valid_620632, JArray, required = false,
                                 default = nil)
  if valid_620632 != nil:
    section.add "VpcSecurityGroupIds", valid_620632
  var valid_620633 = query.getOrDefault("ClusterParameterGroupName")
  valid_620633 = validateParameter(valid_620633, JString, required = false,
                                 default = nil)
  if valid_620633 != nil:
    section.add "ClusterParameterGroupName", valid_620633
  var valid_620634 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_620634 = validateParameter(valid_620634, JString, required = false,
                                 default = nil)
  if valid_620634 != nil:
    section.add "SnapshotScheduleIdentifier", valid_620634
  var valid_620635 = query.getOrDefault("EnhancedVpcRouting")
  valid_620635 = validateParameter(valid_620635, JBool, required = false, default = nil)
  if valid_620635 != nil:
    section.add "EnhancedVpcRouting", valid_620635
  var valid_620636 = query.getOrDefault("AdditionalInfo")
  valid_620636 = validateParameter(valid_620636, JString, required = false,
                                 default = nil)
  if valid_620636 != nil:
    section.add "AdditionalInfo", valid_620636
  var valid_620637 = query.getOrDefault("Action")
  valid_620637 = validateParameter(valid_620637, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_620637 != nil:
    section.add "Action", valid_620637
  var valid_620638 = query.getOrDefault("ClusterIdentifier")
  valid_620638 = validateParameter(valid_620638, JString, required = true,
                                 default = nil)
  if valid_620638 != nil:
    section.add "ClusterIdentifier", valid_620638
  var valid_620639 = query.getOrDefault("KmsKeyId")
  valid_620639 = validateParameter(valid_620639, JString, required = false,
                                 default = nil)
  if valid_620639 != nil:
    section.add "KmsKeyId", valid_620639
  var valid_620640 = query.getOrDefault("PubliclyAccessible")
  valid_620640 = validateParameter(valid_620640, JBool, required = false, default = nil)
  if valid_620640 != nil:
    section.add "PubliclyAccessible", valid_620640
  var valid_620641 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_620641 = validateParameter(valid_620641, JString, required = false,
                                 default = nil)
  if valid_620641 != nil:
    section.add "SnapshotClusterIdentifier", valid_620641
  var valid_620642 = query.getOrDefault("Port")
  valid_620642 = validateParameter(valid_620642, JInt, required = false, default = nil)
  if valid_620642 != nil:
    section.add "Port", valid_620642
  var valid_620643 = query.getOrDefault("NumberOfNodes")
  valid_620643 = validateParameter(valid_620643, JInt, required = false, default = nil)
  if valid_620643 != nil:
    section.add "NumberOfNodes", valid_620643
  var valid_620644 = query.getOrDefault("SnapshotIdentifier")
  valid_620644 = validateParameter(valid_620644, JString, required = true,
                                 default = nil)
  if valid_620644 != nil:
    section.add "SnapshotIdentifier", valid_620644
  var valid_620645 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_620645 = validateParameter(valid_620645, JInt, required = false, default = nil)
  if valid_620645 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_620645
  var valid_620646 = query.getOrDefault("NodeType")
  valid_620646 = validateParameter(valid_620646, JString, required = false,
                                 default = nil)
  if valid_620646 != nil:
    section.add "NodeType", valid_620646
  var valid_620647 = query.getOrDefault("Version")
  valid_620647 = validateParameter(valid_620647, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620647 != nil:
    section.add "Version", valid_620647
  var valid_620648 = query.getOrDefault("OwnerAccount")
  valid_620648 = validateParameter(valid_620648, JString, required = false,
                                 default = nil)
  if valid_620648 != nil:
    section.add "OwnerAccount", valid_620648
  var valid_620649 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_620649 = validateParameter(valid_620649, JInt, required = false, default = nil)
  if valid_620649 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_620649
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620650 = header.getOrDefault("X-Amz-Date")
  valid_620650 = validateParameter(valid_620650, JString, required = false,
                                 default = nil)
  if valid_620650 != nil:
    section.add "X-Amz-Date", valid_620650
  var valid_620651 = header.getOrDefault("X-Amz-Security-Token")
  valid_620651 = validateParameter(valid_620651, JString, required = false,
                                 default = nil)
  if valid_620651 != nil:
    section.add "X-Amz-Security-Token", valid_620651
  var valid_620652 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620652 = validateParameter(valid_620652, JString, required = false,
                                 default = nil)
  if valid_620652 != nil:
    section.add "X-Amz-Content-Sha256", valid_620652
  var valid_620653 = header.getOrDefault("X-Amz-Algorithm")
  valid_620653 = validateParameter(valid_620653, JString, required = false,
                                 default = nil)
  if valid_620653 != nil:
    section.add "X-Amz-Algorithm", valid_620653
  var valid_620654 = header.getOrDefault("X-Amz-Signature")
  valid_620654 = validateParameter(valid_620654, JString, required = false,
                                 default = nil)
  if valid_620654 != nil:
    section.add "X-Amz-Signature", valid_620654
  var valid_620655 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620655 = validateParameter(valid_620655, JString, required = false,
                                 default = nil)
  if valid_620655 != nil:
    section.add "X-Amz-SignedHeaders", valid_620655
  var valid_620656 = header.getOrDefault("X-Amz-Credential")
  valid_620656 = validateParameter(valid_620656, JString, required = false,
                                 default = nil)
  if valid_620656 != nil:
    section.add "X-Amz-Credential", valid_620656
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620657: Call_GetRestoreFromClusterSnapshot_620619;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_620657.validator(path, query, header, formData, body, _)
  let scheme = call_620657.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620657.url(scheme.get, call_620657.host, call_620657.base,
                         call_620657.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620657, url, valid, _)

proc call*(call_620658: Call_GetRestoreFromClusterSnapshot_620619;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          ClusterSecurityGroups: JsonNode = nil;
          ClusterSubnetGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = "";
          HsmConfigurationIdentifier: string = "";
          MaintenanceTrackName: string = ""; IamRoles: JsonNode = nil;
          ElasticIp: string = ""; AvailabilityZone: string = "";
          AllowVersionUpgrade: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          SnapshotScheduleIdentifier: string = ""; EnhancedVpcRouting: bool = false;
          AdditionalInfo: string = "";
          Action: string = "RestoreFromClusterSnapshot"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; SnapshotClusterIdentifier: string = "";
          Port: int = 0; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; NodeType: string = "";
          Version: string = "2012-12-01"; OwnerAccount: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-2a</code> </p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Version: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_620659 = newJObject()
  if ClusterSecurityGroups != nil:
    query_620659.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_620659, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_620659, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_620659, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_620659, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_620659, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if IamRoles != nil:
    query_620659.add "IamRoles", IamRoles
  add(query_620659, "ElasticIp", newJString(ElasticIp))
  add(query_620659, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_620659, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  if VpcSecurityGroupIds != nil:
    query_620659.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_620659, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_620659, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_620659, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_620659, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_620659, "Action", newJString(Action))
  add(query_620659, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620659, "KmsKeyId", newJString(KmsKeyId))
  add(query_620659, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_620659, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_620659, "Port", newJInt(Port))
  add(query_620659, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_620659, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_620659, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_620659, "NodeType", newJString(NodeType))
  add(query_620659, "Version", newJString(Version))
  add(query_620659, "OwnerAccount", newJString(OwnerAccount))
  add(query_620659, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_620658.call(nil, query_620659, nil, nil, nil)

var getRestoreFromClusterSnapshot* = Call_GetRestoreFromClusterSnapshot_620619(
    name: "getRestoreFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_GetRestoreFromClusterSnapshot_620620, base: "/",
    url: url_GetRestoreFromClusterSnapshot_620621,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreTableFromClusterSnapshot_620725 = ref object of OpenApiRestCall_616850
proc url_PostRestoreTableFromClusterSnapshot_620727(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreTableFromClusterSnapshot_620726(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620728 = query.getOrDefault("Action")
  valid_620728 = validateParameter(valid_620728, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_620728 != nil:
    section.add "Action", valid_620728
  var valid_620729 = query.getOrDefault("Version")
  valid_620729 = validateParameter(valid_620729, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620729 != nil:
    section.add "Version", valid_620729
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620730 = header.getOrDefault("X-Amz-Date")
  valid_620730 = validateParameter(valid_620730, JString, required = false,
                                 default = nil)
  if valid_620730 != nil:
    section.add "X-Amz-Date", valid_620730
  var valid_620731 = header.getOrDefault("X-Amz-Security-Token")
  valid_620731 = validateParameter(valid_620731, JString, required = false,
                                 default = nil)
  if valid_620731 != nil:
    section.add "X-Amz-Security-Token", valid_620731
  var valid_620732 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620732 = validateParameter(valid_620732, JString, required = false,
                                 default = nil)
  if valid_620732 != nil:
    section.add "X-Amz-Content-Sha256", valid_620732
  var valid_620733 = header.getOrDefault("X-Amz-Algorithm")
  valid_620733 = validateParameter(valid_620733, JString, required = false,
                                 default = nil)
  if valid_620733 != nil:
    section.add "X-Amz-Algorithm", valid_620733
  var valid_620734 = header.getOrDefault("X-Amz-Signature")
  valid_620734 = validateParameter(valid_620734, JString, required = false,
                                 default = nil)
  if valid_620734 != nil:
    section.add "X-Amz-Signature", valid_620734
  var valid_620735 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620735 = validateParameter(valid_620735, JString, required = false,
                                 default = nil)
  if valid_620735 != nil:
    section.add "X-Amz-SignedHeaders", valid_620735
  var valid_620736 = header.getOrDefault("X-Amz-Credential")
  valid_620736 = validateParameter(valid_620736, JString, required = false,
                                 default = nil)
  if valid_620736 != nil:
    section.add "X-Amz-Credential", valid_620736
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SourceDatabaseName` field"
  var valid_620737 = formData.getOrDefault("SourceDatabaseName")
  valid_620737 = validateParameter(valid_620737, JString, required = true,
                                 default = nil)
  if valid_620737 != nil:
    section.add "SourceDatabaseName", valid_620737
  var valid_620738 = formData.getOrDefault("ClusterIdentifier")
  valid_620738 = validateParameter(valid_620738, JString, required = true,
                                 default = nil)
  if valid_620738 != nil:
    section.add "ClusterIdentifier", valid_620738
  var valid_620739 = formData.getOrDefault("SourceTableName")
  valid_620739 = validateParameter(valid_620739, JString, required = true,
                                 default = nil)
  if valid_620739 != nil:
    section.add "SourceTableName", valid_620739
  var valid_620740 = formData.getOrDefault("TargetDatabaseName")
  valid_620740 = validateParameter(valid_620740, JString, required = false,
                                 default = nil)
  if valid_620740 != nil:
    section.add "TargetDatabaseName", valid_620740
  var valid_620741 = formData.getOrDefault("TargetSchemaName")
  valid_620741 = validateParameter(valid_620741, JString, required = false,
                                 default = nil)
  if valid_620741 != nil:
    section.add "TargetSchemaName", valid_620741
  var valid_620742 = formData.getOrDefault("SnapshotIdentifier")
  valid_620742 = validateParameter(valid_620742, JString, required = true,
                                 default = nil)
  if valid_620742 != nil:
    section.add "SnapshotIdentifier", valid_620742
  var valid_620743 = formData.getOrDefault("NewTableName")
  valid_620743 = validateParameter(valid_620743, JString, required = true,
                                 default = nil)
  if valid_620743 != nil:
    section.add "NewTableName", valid_620743
  var valid_620744 = formData.getOrDefault("SourceSchemaName")
  valid_620744 = validateParameter(valid_620744, JString, required = false,
                                 default = nil)
  if valid_620744 != nil:
    section.add "SourceSchemaName", valid_620744
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620745: Call_PostRestoreTableFromClusterSnapshot_620725;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_620745.validator(path, query, header, formData, body, _)
  let scheme = call_620745.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620745.url(scheme.get, call_620745.host, call_620745.base,
                         call_620745.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620745, url, valid, _)

proc call*(call_620746: Call_PostRestoreTableFromClusterSnapshot_620725;
          SourceDatabaseName: string; ClusterIdentifier: string;
          SourceTableName: string; SnapshotIdentifier: string; NewTableName: string;
          TargetDatabaseName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          TargetSchemaName: string = ""; Version: string = "2012-12-01";
          SourceSchemaName: string = ""): Recallable =
  ## postRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   Action: string (required)
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   Version: string (required)
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  var query_620747 = newJObject()
  var formData_620748 = newJObject()
  add(formData_620748, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(formData_620748, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_620748, "SourceTableName", newJString(SourceTableName))
  add(formData_620748, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(query_620747, "Action", newJString(Action))
  add(formData_620748, "TargetSchemaName", newJString(TargetSchemaName))
  add(formData_620748, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_620748, "NewTableName", newJString(NewTableName))
  add(query_620747, "Version", newJString(Version))
  add(formData_620748, "SourceSchemaName", newJString(SourceSchemaName))
  result = call_620746.call(nil, query_620747, nil, formData_620748, nil)

var postRestoreTableFromClusterSnapshot* = Call_PostRestoreTableFromClusterSnapshot_620725(
    name: "postRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_PostRestoreTableFromClusterSnapshot_620726, base: "/",
    url: url_PostRestoreTableFromClusterSnapshot_620727,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreTableFromClusterSnapshot_620702 = ref object of OpenApiRestCall_616850
proc url_GetRestoreTableFromClusterSnapshot_620704(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreTableFromClusterSnapshot_620703(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   Action: JString (required)
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   Version: JString (required)
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `SourceTableName` field"
  var valid_620705 = query.getOrDefault("SourceTableName")
  valid_620705 = validateParameter(valid_620705, JString, required = true,
                                 default = nil)
  if valid_620705 != nil:
    section.add "SourceTableName", valid_620705
  var valid_620706 = query.getOrDefault("SourceSchemaName")
  valid_620706 = validateParameter(valid_620706, JString, required = false,
                                 default = nil)
  if valid_620706 != nil:
    section.add "SourceSchemaName", valid_620706
  var valid_620707 = query.getOrDefault("ClusterIdentifier")
  valid_620707 = validateParameter(valid_620707, JString, required = true,
                                 default = nil)
  if valid_620707 != nil:
    section.add "ClusterIdentifier", valid_620707
  var valid_620708 = query.getOrDefault("TargetDatabaseName")
  valid_620708 = validateParameter(valid_620708, JString, required = false,
                                 default = nil)
  if valid_620708 != nil:
    section.add "TargetDatabaseName", valid_620708
  var valid_620709 = query.getOrDefault("Action")
  valid_620709 = validateParameter(valid_620709, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_620709 != nil:
    section.add "Action", valid_620709
  var valid_620710 = query.getOrDefault("NewTableName")
  valid_620710 = validateParameter(valid_620710, JString, required = true,
                                 default = nil)
  if valid_620710 != nil:
    section.add "NewTableName", valid_620710
  var valid_620711 = query.getOrDefault("SnapshotIdentifier")
  valid_620711 = validateParameter(valid_620711, JString, required = true,
                                 default = nil)
  if valid_620711 != nil:
    section.add "SnapshotIdentifier", valid_620711
  var valid_620712 = query.getOrDefault("Version")
  valid_620712 = validateParameter(valid_620712, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620712 != nil:
    section.add "Version", valid_620712
  var valid_620713 = query.getOrDefault("TargetSchemaName")
  valid_620713 = validateParameter(valid_620713, JString, required = false,
                                 default = nil)
  if valid_620713 != nil:
    section.add "TargetSchemaName", valid_620713
  var valid_620714 = query.getOrDefault("SourceDatabaseName")
  valid_620714 = validateParameter(valid_620714, JString, required = true,
                                 default = nil)
  if valid_620714 != nil:
    section.add "SourceDatabaseName", valid_620714
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620715 = header.getOrDefault("X-Amz-Date")
  valid_620715 = validateParameter(valid_620715, JString, required = false,
                                 default = nil)
  if valid_620715 != nil:
    section.add "X-Amz-Date", valid_620715
  var valid_620716 = header.getOrDefault("X-Amz-Security-Token")
  valid_620716 = validateParameter(valid_620716, JString, required = false,
                                 default = nil)
  if valid_620716 != nil:
    section.add "X-Amz-Security-Token", valid_620716
  var valid_620717 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620717 = validateParameter(valid_620717, JString, required = false,
                                 default = nil)
  if valid_620717 != nil:
    section.add "X-Amz-Content-Sha256", valid_620717
  var valid_620718 = header.getOrDefault("X-Amz-Algorithm")
  valid_620718 = validateParameter(valid_620718, JString, required = false,
                                 default = nil)
  if valid_620718 != nil:
    section.add "X-Amz-Algorithm", valid_620718
  var valid_620719 = header.getOrDefault("X-Amz-Signature")
  valid_620719 = validateParameter(valid_620719, JString, required = false,
                                 default = nil)
  if valid_620719 != nil:
    section.add "X-Amz-Signature", valid_620719
  var valid_620720 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620720 = validateParameter(valid_620720, JString, required = false,
                                 default = nil)
  if valid_620720 != nil:
    section.add "X-Amz-SignedHeaders", valid_620720
  var valid_620721 = header.getOrDefault("X-Amz-Credential")
  valid_620721 = validateParameter(valid_620721, JString, required = false,
                                 default = nil)
  if valid_620721 != nil:
    section.add "X-Amz-Credential", valid_620721
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620722: Call_GetRestoreTableFromClusterSnapshot_620702;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_620722.validator(path, query, header, formData, body, _)
  let scheme = call_620722.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620722.url(scheme.get, call_620722.host, call_620722.base,
                         call_620722.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620722, url, valid, _)

proc call*(call_620723: Call_GetRestoreTableFromClusterSnapshot_620702;
          SourceTableName: string; ClusterIdentifier: string; NewTableName: string;
          SnapshotIdentifier: string; SourceDatabaseName: string;
          SourceSchemaName: string = ""; TargetDatabaseName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          Version: string = "2012-12-01"; TargetSchemaName: string = ""): Recallable =
  ## getRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   Action: string (required)
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   Version: string (required)
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  var query_620724 = newJObject()
  add(query_620724, "SourceTableName", newJString(SourceTableName))
  add(query_620724, "SourceSchemaName", newJString(SourceSchemaName))
  add(query_620724, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620724, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(query_620724, "Action", newJString(Action))
  add(query_620724, "NewTableName", newJString(NewTableName))
  add(query_620724, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_620724, "Version", newJString(Version))
  add(query_620724, "TargetSchemaName", newJString(TargetSchemaName))
  add(query_620724, "SourceDatabaseName", newJString(SourceDatabaseName))
  result = call_620723.call(nil, query_620724, nil, nil, nil)

var getRestoreTableFromClusterSnapshot* = Call_GetRestoreTableFromClusterSnapshot_620702(
    name: "getRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_GetRestoreTableFromClusterSnapshot_620703, base: "/",
    url: url_GetRestoreTableFromClusterSnapshot_620704,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeClusterSecurityGroupIngress_620768 = ref object of OpenApiRestCall_616850
proc url_PostRevokeClusterSecurityGroupIngress_620770(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeClusterSecurityGroupIngress_620769(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620771 = query.getOrDefault("Action")
  valid_620771 = validateParameter(valid_620771, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_620771 != nil:
    section.add "Action", valid_620771
  var valid_620772 = query.getOrDefault("Version")
  valid_620772 = validateParameter(valid_620772, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620772 != nil:
    section.add "Version", valid_620772
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620773 = header.getOrDefault("X-Amz-Date")
  valid_620773 = validateParameter(valid_620773, JString, required = false,
                                 default = nil)
  if valid_620773 != nil:
    section.add "X-Amz-Date", valid_620773
  var valid_620774 = header.getOrDefault("X-Amz-Security-Token")
  valid_620774 = validateParameter(valid_620774, JString, required = false,
                                 default = nil)
  if valid_620774 != nil:
    section.add "X-Amz-Security-Token", valid_620774
  var valid_620775 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620775 = validateParameter(valid_620775, JString, required = false,
                                 default = nil)
  if valid_620775 != nil:
    section.add "X-Amz-Content-Sha256", valid_620775
  var valid_620776 = header.getOrDefault("X-Amz-Algorithm")
  valid_620776 = validateParameter(valid_620776, JString, required = false,
                                 default = nil)
  if valid_620776 != nil:
    section.add "X-Amz-Algorithm", valid_620776
  var valid_620777 = header.getOrDefault("X-Amz-Signature")
  valid_620777 = validateParameter(valid_620777, JString, required = false,
                                 default = nil)
  if valid_620777 != nil:
    section.add "X-Amz-Signature", valid_620777
  var valid_620778 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620778 = validateParameter(valid_620778, JString, required = false,
                                 default = nil)
  if valid_620778 != nil:
    section.add "X-Amz-SignedHeaders", valid_620778
  var valid_620779 = header.getOrDefault("X-Amz-Credential")
  valid_620779 = validateParameter(valid_620779, JString, required = false,
                                 default = nil)
  if valid_620779 != nil:
    section.add "X-Amz-Credential", valid_620779
  result.add "header", section
  ## parameters in `formData` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  section = newJObject()
  var valid_620780 = formData.getOrDefault("EC2SecurityGroupName")
  valid_620780 = validateParameter(valid_620780, JString, required = false,
                                 default = nil)
  if valid_620780 != nil:
    section.add "EC2SecurityGroupName", valid_620780
  var valid_620781 = formData.getOrDefault("CIDRIP")
  valid_620781 = validateParameter(valid_620781, JString, required = false,
                                 default = nil)
  if valid_620781 != nil:
    section.add "CIDRIP", valid_620781
  var valid_620782 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_620782 = validateParameter(valid_620782, JString, required = false,
                                 default = nil)
  if valid_620782 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_620782
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_620783 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_620783 = validateParameter(valid_620783, JString, required = true,
                                 default = nil)
  if valid_620783 != nil:
    section.add "ClusterSecurityGroupName", valid_620783
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620784: Call_PostRevokeClusterSecurityGroupIngress_620768;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_620784.validator(path, query, header, formData, body, _)
  let scheme = call_620784.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620784.url(scheme.get, call_620784.host, call_620784.base,
                         call_620784.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620784, url, valid, _)

proc call*(call_620785: Call_PostRevokeClusterSecurityGroupIngress_620768;
          ClusterSecurityGroupName: string;
          Action: string = "RevokeClusterSecurityGroupIngress";
          EC2SecurityGroupName: string = ""; CIDRIP: string = "";
          Version: string = "2012-12-01"; EC2SecurityGroupOwnerId: string = ""): Recallable =
  ## postRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   Version: string (required)
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  var query_620786 = newJObject()
  var formData_620787 = newJObject()
  add(query_620786, "Action", newJString(Action))
  add(formData_620787, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_620787, "CIDRIP", newJString(CIDRIP))
  add(query_620786, "Version", newJString(Version))
  add(formData_620787, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_620787, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_620785.call(nil, query_620786, nil, formData_620787, nil)

var postRevokeClusterSecurityGroupIngress* = Call_PostRevokeClusterSecurityGroupIngress_620768(
    name: "postRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_PostRevokeClusterSecurityGroupIngress_620769, base: "/",
    url: url_PostRevokeClusterSecurityGroupIngress_620770,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeClusterSecurityGroupIngress_620749 = ref object of OpenApiRestCall_616850
proc url_GetRevokeClusterSecurityGroupIngress_620751(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeClusterSecurityGroupIngress_620750(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode;
    _: string = ""): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_620752 = query.getOrDefault("ClusterSecurityGroupName")
  valid_620752 = validateParameter(valid_620752, JString, required = true,
                                 default = nil)
  if valid_620752 != nil:
    section.add "ClusterSecurityGroupName", valid_620752
  var valid_620753 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_620753 = validateParameter(valid_620753, JString, required = false,
                                 default = nil)
  if valid_620753 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_620753
  var valid_620754 = query.getOrDefault("Action")
  valid_620754 = validateParameter(valid_620754, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_620754 != nil:
    section.add "Action", valid_620754
  var valid_620755 = query.getOrDefault("CIDRIP")
  valid_620755 = validateParameter(valid_620755, JString, required = false,
                                 default = nil)
  if valid_620755 != nil:
    section.add "CIDRIP", valid_620755
  var valid_620756 = query.getOrDefault("EC2SecurityGroupName")
  valid_620756 = validateParameter(valid_620756, JString, required = false,
                                 default = nil)
  if valid_620756 != nil:
    section.add "EC2SecurityGroupName", valid_620756
  var valid_620757 = query.getOrDefault("Version")
  valid_620757 = validateParameter(valid_620757, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620757 != nil:
    section.add "Version", valid_620757
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620758 = header.getOrDefault("X-Amz-Date")
  valid_620758 = validateParameter(valid_620758, JString, required = false,
                                 default = nil)
  if valid_620758 != nil:
    section.add "X-Amz-Date", valid_620758
  var valid_620759 = header.getOrDefault("X-Amz-Security-Token")
  valid_620759 = validateParameter(valid_620759, JString, required = false,
                                 default = nil)
  if valid_620759 != nil:
    section.add "X-Amz-Security-Token", valid_620759
  var valid_620760 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620760 = validateParameter(valid_620760, JString, required = false,
                                 default = nil)
  if valid_620760 != nil:
    section.add "X-Amz-Content-Sha256", valid_620760
  var valid_620761 = header.getOrDefault("X-Amz-Algorithm")
  valid_620761 = validateParameter(valid_620761, JString, required = false,
                                 default = nil)
  if valid_620761 != nil:
    section.add "X-Amz-Algorithm", valid_620761
  var valid_620762 = header.getOrDefault("X-Amz-Signature")
  valid_620762 = validateParameter(valid_620762, JString, required = false,
                                 default = nil)
  if valid_620762 != nil:
    section.add "X-Amz-Signature", valid_620762
  var valid_620763 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620763 = validateParameter(valid_620763, JString, required = false,
                                 default = nil)
  if valid_620763 != nil:
    section.add "X-Amz-SignedHeaders", valid_620763
  var valid_620764 = header.getOrDefault("X-Amz-Credential")
  valid_620764 = validateParameter(valid_620764, JString, required = false,
                                 default = nil)
  if valid_620764 != nil:
    section.add "X-Amz-Credential", valid_620764
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620765: Call_GetRevokeClusterSecurityGroupIngress_620749;
          path: JsonNode = nil; query: JsonNode = nil; header: JsonNode = nil;
          formData: JsonNode = nil; body: JsonNode = nil; _: string = ""): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_620765.validator(path, query, header, formData, body, _)
  let scheme = call_620765.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620765.url(scheme.get, call_620765.host, call_620765.base,
                         call_620765.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620765, url, valid, _)

proc call*(call_620766: Call_GetRevokeClusterSecurityGroupIngress_620749;
          ClusterSecurityGroupName: string; EC2SecurityGroupOwnerId: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress"; CIDRIP: string = "";
          EC2SecurityGroupName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: string (required)
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   Version: string (required)
  var query_620767 = newJObject()
  add(query_620767, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_620767, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_620767, "Action", newJString(Action))
  add(query_620767, "CIDRIP", newJString(CIDRIP))
  add(query_620767, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_620767, "Version", newJString(Version))
  result = call_620766.call(nil, query_620767, nil, nil, nil)

var getRevokeClusterSecurityGroupIngress* = Call_GetRevokeClusterSecurityGroupIngress_620749(
    name: "getRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_GetRevokeClusterSecurityGroupIngress_620750, base: "/",
    url: url_GetRevokeClusterSecurityGroupIngress_620751,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeSnapshotAccess_620806 = ref object of OpenApiRestCall_616850
proc url_PostRevokeSnapshotAccess_620808(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeSnapshotAccess_620807(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620809 = query.getOrDefault("Action")
  valid_620809 = validateParameter(valid_620809, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_620809 != nil:
    section.add "Action", valid_620809
  var valid_620810 = query.getOrDefault("Version")
  valid_620810 = validateParameter(valid_620810, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620810 != nil:
    section.add "Version", valid_620810
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620811 = header.getOrDefault("X-Amz-Date")
  valid_620811 = validateParameter(valid_620811, JString, required = false,
                                 default = nil)
  if valid_620811 != nil:
    section.add "X-Amz-Date", valid_620811
  var valid_620812 = header.getOrDefault("X-Amz-Security-Token")
  valid_620812 = validateParameter(valid_620812, JString, required = false,
                                 default = nil)
  if valid_620812 != nil:
    section.add "X-Amz-Security-Token", valid_620812
  var valid_620813 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620813 = validateParameter(valid_620813, JString, required = false,
                                 default = nil)
  if valid_620813 != nil:
    section.add "X-Amz-Content-Sha256", valid_620813
  var valid_620814 = header.getOrDefault("X-Amz-Algorithm")
  valid_620814 = validateParameter(valid_620814, JString, required = false,
                                 default = nil)
  if valid_620814 != nil:
    section.add "X-Amz-Algorithm", valid_620814
  var valid_620815 = header.getOrDefault("X-Amz-Signature")
  valid_620815 = validateParameter(valid_620815, JString, required = false,
                                 default = nil)
  if valid_620815 != nil:
    section.add "X-Amz-Signature", valid_620815
  var valid_620816 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620816 = validateParameter(valid_620816, JString, required = false,
                                 default = nil)
  if valid_620816 != nil:
    section.add "X-Amz-SignedHeaders", valid_620816
  var valid_620817 = header.getOrDefault("X-Amz-Credential")
  valid_620817 = validateParameter(valid_620817, JString, required = false,
                                 default = nil)
  if valid_620817 != nil:
    section.add "X-Amz-Credential", valid_620817
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  section = newJObject()
  var valid_620818 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_620818 = validateParameter(valid_620818, JString, required = false,
                                 default = nil)
  if valid_620818 != nil:
    section.add "SnapshotClusterIdentifier", valid_620818
  assert formData != nil, "formData argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_620819 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_620819 = validateParameter(valid_620819, JString, required = true,
                                 default = nil)
  if valid_620819 != nil:
    section.add "AccountWithRestoreAccess", valid_620819
  var valid_620820 = formData.getOrDefault("SnapshotIdentifier")
  valid_620820 = validateParameter(valid_620820, JString, required = true,
                                 default = nil)
  if valid_620820 != nil:
    section.add "SnapshotIdentifier", valid_620820
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620821: Call_PostRevokeSnapshotAccess_620806; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_620821.validator(path, query, header, formData, body, _)
  let scheme = call_620821.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620821.url(scheme.get, call_620821.host, call_620821.base,
                         call_620821.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620821, url, valid, _)

proc call*(call_620822: Call_PostRevokeSnapshotAccess_620806;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "RevokeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## postRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: string (required)
  var query_620823 = newJObject()
  var formData_620824 = newJObject()
  add(formData_620824, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(formData_620824, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_620823, "Action", newJString(Action))
  add(formData_620824, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_620823, "Version", newJString(Version))
  result = call_620822.call(nil, query_620823, nil, formData_620824, nil)

var postRevokeSnapshotAccess* = Call_PostRevokeSnapshotAccess_620806(
    name: "postRevokeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_PostRevokeSnapshotAccess_620807, base: "/",
    url: url_PostRevokeSnapshotAccess_620808, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeSnapshotAccess_620788 = ref object of OpenApiRestCall_616850
proc url_GetRevokeSnapshotAccess_620790(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeSnapshotAccess_620789(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_620791 = query.getOrDefault("AccountWithRestoreAccess")
  valid_620791 = validateParameter(valid_620791, JString, required = true,
                                 default = nil)
  if valid_620791 != nil:
    section.add "AccountWithRestoreAccess", valid_620791
  var valid_620792 = query.getOrDefault("Action")
  valid_620792 = validateParameter(valid_620792, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_620792 != nil:
    section.add "Action", valid_620792
  var valid_620793 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_620793 = validateParameter(valid_620793, JString, required = false,
                                 default = nil)
  if valid_620793 != nil:
    section.add "SnapshotClusterIdentifier", valid_620793
  var valid_620794 = query.getOrDefault("SnapshotIdentifier")
  valid_620794 = validateParameter(valid_620794, JString, required = true,
                                 default = nil)
  if valid_620794 != nil:
    section.add "SnapshotIdentifier", valid_620794
  var valid_620795 = query.getOrDefault("Version")
  valid_620795 = validateParameter(valid_620795, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620795 != nil:
    section.add "Version", valid_620795
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620796 = header.getOrDefault("X-Amz-Date")
  valid_620796 = validateParameter(valid_620796, JString, required = false,
                                 default = nil)
  if valid_620796 != nil:
    section.add "X-Amz-Date", valid_620796
  var valid_620797 = header.getOrDefault("X-Amz-Security-Token")
  valid_620797 = validateParameter(valid_620797, JString, required = false,
                                 default = nil)
  if valid_620797 != nil:
    section.add "X-Amz-Security-Token", valid_620797
  var valid_620798 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620798 = validateParameter(valid_620798, JString, required = false,
                                 default = nil)
  if valid_620798 != nil:
    section.add "X-Amz-Content-Sha256", valid_620798
  var valid_620799 = header.getOrDefault("X-Amz-Algorithm")
  valid_620799 = validateParameter(valid_620799, JString, required = false,
                                 default = nil)
  if valid_620799 != nil:
    section.add "X-Amz-Algorithm", valid_620799
  var valid_620800 = header.getOrDefault("X-Amz-Signature")
  valid_620800 = validateParameter(valid_620800, JString, required = false,
                                 default = nil)
  if valid_620800 != nil:
    section.add "X-Amz-Signature", valid_620800
  var valid_620801 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620801 = validateParameter(valid_620801, JString, required = false,
                                 default = nil)
  if valid_620801 != nil:
    section.add "X-Amz-SignedHeaders", valid_620801
  var valid_620802 = header.getOrDefault("X-Amz-Credential")
  valid_620802 = validateParameter(valid_620802, JString, required = false,
                                 default = nil)
  if valid_620802 != nil:
    section.add "X-Amz-Credential", valid_620802
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620803: Call_GetRevokeSnapshotAccess_620788; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_620803.validator(path, query, header, formData, body, _)
  let scheme = call_620803.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620803.url(scheme.get, call_620803.host, call_620803.base,
                         call_620803.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620803, url, valid, _)

proc call*(call_620804: Call_GetRevokeSnapshotAccess_620788;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          Action: string = "RevokeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: string (required)
  var query_620805 = newJObject()
  add(query_620805, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_620805, "Action", newJString(Action))
  add(query_620805, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_620805, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_620805, "Version", newJString(Version))
  result = call_620804.call(nil, query_620805, nil, nil, nil)

var getRevokeSnapshotAccess* = Call_GetRevokeSnapshotAccess_620788(
    name: "getRevokeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_GetRevokeSnapshotAccess_620789, base: "/",
    url: url_GetRevokeSnapshotAccess_620790, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRotateEncryptionKey_620841 = ref object of OpenApiRestCall_616850
proc url_PostRotateEncryptionKey_620843(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRotateEncryptionKey_620842(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_620844 = query.getOrDefault("Action")
  valid_620844 = validateParameter(valid_620844, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_620844 != nil:
    section.add "Action", valid_620844
  var valid_620845 = query.getOrDefault("Version")
  valid_620845 = validateParameter(valid_620845, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620845 != nil:
    section.add "Version", valid_620845
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620846 = header.getOrDefault("X-Amz-Date")
  valid_620846 = validateParameter(valid_620846, JString, required = false,
                                 default = nil)
  if valid_620846 != nil:
    section.add "X-Amz-Date", valid_620846
  var valid_620847 = header.getOrDefault("X-Amz-Security-Token")
  valid_620847 = validateParameter(valid_620847, JString, required = false,
                                 default = nil)
  if valid_620847 != nil:
    section.add "X-Amz-Security-Token", valid_620847
  var valid_620848 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620848 = validateParameter(valid_620848, JString, required = false,
                                 default = nil)
  if valid_620848 != nil:
    section.add "X-Amz-Content-Sha256", valid_620848
  var valid_620849 = header.getOrDefault("X-Amz-Algorithm")
  valid_620849 = validateParameter(valid_620849, JString, required = false,
                                 default = nil)
  if valid_620849 != nil:
    section.add "X-Amz-Algorithm", valid_620849
  var valid_620850 = header.getOrDefault("X-Amz-Signature")
  valid_620850 = validateParameter(valid_620850, JString, required = false,
                                 default = nil)
  if valid_620850 != nil:
    section.add "X-Amz-Signature", valid_620850
  var valid_620851 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620851 = validateParameter(valid_620851, JString, required = false,
                                 default = nil)
  if valid_620851 != nil:
    section.add "X-Amz-SignedHeaders", valid_620851
  var valid_620852 = header.getOrDefault("X-Amz-Credential")
  valid_620852 = validateParameter(valid_620852, JString, required = false,
                                 default = nil)
  if valid_620852 != nil:
    section.add "X-Amz-Credential", valid_620852
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_620853 = formData.getOrDefault("ClusterIdentifier")
  valid_620853 = validateParameter(valid_620853, JString, required = true,
                                 default = nil)
  if valid_620853 != nil:
    section.add "ClusterIdentifier", valid_620853
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620854: Call_PostRotateEncryptionKey_620841; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_620854.validator(path, query, header, formData, body, _)
  let scheme = call_620854.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620854.url(scheme.get, call_620854.host, call_620854.base,
                         call_620854.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620854, url, valid, _)

proc call*(call_620855: Call_PostRotateEncryptionKey_620841;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## postRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_620856 = newJObject()
  var formData_620857 = newJObject()
  add(query_620856, "Action", newJString(Action))
  add(formData_620857, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620856, "Version", newJString(Version))
  result = call_620855.call(nil, query_620856, nil, formData_620857, nil)

var postRotateEncryptionKey* = Call_PostRotateEncryptionKey_620841(
    name: "postRotateEncryptionKey", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_PostRotateEncryptionKey_620842, base: "/",
    url: url_PostRotateEncryptionKey_620843, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRotateEncryptionKey_620825 = ref object of OpenApiRestCall_616850
proc url_GetRotateEncryptionKey_620827(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base == "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRotateEncryptionKey_620826(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode; _: string = ""): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_620828 = query.getOrDefault("Action")
  valid_620828 = validateParameter(valid_620828, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_620828 != nil:
    section.add "Action", valid_620828
  var valid_620829 = query.getOrDefault("ClusterIdentifier")
  valid_620829 = validateParameter(valid_620829, JString, required = true,
                                 default = nil)
  if valid_620829 != nil:
    section.add "ClusterIdentifier", valid_620829
  var valid_620830 = query.getOrDefault("Version")
  valid_620830 = validateParameter(valid_620830, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_620830 != nil:
    section.add "Version", valid_620830
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_620831 = header.getOrDefault("X-Amz-Date")
  valid_620831 = validateParameter(valid_620831, JString, required = false,
                                 default = nil)
  if valid_620831 != nil:
    section.add "X-Amz-Date", valid_620831
  var valid_620832 = header.getOrDefault("X-Amz-Security-Token")
  valid_620832 = validateParameter(valid_620832, JString, required = false,
                                 default = nil)
  if valid_620832 != nil:
    section.add "X-Amz-Security-Token", valid_620832
  var valid_620833 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_620833 = validateParameter(valid_620833, JString, required = false,
                                 default = nil)
  if valid_620833 != nil:
    section.add "X-Amz-Content-Sha256", valid_620833
  var valid_620834 = header.getOrDefault("X-Amz-Algorithm")
  valid_620834 = validateParameter(valid_620834, JString, required = false,
                                 default = nil)
  if valid_620834 != nil:
    section.add "X-Amz-Algorithm", valid_620834
  var valid_620835 = header.getOrDefault("X-Amz-Signature")
  valid_620835 = validateParameter(valid_620835, JString, required = false,
                                 default = nil)
  if valid_620835 != nil:
    section.add "X-Amz-Signature", valid_620835
  var valid_620836 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_620836 = validateParameter(valid_620836, JString, required = false,
                                 default = nil)
  if valid_620836 != nil:
    section.add "X-Amz-SignedHeaders", valid_620836
  var valid_620837 = header.getOrDefault("X-Amz-Credential")
  valid_620837 = validateParameter(valid_620837, JString, required = false,
                                 default = nil)
  if valid_620837 != nil:
    section.add "X-Amz-Credential", valid_620837
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_620838: Call_GetRotateEncryptionKey_620825; path: JsonNode = nil;
          query: JsonNode = nil; header: JsonNode = nil; formData: JsonNode = nil;
          body: JsonNode = nil; _: string = ""): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_620838.validator(path, query, header, formData, body, _)
  let scheme = call_620838.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_620838.url(scheme.get, call_620838.host, call_620838.base,
                         call_620838.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_620838, url, valid, _)

proc call*(call_620839: Call_GetRotateEncryptionKey_620825;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## getRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_620840 = newJObject()
  add(query_620840, "Action", newJString(Action))
  add(query_620840, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_620840, "Version", newJString(Version))
  result = call_620839.call(nil, query_620840, nil, nil, nil)

var getRotateEncryptionKey* = Call_GetRotateEncryptionKey_620825(
    name: "getRotateEncryptionKey", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_GetRotateEncryptionKey_620826, base: "/",
    url: url_GetRotateEncryptionKey_620827, schemes: {Scheme.Https, Scheme.Http})
export
  rest

type
  EnvKind = enum
    BakeIntoBinary = "Baking $1 into the binary",
    FetchFromEnv = "Fetch $1 from the environment"
template sloppyConst(via: EnvKind; name: untyped): untyped =
  import
    macros

  const
    name {.strdefine.}: string = case via
    of BakeIntoBinary:
      getEnv(astToStr(name), "")
    of FetchFromEnv:
      ""
  static :
    let msg = block:
      if name == "":
        "Missing $1 in the environment"
      else:
        $via
    warning msg % [astToStr(name)]

sloppyConst FetchFromEnv, AWS_ACCESS_KEY_ID
sloppyConst FetchFromEnv, AWS_SECRET_ACCESS_KEY
sloppyConst BakeIntoBinary, AWS_REGION
sloppyConst FetchFromEnv, AWS_ACCOUNT_ID
type
  XAmz = enum
    SecurityToken = "X-Amz-Security-Token", ContentSha256 = "X-Amz-Content-Sha256"
proc atozSign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", AWS_ACCESS_KEY_ID)
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", AWS_SECRET_ACCESS_KEY)
    region = os.getEnv("AWS_REGION", AWS_REGION)
  assert secret != "", "need $AWS_SECRET_ACCESS_KEY in environment"
  assert access != "", "need $AWS_ACCESS_KEY_ID in environment"
  assert region != "", "need $AWS_REGION in environment"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  recall.headers[$ContentSha256] = hash(recall.body, SHA256)
  let
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode; body = ""): Recallable {.
    base.} =
  ## the hook is a terrible earworm
  var
    headers = newHttpHeaders(massageHeaders(input.getOrDefault("header")))
    text = body
  if text.len == 0 and "body" in input:
    text = input.getOrDefault("body").getStr
    if not headers.hasKey("content-type"):
      headers["content-type"] = "application/x-amz-json-1.0"
  else:
    headers["content-md5"] = $text.toMD5
  if not headers.hasKey($SecurityToken):
    let session = getEnv("AWS_SESSION_TOKEN", "")
    if session != "":
      headers[$SecurityToken] = session
  result = newRecallable(call, url, headers, text)
  result.atozSign(input.getOrDefault("query"), SHA256)
