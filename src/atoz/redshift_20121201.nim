
import
  json, options, hashes, uri, strutils, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: Amazon Redshift
## version: 2012-12-01
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>Amazon Redshift</fullname> <p> <b>Overview</b> </p> <p>This is an interface reference for Amazon Redshift. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Redshift clusters. Note that Amazon Redshift is asynchronous, which means that some interfaces may require techniques, such as polling or asynchronous callback handlers, to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a change is applied immediately, on the next instance reboot, or during the next maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the Amazon Redshift Management Interfaces</a>.</p> <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data warehouse: provisioning capacity, monitoring and backing up the cluster, and applying patches and upgrades to the Amazon Redshift engine. You can focus on using your data to acquire new insights for your business and customers.</p> <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p> <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design, build, query, and maintain the databases that make up your data warehouse. </p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/redshift/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_599352 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_599352](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_599352): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com", "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
                           "us-west-2": "redshift.us-west-2.amazonaws.com",
                           "eu-west-2": "redshift.eu-west-2.amazonaws.com", "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com", "eu-central-1": "redshift.eu-central-1.amazonaws.com",
                           "us-east-2": "redshift.us-east-2.amazonaws.com",
                           "us-east-1": "redshift.us-east-1.amazonaws.com", "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "redshift.ap-south-1.amazonaws.com",
                           "eu-north-1": "redshift.eu-north-1.amazonaws.com", "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
                           "us-west-1": "redshift.us-west-1.amazonaws.com", "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "redshift.eu-west-3.amazonaws.com", "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "redshift.sa-east-1.amazonaws.com",
                           "eu-west-1": "redshift.eu-west-1.amazonaws.com", "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com", "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com", "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
      "us-west-2": "redshift.us-west-2.amazonaws.com",
      "eu-west-2": "redshift.eu-west-2.amazonaws.com",
      "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com",
      "eu-central-1": "redshift.eu-central-1.amazonaws.com",
      "us-east-2": "redshift.us-east-2.amazonaws.com",
      "us-east-1": "redshift.us-east-1.amazonaws.com",
      "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "redshift.ap-south-1.amazonaws.com",
      "eu-north-1": "redshift.eu-north-1.amazonaws.com",
      "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
      "us-west-1": "redshift.us-west-1.amazonaws.com",
      "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
      "eu-west-3": "redshift.eu-west-3.amazonaws.com",
      "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "redshift.sa-east-1.amazonaws.com",
      "eu-west-1": "redshift.eu-west-1.amazonaws.com",
      "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com",
      "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "redshift"
method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_PostAcceptReservedNodeExchange_599961 = ref object of OpenApiRestCall_599352
proc url_PostAcceptReservedNodeExchange_599963(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAcceptReservedNodeExchange_599962(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_599964 = query.getOrDefault("Action")
  valid_599964 = validateParameter(valid_599964, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_599964 != nil:
    section.add "Action", valid_599964
  var valid_599965 = query.getOrDefault("Version")
  valid_599965 = validateParameter(valid_599965, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_599965 != nil:
    section.add "Version", valid_599965
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_599966 = header.getOrDefault("X-Amz-Date")
  valid_599966 = validateParameter(valid_599966, JString, required = false,
                                 default = nil)
  if valid_599966 != nil:
    section.add "X-Amz-Date", valid_599966
  var valid_599967 = header.getOrDefault("X-Amz-Security-Token")
  valid_599967 = validateParameter(valid_599967, JString, required = false,
                                 default = nil)
  if valid_599967 != nil:
    section.add "X-Amz-Security-Token", valid_599967
  var valid_599968 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_599968 = validateParameter(valid_599968, JString, required = false,
                                 default = nil)
  if valid_599968 != nil:
    section.add "X-Amz-Content-Sha256", valid_599968
  var valid_599969 = header.getOrDefault("X-Amz-Algorithm")
  valid_599969 = validateParameter(valid_599969, JString, required = false,
                                 default = nil)
  if valid_599969 != nil:
    section.add "X-Amz-Algorithm", valid_599969
  var valid_599970 = header.getOrDefault("X-Amz-Signature")
  valid_599970 = validateParameter(valid_599970, JString, required = false,
                                 default = nil)
  if valid_599970 != nil:
    section.add "X-Amz-Signature", valid_599970
  var valid_599971 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_599971 = validateParameter(valid_599971, JString, required = false,
                                 default = nil)
  if valid_599971 != nil:
    section.add "X-Amz-SignedHeaders", valid_599971
  var valid_599972 = header.getOrDefault("X-Amz-Credential")
  valid_599972 = validateParameter(valid_599972, JString, required = false,
                                 default = nil)
  if valid_599972 != nil:
    section.add "X-Amz-Credential", valid_599972
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_599973 = formData.getOrDefault("ReservedNodeId")
  valid_599973 = validateParameter(valid_599973, JString, required = true,
                                 default = nil)
  if valid_599973 != nil:
    section.add "ReservedNodeId", valid_599973
  var valid_599974 = formData.getOrDefault("TargetReservedNodeOfferingId")
  valid_599974 = validateParameter(valid_599974, JString, required = true,
                                 default = nil)
  if valid_599974 != nil:
    section.add "TargetReservedNodeOfferingId", valid_599974
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_599975: Call_PostAcceptReservedNodeExchange_599961; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_599975.validator(path, query, header, formData, body)
  let scheme = call_599975.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_599975.url(scheme.get, call_599975.host, call_599975.base,
                         call_599975.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_599975, url, valid)

proc call*(call_599976: Call_PostAcceptReservedNodeExchange_599961;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## postAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_599977 = newJObject()
  var formData_599978 = newJObject()
  add(formData_599978, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_599978, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_599977, "Action", newJString(Action))
  add(query_599977, "Version", newJString(Version))
  result = call_599976.call(nil, query_599977, nil, formData_599978, nil)

var postAcceptReservedNodeExchange* = Call_PostAcceptReservedNodeExchange_599961(
    name: "postAcceptReservedNodeExchange", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_PostAcceptReservedNodeExchange_599962, base: "/",
    url: url_PostAcceptReservedNodeExchange_599963,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAcceptReservedNodeExchange_599689 = ref object of OpenApiRestCall_599352
proc url_GetAcceptReservedNodeExchange_599691(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAcceptReservedNodeExchange_599690(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Version: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_599816 = query.getOrDefault("Action")
  valid_599816 = validateParameter(valid_599816, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_599816 != nil:
    section.add "Action", valid_599816
  var valid_599817 = query.getOrDefault("TargetReservedNodeOfferingId")
  valid_599817 = validateParameter(valid_599817, JString, required = true,
                                 default = nil)
  if valid_599817 != nil:
    section.add "TargetReservedNodeOfferingId", valid_599817
  var valid_599818 = query.getOrDefault("Version")
  valid_599818 = validateParameter(valid_599818, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_599818 != nil:
    section.add "Version", valid_599818
  var valid_599819 = query.getOrDefault("ReservedNodeId")
  valid_599819 = validateParameter(valid_599819, JString, required = true,
                                 default = nil)
  if valid_599819 != nil:
    section.add "ReservedNodeId", valid_599819
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_599820 = header.getOrDefault("X-Amz-Date")
  valid_599820 = validateParameter(valid_599820, JString, required = false,
                                 default = nil)
  if valid_599820 != nil:
    section.add "X-Amz-Date", valid_599820
  var valid_599821 = header.getOrDefault("X-Amz-Security-Token")
  valid_599821 = validateParameter(valid_599821, JString, required = false,
                                 default = nil)
  if valid_599821 != nil:
    section.add "X-Amz-Security-Token", valid_599821
  var valid_599822 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_599822 = validateParameter(valid_599822, JString, required = false,
                                 default = nil)
  if valid_599822 != nil:
    section.add "X-Amz-Content-Sha256", valid_599822
  var valid_599823 = header.getOrDefault("X-Amz-Algorithm")
  valid_599823 = validateParameter(valid_599823, JString, required = false,
                                 default = nil)
  if valid_599823 != nil:
    section.add "X-Amz-Algorithm", valid_599823
  var valid_599824 = header.getOrDefault("X-Amz-Signature")
  valid_599824 = validateParameter(valid_599824, JString, required = false,
                                 default = nil)
  if valid_599824 != nil:
    section.add "X-Amz-Signature", valid_599824
  var valid_599825 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_599825 = validateParameter(valid_599825, JString, required = false,
                                 default = nil)
  if valid_599825 != nil:
    section.add "X-Amz-SignedHeaders", valid_599825
  var valid_599826 = header.getOrDefault("X-Amz-Credential")
  valid_599826 = validateParameter(valid_599826, JString, required = false,
                                 default = nil)
  if valid_599826 != nil:
    section.add "X-Amz-Credential", valid_599826
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_599849: Call_GetAcceptReservedNodeExchange_599689; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_599849.validator(path, query, header, formData, body)
  let scheme = call_599849.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_599849.url(scheme.get, call_599849.host, call_599849.base,
                         call_599849.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_599849, url, valid)

proc call*(call_599920: Call_GetAcceptReservedNodeExchange_599689;
          TargetReservedNodeOfferingId: string; ReservedNodeId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## getAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   Action: string (required)
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Version: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  var query_599921 = newJObject()
  add(query_599921, "Action", newJString(Action))
  add(query_599921, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_599921, "Version", newJString(Version))
  add(query_599921, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_599920.call(nil, query_599921, nil, nil, nil)

var getAcceptReservedNodeExchange* = Call_GetAcceptReservedNodeExchange_599689(
    name: "getAcceptReservedNodeExchange", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_GetAcceptReservedNodeExchange_599690, base: "/",
    url: url_GetAcceptReservedNodeExchange_599691,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeClusterSecurityGroupIngress_599998 = ref object of OpenApiRestCall_599352
proc url_PostAuthorizeClusterSecurityGroupIngress_600000(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeClusterSecurityGroupIngress_599999(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600001 = query.getOrDefault("Action")
  valid_600001 = validateParameter(valid_600001, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_600001 != nil:
    section.add "Action", valid_600001
  var valid_600002 = query.getOrDefault("Version")
  valid_600002 = validateParameter(valid_600002, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600002 != nil:
    section.add "Version", valid_600002
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600003 = header.getOrDefault("X-Amz-Date")
  valid_600003 = validateParameter(valid_600003, JString, required = false,
                                 default = nil)
  if valid_600003 != nil:
    section.add "X-Amz-Date", valid_600003
  var valid_600004 = header.getOrDefault("X-Amz-Security-Token")
  valid_600004 = validateParameter(valid_600004, JString, required = false,
                                 default = nil)
  if valid_600004 != nil:
    section.add "X-Amz-Security-Token", valid_600004
  var valid_600005 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600005 = validateParameter(valid_600005, JString, required = false,
                                 default = nil)
  if valid_600005 != nil:
    section.add "X-Amz-Content-Sha256", valid_600005
  var valid_600006 = header.getOrDefault("X-Amz-Algorithm")
  valid_600006 = validateParameter(valid_600006, JString, required = false,
                                 default = nil)
  if valid_600006 != nil:
    section.add "X-Amz-Algorithm", valid_600006
  var valid_600007 = header.getOrDefault("X-Amz-Signature")
  valid_600007 = validateParameter(valid_600007, JString, required = false,
                                 default = nil)
  if valid_600007 != nil:
    section.add "X-Amz-Signature", valid_600007
  var valid_600008 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600008 = validateParameter(valid_600008, JString, required = false,
                                 default = nil)
  if valid_600008 != nil:
    section.add "X-Amz-SignedHeaders", valid_600008
  var valid_600009 = header.getOrDefault("X-Amz-Credential")
  valid_600009 = validateParameter(valid_600009, JString, required = false,
                                 default = nil)
  if valid_600009 != nil:
    section.add "X-Amz-Credential", valid_600009
  result.add "header", section
  ## parameters in `formData` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  section = newJObject()
  var valid_600010 = formData.getOrDefault("EC2SecurityGroupName")
  valid_600010 = validateParameter(valid_600010, JString, required = false,
                                 default = nil)
  if valid_600010 != nil:
    section.add "EC2SecurityGroupName", valid_600010
  var valid_600011 = formData.getOrDefault("CIDRIP")
  valid_600011 = validateParameter(valid_600011, JString, required = false,
                                 default = nil)
  if valid_600011 != nil:
    section.add "CIDRIP", valid_600011
  var valid_600012 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_600012 = validateParameter(valid_600012, JString, required = false,
                                 default = nil)
  if valid_600012 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_600012
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_600013 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_600013 = validateParameter(valid_600013, JString, required = true,
                                 default = nil)
  if valid_600013 != nil:
    section.add "ClusterSecurityGroupName", valid_600013
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600014: Call_PostAuthorizeClusterSecurityGroupIngress_599998;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600014.validator(path, query, header, formData, body)
  let scheme = call_600014.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600014.url(scheme.get, call_600014.host, call_600014.base,
                         call_600014.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600014, url, valid)

proc call*(call_600015: Call_PostAuthorizeClusterSecurityGroupIngress_599998;
          ClusterSecurityGroupName: string;
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          EC2SecurityGroupName: string = ""; CIDRIP: string = "";
          Version: string = "2012-12-01"; EC2SecurityGroupOwnerId: string = ""): Recallable =
  ## postAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   Version: string (required)
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  var query_600016 = newJObject()
  var formData_600017 = newJObject()
  add(query_600016, "Action", newJString(Action))
  add(formData_600017, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_600017, "CIDRIP", newJString(CIDRIP))
  add(query_600016, "Version", newJString(Version))
  add(formData_600017, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_600017, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_600015.call(nil, query_600016, nil, formData_600017, nil)

var postAuthorizeClusterSecurityGroupIngress* = Call_PostAuthorizeClusterSecurityGroupIngress_599998(
    name: "postAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_PostAuthorizeClusterSecurityGroupIngress_599999,
    base: "/", url: url_PostAuthorizeClusterSecurityGroupIngress_600000,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeClusterSecurityGroupIngress_599979 = ref object of OpenApiRestCall_599352
proc url_GetAuthorizeClusterSecurityGroupIngress_599981(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeClusterSecurityGroupIngress_599980(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_599982 = query.getOrDefault("ClusterSecurityGroupName")
  valid_599982 = validateParameter(valid_599982, JString, required = true,
                                 default = nil)
  if valid_599982 != nil:
    section.add "ClusterSecurityGroupName", valid_599982
  var valid_599983 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_599983 = validateParameter(valid_599983, JString, required = false,
                                 default = nil)
  if valid_599983 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_599983
  var valid_599984 = query.getOrDefault("Action")
  valid_599984 = validateParameter(valid_599984, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_599984 != nil:
    section.add "Action", valid_599984
  var valid_599985 = query.getOrDefault("CIDRIP")
  valid_599985 = validateParameter(valid_599985, JString, required = false,
                                 default = nil)
  if valid_599985 != nil:
    section.add "CIDRIP", valid_599985
  var valid_599986 = query.getOrDefault("EC2SecurityGroupName")
  valid_599986 = validateParameter(valid_599986, JString, required = false,
                                 default = nil)
  if valid_599986 != nil:
    section.add "EC2SecurityGroupName", valid_599986
  var valid_599987 = query.getOrDefault("Version")
  valid_599987 = validateParameter(valid_599987, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_599987 != nil:
    section.add "Version", valid_599987
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_599988 = header.getOrDefault("X-Amz-Date")
  valid_599988 = validateParameter(valid_599988, JString, required = false,
                                 default = nil)
  if valid_599988 != nil:
    section.add "X-Amz-Date", valid_599988
  var valid_599989 = header.getOrDefault("X-Amz-Security-Token")
  valid_599989 = validateParameter(valid_599989, JString, required = false,
                                 default = nil)
  if valid_599989 != nil:
    section.add "X-Amz-Security-Token", valid_599989
  var valid_599990 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_599990 = validateParameter(valid_599990, JString, required = false,
                                 default = nil)
  if valid_599990 != nil:
    section.add "X-Amz-Content-Sha256", valid_599990
  var valid_599991 = header.getOrDefault("X-Amz-Algorithm")
  valid_599991 = validateParameter(valid_599991, JString, required = false,
                                 default = nil)
  if valid_599991 != nil:
    section.add "X-Amz-Algorithm", valid_599991
  var valid_599992 = header.getOrDefault("X-Amz-Signature")
  valid_599992 = validateParameter(valid_599992, JString, required = false,
                                 default = nil)
  if valid_599992 != nil:
    section.add "X-Amz-Signature", valid_599992
  var valid_599993 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_599993 = validateParameter(valid_599993, JString, required = false,
                                 default = nil)
  if valid_599993 != nil:
    section.add "X-Amz-SignedHeaders", valid_599993
  var valid_599994 = header.getOrDefault("X-Amz-Credential")
  valid_599994 = validateParameter(valid_599994, JString, required = false,
                                 default = nil)
  if valid_599994 != nil:
    section.add "X-Amz-Credential", valid_599994
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_599995: Call_GetAuthorizeClusterSecurityGroupIngress_599979;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_599995.validator(path, query, header, formData, body)
  let scheme = call_599995.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_599995.url(scheme.get, call_599995.host, call_599995.base,
                         call_599995.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_599995, url, valid)

proc call*(call_599996: Call_GetAuthorizeClusterSecurityGroupIngress_599979;
          ClusterSecurityGroupName: string; EC2SecurityGroupOwnerId: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          CIDRIP: string = ""; EC2SecurityGroupName: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: string (required)
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   Version: string (required)
  var query_599997 = newJObject()
  add(query_599997, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_599997, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_599997, "Action", newJString(Action))
  add(query_599997, "CIDRIP", newJString(CIDRIP))
  add(query_599997, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_599997, "Version", newJString(Version))
  result = call_599996.call(nil, query_599997, nil, nil, nil)

var getAuthorizeClusterSecurityGroupIngress* = Call_GetAuthorizeClusterSecurityGroupIngress_599979(
    name: "getAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_GetAuthorizeClusterSecurityGroupIngress_599980, base: "/",
    url: url_GetAuthorizeClusterSecurityGroupIngress_599981,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeSnapshotAccess_600036 = ref object of OpenApiRestCall_599352
proc url_PostAuthorizeSnapshotAccess_600038(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostAuthorizeSnapshotAccess_600037(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600039 = query.getOrDefault("Action")
  valid_600039 = validateParameter(valid_600039, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_600039 != nil:
    section.add "Action", valid_600039
  var valid_600040 = query.getOrDefault("Version")
  valid_600040 = validateParameter(valid_600040, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600040 != nil:
    section.add "Version", valid_600040
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600041 = header.getOrDefault("X-Amz-Date")
  valid_600041 = validateParameter(valid_600041, JString, required = false,
                                 default = nil)
  if valid_600041 != nil:
    section.add "X-Amz-Date", valid_600041
  var valid_600042 = header.getOrDefault("X-Amz-Security-Token")
  valid_600042 = validateParameter(valid_600042, JString, required = false,
                                 default = nil)
  if valid_600042 != nil:
    section.add "X-Amz-Security-Token", valid_600042
  var valid_600043 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600043 = validateParameter(valid_600043, JString, required = false,
                                 default = nil)
  if valid_600043 != nil:
    section.add "X-Amz-Content-Sha256", valid_600043
  var valid_600044 = header.getOrDefault("X-Amz-Algorithm")
  valid_600044 = validateParameter(valid_600044, JString, required = false,
                                 default = nil)
  if valid_600044 != nil:
    section.add "X-Amz-Algorithm", valid_600044
  var valid_600045 = header.getOrDefault("X-Amz-Signature")
  valid_600045 = validateParameter(valid_600045, JString, required = false,
                                 default = nil)
  if valid_600045 != nil:
    section.add "X-Amz-Signature", valid_600045
  var valid_600046 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600046 = validateParameter(valid_600046, JString, required = false,
                                 default = nil)
  if valid_600046 != nil:
    section.add "X-Amz-SignedHeaders", valid_600046
  var valid_600047 = header.getOrDefault("X-Amz-Credential")
  valid_600047 = validateParameter(valid_600047, JString, required = false,
                                 default = nil)
  if valid_600047 != nil:
    section.add "X-Amz-Credential", valid_600047
  result.add "header", section
  ## parameters in `formData` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_600048 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_600048 = validateParameter(valid_600048, JString, required = true,
                                 default = nil)
  if valid_600048 != nil:
    section.add "AccountWithRestoreAccess", valid_600048
  var valid_600049 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_600049 = validateParameter(valid_600049, JString, required = false,
                                 default = nil)
  if valid_600049 != nil:
    section.add "SnapshotClusterIdentifier", valid_600049
  var valid_600050 = formData.getOrDefault("SnapshotIdentifier")
  valid_600050 = validateParameter(valid_600050, JString, required = true,
                                 default = nil)
  if valid_600050 != nil:
    section.add "SnapshotIdentifier", valid_600050
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600051: Call_PostAuthorizeSnapshotAccess_600036; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600051.validator(path, query, header, formData, body)
  let scheme = call_600051.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600051.url(scheme.get, call_600051.host, call_600051.base,
                         call_600051.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600051, url, valid)

proc call*(call_600052: Call_PostAuthorizeSnapshotAccess_600036;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "AuthorizeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: string (required)
  var query_600053 = newJObject()
  var formData_600054 = newJObject()
  add(formData_600054, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_600054, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_600053, "Action", newJString(Action))
  add(formData_600054, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_600053, "Version", newJString(Version))
  result = call_600052.call(nil, query_600053, nil, formData_600054, nil)

var postAuthorizeSnapshotAccess* = Call_PostAuthorizeSnapshotAccess_600036(
    name: "postAuthorizeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_PostAuthorizeSnapshotAccess_600037, base: "/",
    url: url_PostAuthorizeSnapshotAccess_600038,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeSnapshotAccess_600018 = ref object of OpenApiRestCall_599352
proc url_GetAuthorizeSnapshotAccess_600020(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetAuthorizeSnapshotAccess_600019(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_600021 = query.getOrDefault("AccountWithRestoreAccess")
  valid_600021 = validateParameter(valid_600021, JString, required = true,
                                 default = nil)
  if valid_600021 != nil:
    section.add "AccountWithRestoreAccess", valid_600021
  var valid_600022 = query.getOrDefault("Action")
  valid_600022 = validateParameter(valid_600022, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_600022 != nil:
    section.add "Action", valid_600022
  var valid_600023 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_600023 = validateParameter(valid_600023, JString, required = false,
                                 default = nil)
  if valid_600023 != nil:
    section.add "SnapshotClusterIdentifier", valid_600023
  var valid_600024 = query.getOrDefault("SnapshotIdentifier")
  valid_600024 = validateParameter(valid_600024, JString, required = true,
                                 default = nil)
  if valid_600024 != nil:
    section.add "SnapshotIdentifier", valid_600024
  var valid_600025 = query.getOrDefault("Version")
  valid_600025 = validateParameter(valid_600025, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600025 != nil:
    section.add "Version", valid_600025
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600026 = header.getOrDefault("X-Amz-Date")
  valid_600026 = validateParameter(valid_600026, JString, required = false,
                                 default = nil)
  if valid_600026 != nil:
    section.add "X-Amz-Date", valid_600026
  var valid_600027 = header.getOrDefault("X-Amz-Security-Token")
  valid_600027 = validateParameter(valid_600027, JString, required = false,
                                 default = nil)
  if valid_600027 != nil:
    section.add "X-Amz-Security-Token", valid_600027
  var valid_600028 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600028 = validateParameter(valid_600028, JString, required = false,
                                 default = nil)
  if valid_600028 != nil:
    section.add "X-Amz-Content-Sha256", valid_600028
  var valid_600029 = header.getOrDefault("X-Amz-Algorithm")
  valid_600029 = validateParameter(valid_600029, JString, required = false,
                                 default = nil)
  if valid_600029 != nil:
    section.add "X-Amz-Algorithm", valid_600029
  var valid_600030 = header.getOrDefault("X-Amz-Signature")
  valid_600030 = validateParameter(valid_600030, JString, required = false,
                                 default = nil)
  if valid_600030 != nil:
    section.add "X-Amz-Signature", valid_600030
  var valid_600031 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600031 = validateParameter(valid_600031, JString, required = false,
                                 default = nil)
  if valid_600031 != nil:
    section.add "X-Amz-SignedHeaders", valid_600031
  var valid_600032 = header.getOrDefault("X-Amz-Credential")
  valid_600032 = validateParameter(valid_600032, JString, required = false,
                                 default = nil)
  if valid_600032 != nil:
    section.add "X-Amz-Credential", valid_600032
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600033: Call_GetAuthorizeSnapshotAccess_600018; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600033.validator(path, query, header, formData, body)
  let scheme = call_600033.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600033.url(scheme.get, call_600033.host, call_600033.base,
                         call_600033.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600033, url, valid)

proc call*(call_600034: Call_GetAuthorizeSnapshotAccess_600018;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          Action: string = "AuthorizeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Version: string (required)
  var query_600035 = newJObject()
  add(query_600035, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_600035, "Action", newJString(Action))
  add(query_600035, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_600035, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_600035, "Version", newJString(Version))
  result = call_600034.call(nil, query_600035, nil, nil, nil)

var getAuthorizeSnapshotAccess* = Call_GetAuthorizeSnapshotAccess_600018(
    name: "getAuthorizeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_GetAuthorizeSnapshotAccess_600019, base: "/",
    url: url_GetAuthorizeSnapshotAccess_600020,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchDeleteClusterSnapshots_600071 = ref object of OpenApiRestCall_599352
proc url_PostBatchDeleteClusterSnapshots_600073(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchDeleteClusterSnapshots_600072(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600074 = query.getOrDefault("Action")
  valid_600074 = validateParameter(valid_600074, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_600074 != nil:
    section.add "Action", valid_600074
  var valid_600075 = query.getOrDefault("Version")
  valid_600075 = validateParameter(valid_600075, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600075 != nil:
    section.add "Version", valid_600075
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600076 = header.getOrDefault("X-Amz-Date")
  valid_600076 = validateParameter(valid_600076, JString, required = false,
                                 default = nil)
  if valid_600076 != nil:
    section.add "X-Amz-Date", valid_600076
  var valid_600077 = header.getOrDefault("X-Amz-Security-Token")
  valid_600077 = validateParameter(valid_600077, JString, required = false,
                                 default = nil)
  if valid_600077 != nil:
    section.add "X-Amz-Security-Token", valid_600077
  var valid_600078 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600078 = validateParameter(valid_600078, JString, required = false,
                                 default = nil)
  if valid_600078 != nil:
    section.add "X-Amz-Content-Sha256", valid_600078
  var valid_600079 = header.getOrDefault("X-Amz-Algorithm")
  valid_600079 = validateParameter(valid_600079, JString, required = false,
                                 default = nil)
  if valid_600079 != nil:
    section.add "X-Amz-Algorithm", valid_600079
  var valid_600080 = header.getOrDefault("X-Amz-Signature")
  valid_600080 = validateParameter(valid_600080, JString, required = false,
                                 default = nil)
  if valid_600080 != nil:
    section.add "X-Amz-Signature", valid_600080
  var valid_600081 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600081 = validateParameter(valid_600081, JString, required = false,
                                 default = nil)
  if valid_600081 != nil:
    section.add "X-Amz-SignedHeaders", valid_600081
  var valid_600082 = header.getOrDefault("X-Amz-Credential")
  valid_600082 = validateParameter(valid_600082, JString, required = false,
                                 default = nil)
  if valid_600082 != nil:
    section.add "X-Amz-Credential", valid_600082
  result.add "header", section
  ## parameters in `formData` object:
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Identifiers` field"
  var valid_600083 = formData.getOrDefault("Identifiers")
  valid_600083 = validateParameter(valid_600083, JArray, required = true, default = nil)
  if valid_600083 != nil:
    section.add "Identifiers", valid_600083
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600084: Call_PostBatchDeleteClusterSnapshots_600071;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_600084.validator(path, query, header, formData, body)
  let scheme = call_600084.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600084.url(scheme.get, call_600084.host, call_600084.base,
                         call_600084.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600084, url, valid)

proc call*(call_600085: Call_PostBatchDeleteClusterSnapshots_600071;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## postBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_600086 = newJObject()
  var formData_600087 = newJObject()
  if Identifiers != nil:
    formData_600087.add "Identifiers", Identifiers
  add(query_600086, "Action", newJString(Action))
  add(query_600086, "Version", newJString(Version))
  result = call_600085.call(nil, query_600086, nil, formData_600087, nil)

var postBatchDeleteClusterSnapshots* = Call_PostBatchDeleteClusterSnapshots_600071(
    name: "postBatchDeleteClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_PostBatchDeleteClusterSnapshots_600072, base: "/",
    url: url_PostBatchDeleteClusterSnapshots_600073,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchDeleteClusterSnapshots_600055 = ref object of OpenApiRestCall_599352
proc url_GetBatchDeleteClusterSnapshots_600057(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchDeleteClusterSnapshots_600056(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600058 = query.getOrDefault("Action")
  valid_600058 = validateParameter(valid_600058, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_600058 != nil:
    section.add "Action", valid_600058
  var valid_600059 = query.getOrDefault("Identifiers")
  valid_600059 = validateParameter(valid_600059, JArray, required = true, default = nil)
  if valid_600059 != nil:
    section.add "Identifiers", valid_600059
  var valid_600060 = query.getOrDefault("Version")
  valid_600060 = validateParameter(valid_600060, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600060 != nil:
    section.add "Version", valid_600060
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600061 = header.getOrDefault("X-Amz-Date")
  valid_600061 = validateParameter(valid_600061, JString, required = false,
                                 default = nil)
  if valid_600061 != nil:
    section.add "X-Amz-Date", valid_600061
  var valid_600062 = header.getOrDefault("X-Amz-Security-Token")
  valid_600062 = validateParameter(valid_600062, JString, required = false,
                                 default = nil)
  if valid_600062 != nil:
    section.add "X-Amz-Security-Token", valid_600062
  var valid_600063 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600063 = validateParameter(valid_600063, JString, required = false,
                                 default = nil)
  if valid_600063 != nil:
    section.add "X-Amz-Content-Sha256", valid_600063
  var valid_600064 = header.getOrDefault("X-Amz-Algorithm")
  valid_600064 = validateParameter(valid_600064, JString, required = false,
                                 default = nil)
  if valid_600064 != nil:
    section.add "X-Amz-Algorithm", valid_600064
  var valid_600065 = header.getOrDefault("X-Amz-Signature")
  valid_600065 = validateParameter(valid_600065, JString, required = false,
                                 default = nil)
  if valid_600065 != nil:
    section.add "X-Amz-Signature", valid_600065
  var valid_600066 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600066 = validateParameter(valid_600066, JString, required = false,
                                 default = nil)
  if valid_600066 != nil:
    section.add "X-Amz-SignedHeaders", valid_600066
  var valid_600067 = header.getOrDefault("X-Amz-Credential")
  valid_600067 = validateParameter(valid_600067, JString, required = false,
                                 default = nil)
  if valid_600067 != nil:
    section.add "X-Amz-Credential", valid_600067
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600068: Call_GetBatchDeleteClusterSnapshots_600055; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_600068.validator(path, query, header, formData, body)
  let scheme = call_600068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600068.url(scheme.get, call_600068.host, call_600068.base,
                         call_600068.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600068, url, valid)

proc call*(call_600069: Call_GetBatchDeleteClusterSnapshots_600055;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Action: string (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: string (required)
  var query_600070 = newJObject()
  add(query_600070, "Action", newJString(Action))
  if Identifiers != nil:
    query_600070.add "Identifiers", Identifiers
  add(query_600070, "Version", newJString(Version))
  result = call_600069.call(nil, query_600070, nil, nil, nil)

var getBatchDeleteClusterSnapshots* = Call_GetBatchDeleteClusterSnapshots_600055(
    name: "getBatchDeleteClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_GetBatchDeleteClusterSnapshots_600056, base: "/",
    url: url_GetBatchDeleteClusterSnapshots_600057,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchModifyClusterSnapshots_600106 = ref object of OpenApiRestCall_599352
proc url_PostBatchModifyClusterSnapshots_600108(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostBatchModifyClusterSnapshots_600107(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600109 = query.getOrDefault("Action")
  valid_600109 = validateParameter(valid_600109, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_600109 != nil:
    section.add "Action", valid_600109
  var valid_600110 = query.getOrDefault("Version")
  valid_600110 = validateParameter(valid_600110, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600110 != nil:
    section.add "Version", valid_600110
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600111 = header.getOrDefault("X-Amz-Date")
  valid_600111 = validateParameter(valid_600111, JString, required = false,
                                 default = nil)
  if valid_600111 != nil:
    section.add "X-Amz-Date", valid_600111
  var valid_600112 = header.getOrDefault("X-Amz-Security-Token")
  valid_600112 = validateParameter(valid_600112, JString, required = false,
                                 default = nil)
  if valid_600112 != nil:
    section.add "X-Amz-Security-Token", valid_600112
  var valid_600113 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600113 = validateParameter(valid_600113, JString, required = false,
                                 default = nil)
  if valid_600113 != nil:
    section.add "X-Amz-Content-Sha256", valid_600113
  var valid_600114 = header.getOrDefault("X-Amz-Algorithm")
  valid_600114 = validateParameter(valid_600114, JString, required = false,
                                 default = nil)
  if valid_600114 != nil:
    section.add "X-Amz-Algorithm", valid_600114
  var valid_600115 = header.getOrDefault("X-Amz-Signature")
  valid_600115 = validateParameter(valid_600115, JString, required = false,
                                 default = nil)
  if valid_600115 != nil:
    section.add "X-Amz-Signature", valid_600115
  var valid_600116 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600116 = validateParameter(valid_600116, JString, required = false,
                                 default = nil)
  if valid_600116 != nil:
    section.add "X-Amz-SignedHeaders", valid_600116
  var valid_600117 = header.getOrDefault("X-Amz-Credential")
  valid_600117 = validateParameter(valid_600117, JString, required = false,
                                 default = nil)
  if valid_600117 != nil:
    section.add "X-Amz-Credential", valid_600117
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  var valid_600118 = formData.getOrDefault("Force")
  valid_600118 = validateParameter(valid_600118, JBool, required = false, default = nil)
  if valid_600118 != nil:
    section.add "Force", valid_600118
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_600119 = formData.getOrDefault("SnapshotIdentifierList")
  valid_600119 = validateParameter(valid_600119, JArray, required = true, default = nil)
  if valid_600119 != nil:
    section.add "SnapshotIdentifierList", valid_600119
  var valid_600120 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_600120 = validateParameter(valid_600120, JInt, required = false, default = nil)
  if valid_600120 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_600120
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600121: Call_PostBatchModifyClusterSnapshots_600106;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_600121.validator(path, query, header, formData, body)
  let scheme = call_600121.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600121.url(scheme.get, call_600121.host, call_600121.base,
                         call_600121.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600121, url, valid)

proc call*(call_600122: Call_PostBatchModifyClusterSnapshots_600106;
          SnapshotIdentifierList: JsonNode; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Version: string (required)
  var query_600123 = newJObject()
  var formData_600124 = newJObject()
  add(formData_600124, "Force", newJBool(Force))
  if SnapshotIdentifierList != nil:
    formData_600124.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_600123, "Action", newJString(Action))
  add(formData_600124, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_600123, "Version", newJString(Version))
  result = call_600122.call(nil, query_600123, nil, formData_600124, nil)

var postBatchModifyClusterSnapshots* = Call_PostBatchModifyClusterSnapshots_600106(
    name: "postBatchModifyClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_PostBatchModifyClusterSnapshots_600107, base: "/",
    url: url_PostBatchModifyClusterSnapshots_600108,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchModifyClusterSnapshots_600088 = ref object of OpenApiRestCall_599352
proc url_GetBatchModifyClusterSnapshots_600090(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetBatchModifyClusterSnapshots_600089(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_600091 = query.getOrDefault("SnapshotIdentifierList")
  valid_600091 = validateParameter(valid_600091, JArray, required = true, default = nil)
  if valid_600091 != nil:
    section.add "SnapshotIdentifierList", valid_600091
  var valid_600092 = query.getOrDefault("Action")
  valid_600092 = validateParameter(valid_600092, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_600092 != nil:
    section.add "Action", valid_600092
  var valid_600093 = query.getOrDefault("Version")
  valid_600093 = validateParameter(valid_600093, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600093 != nil:
    section.add "Version", valid_600093
  var valid_600094 = query.getOrDefault("Force")
  valid_600094 = validateParameter(valid_600094, JBool, required = false, default = nil)
  if valid_600094 != nil:
    section.add "Force", valid_600094
  var valid_600095 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_600095 = validateParameter(valid_600095, JInt, required = false, default = nil)
  if valid_600095 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_600095
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600096 = header.getOrDefault("X-Amz-Date")
  valid_600096 = validateParameter(valid_600096, JString, required = false,
                                 default = nil)
  if valid_600096 != nil:
    section.add "X-Amz-Date", valid_600096
  var valid_600097 = header.getOrDefault("X-Amz-Security-Token")
  valid_600097 = validateParameter(valid_600097, JString, required = false,
                                 default = nil)
  if valid_600097 != nil:
    section.add "X-Amz-Security-Token", valid_600097
  var valid_600098 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600098 = validateParameter(valid_600098, JString, required = false,
                                 default = nil)
  if valid_600098 != nil:
    section.add "X-Amz-Content-Sha256", valid_600098
  var valid_600099 = header.getOrDefault("X-Amz-Algorithm")
  valid_600099 = validateParameter(valid_600099, JString, required = false,
                                 default = nil)
  if valid_600099 != nil:
    section.add "X-Amz-Algorithm", valid_600099
  var valid_600100 = header.getOrDefault("X-Amz-Signature")
  valid_600100 = validateParameter(valid_600100, JString, required = false,
                                 default = nil)
  if valid_600100 != nil:
    section.add "X-Amz-Signature", valid_600100
  var valid_600101 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600101 = validateParameter(valid_600101, JString, required = false,
                                 default = nil)
  if valid_600101 != nil:
    section.add "X-Amz-SignedHeaders", valid_600101
  var valid_600102 = header.getOrDefault("X-Amz-Credential")
  valid_600102 = validateParameter(valid_600102, JString, required = false,
                                 default = nil)
  if valid_600102 != nil:
    section.add "X-Amz-Credential", valid_600102
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600103: Call_GetBatchModifyClusterSnapshots_600088; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_600103.validator(path, query, header, formData, body)
  let scheme = call_600103.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600103.url(scheme.get, call_600103.host, call_600103.base,
                         call_600103.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600103, url, valid)

proc call*(call_600104: Call_GetBatchModifyClusterSnapshots_600088;
          SnapshotIdentifierList: JsonNode;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"; Force: bool = false;
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  var query_600105 = newJObject()
  if SnapshotIdentifierList != nil:
    query_600105.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_600105, "Action", newJString(Action))
  add(query_600105, "Version", newJString(Version))
  add(query_600105, "Force", newJBool(Force))
  add(query_600105, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_600104.call(nil, query_600105, nil, nil, nil)

var getBatchModifyClusterSnapshots* = Call_GetBatchModifyClusterSnapshots_600088(
    name: "getBatchModifyClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_GetBatchModifyClusterSnapshots_600089, base: "/",
    url: url_GetBatchModifyClusterSnapshots_600090,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCancelResize_600141 = ref object of OpenApiRestCall_599352
proc url_PostCancelResize_600143(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCancelResize_600142(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600144 = query.getOrDefault("Action")
  valid_600144 = validateParameter(valid_600144, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_600144 != nil:
    section.add "Action", valid_600144
  var valid_600145 = query.getOrDefault("Version")
  valid_600145 = validateParameter(valid_600145, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600145 != nil:
    section.add "Version", valid_600145
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600146 = header.getOrDefault("X-Amz-Date")
  valid_600146 = validateParameter(valid_600146, JString, required = false,
                                 default = nil)
  if valid_600146 != nil:
    section.add "X-Amz-Date", valid_600146
  var valid_600147 = header.getOrDefault("X-Amz-Security-Token")
  valid_600147 = validateParameter(valid_600147, JString, required = false,
                                 default = nil)
  if valid_600147 != nil:
    section.add "X-Amz-Security-Token", valid_600147
  var valid_600148 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600148 = validateParameter(valid_600148, JString, required = false,
                                 default = nil)
  if valid_600148 != nil:
    section.add "X-Amz-Content-Sha256", valid_600148
  var valid_600149 = header.getOrDefault("X-Amz-Algorithm")
  valid_600149 = validateParameter(valid_600149, JString, required = false,
                                 default = nil)
  if valid_600149 != nil:
    section.add "X-Amz-Algorithm", valid_600149
  var valid_600150 = header.getOrDefault("X-Amz-Signature")
  valid_600150 = validateParameter(valid_600150, JString, required = false,
                                 default = nil)
  if valid_600150 != nil:
    section.add "X-Amz-Signature", valid_600150
  var valid_600151 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600151 = validateParameter(valid_600151, JString, required = false,
                                 default = nil)
  if valid_600151 != nil:
    section.add "X-Amz-SignedHeaders", valid_600151
  var valid_600152 = header.getOrDefault("X-Amz-Credential")
  valid_600152 = validateParameter(valid_600152, JString, required = false,
                                 default = nil)
  if valid_600152 != nil:
    section.add "X-Amz-Credential", valid_600152
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_600153 = formData.getOrDefault("ClusterIdentifier")
  valid_600153 = validateParameter(valid_600153, JString, required = true,
                                 default = nil)
  if valid_600153 != nil:
    section.add "ClusterIdentifier", valid_600153
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600154: Call_PostCancelResize_600141; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_600154.validator(path, query, header, formData, body)
  let scheme = call_600154.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600154.url(scheme.get, call_600154.host, call_600154.base,
                         call_600154.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600154, url, valid)

proc call*(call_600155: Call_PostCancelResize_600141; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## postCancelResize
  ## Cancels a resize operation.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_600156 = newJObject()
  var formData_600157 = newJObject()
  add(query_600156, "Action", newJString(Action))
  add(formData_600157, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_600156, "Version", newJString(Version))
  result = call_600155.call(nil, query_600156, nil, formData_600157, nil)

var postCancelResize* = Call_PostCancelResize_600141(name: "postCancelResize",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_PostCancelResize_600142,
    base: "/", url: url_PostCancelResize_600143,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCancelResize_600125 = ref object of OpenApiRestCall_599352
proc url_GetCancelResize_600127(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCancelResize_600126(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600128 = query.getOrDefault("Action")
  valid_600128 = validateParameter(valid_600128, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_600128 != nil:
    section.add "Action", valid_600128
  var valid_600129 = query.getOrDefault("ClusterIdentifier")
  valid_600129 = validateParameter(valid_600129, JString, required = true,
                                 default = nil)
  if valid_600129 != nil:
    section.add "ClusterIdentifier", valid_600129
  var valid_600130 = query.getOrDefault("Version")
  valid_600130 = validateParameter(valid_600130, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600130 != nil:
    section.add "Version", valid_600130
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600131 = header.getOrDefault("X-Amz-Date")
  valid_600131 = validateParameter(valid_600131, JString, required = false,
                                 default = nil)
  if valid_600131 != nil:
    section.add "X-Amz-Date", valid_600131
  var valid_600132 = header.getOrDefault("X-Amz-Security-Token")
  valid_600132 = validateParameter(valid_600132, JString, required = false,
                                 default = nil)
  if valid_600132 != nil:
    section.add "X-Amz-Security-Token", valid_600132
  var valid_600133 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600133 = validateParameter(valid_600133, JString, required = false,
                                 default = nil)
  if valid_600133 != nil:
    section.add "X-Amz-Content-Sha256", valid_600133
  var valid_600134 = header.getOrDefault("X-Amz-Algorithm")
  valid_600134 = validateParameter(valid_600134, JString, required = false,
                                 default = nil)
  if valid_600134 != nil:
    section.add "X-Amz-Algorithm", valid_600134
  var valid_600135 = header.getOrDefault("X-Amz-Signature")
  valid_600135 = validateParameter(valid_600135, JString, required = false,
                                 default = nil)
  if valid_600135 != nil:
    section.add "X-Amz-Signature", valid_600135
  var valid_600136 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600136 = validateParameter(valid_600136, JString, required = false,
                                 default = nil)
  if valid_600136 != nil:
    section.add "X-Amz-SignedHeaders", valid_600136
  var valid_600137 = header.getOrDefault("X-Amz-Credential")
  valid_600137 = validateParameter(valid_600137, JString, required = false,
                                 default = nil)
  if valid_600137 != nil:
    section.add "X-Amz-Credential", valid_600137
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600138: Call_GetCancelResize_600125; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_600138.validator(path, query, header, formData, body)
  let scheme = call_600138.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600138.url(scheme.get, call_600138.host, call_600138.base,
                         call_600138.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600138, url, valid)

proc call*(call_600139: Call_GetCancelResize_600125; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## getCancelResize
  ## Cancels a resize operation.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_600140 = newJObject()
  add(query_600140, "Action", newJString(Action))
  add(query_600140, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_600140, "Version", newJString(Version))
  result = call_600139.call(nil, query_600140, nil, nil, nil)

var getCancelResize* = Call_GetCancelResize_600125(name: "getCancelResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_GetCancelResize_600126,
    base: "/", url: url_GetCancelResize_600127, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCopyClusterSnapshot_600177 = ref object of OpenApiRestCall_599352
proc url_PostCopyClusterSnapshot_600179(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCopyClusterSnapshot_600178(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600180 = query.getOrDefault("Action")
  valid_600180 = validateParameter(valid_600180, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_600180 != nil:
    section.add "Action", valid_600180
  var valid_600181 = query.getOrDefault("Version")
  valid_600181 = validateParameter(valid_600181, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600181 != nil:
    section.add "Version", valid_600181
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600182 = header.getOrDefault("X-Amz-Date")
  valid_600182 = validateParameter(valid_600182, JString, required = false,
                                 default = nil)
  if valid_600182 != nil:
    section.add "X-Amz-Date", valid_600182
  var valid_600183 = header.getOrDefault("X-Amz-Security-Token")
  valid_600183 = validateParameter(valid_600183, JString, required = false,
                                 default = nil)
  if valid_600183 != nil:
    section.add "X-Amz-Security-Token", valid_600183
  var valid_600184 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600184 = validateParameter(valid_600184, JString, required = false,
                                 default = nil)
  if valid_600184 != nil:
    section.add "X-Amz-Content-Sha256", valid_600184
  var valid_600185 = header.getOrDefault("X-Amz-Algorithm")
  valid_600185 = validateParameter(valid_600185, JString, required = false,
                                 default = nil)
  if valid_600185 != nil:
    section.add "X-Amz-Algorithm", valid_600185
  var valid_600186 = header.getOrDefault("X-Amz-Signature")
  valid_600186 = validateParameter(valid_600186, JString, required = false,
                                 default = nil)
  if valid_600186 != nil:
    section.add "X-Amz-Signature", valid_600186
  var valid_600187 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600187 = validateParameter(valid_600187, JString, required = false,
                                 default = nil)
  if valid_600187 != nil:
    section.add "X-Amz-SignedHeaders", valid_600187
  var valid_600188 = header.getOrDefault("X-Amz-Credential")
  valid_600188 = validateParameter(valid_600188, JString, required = false,
                                 default = nil)
  if valid_600188 != nil:
    section.add "X-Amz-Credential", valid_600188
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_600189 = formData.getOrDefault("SourceSnapshotIdentifier")
  valid_600189 = validateParameter(valid_600189, JString, required = true,
                                 default = nil)
  if valid_600189 != nil:
    section.add "SourceSnapshotIdentifier", valid_600189
  var valid_600190 = formData.getOrDefault("TargetSnapshotIdentifier")
  valid_600190 = validateParameter(valid_600190, JString, required = true,
                                 default = nil)
  if valid_600190 != nil:
    section.add "TargetSnapshotIdentifier", valid_600190
  var valid_600191 = formData.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_600191 = validateParameter(valid_600191, JString, required = false,
                                 default = nil)
  if valid_600191 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_600191
  var valid_600192 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_600192 = validateParameter(valid_600192, JInt, required = false, default = nil)
  if valid_600192 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_600192
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600193: Call_PostCopyClusterSnapshot_600177; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600193.validator(path, query, header, formData, body)
  let scheme = call_600193.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600193.url(scheme.get, call_600193.host, call_600193.base,
                         call_600193.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600193, url, valid)

proc call*(call_600194: Call_PostCopyClusterSnapshot_600177;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          Action: string = "CopyClusterSnapshot";
          SourceSnapshotClusterIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  var query_600195 = newJObject()
  var formData_600196 = newJObject()
  add(formData_600196, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(formData_600196, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_600195, "Action", newJString(Action))
  add(formData_600196, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(formData_600196, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_600195, "Version", newJString(Version))
  result = call_600194.call(nil, query_600195, nil, formData_600196, nil)

var postCopyClusterSnapshot* = Call_PostCopyClusterSnapshot_600177(
    name: "postCopyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_PostCopyClusterSnapshot_600178, base: "/",
    url: url_PostCopyClusterSnapshot_600179, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCopyClusterSnapshot_600158 = ref object of OpenApiRestCall_599352
proc url_GetCopyClusterSnapshot_600160(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCopyClusterSnapshot_600159(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   Action: JString (required)
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Version: JString (required)
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_600161 = query.getOrDefault("SourceSnapshotIdentifier")
  valid_600161 = validateParameter(valid_600161, JString, required = true,
                                 default = nil)
  if valid_600161 != nil:
    section.add "SourceSnapshotIdentifier", valid_600161
  var valid_600162 = query.getOrDefault("Action")
  valid_600162 = validateParameter(valid_600162, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_600162 != nil:
    section.add "Action", valid_600162
  var valid_600163 = query.getOrDefault("TargetSnapshotIdentifier")
  valid_600163 = validateParameter(valid_600163, JString, required = true,
                                 default = nil)
  if valid_600163 != nil:
    section.add "TargetSnapshotIdentifier", valid_600163
  var valid_600164 = query.getOrDefault("Version")
  valid_600164 = validateParameter(valid_600164, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600164 != nil:
    section.add "Version", valid_600164
  var valid_600165 = query.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_600165 = validateParameter(valid_600165, JString, required = false,
                                 default = nil)
  if valid_600165 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_600165
  var valid_600166 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_600166 = validateParameter(valid_600166, JInt, required = false, default = nil)
  if valid_600166 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_600166
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600167 = header.getOrDefault("X-Amz-Date")
  valid_600167 = validateParameter(valid_600167, JString, required = false,
                                 default = nil)
  if valid_600167 != nil:
    section.add "X-Amz-Date", valid_600167
  var valid_600168 = header.getOrDefault("X-Amz-Security-Token")
  valid_600168 = validateParameter(valid_600168, JString, required = false,
                                 default = nil)
  if valid_600168 != nil:
    section.add "X-Amz-Security-Token", valid_600168
  var valid_600169 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600169 = validateParameter(valid_600169, JString, required = false,
                                 default = nil)
  if valid_600169 != nil:
    section.add "X-Amz-Content-Sha256", valid_600169
  var valid_600170 = header.getOrDefault("X-Amz-Algorithm")
  valid_600170 = validateParameter(valid_600170, JString, required = false,
                                 default = nil)
  if valid_600170 != nil:
    section.add "X-Amz-Algorithm", valid_600170
  var valid_600171 = header.getOrDefault("X-Amz-Signature")
  valid_600171 = validateParameter(valid_600171, JString, required = false,
                                 default = nil)
  if valid_600171 != nil:
    section.add "X-Amz-Signature", valid_600171
  var valid_600172 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600172 = validateParameter(valid_600172, JString, required = false,
                                 default = nil)
  if valid_600172 != nil:
    section.add "X-Amz-SignedHeaders", valid_600172
  var valid_600173 = header.getOrDefault("X-Amz-Credential")
  valid_600173 = validateParameter(valid_600173, JString, required = false,
                                 default = nil)
  if valid_600173 != nil:
    section.add "X-Amz-Credential", valid_600173
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600174: Call_GetCopyClusterSnapshot_600158; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600174.validator(path, query, header, formData, body)
  let scheme = call_600174.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600174.url(scheme.get, call_600174.host, call_600174.base,
                         call_600174.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600174, url, valid)

proc call*(call_600175: Call_GetCopyClusterSnapshot_600158;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          SourceSnapshotClusterIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   Action: string (required)
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Version: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_600176 = newJObject()
  add(query_600176, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(query_600176, "Action", newJString(Action))
  add(query_600176, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_600176, "Version", newJString(Version))
  add(query_600176, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(query_600176, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_600175.call(nil, query_600176, nil, nil, nil)

var getCopyClusterSnapshot* = Call_GetCopyClusterSnapshot_600158(
    name: "getCopyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_GetCopyClusterSnapshot_600159, base: "/",
    url: url_GetCopyClusterSnapshot_600160, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateCluster_600242 = ref object of OpenApiRestCall_599352
proc url_PostCreateCluster_600244(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateCluster_600243(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600245 = query.getOrDefault("Action")
  valid_600245 = validateParameter(valid_600245, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_600245 != nil:
    section.add "Action", valid_600245
  var valid_600246 = query.getOrDefault("Version")
  valid_600246 = validateParameter(valid_600246, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600246 != nil:
    section.add "Version", valid_600246
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600247 = header.getOrDefault("X-Amz-Date")
  valid_600247 = validateParameter(valid_600247, JString, required = false,
                                 default = nil)
  if valid_600247 != nil:
    section.add "X-Amz-Date", valid_600247
  var valid_600248 = header.getOrDefault("X-Amz-Security-Token")
  valid_600248 = validateParameter(valid_600248, JString, required = false,
                                 default = nil)
  if valid_600248 != nil:
    section.add "X-Amz-Security-Token", valid_600248
  var valid_600249 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600249 = validateParameter(valid_600249, JString, required = false,
                                 default = nil)
  if valid_600249 != nil:
    section.add "X-Amz-Content-Sha256", valid_600249
  var valid_600250 = header.getOrDefault("X-Amz-Algorithm")
  valid_600250 = validateParameter(valid_600250, JString, required = false,
                                 default = nil)
  if valid_600250 != nil:
    section.add "X-Amz-Algorithm", valid_600250
  var valid_600251 = header.getOrDefault("X-Amz-Signature")
  valid_600251 = validateParameter(valid_600251, JString, required = false,
                                 default = nil)
  if valid_600251 != nil:
    section.add "X-Amz-Signature", valid_600251
  var valid_600252 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600252 = validateParameter(valid_600252, JString, required = false,
                                 default = nil)
  if valid_600252 != nil:
    section.add "X-Amz-SignedHeaders", valid_600252
  var valid_600253 = header.getOrDefault("X-Amz-Credential")
  valid_600253 = validateParameter(valid_600253, JString, required = false,
                                 default = nil)
  if valid_600253 != nil:
    section.add "X-Amz-Credential", valid_600253
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  section = newJObject()
  var valid_600254 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_600254 = validateParameter(valid_600254, JString, required = false,
                                 default = nil)
  if valid_600254 != nil:
    section.add "PreferredMaintenanceWindow", valid_600254
  var valid_600255 = formData.getOrDefault("EnhancedVpcRouting")
  valid_600255 = validateParameter(valid_600255, JBool, required = false, default = nil)
  if valid_600255 != nil:
    section.add "EnhancedVpcRouting", valid_600255
  var valid_600256 = formData.getOrDefault("Port")
  valid_600256 = validateParameter(valid_600256, JInt, required = false, default = nil)
  if valid_600256 != nil:
    section.add "Port", valid_600256
  var valid_600257 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_600257 = validateParameter(valid_600257, JArray, required = false,
                                 default = nil)
  if valid_600257 != nil:
    section.add "VpcSecurityGroupIds", valid_600257
  var valid_600258 = formData.getOrDefault("DBName")
  valid_600258 = validateParameter(valid_600258, JString, required = false,
                                 default = nil)
  if valid_600258 != nil:
    section.add "DBName", valid_600258
  var valid_600259 = formData.getOrDefault("ClusterVersion")
  valid_600259 = validateParameter(valid_600259, JString, required = false,
                                 default = nil)
  if valid_600259 != nil:
    section.add "ClusterVersion", valid_600259
  var valid_600260 = formData.getOrDefault("ClusterType")
  valid_600260 = validateParameter(valid_600260, JString, required = false,
                                 default = nil)
  if valid_600260 != nil:
    section.add "ClusterType", valid_600260
  assert formData != nil, "formData argument is necessary due to required `MasterUserPassword` field"
  var valid_600261 = formData.getOrDefault("MasterUserPassword")
  valid_600261 = validateParameter(valid_600261, JString, required = true,
                                 default = nil)
  if valid_600261 != nil:
    section.add "MasterUserPassword", valid_600261
  var valid_600262 = formData.getOrDefault("Tags")
  valid_600262 = validateParameter(valid_600262, JArray, required = false,
                                 default = nil)
  if valid_600262 != nil:
    section.add "Tags", valid_600262
  var valid_600263 = formData.getOrDefault("AdditionalInfo")
  valid_600263 = validateParameter(valid_600263, JString, required = false,
                                 default = nil)
  if valid_600263 != nil:
    section.add "AdditionalInfo", valid_600263
  var valid_600264 = formData.getOrDefault("ClusterSecurityGroups")
  valid_600264 = validateParameter(valid_600264, JArray, required = false,
                                 default = nil)
  if valid_600264 != nil:
    section.add "ClusterSecurityGroups", valid_600264
  var valid_600265 = formData.getOrDefault("AvailabilityZone")
  valid_600265 = validateParameter(valid_600265, JString, required = false,
                                 default = nil)
  if valid_600265 != nil:
    section.add "AvailabilityZone", valid_600265
  var valid_600266 = formData.getOrDefault("Encrypted")
  valid_600266 = validateParameter(valid_600266, JBool, required = false, default = nil)
  if valid_600266 != nil:
    section.add "Encrypted", valid_600266
  var valid_600267 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_600267 = validateParameter(valid_600267, JString, required = false,
                                 default = nil)
  if valid_600267 != nil:
    section.add "HsmConfigurationIdentifier", valid_600267
  var valid_600268 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_600268 = validateParameter(valid_600268, JString, required = false,
                                 default = nil)
  if valid_600268 != nil:
    section.add "HsmClientCertificateIdentifier", valid_600268
  var valid_600269 = formData.getOrDefault("PubliclyAccessible")
  valid_600269 = validateParameter(valid_600269, JBool, required = false, default = nil)
  if valid_600269 != nil:
    section.add "PubliclyAccessible", valid_600269
  var valid_600270 = formData.getOrDefault("ClusterIdentifier")
  valid_600270 = validateParameter(valid_600270, JString, required = true,
                                 default = nil)
  if valid_600270 != nil:
    section.add "ClusterIdentifier", valid_600270
  var valid_600271 = formData.getOrDefault("MasterUsername")
  valid_600271 = validateParameter(valid_600271, JString, required = true,
                                 default = nil)
  if valid_600271 != nil:
    section.add "MasterUsername", valid_600271
  var valid_600272 = formData.getOrDefault("NumberOfNodes")
  valid_600272 = validateParameter(valid_600272, JInt, required = false, default = nil)
  if valid_600272 != nil:
    section.add "NumberOfNodes", valid_600272
  var valid_600273 = formData.getOrDefault("IamRoles")
  valid_600273 = validateParameter(valid_600273, JArray, required = false,
                                 default = nil)
  if valid_600273 != nil:
    section.add "IamRoles", valid_600273
  var valid_600274 = formData.getOrDefault("ClusterParameterGroupName")
  valid_600274 = validateParameter(valid_600274, JString, required = false,
                                 default = nil)
  if valid_600274 != nil:
    section.add "ClusterParameterGroupName", valid_600274
  var valid_600275 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_600275 = validateParameter(valid_600275, JString, required = false,
                                 default = nil)
  if valid_600275 != nil:
    section.add "SnapshotScheduleIdentifier", valid_600275
  var valid_600276 = formData.getOrDefault("KmsKeyId")
  valid_600276 = validateParameter(valid_600276, JString, required = false,
                                 default = nil)
  if valid_600276 != nil:
    section.add "KmsKeyId", valid_600276
  var valid_600277 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_600277 = validateParameter(valid_600277, JInt, required = false, default = nil)
  if valid_600277 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_600277
  var valid_600278 = formData.getOrDefault("ElasticIp")
  valid_600278 = validateParameter(valid_600278, JString, required = false,
                                 default = nil)
  if valid_600278 != nil:
    section.add "ElasticIp", valid_600278
  var valid_600279 = formData.getOrDefault("AllowVersionUpgrade")
  valid_600279 = validateParameter(valid_600279, JBool, required = false, default = nil)
  if valid_600279 != nil:
    section.add "AllowVersionUpgrade", valid_600279
  var valid_600280 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_600280 = validateParameter(valid_600280, JInt, required = false, default = nil)
  if valid_600280 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_600280
  var valid_600281 = formData.getOrDefault("NodeType")
  valid_600281 = validateParameter(valid_600281, JString, required = true,
                                 default = nil)
  if valid_600281 != nil:
    section.add "NodeType", valid_600281
  var valid_600282 = formData.getOrDefault("MaintenanceTrackName")
  valid_600282 = validateParameter(valid_600282, JString, required = false,
                                 default = nil)
  if valid_600282 != nil:
    section.add "MaintenanceTrackName", valid_600282
  var valid_600283 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_600283 = validateParameter(valid_600283, JString, required = false,
                                 default = nil)
  if valid_600283 != nil:
    section.add "ClusterSubnetGroupName", valid_600283
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600284: Call_PostCreateCluster_600242; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600284.validator(path, query, header, formData, body)
  let scheme = call_600284.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600284.url(scheme.get, call_600284.host, call_600284.base,
                         call_600284.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600284, url, valid)

proc call*(call_600285: Call_PostCreateCluster_600242; MasterUserPassword: string;
          ClusterIdentifier: string; MasterUsername: string; NodeType: string;
          PreferredMaintenanceWindow: string = ""; EnhancedVpcRouting: bool = false;
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil; DBName: string = "";
          ClusterVersion: string = ""; ClusterType: string = ""; Tags: JsonNode = nil;
          AdditionalInfo: string = ""; ClusterSecurityGroups: JsonNode = nil;
          AvailabilityZone: string = ""; Encrypted: bool = false;
          HsmConfigurationIdentifier: string = ""; Action: string = "CreateCluster";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          IamRoles: JsonNode = nil; ClusterParameterGroupName: string = "";
          SnapshotScheduleIdentifier: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          MaintenanceTrackName: string = ""; ClusterSubnetGroupName: string = ""): Recallable =
  ## postCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  var query_600286 = newJObject()
  var formData_600287 = newJObject()
  add(formData_600287, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_600287, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_600287, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    formData_600287.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_600287, "DBName", newJString(DBName))
  add(formData_600287, "ClusterVersion", newJString(ClusterVersion))
  add(formData_600287, "ClusterType", newJString(ClusterType))
  add(formData_600287, "MasterUserPassword", newJString(MasterUserPassword))
  if Tags != nil:
    formData_600287.add "Tags", Tags
  add(formData_600287, "AdditionalInfo", newJString(AdditionalInfo))
  if ClusterSecurityGroups != nil:
    formData_600287.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_600287, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_600287, "Encrypted", newJBool(Encrypted))
  add(formData_600287, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_600286, "Action", newJString(Action))
  add(formData_600287, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_600287, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_600287, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_600287, "MasterUsername", newJString(MasterUsername))
  add(formData_600287, "NumberOfNodes", newJInt(NumberOfNodes))
  if IamRoles != nil:
    formData_600287.add "IamRoles", IamRoles
  add(formData_600287, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_600287, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(formData_600287, "KmsKeyId", newJString(KmsKeyId))
  add(formData_600287, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_600287, "ElasticIp", newJString(ElasticIp))
  add(formData_600287, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_600287, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_600286, "Version", newJString(Version))
  add(formData_600287, "NodeType", newJString(NodeType))
  add(formData_600287, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_600287, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_600285.call(nil, query_600286, nil, formData_600287, nil)

var postCreateCluster* = Call_PostCreateCluster_600242(name: "postCreateCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_PostCreateCluster_600243,
    base: "/", url: url_PostCreateCluster_600244,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateCluster_600197 = ref object of OpenApiRestCall_599352
proc url_GetCreateCluster_600199(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateCluster_600198(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_600200 = query.getOrDefault("ClusterSecurityGroups")
  valid_600200 = validateParameter(valid_600200, JArray, required = false,
                                 default = nil)
  if valid_600200 != nil:
    section.add "ClusterSecurityGroups", valid_600200
  assert query != nil,
        "query argument is necessary due to required `MasterUsername` field"
  var valid_600201 = query.getOrDefault("MasterUsername")
  valid_600201 = validateParameter(valid_600201, JString, required = true,
                                 default = nil)
  if valid_600201 != nil:
    section.add "MasterUsername", valid_600201
  var valid_600202 = query.getOrDefault("ClusterSubnetGroupName")
  valid_600202 = validateParameter(valid_600202, JString, required = false,
                                 default = nil)
  if valid_600202 != nil:
    section.add "ClusterSubnetGroupName", valid_600202
  var valid_600203 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_600203 = validateParameter(valid_600203, JString, required = false,
                                 default = nil)
  if valid_600203 != nil:
    section.add "HsmClientCertificateIdentifier", valid_600203
  var valid_600204 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_600204 = validateParameter(valid_600204, JString, required = false,
                                 default = nil)
  if valid_600204 != nil:
    section.add "PreferredMaintenanceWindow", valid_600204
  var valid_600205 = query.getOrDefault("Encrypted")
  valid_600205 = validateParameter(valid_600205, JBool, required = false, default = nil)
  if valid_600205 != nil:
    section.add "Encrypted", valid_600205
  var valid_600206 = query.getOrDefault("MaintenanceTrackName")
  valid_600206 = validateParameter(valid_600206, JString, required = false,
                                 default = nil)
  if valid_600206 != nil:
    section.add "MaintenanceTrackName", valid_600206
  var valid_600207 = query.getOrDefault("IamRoles")
  valid_600207 = validateParameter(valid_600207, JArray, required = false,
                                 default = nil)
  if valid_600207 != nil:
    section.add "IamRoles", valid_600207
  var valid_600208 = query.getOrDefault("AvailabilityZone")
  valid_600208 = validateParameter(valid_600208, JString, required = false,
                                 default = nil)
  if valid_600208 != nil:
    section.add "AvailabilityZone", valid_600208
  var valid_600209 = query.getOrDefault("MasterUserPassword")
  valid_600209 = validateParameter(valid_600209, JString, required = true,
                                 default = nil)
  if valid_600209 != nil:
    section.add "MasterUserPassword", valid_600209
  var valid_600210 = query.getOrDefault("AllowVersionUpgrade")
  valid_600210 = validateParameter(valid_600210, JBool, required = false, default = nil)
  if valid_600210 != nil:
    section.add "AllowVersionUpgrade", valid_600210
  var valid_600211 = query.getOrDefault("EnhancedVpcRouting")
  valid_600211 = validateParameter(valid_600211, JBool, required = false, default = nil)
  if valid_600211 != nil:
    section.add "EnhancedVpcRouting", valid_600211
  var valid_600212 = query.getOrDefault("VpcSecurityGroupIds")
  valid_600212 = validateParameter(valid_600212, JArray, required = false,
                                 default = nil)
  if valid_600212 != nil:
    section.add "VpcSecurityGroupIds", valid_600212
  var valid_600213 = query.getOrDefault("ClusterParameterGroupName")
  valid_600213 = validateParameter(valid_600213, JString, required = false,
                                 default = nil)
  if valid_600213 != nil:
    section.add "ClusterParameterGroupName", valid_600213
  var valid_600214 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_600214 = validateParameter(valid_600214, JString, required = false,
                                 default = nil)
  if valid_600214 != nil:
    section.add "HsmConfigurationIdentifier", valid_600214
  var valid_600215 = query.getOrDefault("Tags")
  valid_600215 = validateParameter(valid_600215, JArray, required = false,
                                 default = nil)
  if valid_600215 != nil:
    section.add "Tags", valid_600215
  var valid_600216 = query.getOrDefault("DBName")
  valid_600216 = validateParameter(valid_600216, JString, required = false,
                                 default = nil)
  if valid_600216 != nil:
    section.add "DBName", valid_600216
  var valid_600217 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_600217 = validateParameter(valid_600217, JString, required = false,
                                 default = nil)
  if valid_600217 != nil:
    section.add "SnapshotScheduleIdentifier", valid_600217
  var valid_600218 = query.getOrDefault("AdditionalInfo")
  valid_600218 = validateParameter(valid_600218, JString, required = false,
                                 default = nil)
  if valid_600218 != nil:
    section.add "AdditionalInfo", valid_600218
  var valid_600219 = query.getOrDefault("ElasticIp")
  valid_600219 = validateParameter(valid_600219, JString, required = false,
                                 default = nil)
  if valid_600219 != nil:
    section.add "ElasticIp", valid_600219
  var valid_600220 = query.getOrDefault("ClusterIdentifier")
  valid_600220 = validateParameter(valid_600220, JString, required = true,
                                 default = nil)
  if valid_600220 != nil:
    section.add "ClusterIdentifier", valid_600220
  var valid_600221 = query.getOrDefault("Action")
  valid_600221 = validateParameter(valid_600221, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_600221 != nil:
    section.add "Action", valid_600221
  var valid_600222 = query.getOrDefault("KmsKeyId")
  valid_600222 = validateParameter(valid_600222, JString, required = false,
                                 default = nil)
  if valid_600222 != nil:
    section.add "KmsKeyId", valid_600222
  var valid_600223 = query.getOrDefault("PubliclyAccessible")
  valid_600223 = validateParameter(valid_600223, JBool, required = false, default = nil)
  if valid_600223 != nil:
    section.add "PubliclyAccessible", valid_600223
  var valid_600224 = query.getOrDefault("Port")
  valid_600224 = validateParameter(valid_600224, JInt, required = false, default = nil)
  if valid_600224 != nil:
    section.add "Port", valid_600224
  var valid_600225 = query.getOrDefault("NumberOfNodes")
  valid_600225 = validateParameter(valid_600225, JInt, required = false, default = nil)
  if valid_600225 != nil:
    section.add "NumberOfNodes", valid_600225
  var valid_600226 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_600226 = validateParameter(valid_600226, JInt, required = false, default = nil)
  if valid_600226 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_600226
  var valid_600227 = query.getOrDefault("NodeType")
  valid_600227 = validateParameter(valid_600227, JString, required = true,
                                 default = nil)
  if valid_600227 != nil:
    section.add "NodeType", valid_600227
  var valid_600228 = query.getOrDefault("ClusterVersion")
  valid_600228 = validateParameter(valid_600228, JString, required = false,
                                 default = nil)
  if valid_600228 != nil:
    section.add "ClusterVersion", valid_600228
  var valid_600229 = query.getOrDefault("Version")
  valid_600229 = validateParameter(valid_600229, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600229 != nil:
    section.add "Version", valid_600229
  var valid_600230 = query.getOrDefault("ClusterType")
  valid_600230 = validateParameter(valid_600230, JString, required = false,
                                 default = nil)
  if valid_600230 != nil:
    section.add "ClusterType", valid_600230
  var valid_600231 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_600231 = validateParameter(valid_600231, JInt, required = false, default = nil)
  if valid_600231 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_600231
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600232 = header.getOrDefault("X-Amz-Date")
  valid_600232 = validateParameter(valid_600232, JString, required = false,
                                 default = nil)
  if valid_600232 != nil:
    section.add "X-Amz-Date", valid_600232
  var valid_600233 = header.getOrDefault("X-Amz-Security-Token")
  valid_600233 = validateParameter(valid_600233, JString, required = false,
                                 default = nil)
  if valid_600233 != nil:
    section.add "X-Amz-Security-Token", valid_600233
  var valid_600234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600234 = validateParameter(valid_600234, JString, required = false,
                                 default = nil)
  if valid_600234 != nil:
    section.add "X-Amz-Content-Sha256", valid_600234
  var valid_600235 = header.getOrDefault("X-Amz-Algorithm")
  valid_600235 = validateParameter(valid_600235, JString, required = false,
                                 default = nil)
  if valid_600235 != nil:
    section.add "X-Amz-Algorithm", valid_600235
  var valid_600236 = header.getOrDefault("X-Amz-Signature")
  valid_600236 = validateParameter(valid_600236, JString, required = false,
                                 default = nil)
  if valid_600236 != nil:
    section.add "X-Amz-Signature", valid_600236
  var valid_600237 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600237 = validateParameter(valid_600237, JString, required = false,
                                 default = nil)
  if valid_600237 != nil:
    section.add "X-Amz-SignedHeaders", valid_600237
  var valid_600238 = header.getOrDefault("X-Amz-Credential")
  valid_600238 = validateParameter(valid_600238, JString, required = false,
                                 default = nil)
  if valid_600238 != nil:
    section.add "X-Amz-Credential", valid_600238
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600239: Call_GetCreateCluster_600197; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600239.validator(path, query, header, formData, body)
  let scheme = call_600239.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600239.url(scheme.get, call_600239.host, call_600239.base,
                         call_600239.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600239, url, valid)

proc call*(call_600240: Call_GetCreateCluster_600197; MasterUsername: string;
          MasterUserPassword: string; ClusterIdentifier: string; NodeType: string;
          ClusterSecurityGroups: JsonNode = nil;
          ClusterSubnetGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = ""; Encrypted: bool = false;
          MaintenanceTrackName: string = ""; IamRoles: JsonNode = nil;
          AvailabilityZone: string = ""; AllowVersionUpgrade: bool = false;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = ""; Tags: JsonNode = nil;
          DBName: string = ""; SnapshotScheduleIdentifier: string = "";
          AdditionalInfo: string = ""; ElasticIp: string = "";
          Action: string = "CreateCluster"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; Port: int = 0; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; ClusterVersion: string = "";
          Version: string = "2012-12-01"; ClusterType: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_600241 = newJObject()
  if ClusterSecurityGroups != nil:
    query_600241.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_600241, "MasterUsername", newJString(MasterUsername))
  add(query_600241, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_600241, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_600241, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_600241, "Encrypted", newJBool(Encrypted))
  add(query_600241, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if IamRoles != nil:
    query_600241.add "IamRoles", IamRoles
  add(query_600241, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_600241, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_600241, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_600241, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_600241.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_600241, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_600241, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  if Tags != nil:
    query_600241.add "Tags", Tags
  add(query_600241, "DBName", newJString(DBName))
  add(query_600241, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_600241, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_600241, "ElasticIp", newJString(ElasticIp))
  add(query_600241, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_600241, "Action", newJString(Action))
  add(query_600241, "KmsKeyId", newJString(KmsKeyId))
  add(query_600241, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_600241, "Port", newJInt(Port))
  add(query_600241, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_600241, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_600241, "NodeType", newJString(NodeType))
  add(query_600241, "ClusterVersion", newJString(ClusterVersion))
  add(query_600241, "Version", newJString(Version))
  add(query_600241, "ClusterType", newJString(ClusterType))
  add(query_600241, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_600240.call(nil, query_600241, nil, nil, nil)

var getCreateCluster* = Call_GetCreateCluster_600197(name: "getCreateCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_GetCreateCluster_600198,
    base: "/", url: url_GetCreateCluster_600199,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterParameterGroup_600307 = ref object of OpenApiRestCall_599352
proc url_PostCreateClusterParameterGroup_600309(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterParameterGroup_600308(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600310 = query.getOrDefault("Action")
  valid_600310 = validateParameter(valid_600310, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_600310 != nil:
    section.add "Action", valid_600310
  var valid_600311 = query.getOrDefault("Version")
  valid_600311 = validateParameter(valid_600311, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600311 != nil:
    section.add "Version", valid_600311
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600312 = header.getOrDefault("X-Amz-Date")
  valid_600312 = validateParameter(valid_600312, JString, required = false,
                                 default = nil)
  if valid_600312 != nil:
    section.add "X-Amz-Date", valid_600312
  var valid_600313 = header.getOrDefault("X-Amz-Security-Token")
  valid_600313 = validateParameter(valid_600313, JString, required = false,
                                 default = nil)
  if valid_600313 != nil:
    section.add "X-Amz-Security-Token", valid_600313
  var valid_600314 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600314 = validateParameter(valid_600314, JString, required = false,
                                 default = nil)
  if valid_600314 != nil:
    section.add "X-Amz-Content-Sha256", valid_600314
  var valid_600315 = header.getOrDefault("X-Amz-Algorithm")
  valid_600315 = validateParameter(valid_600315, JString, required = false,
                                 default = nil)
  if valid_600315 != nil:
    section.add "X-Amz-Algorithm", valid_600315
  var valid_600316 = header.getOrDefault("X-Amz-Signature")
  valid_600316 = validateParameter(valid_600316, JString, required = false,
                                 default = nil)
  if valid_600316 != nil:
    section.add "X-Amz-Signature", valid_600316
  var valid_600317 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600317 = validateParameter(valid_600317, JString, required = false,
                                 default = nil)
  if valid_600317 != nil:
    section.add "X-Amz-SignedHeaders", valid_600317
  var valid_600318 = header.getOrDefault("X-Amz-Credential")
  valid_600318 = validateParameter(valid_600318, JString, required = false,
                                 default = nil)
  if valid_600318 != nil:
    section.add "X-Amz-Credential", valid_600318
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_600319 = formData.getOrDefault("ParameterGroupName")
  valid_600319 = validateParameter(valid_600319, JString, required = true,
                                 default = nil)
  if valid_600319 != nil:
    section.add "ParameterGroupName", valid_600319
  var valid_600320 = formData.getOrDefault("Tags")
  valid_600320 = validateParameter(valid_600320, JArray, required = false,
                                 default = nil)
  if valid_600320 != nil:
    section.add "Tags", valid_600320
  var valid_600321 = formData.getOrDefault("ParameterGroupFamily")
  valid_600321 = validateParameter(valid_600321, JString, required = true,
                                 default = nil)
  if valid_600321 != nil:
    section.add "ParameterGroupFamily", valid_600321
  var valid_600322 = formData.getOrDefault("Description")
  valid_600322 = validateParameter(valid_600322, JString, required = true,
                                 default = nil)
  if valid_600322 != nil:
    section.add "Description", valid_600322
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600323: Call_PostCreateClusterParameterGroup_600307;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600323.validator(path, query, header, formData, body)
  let scheme = call_600323.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600323.url(scheme.get, call_600323.host, call_600323.base,
                         call_600323.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600323, url, valid)

proc call*(call_600324: Call_PostCreateClusterParameterGroup_600307;
          ParameterGroupName: string; ParameterGroupFamily: string;
          Description: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description of the parameter group.
  var query_600325 = newJObject()
  var formData_600326 = newJObject()
  add(formData_600326, "ParameterGroupName", newJString(ParameterGroupName))
  if Tags != nil:
    formData_600326.add "Tags", Tags
  add(query_600325, "Action", newJString(Action))
  add(formData_600326, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_600325, "Version", newJString(Version))
  add(formData_600326, "Description", newJString(Description))
  result = call_600324.call(nil, query_600325, nil, formData_600326, nil)

var postCreateClusterParameterGroup* = Call_PostCreateClusterParameterGroup_600307(
    name: "postCreateClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_PostCreateClusterParameterGroup_600308, base: "/",
    url: url_PostCreateClusterParameterGroup_600309,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterParameterGroup_600288 = ref object of OpenApiRestCall_599352
proc url_GetCreateClusterParameterGroup_600290(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterParameterGroup_600289(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Action: JString (required)
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Description` field"
  var valid_600291 = query.getOrDefault("Description")
  valid_600291 = validateParameter(valid_600291, JString, required = true,
                                 default = nil)
  if valid_600291 != nil:
    section.add "Description", valid_600291
  var valid_600292 = query.getOrDefault("Tags")
  valid_600292 = validateParameter(valid_600292, JArray, required = false,
                                 default = nil)
  if valid_600292 != nil:
    section.add "Tags", valid_600292
  var valid_600293 = query.getOrDefault("ParameterGroupName")
  valid_600293 = validateParameter(valid_600293, JString, required = true,
                                 default = nil)
  if valid_600293 != nil:
    section.add "ParameterGroupName", valid_600293
  var valid_600294 = query.getOrDefault("Action")
  valid_600294 = validateParameter(valid_600294, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_600294 != nil:
    section.add "Action", valid_600294
  var valid_600295 = query.getOrDefault("ParameterGroupFamily")
  valid_600295 = validateParameter(valid_600295, JString, required = true,
                                 default = nil)
  if valid_600295 != nil:
    section.add "ParameterGroupFamily", valid_600295
  var valid_600296 = query.getOrDefault("Version")
  valid_600296 = validateParameter(valid_600296, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600296 != nil:
    section.add "Version", valid_600296
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600297 = header.getOrDefault("X-Amz-Date")
  valid_600297 = validateParameter(valid_600297, JString, required = false,
                                 default = nil)
  if valid_600297 != nil:
    section.add "X-Amz-Date", valid_600297
  var valid_600298 = header.getOrDefault("X-Amz-Security-Token")
  valid_600298 = validateParameter(valid_600298, JString, required = false,
                                 default = nil)
  if valid_600298 != nil:
    section.add "X-Amz-Security-Token", valid_600298
  var valid_600299 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600299 = validateParameter(valid_600299, JString, required = false,
                                 default = nil)
  if valid_600299 != nil:
    section.add "X-Amz-Content-Sha256", valid_600299
  var valid_600300 = header.getOrDefault("X-Amz-Algorithm")
  valid_600300 = validateParameter(valid_600300, JString, required = false,
                                 default = nil)
  if valid_600300 != nil:
    section.add "X-Amz-Algorithm", valid_600300
  var valid_600301 = header.getOrDefault("X-Amz-Signature")
  valid_600301 = validateParameter(valid_600301, JString, required = false,
                                 default = nil)
  if valid_600301 != nil:
    section.add "X-Amz-Signature", valid_600301
  var valid_600302 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600302 = validateParameter(valid_600302, JString, required = false,
                                 default = nil)
  if valid_600302 != nil:
    section.add "X-Amz-SignedHeaders", valid_600302
  var valid_600303 = header.getOrDefault("X-Amz-Credential")
  valid_600303 = validateParameter(valid_600303, JString, required = false,
                                 default = nil)
  if valid_600303 != nil:
    section.add "X-Amz-Credential", valid_600303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600304: Call_GetCreateClusterParameterGroup_600288; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600304.validator(path, query, header, formData, body)
  let scheme = call_600304.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600304.url(scheme.get, call_600304.host, call_600304.base,
                         call_600304.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600304, url, valid)

proc call*(call_600305: Call_GetCreateClusterParameterGroup_600288;
          Description: string; ParameterGroupName: string;
          ParameterGroupFamily: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Version: string (required)
  var query_600306 = newJObject()
  add(query_600306, "Description", newJString(Description))
  if Tags != nil:
    query_600306.add "Tags", Tags
  add(query_600306, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_600306, "Action", newJString(Action))
  add(query_600306, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_600306, "Version", newJString(Version))
  result = call_600305.call(nil, query_600306, nil, nil, nil)

var getCreateClusterParameterGroup* = Call_GetCreateClusterParameterGroup_600288(
    name: "getCreateClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_GetCreateClusterParameterGroup_600289, base: "/",
    url: url_GetCreateClusterParameterGroup_600290,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSecurityGroup_600345 = ref object of OpenApiRestCall_599352
proc url_PostCreateClusterSecurityGroup_600347(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSecurityGroup_600346(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600348 = query.getOrDefault("Action")
  valid_600348 = validateParameter(valid_600348, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_600348 != nil:
    section.add "Action", valid_600348
  var valid_600349 = query.getOrDefault("Version")
  valid_600349 = validateParameter(valid_600349, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600349 != nil:
    section.add "Version", valid_600349
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600350 = header.getOrDefault("X-Amz-Date")
  valid_600350 = validateParameter(valid_600350, JString, required = false,
                                 default = nil)
  if valid_600350 != nil:
    section.add "X-Amz-Date", valid_600350
  var valid_600351 = header.getOrDefault("X-Amz-Security-Token")
  valid_600351 = validateParameter(valid_600351, JString, required = false,
                                 default = nil)
  if valid_600351 != nil:
    section.add "X-Amz-Security-Token", valid_600351
  var valid_600352 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600352 = validateParameter(valid_600352, JString, required = false,
                                 default = nil)
  if valid_600352 != nil:
    section.add "X-Amz-Content-Sha256", valid_600352
  var valid_600353 = header.getOrDefault("X-Amz-Algorithm")
  valid_600353 = validateParameter(valid_600353, JString, required = false,
                                 default = nil)
  if valid_600353 != nil:
    section.add "X-Amz-Algorithm", valid_600353
  var valid_600354 = header.getOrDefault("X-Amz-Signature")
  valid_600354 = validateParameter(valid_600354, JString, required = false,
                                 default = nil)
  if valid_600354 != nil:
    section.add "X-Amz-Signature", valid_600354
  var valid_600355 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600355 = validateParameter(valid_600355, JString, required = false,
                                 default = nil)
  if valid_600355 != nil:
    section.add "X-Amz-SignedHeaders", valid_600355
  var valid_600356 = header.getOrDefault("X-Amz-Credential")
  valid_600356 = validateParameter(valid_600356, JString, required = false,
                                 default = nil)
  if valid_600356 != nil:
    section.add "X-Amz-Credential", valid_600356
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  section = newJObject()
  var valid_600357 = formData.getOrDefault("Tags")
  valid_600357 = validateParameter(valid_600357, JArray, required = false,
                                 default = nil)
  if valid_600357 != nil:
    section.add "Tags", valid_600357
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_600358 = formData.getOrDefault("Description")
  valid_600358 = validateParameter(valid_600358, JString, required = true,
                                 default = nil)
  if valid_600358 != nil:
    section.add "Description", valid_600358
  var valid_600359 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_600359 = validateParameter(valid_600359, JString, required = true,
                                 default = nil)
  if valid_600359 != nil:
    section.add "ClusterSecurityGroupName", valid_600359
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600360: Call_PostCreateClusterSecurityGroup_600345; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600360.validator(path, query, header, formData, body)
  let scheme = call_600360.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600360.url(scheme.get, call_600360.host, call_600360.base,
                         call_600360.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600360, url, valid)

proc call*(call_600361: Call_PostCreateClusterSecurityGroup_600345;
          Description: string; ClusterSecurityGroupName: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  var query_600362 = newJObject()
  var formData_600363 = newJObject()
  if Tags != nil:
    formData_600363.add "Tags", Tags
  add(query_600362, "Action", newJString(Action))
  add(query_600362, "Version", newJString(Version))
  add(formData_600363, "Description", newJString(Description))
  add(formData_600363, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_600361.call(nil, query_600362, nil, formData_600363, nil)

var postCreateClusterSecurityGroup* = Call_PostCreateClusterSecurityGroup_600345(
    name: "postCreateClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_PostCreateClusterSecurityGroup_600346, base: "/",
    url: url_PostCreateClusterSecurityGroup_600347,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSecurityGroup_600327 = ref object of OpenApiRestCall_599352
proc url_GetCreateClusterSecurityGroup_600329(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSecurityGroup_600328(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_600330 = query.getOrDefault("ClusterSecurityGroupName")
  valid_600330 = validateParameter(valid_600330, JString, required = true,
                                 default = nil)
  if valid_600330 != nil:
    section.add "ClusterSecurityGroupName", valid_600330
  var valid_600331 = query.getOrDefault("Description")
  valid_600331 = validateParameter(valid_600331, JString, required = true,
                                 default = nil)
  if valid_600331 != nil:
    section.add "Description", valid_600331
  var valid_600332 = query.getOrDefault("Tags")
  valid_600332 = validateParameter(valid_600332, JArray, required = false,
                                 default = nil)
  if valid_600332 != nil:
    section.add "Tags", valid_600332
  var valid_600333 = query.getOrDefault("Action")
  valid_600333 = validateParameter(valid_600333, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_600333 != nil:
    section.add "Action", valid_600333
  var valid_600334 = query.getOrDefault("Version")
  valid_600334 = validateParameter(valid_600334, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600334 != nil:
    section.add "Version", valid_600334
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600335 = header.getOrDefault("X-Amz-Date")
  valid_600335 = validateParameter(valid_600335, JString, required = false,
                                 default = nil)
  if valid_600335 != nil:
    section.add "X-Amz-Date", valid_600335
  var valid_600336 = header.getOrDefault("X-Amz-Security-Token")
  valid_600336 = validateParameter(valid_600336, JString, required = false,
                                 default = nil)
  if valid_600336 != nil:
    section.add "X-Amz-Security-Token", valid_600336
  var valid_600337 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600337 = validateParameter(valid_600337, JString, required = false,
                                 default = nil)
  if valid_600337 != nil:
    section.add "X-Amz-Content-Sha256", valid_600337
  var valid_600338 = header.getOrDefault("X-Amz-Algorithm")
  valid_600338 = validateParameter(valid_600338, JString, required = false,
                                 default = nil)
  if valid_600338 != nil:
    section.add "X-Amz-Algorithm", valid_600338
  var valid_600339 = header.getOrDefault("X-Amz-Signature")
  valid_600339 = validateParameter(valid_600339, JString, required = false,
                                 default = nil)
  if valid_600339 != nil:
    section.add "X-Amz-Signature", valid_600339
  var valid_600340 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600340 = validateParameter(valid_600340, JString, required = false,
                                 default = nil)
  if valid_600340 != nil:
    section.add "X-Amz-SignedHeaders", valid_600340
  var valid_600341 = header.getOrDefault("X-Amz-Credential")
  valid_600341 = validateParameter(valid_600341, JString, required = false,
                                 default = nil)
  if valid_600341 != nil:
    section.add "X-Amz-Credential", valid_600341
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600342: Call_GetCreateClusterSecurityGroup_600327; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600342.validator(path, query, header, formData, body)
  let scheme = call_600342.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600342.url(scheme.get, call_600342.host, call_600342.base,
                         call_600342.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600342, url, valid)

proc call*(call_600343: Call_GetCreateClusterSecurityGroup_600327;
          ClusterSecurityGroupName: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_600344 = newJObject()
  add(query_600344, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_600344, "Description", newJString(Description))
  if Tags != nil:
    query_600344.add "Tags", Tags
  add(query_600344, "Action", newJString(Action))
  add(query_600344, "Version", newJString(Version))
  result = call_600343.call(nil, query_600344, nil, nil, nil)

var getCreateClusterSecurityGroup* = Call_GetCreateClusterSecurityGroup_600327(
    name: "getCreateClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_GetCreateClusterSecurityGroup_600328, base: "/",
    url: url_GetCreateClusterSecurityGroup_600329,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSnapshot_600383 = ref object of OpenApiRestCall_599352
proc url_PostCreateClusterSnapshot_600385(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSnapshot_600384(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600386 = query.getOrDefault("Action")
  valid_600386 = validateParameter(valid_600386, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_600386 != nil:
    section.add "Action", valid_600386
  var valid_600387 = query.getOrDefault("Version")
  valid_600387 = validateParameter(valid_600387, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600387 != nil:
    section.add "Version", valid_600387
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600388 = header.getOrDefault("X-Amz-Date")
  valid_600388 = validateParameter(valid_600388, JString, required = false,
                                 default = nil)
  if valid_600388 != nil:
    section.add "X-Amz-Date", valid_600388
  var valid_600389 = header.getOrDefault("X-Amz-Security-Token")
  valid_600389 = validateParameter(valid_600389, JString, required = false,
                                 default = nil)
  if valid_600389 != nil:
    section.add "X-Amz-Security-Token", valid_600389
  var valid_600390 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600390 = validateParameter(valid_600390, JString, required = false,
                                 default = nil)
  if valid_600390 != nil:
    section.add "X-Amz-Content-Sha256", valid_600390
  var valid_600391 = header.getOrDefault("X-Amz-Algorithm")
  valid_600391 = validateParameter(valid_600391, JString, required = false,
                                 default = nil)
  if valid_600391 != nil:
    section.add "X-Amz-Algorithm", valid_600391
  var valid_600392 = header.getOrDefault("X-Amz-Signature")
  valid_600392 = validateParameter(valid_600392, JString, required = false,
                                 default = nil)
  if valid_600392 != nil:
    section.add "X-Amz-Signature", valid_600392
  var valid_600393 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600393 = validateParameter(valid_600393, JString, required = false,
                                 default = nil)
  if valid_600393 != nil:
    section.add "X-Amz-SignedHeaders", valid_600393
  var valid_600394 = header.getOrDefault("X-Amz-Credential")
  valid_600394 = validateParameter(valid_600394, JString, required = false,
                                 default = nil)
  if valid_600394 != nil:
    section.add "X-Amz-Credential", valid_600394
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_600395 = formData.getOrDefault("Tags")
  valid_600395 = validateParameter(valid_600395, JArray, required = false,
                                 default = nil)
  if valid_600395 != nil:
    section.add "Tags", valid_600395
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_600396 = formData.getOrDefault("ClusterIdentifier")
  valid_600396 = validateParameter(valid_600396, JString, required = true,
                                 default = nil)
  if valid_600396 != nil:
    section.add "ClusterIdentifier", valid_600396
  var valid_600397 = formData.getOrDefault("SnapshotIdentifier")
  valid_600397 = validateParameter(valid_600397, JString, required = true,
                                 default = nil)
  if valid_600397 != nil:
    section.add "SnapshotIdentifier", valid_600397
  var valid_600398 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_600398 = validateParameter(valid_600398, JInt, required = false, default = nil)
  if valid_600398 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_600398
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600399: Call_PostCreateClusterSnapshot_600383; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600399.validator(path, query, header, formData, body)
  let scheme = call_600399.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600399.url(scheme.get, call_600399.host, call_600399.base,
                         call_600399.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600399, url, valid)

proc call*(call_600400: Call_PostCreateClusterSnapshot_600383;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSnapshot";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  var query_600401 = newJObject()
  var formData_600402 = newJObject()
  if Tags != nil:
    formData_600402.add "Tags", Tags
  add(query_600401, "Action", newJString(Action))
  add(formData_600402, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_600402, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_600402, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_600401, "Version", newJString(Version))
  result = call_600400.call(nil, query_600401, nil, formData_600402, nil)

var postCreateClusterSnapshot* = Call_PostCreateClusterSnapshot_600383(
    name: "postCreateClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_PostCreateClusterSnapshot_600384, base: "/",
    url: url_PostCreateClusterSnapshot_600385,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSnapshot_600364 = ref object of OpenApiRestCall_599352
proc url_GetCreateClusterSnapshot_600366(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSnapshot_600365(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_600367 = query.getOrDefault("Tags")
  valid_600367 = validateParameter(valid_600367, JArray, required = false,
                                 default = nil)
  if valid_600367 != nil:
    section.add "Tags", valid_600367
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600368 = query.getOrDefault("Action")
  valid_600368 = validateParameter(valid_600368, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_600368 != nil:
    section.add "Action", valid_600368
  var valid_600369 = query.getOrDefault("ClusterIdentifier")
  valid_600369 = validateParameter(valid_600369, JString, required = true,
                                 default = nil)
  if valid_600369 != nil:
    section.add "ClusterIdentifier", valid_600369
  var valid_600370 = query.getOrDefault("SnapshotIdentifier")
  valid_600370 = validateParameter(valid_600370, JString, required = true,
                                 default = nil)
  if valid_600370 != nil:
    section.add "SnapshotIdentifier", valid_600370
  var valid_600371 = query.getOrDefault("Version")
  valid_600371 = validateParameter(valid_600371, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600371 != nil:
    section.add "Version", valid_600371
  var valid_600372 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_600372 = validateParameter(valid_600372, JInt, required = false, default = nil)
  if valid_600372 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_600372
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600373 = header.getOrDefault("X-Amz-Date")
  valid_600373 = validateParameter(valid_600373, JString, required = false,
                                 default = nil)
  if valid_600373 != nil:
    section.add "X-Amz-Date", valid_600373
  var valid_600374 = header.getOrDefault("X-Amz-Security-Token")
  valid_600374 = validateParameter(valid_600374, JString, required = false,
                                 default = nil)
  if valid_600374 != nil:
    section.add "X-Amz-Security-Token", valid_600374
  var valid_600375 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600375 = validateParameter(valid_600375, JString, required = false,
                                 default = nil)
  if valid_600375 != nil:
    section.add "X-Amz-Content-Sha256", valid_600375
  var valid_600376 = header.getOrDefault("X-Amz-Algorithm")
  valid_600376 = validateParameter(valid_600376, JString, required = false,
                                 default = nil)
  if valid_600376 != nil:
    section.add "X-Amz-Algorithm", valid_600376
  var valid_600377 = header.getOrDefault("X-Amz-Signature")
  valid_600377 = validateParameter(valid_600377, JString, required = false,
                                 default = nil)
  if valid_600377 != nil:
    section.add "X-Amz-Signature", valid_600377
  var valid_600378 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600378 = validateParameter(valid_600378, JString, required = false,
                                 default = nil)
  if valid_600378 != nil:
    section.add "X-Amz-SignedHeaders", valid_600378
  var valid_600379 = header.getOrDefault("X-Amz-Credential")
  valid_600379 = validateParameter(valid_600379, JString, required = false,
                                 default = nil)
  if valid_600379 != nil:
    section.add "X-Amz-Credential", valid_600379
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600380: Call_GetCreateClusterSnapshot_600364; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600380.validator(path, query, header, formData, body)
  let scheme = call_600380.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600380.url(scheme.get, call_600380.host, call_600380.base,
                         call_600380.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600380, url, valid)

proc call*(call_600381: Call_GetCreateClusterSnapshot_600364;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSnapshot";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_600382 = newJObject()
  if Tags != nil:
    query_600382.add "Tags", Tags
  add(query_600382, "Action", newJString(Action))
  add(query_600382, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_600382, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_600382, "Version", newJString(Version))
  add(query_600382, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_600381.call(nil, query_600382, nil, nil, nil)

var getCreateClusterSnapshot* = Call_GetCreateClusterSnapshot_600364(
    name: "getCreateClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_GetCreateClusterSnapshot_600365, base: "/",
    url: url_GetCreateClusterSnapshot_600366, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSubnetGroup_600422 = ref object of OpenApiRestCall_599352
proc url_PostCreateClusterSubnetGroup_600424(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateClusterSubnetGroup_600423(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600425 = query.getOrDefault("Action")
  valid_600425 = validateParameter(valid_600425, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_600425 != nil:
    section.add "Action", valid_600425
  var valid_600426 = query.getOrDefault("Version")
  valid_600426 = validateParameter(valid_600426, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600426 != nil:
    section.add "Version", valid_600426
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600427 = header.getOrDefault("X-Amz-Date")
  valid_600427 = validateParameter(valid_600427, JString, required = false,
                                 default = nil)
  if valid_600427 != nil:
    section.add "X-Amz-Date", valid_600427
  var valid_600428 = header.getOrDefault("X-Amz-Security-Token")
  valid_600428 = validateParameter(valid_600428, JString, required = false,
                                 default = nil)
  if valid_600428 != nil:
    section.add "X-Amz-Security-Token", valid_600428
  var valid_600429 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600429 = validateParameter(valid_600429, JString, required = false,
                                 default = nil)
  if valid_600429 != nil:
    section.add "X-Amz-Content-Sha256", valid_600429
  var valid_600430 = header.getOrDefault("X-Amz-Algorithm")
  valid_600430 = validateParameter(valid_600430, JString, required = false,
                                 default = nil)
  if valid_600430 != nil:
    section.add "X-Amz-Algorithm", valid_600430
  var valid_600431 = header.getOrDefault("X-Amz-Signature")
  valid_600431 = validateParameter(valid_600431, JString, required = false,
                                 default = nil)
  if valid_600431 != nil:
    section.add "X-Amz-Signature", valid_600431
  var valid_600432 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600432 = validateParameter(valid_600432, JString, required = false,
                                 default = nil)
  if valid_600432 != nil:
    section.add "X-Amz-SignedHeaders", valid_600432
  var valid_600433 = header.getOrDefault("X-Amz-Credential")
  valid_600433 = validateParameter(valid_600433, JString, required = false,
                                 default = nil)
  if valid_600433 != nil:
    section.add "X-Amz-Credential", valid_600433
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  section = newJObject()
  var valid_600434 = formData.getOrDefault("Tags")
  valid_600434 = validateParameter(valid_600434, JArray, required = false,
                                 default = nil)
  if valid_600434 != nil:
    section.add "Tags", valid_600434
  assert formData != nil,
        "formData argument is necessary due to required `SubnetIds` field"
  var valid_600435 = formData.getOrDefault("SubnetIds")
  valid_600435 = validateParameter(valid_600435, JArray, required = true, default = nil)
  if valid_600435 != nil:
    section.add "SubnetIds", valid_600435
  var valid_600436 = formData.getOrDefault("Description")
  valid_600436 = validateParameter(valid_600436, JString, required = true,
                                 default = nil)
  if valid_600436 != nil:
    section.add "Description", valid_600436
  var valid_600437 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_600437 = validateParameter(valid_600437, JString, required = true,
                                 default = nil)
  if valid_600437 != nil:
    section.add "ClusterSubnetGroupName", valid_600437
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600438: Call_PostCreateClusterSubnetGroup_600422; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600438.validator(path, query, header, formData, body)
  let scheme = call_600438.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600438.url(scheme.get, call_600438.host, call_600438.base,
                         call_600438.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600438, url, valid)

proc call*(call_600439: Call_PostCreateClusterSubnetGroup_600422;
          SubnetIds: JsonNode; Description: string; ClusterSubnetGroupName: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  var query_600440 = newJObject()
  var formData_600441 = newJObject()
  if Tags != nil:
    formData_600441.add "Tags", Tags
  if SubnetIds != nil:
    formData_600441.add "SubnetIds", SubnetIds
  add(query_600440, "Action", newJString(Action))
  add(query_600440, "Version", newJString(Version))
  add(formData_600441, "Description", newJString(Description))
  add(formData_600441, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_600439.call(nil, query_600440, nil, formData_600441, nil)

var postCreateClusterSubnetGroup* = Call_PostCreateClusterSubnetGroup_600422(
    name: "postCreateClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_PostCreateClusterSubnetGroup_600423, base: "/",
    url: url_PostCreateClusterSubnetGroup_600424,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSubnetGroup_600403 = ref object of OpenApiRestCall_599352
proc url_GetCreateClusterSubnetGroup_600405(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateClusterSubnetGroup_600404(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_600406 = query.getOrDefault("ClusterSubnetGroupName")
  valid_600406 = validateParameter(valid_600406, JString, required = true,
                                 default = nil)
  if valid_600406 != nil:
    section.add "ClusterSubnetGroupName", valid_600406
  var valid_600407 = query.getOrDefault("Description")
  valid_600407 = validateParameter(valid_600407, JString, required = true,
                                 default = nil)
  if valid_600407 != nil:
    section.add "Description", valid_600407
  var valid_600408 = query.getOrDefault("Tags")
  valid_600408 = validateParameter(valid_600408, JArray, required = false,
                                 default = nil)
  if valid_600408 != nil:
    section.add "Tags", valid_600408
  var valid_600409 = query.getOrDefault("Action")
  valid_600409 = validateParameter(valid_600409, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_600409 != nil:
    section.add "Action", valid_600409
  var valid_600410 = query.getOrDefault("SubnetIds")
  valid_600410 = validateParameter(valid_600410, JArray, required = true, default = nil)
  if valid_600410 != nil:
    section.add "SubnetIds", valid_600410
  var valid_600411 = query.getOrDefault("Version")
  valid_600411 = validateParameter(valid_600411, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600411 != nil:
    section.add "Version", valid_600411
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600412 = header.getOrDefault("X-Amz-Date")
  valid_600412 = validateParameter(valid_600412, JString, required = false,
                                 default = nil)
  if valid_600412 != nil:
    section.add "X-Amz-Date", valid_600412
  var valid_600413 = header.getOrDefault("X-Amz-Security-Token")
  valid_600413 = validateParameter(valid_600413, JString, required = false,
                                 default = nil)
  if valid_600413 != nil:
    section.add "X-Amz-Security-Token", valid_600413
  var valid_600414 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600414 = validateParameter(valid_600414, JString, required = false,
                                 default = nil)
  if valid_600414 != nil:
    section.add "X-Amz-Content-Sha256", valid_600414
  var valid_600415 = header.getOrDefault("X-Amz-Algorithm")
  valid_600415 = validateParameter(valid_600415, JString, required = false,
                                 default = nil)
  if valid_600415 != nil:
    section.add "X-Amz-Algorithm", valid_600415
  var valid_600416 = header.getOrDefault("X-Amz-Signature")
  valid_600416 = validateParameter(valid_600416, JString, required = false,
                                 default = nil)
  if valid_600416 != nil:
    section.add "X-Amz-Signature", valid_600416
  var valid_600417 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600417 = validateParameter(valid_600417, JString, required = false,
                                 default = nil)
  if valid_600417 != nil:
    section.add "X-Amz-SignedHeaders", valid_600417
  var valid_600418 = header.getOrDefault("X-Amz-Credential")
  valid_600418 = validateParameter(valid_600418, JString, required = false,
                                 default = nil)
  if valid_600418 != nil:
    section.add "X-Amz-Credential", valid_600418
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600419: Call_GetCreateClusterSubnetGroup_600403; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600419.validator(path, query, header, formData, body)
  let scheme = call_600419.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600419.url(scheme.get, call_600419.host, call_600419.base,
                         call_600419.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600419, url, valid)

proc call*(call_600420: Call_GetCreateClusterSubnetGroup_600403;
          ClusterSubnetGroupName: string; Description: string; SubnetIds: JsonNode;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: string (required)
  var query_600421 = newJObject()
  add(query_600421, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_600421, "Description", newJString(Description))
  if Tags != nil:
    query_600421.add "Tags", Tags
  add(query_600421, "Action", newJString(Action))
  if SubnetIds != nil:
    query_600421.add "SubnetIds", SubnetIds
  add(query_600421, "Version", newJString(Version))
  result = call_600420.call(nil, query_600421, nil, nil, nil)

var getCreateClusterSubnetGroup* = Call_GetCreateClusterSubnetGroup_600403(
    name: "getCreateClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_GetCreateClusterSubnetGroup_600404, base: "/",
    url: url_GetCreateClusterSubnetGroup_600405,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateEventSubscription_600465 = ref object of OpenApiRestCall_599352
proc url_PostCreateEventSubscription_600467(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateEventSubscription_600466(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600468 = query.getOrDefault("Action")
  valid_600468 = validateParameter(valid_600468, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_600468 != nil:
    section.add "Action", valid_600468
  var valid_600469 = query.getOrDefault("Version")
  valid_600469 = validateParameter(valid_600469, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600469 != nil:
    section.add "Version", valid_600469
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600470 = header.getOrDefault("X-Amz-Date")
  valid_600470 = validateParameter(valid_600470, JString, required = false,
                                 default = nil)
  if valid_600470 != nil:
    section.add "X-Amz-Date", valid_600470
  var valid_600471 = header.getOrDefault("X-Amz-Security-Token")
  valid_600471 = validateParameter(valid_600471, JString, required = false,
                                 default = nil)
  if valid_600471 != nil:
    section.add "X-Amz-Security-Token", valid_600471
  var valid_600472 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600472 = validateParameter(valid_600472, JString, required = false,
                                 default = nil)
  if valid_600472 != nil:
    section.add "X-Amz-Content-Sha256", valid_600472
  var valid_600473 = header.getOrDefault("X-Amz-Algorithm")
  valid_600473 = validateParameter(valid_600473, JString, required = false,
                                 default = nil)
  if valid_600473 != nil:
    section.add "X-Amz-Algorithm", valid_600473
  var valid_600474 = header.getOrDefault("X-Amz-Signature")
  valid_600474 = validateParameter(valid_600474, JString, required = false,
                                 default = nil)
  if valid_600474 != nil:
    section.add "X-Amz-Signature", valid_600474
  var valid_600475 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600475 = validateParameter(valid_600475, JString, required = false,
                                 default = nil)
  if valid_600475 != nil:
    section.add "X-Amz-SignedHeaders", valid_600475
  var valid_600476 = header.getOrDefault("X-Amz-Credential")
  valid_600476 = validateParameter(valid_600476, JString, required = false,
                                 default = nil)
  if valid_600476 != nil:
    section.add "X-Amz-Credential", valid_600476
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  section = newJObject()
  var valid_600477 = formData.getOrDefault("Enabled")
  valid_600477 = validateParameter(valid_600477, JBool, required = false, default = nil)
  if valid_600477 != nil:
    section.add "Enabled", valid_600477
  var valid_600478 = formData.getOrDefault("EventCategories")
  valid_600478 = validateParameter(valid_600478, JArray, required = false,
                                 default = nil)
  if valid_600478 != nil:
    section.add "EventCategories", valid_600478
  assert formData != nil,
        "formData argument is necessary due to required `SnsTopicArn` field"
  var valid_600479 = formData.getOrDefault("SnsTopicArn")
  valid_600479 = validateParameter(valid_600479, JString, required = true,
                                 default = nil)
  if valid_600479 != nil:
    section.add "SnsTopicArn", valid_600479
  var valid_600480 = formData.getOrDefault("Severity")
  valid_600480 = validateParameter(valid_600480, JString, required = false,
                                 default = nil)
  if valid_600480 != nil:
    section.add "Severity", valid_600480
  var valid_600481 = formData.getOrDefault("SourceIds")
  valid_600481 = validateParameter(valid_600481, JArray, required = false,
                                 default = nil)
  if valid_600481 != nil:
    section.add "SourceIds", valid_600481
  var valid_600482 = formData.getOrDefault("Tags")
  valid_600482 = validateParameter(valid_600482, JArray, required = false,
                                 default = nil)
  if valid_600482 != nil:
    section.add "Tags", valid_600482
  var valid_600483 = formData.getOrDefault("SubscriptionName")
  valid_600483 = validateParameter(valid_600483, JString, required = true,
                                 default = nil)
  if valid_600483 != nil:
    section.add "SubscriptionName", valid_600483
  var valid_600484 = formData.getOrDefault("SourceType")
  valid_600484 = validateParameter(valid_600484, JString, required = false,
                                 default = nil)
  if valid_600484 != nil:
    section.add "SourceType", valid_600484
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600485: Call_PostCreateEventSubscription_600465; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_600485.validator(path, query, header, formData, body)
  let scheme = call_600485.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600485.url(scheme.get, call_600485.host, call_600485.base,
                         call_600485.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600485, url, valid)

proc call*(call_600486: Call_PostCreateEventSubscription_600465;
          SnsTopicArn: string; SubscriptionName: string; Enabled: bool = false;
          EventCategories: JsonNode = nil; Severity: string = "";
          SourceIds: JsonNode = nil; Tags: JsonNode = nil;
          Action: string = "CreateEventSubscription";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  var query_600487 = newJObject()
  var formData_600488 = newJObject()
  add(formData_600488, "Enabled", newJBool(Enabled))
  if EventCategories != nil:
    formData_600488.add "EventCategories", EventCategories
  add(formData_600488, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_600488, "Severity", newJString(Severity))
  if SourceIds != nil:
    formData_600488.add "SourceIds", SourceIds
  if Tags != nil:
    formData_600488.add "Tags", Tags
  add(formData_600488, "SubscriptionName", newJString(SubscriptionName))
  add(query_600487, "Action", newJString(Action))
  add(query_600487, "Version", newJString(Version))
  add(formData_600488, "SourceType", newJString(SourceType))
  result = call_600486.call(nil, query_600487, nil, formData_600488, nil)

var postCreateEventSubscription* = Call_PostCreateEventSubscription_600465(
    name: "postCreateEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_PostCreateEventSubscription_600466, base: "/",
    url: url_PostCreateEventSubscription_600467,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateEventSubscription_600442 = ref object of OpenApiRestCall_599352
proc url_GetCreateEventSubscription_600444(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateEventSubscription_600443(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_600445 = query.getOrDefault("SourceType")
  valid_600445 = validateParameter(valid_600445, JString, required = false,
                                 default = nil)
  if valid_600445 != nil:
    section.add "SourceType", valid_600445
  var valid_600446 = query.getOrDefault("SourceIds")
  valid_600446 = validateParameter(valid_600446, JArray, required = false,
                                 default = nil)
  if valid_600446 != nil:
    section.add "SourceIds", valid_600446
  var valid_600447 = query.getOrDefault("Enabled")
  valid_600447 = validateParameter(valid_600447, JBool, required = false, default = nil)
  if valid_600447 != nil:
    section.add "Enabled", valid_600447
  var valid_600448 = query.getOrDefault("Tags")
  valid_600448 = validateParameter(valid_600448, JArray, required = false,
                                 default = nil)
  if valid_600448 != nil:
    section.add "Tags", valid_600448
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600449 = query.getOrDefault("Action")
  valid_600449 = validateParameter(valid_600449, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_600449 != nil:
    section.add "Action", valid_600449
  var valid_600450 = query.getOrDefault("SnsTopicArn")
  valid_600450 = validateParameter(valid_600450, JString, required = true,
                                 default = nil)
  if valid_600450 != nil:
    section.add "SnsTopicArn", valid_600450
  var valid_600451 = query.getOrDefault("EventCategories")
  valid_600451 = validateParameter(valid_600451, JArray, required = false,
                                 default = nil)
  if valid_600451 != nil:
    section.add "EventCategories", valid_600451
  var valid_600452 = query.getOrDefault("SubscriptionName")
  valid_600452 = validateParameter(valid_600452, JString, required = true,
                                 default = nil)
  if valid_600452 != nil:
    section.add "SubscriptionName", valid_600452
  var valid_600453 = query.getOrDefault("Severity")
  valid_600453 = validateParameter(valid_600453, JString, required = false,
                                 default = nil)
  if valid_600453 != nil:
    section.add "Severity", valid_600453
  var valid_600454 = query.getOrDefault("Version")
  valid_600454 = validateParameter(valid_600454, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600454 != nil:
    section.add "Version", valid_600454
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600455 = header.getOrDefault("X-Amz-Date")
  valid_600455 = validateParameter(valid_600455, JString, required = false,
                                 default = nil)
  if valid_600455 != nil:
    section.add "X-Amz-Date", valid_600455
  var valid_600456 = header.getOrDefault("X-Amz-Security-Token")
  valid_600456 = validateParameter(valid_600456, JString, required = false,
                                 default = nil)
  if valid_600456 != nil:
    section.add "X-Amz-Security-Token", valid_600456
  var valid_600457 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600457 = validateParameter(valid_600457, JString, required = false,
                                 default = nil)
  if valid_600457 != nil:
    section.add "X-Amz-Content-Sha256", valid_600457
  var valid_600458 = header.getOrDefault("X-Amz-Algorithm")
  valid_600458 = validateParameter(valid_600458, JString, required = false,
                                 default = nil)
  if valid_600458 != nil:
    section.add "X-Amz-Algorithm", valid_600458
  var valid_600459 = header.getOrDefault("X-Amz-Signature")
  valid_600459 = validateParameter(valid_600459, JString, required = false,
                                 default = nil)
  if valid_600459 != nil:
    section.add "X-Amz-Signature", valid_600459
  var valid_600460 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600460 = validateParameter(valid_600460, JString, required = false,
                                 default = nil)
  if valid_600460 != nil:
    section.add "X-Amz-SignedHeaders", valid_600460
  var valid_600461 = header.getOrDefault("X-Amz-Credential")
  valid_600461 = validateParameter(valid_600461, JString, required = false,
                                 default = nil)
  if valid_600461 != nil:
    section.add "X-Amz-Credential", valid_600461
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600462: Call_GetCreateEventSubscription_600442; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_600462.validator(path, query, header, formData, body)
  let scheme = call_600462.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600462.url(scheme.get, call_600462.host, call_600462.base,
                         call_600462.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600462, url, valid)

proc call*(call_600463: Call_GetCreateEventSubscription_600442;
          SnsTopicArn: string; SubscriptionName: string; SourceType: string = "";
          SourceIds: JsonNode = nil; Enabled: bool = false; Tags: JsonNode = nil;
          Action: string = "CreateEventSubscription";
          EventCategories: JsonNode = nil; Severity: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: string (required)
  var query_600464 = newJObject()
  add(query_600464, "SourceType", newJString(SourceType))
  if SourceIds != nil:
    query_600464.add "SourceIds", SourceIds
  add(query_600464, "Enabled", newJBool(Enabled))
  if Tags != nil:
    query_600464.add "Tags", Tags
  add(query_600464, "Action", newJString(Action))
  add(query_600464, "SnsTopicArn", newJString(SnsTopicArn))
  if EventCategories != nil:
    query_600464.add "EventCategories", EventCategories
  add(query_600464, "SubscriptionName", newJString(SubscriptionName))
  add(query_600464, "Severity", newJString(Severity))
  add(query_600464, "Version", newJString(Version))
  result = call_600463.call(nil, query_600464, nil, nil, nil)

var getCreateEventSubscription* = Call_GetCreateEventSubscription_600442(
    name: "getCreateEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_GetCreateEventSubscription_600443, base: "/",
    url: url_GetCreateEventSubscription_600444,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmClientCertificate_600506 = ref object of OpenApiRestCall_599352
proc url_PostCreateHsmClientCertificate_600508(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmClientCertificate_600507(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600509 = query.getOrDefault("Action")
  valid_600509 = validateParameter(valid_600509, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_600509 != nil:
    section.add "Action", valid_600509
  var valid_600510 = query.getOrDefault("Version")
  valid_600510 = validateParameter(valid_600510, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600510 != nil:
    section.add "Version", valid_600510
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600511 = header.getOrDefault("X-Amz-Date")
  valid_600511 = validateParameter(valid_600511, JString, required = false,
                                 default = nil)
  if valid_600511 != nil:
    section.add "X-Amz-Date", valid_600511
  var valid_600512 = header.getOrDefault("X-Amz-Security-Token")
  valid_600512 = validateParameter(valid_600512, JString, required = false,
                                 default = nil)
  if valid_600512 != nil:
    section.add "X-Amz-Security-Token", valid_600512
  var valid_600513 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600513 = validateParameter(valid_600513, JString, required = false,
                                 default = nil)
  if valid_600513 != nil:
    section.add "X-Amz-Content-Sha256", valid_600513
  var valid_600514 = header.getOrDefault("X-Amz-Algorithm")
  valid_600514 = validateParameter(valid_600514, JString, required = false,
                                 default = nil)
  if valid_600514 != nil:
    section.add "X-Amz-Algorithm", valid_600514
  var valid_600515 = header.getOrDefault("X-Amz-Signature")
  valid_600515 = validateParameter(valid_600515, JString, required = false,
                                 default = nil)
  if valid_600515 != nil:
    section.add "X-Amz-Signature", valid_600515
  var valid_600516 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600516 = validateParameter(valid_600516, JString, required = false,
                                 default = nil)
  if valid_600516 != nil:
    section.add "X-Amz-SignedHeaders", valid_600516
  var valid_600517 = header.getOrDefault("X-Amz-Credential")
  valid_600517 = validateParameter(valid_600517, JString, required = false,
                                 default = nil)
  if valid_600517 != nil:
    section.add "X-Amz-Credential", valid_600517
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  section = newJObject()
  var valid_600518 = formData.getOrDefault("Tags")
  valid_600518 = validateParameter(valid_600518, JArray, required = false,
                                 default = nil)
  if valid_600518 != nil:
    section.add "Tags", valid_600518
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_600519 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_600519 = validateParameter(valid_600519, JString, required = true,
                                 default = nil)
  if valid_600519 != nil:
    section.add "HsmClientCertificateIdentifier", valid_600519
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600520: Call_PostCreateHsmClientCertificate_600506; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_600520.validator(path, query, header, formData, body)
  let scheme = call_600520.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600520.url(scheme.get, call_600520.host, call_600520.base,
                         call_600520.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600520, url, valid)

proc call*(call_600521: Call_PostCreateHsmClientCertificate_600506;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Version: string (required)
  var query_600522 = newJObject()
  var formData_600523 = newJObject()
  if Tags != nil:
    formData_600523.add "Tags", Tags
  add(query_600522, "Action", newJString(Action))
  add(formData_600523, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_600522, "Version", newJString(Version))
  result = call_600521.call(nil, query_600522, nil, formData_600523, nil)

var postCreateHsmClientCertificate* = Call_PostCreateHsmClientCertificate_600506(
    name: "postCreateHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_PostCreateHsmClientCertificate_600507, base: "/",
    url: url_PostCreateHsmClientCertificate_600508,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmClientCertificate_600489 = ref object of OpenApiRestCall_599352
proc url_GetCreateHsmClientCertificate_600491(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmClientCertificate_600490(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_600492 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_600492 = validateParameter(valid_600492, JString, required = true,
                                 default = nil)
  if valid_600492 != nil:
    section.add "HsmClientCertificateIdentifier", valid_600492
  var valid_600493 = query.getOrDefault("Tags")
  valid_600493 = validateParameter(valid_600493, JArray, required = false,
                                 default = nil)
  if valid_600493 != nil:
    section.add "Tags", valid_600493
  var valid_600494 = query.getOrDefault("Action")
  valid_600494 = validateParameter(valid_600494, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_600494 != nil:
    section.add "Action", valid_600494
  var valid_600495 = query.getOrDefault("Version")
  valid_600495 = validateParameter(valid_600495, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600495 != nil:
    section.add "Version", valid_600495
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600496 = header.getOrDefault("X-Amz-Date")
  valid_600496 = validateParameter(valid_600496, JString, required = false,
                                 default = nil)
  if valid_600496 != nil:
    section.add "X-Amz-Date", valid_600496
  var valid_600497 = header.getOrDefault("X-Amz-Security-Token")
  valid_600497 = validateParameter(valid_600497, JString, required = false,
                                 default = nil)
  if valid_600497 != nil:
    section.add "X-Amz-Security-Token", valid_600497
  var valid_600498 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600498 = validateParameter(valid_600498, JString, required = false,
                                 default = nil)
  if valid_600498 != nil:
    section.add "X-Amz-Content-Sha256", valid_600498
  var valid_600499 = header.getOrDefault("X-Amz-Algorithm")
  valid_600499 = validateParameter(valid_600499, JString, required = false,
                                 default = nil)
  if valid_600499 != nil:
    section.add "X-Amz-Algorithm", valid_600499
  var valid_600500 = header.getOrDefault("X-Amz-Signature")
  valid_600500 = validateParameter(valid_600500, JString, required = false,
                                 default = nil)
  if valid_600500 != nil:
    section.add "X-Amz-Signature", valid_600500
  var valid_600501 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600501 = validateParameter(valid_600501, JString, required = false,
                                 default = nil)
  if valid_600501 != nil:
    section.add "X-Amz-SignedHeaders", valid_600501
  var valid_600502 = header.getOrDefault("X-Amz-Credential")
  valid_600502 = validateParameter(valid_600502, JString, required = false,
                                 default = nil)
  if valid_600502 != nil:
    section.add "X-Amz-Credential", valid_600502
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600503: Call_GetCreateHsmClientCertificate_600489; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_600503.validator(path, query, header, formData, body)
  let scheme = call_600503.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600503.url(scheme.get, call_600503.host, call_600503.base,
                         call_600503.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600503, url, valid)

proc call*(call_600504: Call_GetCreateHsmClientCertificate_600489;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_600505 = newJObject()
  add(query_600505, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    query_600505.add "Tags", Tags
  add(query_600505, "Action", newJString(Action))
  add(query_600505, "Version", newJString(Version))
  result = call_600504.call(nil, query_600505, nil, nil, nil)

var getCreateHsmClientCertificate* = Call_GetCreateHsmClientCertificate_600489(
    name: "getCreateHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_GetCreateHsmClientCertificate_600490, base: "/",
    url: url_GetCreateHsmClientCertificate_600491,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmConfiguration_600546 = ref object of OpenApiRestCall_599352
proc url_PostCreateHsmConfiguration_600548(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateHsmConfiguration_600547(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600549 = query.getOrDefault("Action")
  valid_600549 = validateParameter(valid_600549, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_600549 != nil:
    section.add "Action", valid_600549
  var valid_600550 = query.getOrDefault("Version")
  valid_600550 = validateParameter(valid_600550, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600550 != nil:
    section.add "Version", valid_600550
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600551 = header.getOrDefault("X-Amz-Date")
  valid_600551 = validateParameter(valid_600551, JString, required = false,
                                 default = nil)
  if valid_600551 != nil:
    section.add "X-Amz-Date", valid_600551
  var valid_600552 = header.getOrDefault("X-Amz-Security-Token")
  valid_600552 = validateParameter(valid_600552, JString, required = false,
                                 default = nil)
  if valid_600552 != nil:
    section.add "X-Amz-Security-Token", valid_600552
  var valid_600553 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600553 = validateParameter(valid_600553, JString, required = false,
                                 default = nil)
  if valid_600553 != nil:
    section.add "X-Amz-Content-Sha256", valid_600553
  var valid_600554 = header.getOrDefault("X-Amz-Algorithm")
  valid_600554 = validateParameter(valid_600554, JString, required = false,
                                 default = nil)
  if valid_600554 != nil:
    section.add "X-Amz-Algorithm", valid_600554
  var valid_600555 = header.getOrDefault("X-Amz-Signature")
  valid_600555 = validateParameter(valid_600555, JString, required = false,
                                 default = nil)
  if valid_600555 != nil:
    section.add "X-Amz-Signature", valid_600555
  var valid_600556 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600556 = validateParameter(valid_600556, JString, required = false,
                                 default = nil)
  if valid_600556 != nil:
    section.add "X-Amz-SignedHeaders", valid_600556
  var valid_600557 = header.getOrDefault("X-Amz-Credential")
  valid_600557 = validateParameter(valid_600557, JString, required = false,
                                 default = nil)
  if valid_600557 != nil:
    section.add "X-Amz-Credential", valid_600557
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `HsmIpAddress` field"
  var valid_600558 = formData.getOrDefault("HsmIpAddress")
  valid_600558 = validateParameter(valid_600558, JString, required = true,
                                 default = nil)
  if valid_600558 != nil:
    section.add "HsmIpAddress", valid_600558
  var valid_600559 = formData.getOrDefault("HsmPartitionName")
  valid_600559 = validateParameter(valid_600559, JString, required = true,
                                 default = nil)
  if valid_600559 != nil:
    section.add "HsmPartitionName", valid_600559
  var valid_600560 = formData.getOrDefault("Tags")
  valid_600560 = validateParameter(valid_600560, JArray, required = false,
                                 default = nil)
  if valid_600560 != nil:
    section.add "Tags", valid_600560
  var valid_600561 = formData.getOrDefault("HsmPartitionPassword")
  valid_600561 = validateParameter(valid_600561, JString, required = true,
                                 default = nil)
  if valid_600561 != nil:
    section.add "HsmPartitionPassword", valid_600561
  var valid_600562 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_600562 = validateParameter(valid_600562, JString, required = true,
                                 default = nil)
  if valid_600562 != nil:
    section.add "HsmConfigurationIdentifier", valid_600562
  var valid_600563 = formData.getOrDefault("HsmServerPublicCertificate")
  valid_600563 = validateParameter(valid_600563, JString, required = true,
                                 default = nil)
  if valid_600563 != nil:
    section.add "HsmServerPublicCertificate", valid_600563
  var valid_600564 = formData.getOrDefault("Description")
  valid_600564 = validateParameter(valid_600564, JString, required = true,
                                 default = nil)
  if valid_600564 != nil:
    section.add "Description", valid_600564
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600565: Call_PostCreateHsmConfiguration_600546; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_600565.validator(path, query, header, formData, body)
  let scheme = call_600565.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600565.url(scheme.get, call_600565.host, call_600565.base,
                         call_600565.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600565, url, valid)

proc call*(call_600566: Call_PostCreateHsmConfiguration_600546;
          HsmIpAddress: string; HsmPartitionName: string;
          HsmPartitionPassword: string; HsmConfigurationIdentifier: string;
          HsmServerPublicCertificate: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   Version: string (required)
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  var query_600567 = newJObject()
  var formData_600568 = newJObject()
  add(formData_600568, "HsmIpAddress", newJString(HsmIpAddress))
  add(formData_600568, "HsmPartitionName", newJString(HsmPartitionName))
  if Tags != nil:
    formData_600568.add "Tags", Tags
  add(formData_600568, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(formData_600568, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_600567, "Action", newJString(Action))
  add(formData_600568, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_600567, "Version", newJString(Version))
  add(formData_600568, "Description", newJString(Description))
  result = call_600566.call(nil, query_600567, nil, formData_600568, nil)

var postCreateHsmConfiguration* = Call_PostCreateHsmConfiguration_600546(
    name: "postCreateHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_PostCreateHsmConfiguration_600547, base: "/",
    url: url_PostCreateHsmConfiguration_600548,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmConfiguration_600524 = ref object of OpenApiRestCall_599352
proc url_GetCreateHsmConfiguration_600526(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateHsmConfiguration_600525(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmPartitionPassword` field"
  var valid_600527 = query.getOrDefault("HsmPartitionPassword")
  valid_600527 = validateParameter(valid_600527, JString, required = true,
                                 default = nil)
  if valid_600527 != nil:
    section.add "HsmPartitionPassword", valid_600527
  var valid_600528 = query.getOrDefault("Description")
  valid_600528 = validateParameter(valid_600528, JString, required = true,
                                 default = nil)
  if valid_600528 != nil:
    section.add "Description", valid_600528
  var valid_600529 = query.getOrDefault("HsmPartitionName")
  valid_600529 = validateParameter(valid_600529, JString, required = true,
                                 default = nil)
  if valid_600529 != nil:
    section.add "HsmPartitionName", valid_600529
  var valid_600530 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_600530 = validateParameter(valid_600530, JString, required = true,
                                 default = nil)
  if valid_600530 != nil:
    section.add "HsmConfigurationIdentifier", valid_600530
  var valid_600531 = query.getOrDefault("Tags")
  valid_600531 = validateParameter(valid_600531, JArray, required = false,
                                 default = nil)
  if valid_600531 != nil:
    section.add "Tags", valid_600531
  var valid_600532 = query.getOrDefault("Action")
  valid_600532 = validateParameter(valid_600532, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_600532 != nil:
    section.add "Action", valid_600532
  var valid_600533 = query.getOrDefault("HsmServerPublicCertificate")
  valid_600533 = validateParameter(valid_600533, JString, required = true,
                                 default = nil)
  if valid_600533 != nil:
    section.add "HsmServerPublicCertificate", valid_600533
  var valid_600534 = query.getOrDefault("HsmIpAddress")
  valid_600534 = validateParameter(valid_600534, JString, required = true,
                                 default = nil)
  if valid_600534 != nil:
    section.add "HsmIpAddress", valid_600534
  var valid_600535 = query.getOrDefault("Version")
  valid_600535 = validateParameter(valid_600535, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600535 != nil:
    section.add "Version", valid_600535
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600536 = header.getOrDefault("X-Amz-Date")
  valid_600536 = validateParameter(valid_600536, JString, required = false,
                                 default = nil)
  if valid_600536 != nil:
    section.add "X-Amz-Date", valid_600536
  var valid_600537 = header.getOrDefault("X-Amz-Security-Token")
  valid_600537 = validateParameter(valid_600537, JString, required = false,
                                 default = nil)
  if valid_600537 != nil:
    section.add "X-Amz-Security-Token", valid_600537
  var valid_600538 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600538 = validateParameter(valid_600538, JString, required = false,
                                 default = nil)
  if valid_600538 != nil:
    section.add "X-Amz-Content-Sha256", valid_600538
  var valid_600539 = header.getOrDefault("X-Amz-Algorithm")
  valid_600539 = validateParameter(valid_600539, JString, required = false,
                                 default = nil)
  if valid_600539 != nil:
    section.add "X-Amz-Algorithm", valid_600539
  var valid_600540 = header.getOrDefault("X-Amz-Signature")
  valid_600540 = validateParameter(valid_600540, JString, required = false,
                                 default = nil)
  if valid_600540 != nil:
    section.add "X-Amz-Signature", valid_600540
  var valid_600541 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600541 = validateParameter(valid_600541, JString, required = false,
                                 default = nil)
  if valid_600541 != nil:
    section.add "X-Amz-SignedHeaders", valid_600541
  var valid_600542 = header.getOrDefault("X-Amz-Credential")
  valid_600542 = validateParameter(valid_600542, JString, required = false,
                                 default = nil)
  if valid_600542 != nil:
    section.add "X-Amz-Credential", valid_600542
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600543: Call_GetCreateHsmConfiguration_600524; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_600543.validator(path, query, header, formData, body)
  let scheme = call_600543.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600543.url(scheme.get, call_600543.host, call_600543.base,
                         call_600543.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600543, url, valid)

proc call*(call_600544: Call_GetCreateHsmConfiguration_600524;
          HsmPartitionPassword: string; Description: string;
          HsmPartitionName: string; HsmConfigurationIdentifier: string;
          HsmServerPublicCertificate: string; HsmIpAddress: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   Version: string (required)
  var query_600545 = newJObject()
  add(query_600545, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_600545, "Description", newJString(Description))
  add(query_600545, "HsmPartitionName", newJString(HsmPartitionName))
  add(query_600545, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  if Tags != nil:
    query_600545.add "Tags", Tags
  add(query_600545, "Action", newJString(Action))
  add(query_600545, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_600545, "HsmIpAddress", newJString(HsmIpAddress))
  add(query_600545, "Version", newJString(Version))
  result = call_600544.call(nil, query_600545, nil, nil, nil)

var getCreateHsmConfiguration* = Call_GetCreateHsmConfiguration_600524(
    name: "getCreateHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_GetCreateHsmConfiguration_600525, base: "/",
    url: url_GetCreateHsmConfiguration_600526,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateScheduledAction_600592 = ref object of OpenApiRestCall_599352
proc url_PostCreateScheduledAction_600594(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateScheduledAction_600593(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600595 = query.getOrDefault("Action")
  valid_600595 = validateParameter(valid_600595, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_600595 != nil:
    section.add "Action", valid_600595
  var valid_600596 = query.getOrDefault("Version")
  valid_600596 = validateParameter(valid_600596, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600596 != nil:
    section.add "Version", valid_600596
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600597 = header.getOrDefault("X-Amz-Date")
  valid_600597 = validateParameter(valid_600597, JString, required = false,
                                 default = nil)
  if valid_600597 != nil:
    section.add "X-Amz-Date", valid_600597
  var valid_600598 = header.getOrDefault("X-Amz-Security-Token")
  valid_600598 = validateParameter(valid_600598, JString, required = false,
                                 default = nil)
  if valid_600598 != nil:
    section.add "X-Amz-Security-Token", valid_600598
  var valid_600599 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600599 = validateParameter(valid_600599, JString, required = false,
                                 default = nil)
  if valid_600599 != nil:
    section.add "X-Amz-Content-Sha256", valid_600599
  var valid_600600 = header.getOrDefault("X-Amz-Algorithm")
  valid_600600 = validateParameter(valid_600600, JString, required = false,
                                 default = nil)
  if valid_600600 != nil:
    section.add "X-Amz-Algorithm", valid_600600
  var valid_600601 = header.getOrDefault("X-Amz-Signature")
  valid_600601 = validateParameter(valid_600601, JString, required = false,
                                 default = nil)
  if valid_600601 != nil:
    section.add "X-Amz-Signature", valid_600601
  var valid_600602 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600602 = validateParameter(valid_600602, JString, required = false,
                                 default = nil)
  if valid_600602 != nil:
    section.add "X-Amz-SignedHeaders", valid_600602
  var valid_600603 = header.getOrDefault("X-Amz-Credential")
  valid_600603 = validateParameter(valid_600603, JString, required = false,
                                 default = nil)
  if valid_600603 != nil:
    section.add "X-Amz-Credential", valid_600603
  result.add "header", section
  ## parameters in `formData` object:
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Schedule` field"
  var valid_600604 = formData.getOrDefault("Schedule")
  valid_600604 = validateParameter(valid_600604, JString, required = true,
                                 default = nil)
  if valid_600604 != nil:
    section.add "Schedule", valid_600604
  var valid_600605 = formData.getOrDefault("ScheduledActionDescription")
  valid_600605 = validateParameter(valid_600605, JString, required = false,
                                 default = nil)
  if valid_600605 != nil:
    section.add "ScheduledActionDescription", valid_600605
  var valid_600606 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_600606 = validateParameter(valid_600606, JString, required = false,
                                 default = nil)
  if valid_600606 != nil:
    section.add "TargetAction.ResizeCluster", valid_600606
  var valid_600607 = formData.getOrDefault("StartTime")
  valid_600607 = validateParameter(valid_600607, JString, required = false,
                                 default = nil)
  if valid_600607 != nil:
    section.add "StartTime", valid_600607
  var valid_600608 = formData.getOrDefault("ScheduledActionName")
  valid_600608 = validateParameter(valid_600608, JString, required = true,
                                 default = nil)
  if valid_600608 != nil:
    section.add "ScheduledActionName", valid_600608
  var valid_600609 = formData.getOrDefault("Enable")
  valid_600609 = validateParameter(valid_600609, JBool, required = false, default = nil)
  if valid_600609 != nil:
    section.add "Enable", valid_600609
  var valid_600610 = formData.getOrDefault("IamRole")
  valid_600610 = validateParameter(valid_600610, JString, required = true,
                                 default = nil)
  if valid_600610 != nil:
    section.add "IamRole", valid_600610
  var valid_600611 = formData.getOrDefault("EndTime")
  valid_600611 = validateParameter(valid_600611, JString, required = false,
                                 default = nil)
  if valid_600611 != nil:
    section.add "EndTime", valid_600611
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600612: Call_PostCreateScheduledAction_600592; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_600612.validator(path, query, header, formData, body)
  let scheme = call_600612.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600612.url(scheme.get, call_600612.host, call_600612.base,
                         call_600612.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600612, url, valid)

proc call*(call_600613: Call_PostCreateScheduledAction_600592; Schedule: string;
          ScheduledActionName: string; IamRole: string;
          ScheduledActionDescription: string = "";
          TargetActionResizeCluster: string = ""; StartTime: string = "";
          Action: string = "CreateScheduledAction"; Enable: bool = false;
          EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Action: string (required)
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_600614 = newJObject()
  var formData_600615 = newJObject()
  add(formData_600615, "Schedule", newJString(Schedule))
  add(formData_600615, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_600615, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_600615, "StartTime", newJString(StartTime))
  add(query_600614, "Action", newJString(Action))
  add(formData_600615, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_600615, "Enable", newJBool(Enable))
  add(formData_600615, "IamRole", newJString(IamRole))
  add(formData_600615, "EndTime", newJString(EndTime))
  add(query_600614, "Version", newJString(Version))
  result = call_600613.call(nil, query_600614, nil, formData_600615, nil)

var postCreateScheduledAction* = Call_PostCreateScheduledAction_600592(
    name: "postCreateScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_PostCreateScheduledAction_600593, base: "/",
    url: url_PostCreateScheduledAction_600594,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateScheduledAction_600569 = ref object of OpenApiRestCall_599352
proc url_GetCreateScheduledAction_600571(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateScheduledAction_600570(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   IamRole: JString (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Enable: JBool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   Action: JString (required)
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  ##   ScheduledActionDescription: JString
  ##                             : The description of the scheduled action. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Schedule` field"
  var valid_600572 = query.getOrDefault("Schedule")
  valid_600572 = validateParameter(valid_600572, JString, required = true,
                                 default = nil)
  if valid_600572 != nil:
    section.add "Schedule", valid_600572
  var valid_600573 = query.getOrDefault("ScheduledActionName")
  valid_600573 = validateParameter(valid_600573, JString, required = true,
                                 default = nil)
  if valid_600573 != nil:
    section.add "ScheduledActionName", valid_600573
  var valid_600574 = query.getOrDefault("StartTime")
  valid_600574 = validateParameter(valid_600574, JString, required = false,
                                 default = nil)
  if valid_600574 != nil:
    section.add "StartTime", valid_600574
  var valid_600575 = query.getOrDefault("IamRole")
  valid_600575 = validateParameter(valid_600575, JString, required = true,
                                 default = nil)
  if valid_600575 != nil:
    section.add "IamRole", valid_600575
  var valid_600576 = query.getOrDefault("Enable")
  valid_600576 = validateParameter(valid_600576, JBool, required = false, default = nil)
  if valid_600576 != nil:
    section.add "Enable", valid_600576
  var valid_600577 = query.getOrDefault("Action")
  valid_600577 = validateParameter(valid_600577, JString, required = true,
                                 default = newJString("CreateScheduledAction"))
  if valid_600577 != nil:
    section.add "Action", valid_600577
  var valid_600578 = query.getOrDefault("EndTime")
  valid_600578 = validateParameter(valid_600578, JString, required = false,
                                 default = nil)
  if valid_600578 != nil:
    section.add "EndTime", valid_600578
  var valid_600579 = query.getOrDefault("Version")
  valid_600579 = validateParameter(valid_600579, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600579 != nil:
    section.add "Version", valid_600579
  var valid_600580 = query.getOrDefault("ScheduledActionDescription")
  valid_600580 = validateParameter(valid_600580, JString, required = false,
                                 default = nil)
  if valid_600580 != nil:
    section.add "ScheduledActionDescription", valid_600580
  var valid_600581 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_600581 = validateParameter(valid_600581, JString, required = false,
                                 default = nil)
  if valid_600581 != nil:
    section.add "TargetAction.ResizeCluster", valid_600581
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600582 = header.getOrDefault("X-Amz-Date")
  valid_600582 = validateParameter(valid_600582, JString, required = false,
                                 default = nil)
  if valid_600582 != nil:
    section.add "X-Amz-Date", valid_600582
  var valid_600583 = header.getOrDefault("X-Amz-Security-Token")
  valid_600583 = validateParameter(valid_600583, JString, required = false,
                                 default = nil)
  if valid_600583 != nil:
    section.add "X-Amz-Security-Token", valid_600583
  var valid_600584 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600584 = validateParameter(valid_600584, JString, required = false,
                                 default = nil)
  if valid_600584 != nil:
    section.add "X-Amz-Content-Sha256", valid_600584
  var valid_600585 = header.getOrDefault("X-Amz-Algorithm")
  valid_600585 = validateParameter(valid_600585, JString, required = false,
                                 default = nil)
  if valid_600585 != nil:
    section.add "X-Amz-Algorithm", valid_600585
  var valid_600586 = header.getOrDefault("X-Amz-Signature")
  valid_600586 = validateParameter(valid_600586, JString, required = false,
                                 default = nil)
  if valid_600586 != nil:
    section.add "X-Amz-Signature", valid_600586
  var valid_600587 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600587 = validateParameter(valid_600587, JString, required = false,
                                 default = nil)
  if valid_600587 != nil:
    section.add "X-Amz-SignedHeaders", valid_600587
  var valid_600588 = header.getOrDefault("X-Amz-Credential")
  valid_600588 = validateParameter(valid_600588, JString, required = false,
                                 default = nil)
  if valid_600588 != nil:
    section.add "X-Amz-Credential", valid_600588
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600589: Call_GetCreateScheduledAction_600569; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ## 
  let valid = call_600589.validator(path, query, header, formData, body)
  let scheme = call_600589.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600589.url(scheme.get, call_600589.host, call_600589.base,
                         call_600589.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600589, url, valid)

proc call*(call_600590: Call_GetCreateScheduledAction_600569; Schedule: string;
          ScheduledActionName: string; IamRole: string; StartTime: string = "";
          Enable: bool = false; Action: string = "CreateScheduledAction";
          EndTime: string = ""; Version: string = "2012-12-01";
          ScheduledActionDescription: string = "";
          TargetActionResizeCluster: string = ""): Recallable =
  ## getCreateScheduledAction
  ## Creates a scheduled action. A scheduled action contains a schedule and an Amazon Redshift API action. For example, you can create a schedule of when to run the <code>ResizeCluster</code> API operation. 
  ##   Schedule: string (required)
  ##           : The schedule in <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action. The name must be unique within an account. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled action. Before this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   IamRole: string (required)
  ##          : The IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Enable: bool
  ##         : If true, the schedule is enabled. If false, the scheduled action does not trigger. For more information about <code>state</code> of the scheduled action, see <a>ScheduledAction</a>. 
  ##   Action: string (required)
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action. After this time, the scheduled action does not trigger. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  ##   ScheduledActionDescription: string
  ##                             : The description of the scheduled action. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  var query_600591 = newJObject()
  add(query_600591, "Schedule", newJString(Schedule))
  add(query_600591, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_600591, "StartTime", newJString(StartTime))
  add(query_600591, "IamRole", newJString(IamRole))
  add(query_600591, "Enable", newJBool(Enable))
  add(query_600591, "Action", newJString(Action))
  add(query_600591, "EndTime", newJString(EndTime))
  add(query_600591, "Version", newJString(Version))
  add(query_600591, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_600591, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  result = call_600590.call(nil, query_600591, nil, nil, nil)

var getCreateScheduledAction* = Call_GetCreateScheduledAction_600569(
    name: "getCreateScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateScheduledAction",
    validator: validate_GetCreateScheduledAction_600570, base: "/",
    url: url_GetCreateScheduledAction_600571, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotCopyGrant_600634 = ref object of OpenApiRestCall_599352
proc url_PostCreateSnapshotCopyGrant_600636(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotCopyGrant_600635(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600637 = query.getOrDefault("Action")
  valid_600637 = validateParameter(valid_600637, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_600637 != nil:
    section.add "Action", valid_600637
  var valid_600638 = query.getOrDefault("Version")
  valid_600638 = validateParameter(valid_600638, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600638 != nil:
    section.add "Version", valid_600638
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600639 = header.getOrDefault("X-Amz-Date")
  valid_600639 = validateParameter(valid_600639, JString, required = false,
                                 default = nil)
  if valid_600639 != nil:
    section.add "X-Amz-Date", valid_600639
  var valid_600640 = header.getOrDefault("X-Amz-Security-Token")
  valid_600640 = validateParameter(valid_600640, JString, required = false,
                                 default = nil)
  if valid_600640 != nil:
    section.add "X-Amz-Security-Token", valid_600640
  var valid_600641 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600641 = validateParameter(valid_600641, JString, required = false,
                                 default = nil)
  if valid_600641 != nil:
    section.add "X-Amz-Content-Sha256", valid_600641
  var valid_600642 = header.getOrDefault("X-Amz-Algorithm")
  valid_600642 = validateParameter(valid_600642, JString, required = false,
                                 default = nil)
  if valid_600642 != nil:
    section.add "X-Amz-Algorithm", valid_600642
  var valid_600643 = header.getOrDefault("X-Amz-Signature")
  valid_600643 = validateParameter(valid_600643, JString, required = false,
                                 default = nil)
  if valid_600643 != nil:
    section.add "X-Amz-Signature", valid_600643
  var valid_600644 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600644 = validateParameter(valid_600644, JString, required = false,
                                 default = nil)
  if valid_600644 != nil:
    section.add "X-Amz-SignedHeaders", valid_600644
  var valid_600645 = header.getOrDefault("X-Amz-Credential")
  valid_600645 = validateParameter(valid_600645, JString, required = false,
                                 default = nil)
  if valid_600645 != nil:
    section.add "X-Amz-Credential", valid_600645
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  section = newJObject()
  var valid_600646 = formData.getOrDefault("Tags")
  valid_600646 = validateParameter(valid_600646, JArray, required = false,
                                 default = nil)
  if valid_600646 != nil:
    section.add "Tags", valid_600646
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_600647 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_600647 = validateParameter(valid_600647, JString, required = true,
                                 default = nil)
  if valid_600647 != nil:
    section.add "SnapshotCopyGrantName", valid_600647
  var valid_600648 = formData.getOrDefault("KmsKeyId")
  valid_600648 = validateParameter(valid_600648, JString, required = false,
                                 default = nil)
  if valid_600648 != nil:
    section.add "KmsKeyId", valid_600648
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600649: Call_PostCreateSnapshotCopyGrant_600634; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_600649.validator(path, query, header, formData, body)
  let scheme = call_600649.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600649.url(scheme.get, call_600649.host, call_600649.base,
                         call_600649.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600649, url, valid)

proc call*(call_600650: Call_PostCreateSnapshotCopyGrant_600634;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil;
          Action: string = "CreateSnapshotCopyGrant"; KmsKeyId: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Version: string (required)
  var query_600651 = newJObject()
  var formData_600652 = newJObject()
  if Tags != nil:
    formData_600652.add "Tags", Tags
  add(query_600651, "Action", newJString(Action))
  add(formData_600652, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(formData_600652, "KmsKeyId", newJString(KmsKeyId))
  add(query_600651, "Version", newJString(Version))
  result = call_600650.call(nil, query_600651, nil, formData_600652, nil)

var postCreateSnapshotCopyGrant* = Call_PostCreateSnapshotCopyGrant_600634(
    name: "postCreateSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_PostCreateSnapshotCopyGrant_600635, base: "/",
    url: url_PostCreateSnapshotCopyGrant_600636,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotCopyGrant_600616 = ref object of OpenApiRestCall_599352
proc url_GetCreateSnapshotCopyGrant_600618(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotCopyGrant_600617(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_600619 = query.getOrDefault("Tags")
  valid_600619 = validateParameter(valid_600619, JArray, required = false,
                                 default = nil)
  if valid_600619 != nil:
    section.add "Tags", valid_600619
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600620 = query.getOrDefault("Action")
  valid_600620 = validateParameter(valid_600620, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_600620 != nil:
    section.add "Action", valid_600620
  var valid_600621 = query.getOrDefault("KmsKeyId")
  valid_600621 = validateParameter(valid_600621, JString, required = false,
                                 default = nil)
  if valid_600621 != nil:
    section.add "KmsKeyId", valid_600621
  var valid_600622 = query.getOrDefault("SnapshotCopyGrantName")
  valid_600622 = validateParameter(valid_600622, JString, required = true,
                                 default = nil)
  if valid_600622 != nil:
    section.add "SnapshotCopyGrantName", valid_600622
  var valid_600623 = query.getOrDefault("Version")
  valid_600623 = validateParameter(valid_600623, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600623 != nil:
    section.add "Version", valid_600623
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600624 = header.getOrDefault("X-Amz-Date")
  valid_600624 = validateParameter(valid_600624, JString, required = false,
                                 default = nil)
  if valid_600624 != nil:
    section.add "X-Amz-Date", valid_600624
  var valid_600625 = header.getOrDefault("X-Amz-Security-Token")
  valid_600625 = validateParameter(valid_600625, JString, required = false,
                                 default = nil)
  if valid_600625 != nil:
    section.add "X-Amz-Security-Token", valid_600625
  var valid_600626 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600626 = validateParameter(valid_600626, JString, required = false,
                                 default = nil)
  if valid_600626 != nil:
    section.add "X-Amz-Content-Sha256", valid_600626
  var valid_600627 = header.getOrDefault("X-Amz-Algorithm")
  valid_600627 = validateParameter(valid_600627, JString, required = false,
                                 default = nil)
  if valid_600627 != nil:
    section.add "X-Amz-Algorithm", valid_600627
  var valid_600628 = header.getOrDefault("X-Amz-Signature")
  valid_600628 = validateParameter(valid_600628, JString, required = false,
                                 default = nil)
  if valid_600628 != nil:
    section.add "X-Amz-Signature", valid_600628
  var valid_600629 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600629 = validateParameter(valid_600629, JString, required = false,
                                 default = nil)
  if valid_600629 != nil:
    section.add "X-Amz-SignedHeaders", valid_600629
  var valid_600630 = header.getOrDefault("X-Amz-Credential")
  valid_600630 = validateParameter(valid_600630, JString, required = false,
                                 default = nil)
  if valid_600630 != nil:
    section.add "X-Amz-Credential", valid_600630
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600631: Call_GetCreateSnapshotCopyGrant_600616; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_600631.validator(path, query, header, formData, body)
  let scheme = call_600631.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600631.url(scheme.get, call_600631.host, call_600631.base,
                         call_600631.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600631, url, valid)

proc call*(call_600632: Call_GetCreateSnapshotCopyGrant_600616;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil;
          Action: string = "CreateSnapshotCopyGrant"; KmsKeyId: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: string (required)
  var query_600633 = newJObject()
  if Tags != nil:
    query_600633.add "Tags", Tags
  add(query_600633, "Action", newJString(Action))
  add(query_600633, "KmsKeyId", newJString(KmsKeyId))
  add(query_600633, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_600633, "Version", newJString(Version))
  result = call_600632.call(nil, query_600633, nil, nil, nil)

var getCreateSnapshotCopyGrant* = Call_GetCreateSnapshotCopyGrant_600616(
    name: "getCreateSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_GetCreateSnapshotCopyGrant_600617, base: "/",
    url: url_GetCreateSnapshotCopyGrant_600618,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotSchedule_600674 = ref object of OpenApiRestCall_599352
proc url_PostCreateSnapshotSchedule_600676(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateSnapshotSchedule_600675(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600677 = query.getOrDefault("Action")
  valid_600677 = validateParameter(valid_600677, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_600677 != nil:
    section.add "Action", valid_600677
  var valid_600678 = query.getOrDefault("Version")
  valid_600678 = validateParameter(valid_600678, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600678 != nil:
    section.add "Version", valid_600678
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600679 = header.getOrDefault("X-Amz-Date")
  valid_600679 = validateParameter(valid_600679, JString, required = false,
                                 default = nil)
  if valid_600679 != nil:
    section.add "X-Amz-Date", valid_600679
  var valid_600680 = header.getOrDefault("X-Amz-Security-Token")
  valid_600680 = validateParameter(valid_600680, JString, required = false,
                                 default = nil)
  if valid_600680 != nil:
    section.add "X-Amz-Security-Token", valid_600680
  var valid_600681 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600681 = validateParameter(valid_600681, JString, required = false,
                                 default = nil)
  if valid_600681 != nil:
    section.add "X-Amz-Content-Sha256", valid_600681
  var valid_600682 = header.getOrDefault("X-Amz-Algorithm")
  valid_600682 = validateParameter(valid_600682, JString, required = false,
                                 default = nil)
  if valid_600682 != nil:
    section.add "X-Amz-Algorithm", valid_600682
  var valid_600683 = header.getOrDefault("X-Amz-Signature")
  valid_600683 = validateParameter(valid_600683, JString, required = false,
                                 default = nil)
  if valid_600683 != nil:
    section.add "X-Amz-Signature", valid_600683
  var valid_600684 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600684 = validateParameter(valid_600684, JString, required = false,
                                 default = nil)
  if valid_600684 != nil:
    section.add "X-Amz-SignedHeaders", valid_600684
  var valid_600685 = header.getOrDefault("X-Amz-Credential")
  valid_600685 = validateParameter(valid_600685, JString, required = false,
                                 default = nil)
  if valid_600685 != nil:
    section.add "X-Amz-Credential", valid_600685
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   DryRun: JBool
  ##         : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   NextInvocations: JInt
  ##                  : <p/>
  section = newJObject()
  var valid_600686 = formData.getOrDefault("ScheduleDefinitions")
  valid_600686 = validateParameter(valid_600686, JArray, required = false,
                                 default = nil)
  if valid_600686 != nil:
    section.add "ScheduleDefinitions", valid_600686
  var valid_600687 = formData.getOrDefault("DryRun")
  valid_600687 = validateParameter(valid_600687, JBool, required = false, default = nil)
  if valid_600687 != nil:
    section.add "DryRun", valid_600687
  var valid_600688 = formData.getOrDefault("Tags")
  valid_600688 = validateParameter(valid_600688, JArray, required = false,
                                 default = nil)
  if valid_600688 != nil:
    section.add "Tags", valid_600688
  var valid_600689 = formData.getOrDefault("ScheduleDescription")
  valid_600689 = validateParameter(valid_600689, JString, required = false,
                                 default = nil)
  if valid_600689 != nil:
    section.add "ScheduleDescription", valid_600689
  var valid_600690 = formData.getOrDefault("ScheduleIdentifier")
  valid_600690 = validateParameter(valid_600690, JString, required = false,
                                 default = nil)
  if valid_600690 != nil:
    section.add "ScheduleIdentifier", valid_600690
  var valid_600691 = formData.getOrDefault("NextInvocations")
  valid_600691 = validateParameter(valid_600691, JInt, required = false, default = nil)
  if valid_600691 != nil:
    section.add "NextInvocations", valid_600691
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600692: Call_PostCreateSnapshotSchedule_600674; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_600692.validator(path, query, header, formData, body)
  let scheme = call_600692.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600692.url(scheme.get, call_600692.host, call_600692.base,
                         call_600692.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600692, url, valid)

proc call*(call_600693: Call_PostCreateSnapshotSchedule_600674;
          ScheduleDefinitions: JsonNode = nil; DryRun: bool = false;
          Tags: JsonNode = nil; ScheduleDescription: string = "";
          Action: string = "CreateSnapshotSchedule";
          ScheduleIdentifier: string = ""; NextInvocations: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   DryRun: bool
  ##         : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Version: string (required)
  var query_600694 = newJObject()
  var formData_600695 = newJObject()
  if ScheduleDefinitions != nil:
    formData_600695.add "ScheduleDefinitions", ScheduleDefinitions
  add(formData_600695, "DryRun", newJBool(DryRun))
  if Tags != nil:
    formData_600695.add "Tags", Tags
  add(formData_600695, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_600694, "Action", newJString(Action))
  add(formData_600695, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(formData_600695, "NextInvocations", newJInt(NextInvocations))
  add(query_600694, "Version", newJString(Version))
  result = call_600693.call(nil, query_600694, nil, formData_600695, nil)

var postCreateSnapshotSchedule* = Call_PostCreateSnapshotSchedule_600674(
    name: "postCreateSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_PostCreateSnapshotSchedule_600675, base: "/",
    url: url_PostCreateSnapshotSchedule_600676,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotSchedule_600653 = ref object of OpenApiRestCall_599352
proc url_GetCreateSnapshotSchedule_600655(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateSnapshotSchedule_600654(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DryRun: JBool
  ##         : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   Version: JString (required)
  section = newJObject()
  var valid_600656 = query.getOrDefault("DryRun")
  valid_600656 = validateParameter(valid_600656, JBool, required = false, default = nil)
  if valid_600656 != nil:
    section.add "DryRun", valid_600656
  var valid_600657 = query.getOrDefault("ScheduleDefinitions")
  valid_600657 = validateParameter(valid_600657, JArray, required = false,
                                 default = nil)
  if valid_600657 != nil:
    section.add "ScheduleDefinitions", valid_600657
  var valid_600658 = query.getOrDefault("Tags")
  valid_600658 = validateParameter(valid_600658, JArray, required = false,
                                 default = nil)
  if valid_600658 != nil:
    section.add "Tags", valid_600658
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600659 = query.getOrDefault("Action")
  valid_600659 = validateParameter(valid_600659, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_600659 != nil:
    section.add "Action", valid_600659
  var valid_600660 = query.getOrDefault("ScheduleIdentifier")
  valid_600660 = validateParameter(valid_600660, JString, required = false,
                                 default = nil)
  if valid_600660 != nil:
    section.add "ScheduleIdentifier", valid_600660
  var valid_600661 = query.getOrDefault("ScheduleDescription")
  valid_600661 = validateParameter(valid_600661, JString, required = false,
                                 default = nil)
  if valid_600661 != nil:
    section.add "ScheduleDescription", valid_600661
  var valid_600662 = query.getOrDefault("NextInvocations")
  valid_600662 = validateParameter(valid_600662, JInt, required = false, default = nil)
  if valid_600662 != nil:
    section.add "NextInvocations", valid_600662
  var valid_600663 = query.getOrDefault("Version")
  valid_600663 = validateParameter(valid_600663, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600663 != nil:
    section.add "Version", valid_600663
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600664 = header.getOrDefault("X-Amz-Date")
  valid_600664 = validateParameter(valid_600664, JString, required = false,
                                 default = nil)
  if valid_600664 != nil:
    section.add "X-Amz-Date", valid_600664
  var valid_600665 = header.getOrDefault("X-Amz-Security-Token")
  valid_600665 = validateParameter(valid_600665, JString, required = false,
                                 default = nil)
  if valid_600665 != nil:
    section.add "X-Amz-Security-Token", valid_600665
  var valid_600666 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600666 = validateParameter(valid_600666, JString, required = false,
                                 default = nil)
  if valid_600666 != nil:
    section.add "X-Amz-Content-Sha256", valid_600666
  var valid_600667 = header.getOrDefault("X-Amz-Algorithm")
  valid_600667 = validateParameter(valid_600667, JString, required = false,
                                 default = nil)
  if valid_600667 != nil:
    section.add "X-Amz-Algorithm", valid_600667
  var valid_600668 = header.getOrDefault("X-Amz-Signature")
  valid_600668 = validateParameter(valid_600668, JString, required = false,
                                 default = nil)
  if valid_600668 != nil:
    section.add "X-Amz-Signature", valid_600668
  var valid_600669 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600669 = validateParameter(valid_600669, JString, required = false,
                                 default = nil)
  if valid_600669 != nil:
    section.add "X-Amz-SignedHeaders", valid_600669
  var valid_600670 = header.getOrDefault("X-Amz-Credential")
  valid_600670 = validateParameter(valid_600670, JString, required = false,
                                 default = nil)
  if valid_600670 != nil:
    section.add "X-Amz-Credential", valid_600670
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600671: Call_GetCreateSnapshotSchedule_600653; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_600671.validator(path, query, header, formData, body)
  let scheme = call_600671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600671.url(scheme.get, call_600671.host, call_600671.base,
                         call_600671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600671, url, valid)

proc call*(call_600672: Call_GetCreateSnapshotSchedule_600653;
          DryRun: bool = false; ScheduleDefinitions: JsonNode = nil;
          Tags: JsonNode = nil; Action: string = "CreateSnapshotSchedule";
          ScheduleIdentifier: string = ""; ScheduleDescription: string = "";
          NextInvocations: int = 0; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   DryRun: bool
  ##         : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Version: string (required)
  var query_600673 = newJObject()
  add(query_600673, "DryRun", newJBool(DryRun))
  if ScheduleDefinitions != nil:
    query_600673.add "ScheduleDefinitions", ScheduleDefinitions
  if Tags != nil:
    query_600673.add "Tags", Tags
  add(query_600673, "Action", newJString(Action))
  add(query_600673, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_600673, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_600673, "NextInvocations", newJInt(NextInvocations))
  add(query_600673, "Version", newJString(Version))
  result = call_600672.call(nil, query_600673, nil, nil, nil)

var getCreateSnapshotSchedule* = Call_GetCreateSnapshotSchedule_600653(
    name: "getCreateSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_GetCreateSnapshotSchedule_600654, base: "/",
    url: url_GetCreateSnapshotSchedule_600655,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateTags_600713 = ref object of OpenApiRestCall_599352
proc url_PostCreateTags_600715(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostCreateTags_600714(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600716 = query.getOrDefault("Action")
  valid_600716 = validateParameter(valid_600716, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_600716 != nil:
    section.add "Action", valid_600716
  var valid_600717 = query.getOrDefault("Version")
  valid_600717 = validateParameter(valid_600717, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600717 != nil:
    section.add "Version", valid_600717
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600718 = header.getOrDefault("X-Amz-Date")
  valid_600718 = validateParameter(valid_600718, JString, required = false,
                                 default = nil)
  if valid_600718 != nil:
    section.add "X-Amz-Date", valid_600718
  var valid_600719 = header.getOrDefault("X-Amz-Security-Token")
  valid_600719 = validateParameter(valid_600719, JString, required = false,
                                 default = nil)
  if valid_600719 != nil:
    section.add "X-Amz-Security-Token", valid_600719
  var valid_600720 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600720 = validateParameter(valid_600720, JString, required = false,
                                 default = nil)
  if valid_600720 != nil:
    section.add "X-Amz-Content-Sha256", valid_600720
  var valid_600721 = header.getOrDefault("X-Amz-Algorithm")
  valid_600721 = validateParameter(valid_600721, JString, required = false,
                                 default = nil)
  if valid_600721 != nil:
    section.add "X-Amz-Algorithm", valid_600721
  var valid_600722 = header.getOrDefault("X-Amz-Signature")
  valid_600722 = validateParameter(valid_600722, JString, required = false,
                                 default = nil)
  if valid_600722 != nil:
    section.add "X-Amz-Signature", valid_600722
  var valid_600723 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600723 = validateParameter(valid_600723, JString, required = false,
                                 default = nil)
  if valid_600723 != nil:
    section.add "X-Amz-SignedHeaders", valid_600723
  var valid_600724 = header.getOrDefault("X-Amz-Credential")
  valid_600724 = validateParameter(valid_600724, JString, required = false,
                                 default = nil)
  if valid_600724 != nil:
    section.add "X-Amz-Credential", valid_600724
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Tags` field"
  var valid_600725 = formData.getOrDefault("Tags")
  valid_600725 = validateParameter(valid_600725, JArray, required = true, default = nil)
  if valid_600725 != nil:
    section.add "Tags", valid_600725
  var valid_600726 = formData.getOrDefault("ResourceName")
  valid_600726 = validateParameter(valid_600726, JString, required = true,
                                 default = nil)
  if valid_600726 != nil:
    section.add "ResourceName", valid_600726
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600727: Call_PostCreateTags_600713; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_600727.validator(path, query, header, formData, body)
  let scheme = call_600727.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600727.url(scheme.get, call_600727.host, call_600727.base,
                         call_600727.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600727, url, valid)

proc call*(call_600728: Call_PostCreateTags_600713; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Action: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Version: string (required)
  var query_600729 = newJObject()
  var formData_600730 = newJObject()
  if Tags != nil:
    formData_600730.add "Tags", Tags
  add(query_600729, "Action", newJString(Action))
  add(formData_600730, "ResourceName", newJString(ResourceName))
  add(query_600729, "Version", newJString(Version))
  result = call_600728.call(nil, query_600729, nil, formData_600730, nil)

var postCreateTags* = Call_PostCreateTags_600713(name: "postCreateTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_PostCreateTags_600714,
    base: "/", url: url_PostCreateTags_600715, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateTags_600696 = ref object of OpenApiRestCall_599352
proc url_GetCreateTags_600698(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetCreateTags_600697(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Tags` field"
  var valid_600699 = query.getOrDefault("Tags")
  valid_600699 = validateParameter(valid_600699, JArray, required = true, default = nil)
  if valid_600699 != nil:
    section.add "Tags", valid_600699
  var valid_600700 = query.getOrDefault("ResourceName")
  valid_600700 = validateParameter(valid_600700, JString, required = true,
                                 default = nil)
  if valid_600700 != nil:
    section.add "ResourceName", valid_600700
  var valid_600701 = query.getOrDefault("Action")
  valid_600701 = validateParameter(valid_600701, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_600701 != nil:
    section.add "Action", valid_600701
  var valid_600702 = query.getOrDefault("Version")
  valid_600702 = validateParameter(valid_600702, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600702 != nil:
    section.add "Version", valid_600702
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600703 = header.getOrDefault("X-Amz-Date")
  valid_600703 = validateParameter(valid_600703, JString, required = false,
                                 default = nil)
  if valid_600703 != nil:
    section.add "X-Amz-Date", valid_600703
  var valid_600704 = header.getOrDefault("X-Amz-Security-Token")
  valid_600704 = validateParameter(valid_600704, JString, required = false,
                                 default = nil)
  if valid_600704 != nil:
    section.add "X-Amz-Security-Token", valid_600704
  var valid_600705 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600705 = validateParameter(valid_600705, JString, required = false,
                                 default = nil)
  if valid_600705 != nil:
    section.add "X-Amz-Content-Sha256", valid_600705
  var valid_600706 = header.getOrDefault("X-Amz-Algorithm")
  valid_600706 = validateParameter(valid_600706, JString, required = false,
                                 default = nil)
  if valid_600706 != nil:
    section.add "X-Amz-Algorithm", valid_600706
  var valid_600707 = header.getOrDefault("X-Amz-Signature")
  valid_600707 = validateParameter(valid_600707, JString, required = false,
                                 default = nil)
  if valid_600707 != nil:
    section.add "X-Amz-Signature", valid_600707
  var valid_600708 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600708 = validateParameter(valid_600708, JString, required = false,
                                 default = nil)
  if valid_600708 != nil:
    section.add "X-Amz-SignedHeaders", valid_600708
  var valid_600709 = header.getOrDefault("X-Amz-Credential")
  valid_600709 = validateParameter(valid_600709, JString, required = false,
                                 default = nil)
  if valid_600709 != nil:
    section.add "X-Amz-Credential", valid_600709
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600710: Call_GetCreateTags_600696; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_600710.validator(path, query, header, formData, body)
  let scheme = call_600710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600710.url(scheme.get, call_600710.host, call_600710.base,
                         call_600710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600710, url, valid)

proc call*(call_600711: Call_GetCreateTags_600696; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_600712 = newJObject()
  if Tags != nil:
    query_600712.add "Tags", Tags
  add(query_600712, "ResourceName", newJString(ResourceName))
  add(query_600712, "Action", newJString(Action))
  add(query_600712, "Version", newJString(Version))
  result = call_600711.call(nil, query_600712, nil, nil, nil)

var getCreateTags* = Call_GetCreateTags_600696(name: "getCreateTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_GetCreateTags_600697,
    base: "/", url: url_GetCreateTags_600698, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteCluster_600750 = ref object of OpenApiRestCall_599352
proc url_PostDeleteCluster_600752(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteCluster_600751(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600753 = query.getOrDefault("Action")
  valid_600753 = validateParameter(valid_600753, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_600753 != nil:
    section.add "Action", valid_600753
  var valid_600754 = query.getOrDefault("Version")
  valid_600754 = validateParameter(valid_600754, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600754 != nil:
    section.add "Version", valid_600754
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600755 = header.getOrDefault("X-Amz-Date")
  valid_600755 = validateParameter(valid_600755, JString, required = false,
                                 default = nil)
  if valid_600755 != nil:
    section.add "X-Amz-Date", valid_600755
  var valid_600756 = header.getOrDefault("X-Amz-Security-Token")
  valid_600756 = validateParameter(valid_600756, JString, required = false,
                                 default = nil)
  if valid_600756 != nil:
    section.add "X-Amz-Security-Token", valid_600756
  var valid_600757 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600757 = validateParameter(valid_600757, JString, required = false,
                                 default = nil)
  if valid_600757 != nil:
    section.add "X-Amz-Content-Sha256", valid_600757
  var valid_600758 = header.getOrDefault("X-Amz-Algorithm")
  valid_600758 = validateParameter(valid_600758, JString, required = false,
                                 default = nil)
  if valid_600758 != nil:
    section.add "X-Amz-Algorithm", valid_600758
  var valid_600759 = header.getOrDefault("X-Amz-Signature")
  valid_600759 = validateParameter(valid_600759, JString, required = false,
                                 default = nil)
  if valid_600759 != nil:
    section.add "X-Amz-Signature", valid_600759
  var valid_600760 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600760 = validateParameter(valid_600760, JString, required = false,
                                 default = nil)
  if valid_600760 != nil:
    section.add "X-Amz-SignedHeaders", valid_600760
  var valid_600761 = header.getOrDefault("X-Amz-Credential")
  valid_600761 = validateParameter(valid_600761, JString, required = false,
                                 default = nil)
  if valid_600761 != nil:
    section.add "X-Amz-Credential", valid_600761
  result.add "header", section
  ## parameters in `formData` object:
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  section = newJObject()
  var valid_600762 = formData.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_600762 = validateParameter(valid_600762, JString, required = false,
                                 default = nil)
  if valid_600762 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_600762
  var valid_600763 = formData.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_600763 = validateParameter(valid_600763, JInt, required = false, default = nil)
  if valid_600763 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_600763
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_600764 = formData.getOrDefault("ClusterIdentifier")
  valid_600764 = validateParameter(valid_600764, JString, required = true,
                                 default = nil)
  if valid_600764 != nil:
    section.add "ClusterIdentifier", valid_600764
  var valid_600765 = formData.getOrDefault("SkipFinalClusterSnapshot")
  valid_600765 = validateParameter(valid_600765, JBool, required = false, default = nil)
  if valid_600765 != nil:
    section.add "SkipFinalClusterSnapshot", valid_600765
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600766: Call_PostDeleteCluster_600750; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600766.validator(path, query, header, formData, body)
  let scheme = call_600766.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600766.url(scheme.get, call_600766.host, call_600766.base,
                         call_600766.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600766, url, valid)

proc call*(call_600767: Call_PostDeleteCluster_600750; ClusterIdentifier: string;
          FinalClusterSnapshotIdentifier: string = "";
          Action: string = "DeleteCluster";
          FinalClusterSnapshotRetentionPeriod: int = 0;
          SkipFinalClusterSnapshot: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   Version: string (required)
  var query_600768 = newJObject()
  var formData_600769 = newJObject()
  add(formData_600769, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_600768, "Action", newJString(Action))
  add(formData_600769, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(formData_600769, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_600769, "SkipFinalClusterSnapshot",
      newJBool(SkipFinalClusterSnapshot))
  add(query_600768, "Version", newJString(Version))
  result = call_600767.call(nil, query_600768, nil, formData_600769, nil)

var postDeleteCluster* = Call_PostDeleteCluster_600750(name: "postDeleteCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_PostDeleteCluster_600751,
    base: "/", url: url_PostDeleteCluster_600752,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteCluster_600731 = ref object of OpenApiRestCall_599352
proc url_GetDeleteCluster_600733(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteCluster_600732(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_600734 = query.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_600734 = validateParameter(valid_600734, JInt, required = false, default = nil)
  if valid_600734 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_600734
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600735 = query.getOrDefault("Action")
  valid_600735 = validateParameter(valid_600735, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_600735 != nil:
    section.add "Action", valid_600735
  var valid_600736 = query.getOrDefault("ClusterIdentifier")
  valid_600736 = validateParameter(valid_600736, JString, required = true,
                                 default = nil)
  if valid_600736 != nil:
    section.add "ClusterIdentifier", valid_600736
  var valid_600737 = query.getOrDefault("SkipFinalClusterSnapshot")
  valid_600737 = validateParameter(valid_600737, JBool, required = false, default = nil)
  if valid_600737 != nil:
    section.add "SkipFinalClusterSnapshot", valid_600737
  var valid_600738 = query.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_600738 = validateParameter(valid_600738, JString, required = false,
                                 default = nil)
  if valid_600738 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_600738
  var valid_600739 = query.getOrDefault("Version")
  valid_600739 = validateParameter(valid_600739, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600739 != nil:
    section.add "Version", valid_600739
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600740 = header.getOrDefault("X-Amz-Date")
  valid_600740 = validateParameter(valid_600740, JString, required = false,
                                 default = nil)
  if valid_600740 != nil:
    section.add "X-Amz-Date", valid_600740
  var valid_600741 = header.getOrDefault("X-Amz-Security-Token")
  valid_600741 = validateParameter(valid_600741, JString, required = false,
                                 default = nil)
  if valid_600741 != nil:
    section.add "X-Amz-Security-Token", valid_600741
  var valid_600742 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600742 = validateParameter(valid_600742, JString, required = false,
                                 default = nil)
  if valid_600742 != nil:
    section.add "X-Amz-Content-Sha256", valid_600742
  var valid_600743 = header.getOrDefault("X-Amz-Algorithm")
  valid_600743 = validateParameter(valid_600743, JString, required = false,
                                 default = nil)
  if valid_600743 != nil:
    section.add "X-Amz-Algorithm", valid_600743
  var valid_600744 = header.getOrDefault("X-Amz-Signature")
  valid_600744 = validateParameter(valid_600744, JString, required = false,
                                 default = nil)
  if valid_600744 != nil:
    section.add "X-Amz-Signature", valid_600744
  var valid_600745 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600745 = validateParameter(valid_600745, JString, required = false,
                                 default = nil)
  if valid_600745 != nil:
    section.add "X-Amz-SignedHeaders", valid_600745
  var valid_600746 = header.getOrDefault("X-Amz-Credential")
  valid_600746 = validateParameter(valid_600746, JString, required = false,
                                 default = nil)
  if valid_600746 != nil:
    section.add "X-Amz-Credential", valid_600746
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600747: Call_GetDeleteCluster_600731; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600747.validator(path, query, header, formData, body)
  let scheme = call_600747.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600747.url(scheme.get, call_600747.host, call_600747.base,
                         call_600747.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600747, url, valid)

proc call*(call_600748: Call_GetDeleteCluster_600731; ClusterIdentifier: string;
          FinalClusterSnapshotRetentionPeriod: int = 0;
          Action: string = "DeleteCluster"; SkipFinalClusterSnapshot: bool = false;
          FinalClusterSnapshotIdentifier: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: string (required)
  var query_600749 = newJObject()
  add(query_600749, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(query_600749, "Action", newJString(Action))
  add(query_600749, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_600749, "SkipFinalClusterSnapshot", newJBool(SkipFinalClusterSnapshot))
  add(query_600749, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_600749, "Version", newJString(Version))
  result = call_600748.call(nil, query_600749, nil, nil, nil)

var getDeleteCluster* = Call_GetDeleteCluster_600731(name: "getDeleteCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_GetDeleteCluster_600732,
    base: "/", url: url_GetDeleteCluster_600733,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterParameterGroup_600786 = ref object of OpenApiRestCall_599352
proc url_PostDeleteClusterParameterGroup_600788(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterParameterGroup_600787(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600789 = query.getOrDefault("Action")
  valid_600789 = validateParameter(valid_600789, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_600789 != nil:
    section.add "Action", valid_600789
  var valid_600790 = query.getOrDefault("Version")
  valid_600790 = validateParameter(valid_600790, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600790 != nil:
    section.add "Version", valid_600790
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600791 = header.getOrDefault("X-Amz-Date")
  valid_600791 = validateParameter(valid_600791, JString, required = false,
                                 default = nil)
  if valid_600791 != nil:
    section.add "X-Amz-Date", valid_600791
  var valid_600792 = header.getOrDefault("X-Amz-Security-Token")
  valid_600792 = validateParameter(valid_600792, JString, required = false,
                                 default = nil)
  if valid_600792 != nil:
    section.add "X-Amz-Security-Token", valid_600792
  var valid_600793 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600793 = validateParameter(valid_600793, JString, required = false,
                                 default = nil)
  if valid_600793 != nil:
    section.add "X-Amz-Content-Sha256", valid_600793
  var valid_600794 = header.getOrDefault("X-Amz-Algorithm")
  valid_600794 = validateParameter(valid_600794, JString, required = false,
                                 default = nil)
  if valid_600794 != nil:
    section.add "X-Amz-Algorithm", valid_600794
  var valid_600795 = header.getOrDefault("X-Amz-Signature")
  valid_600795 = validateParameter(valid_600795, JString, required = false,
                                 default = nil)
  if valid_600795 != nil:
    section.add "X-Amz-Signature", valid_600795
  var valid_600796 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600796 = validateParameter(valid_600796, JString, required = false,
                                 default = nil)
  if valid_600796 != nil:
    section.add "X-Amz-SignedHeaders", valid_600796
  var valid_600797 = header.getOrDefault("X-Amz-Credential")
  valid_600797 = validateParameter(valid_600797, JString, required = false,
                                 default = nil)
  if valid_600797 != nil:
    section.add "X-Amz-Credential", valid_600797
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_600798 = formData.getOrDefault("ParameterGroupName")
  valid_600798 = validateParameter(valid_600798, JString, required = true,
                                 default = nil)
  if valid_600798 != nil:
    section.add "ParameterGroupName", valid_600798
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600799: Call_PostDeleteClusterParameterGroup_600786;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_600799.validator(path, query, header, formData, body)
  let scheme = call_600799.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600799.url(scheme.get, call_600799.host, call_600799.base,
                         call_600799.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600799, url, valid)

proc call*(call_600800: Call_PostDeleteClusterParameterGroup_600786;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_600801 = newJObject()
  var formData_600802 = newJObject()
  add(formData_600802, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_600801, "Action", newJString(Action))
  add(query_600801, "Version", newJString(Version))
  result = call_600800.call(nil, query_600801, nil, formData_600802, nil)

var postDeleteClusterParameterGroup* = Call_PostDeleteClusterParameterGroup_600786(
    name: "postDeleteClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_PostDeleteClusterParameterGroup_600787, base: "/",
    url: url_PostDeleteClusterParameterGroup_600788,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterParameterGroup_600770 = ref object of OpenApiRestCall_599352
proc url_GetDeleteClusterParameterGroup_600772(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterParameterGroup_600771(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_600773 = query.getOrDefault("ParameterGroupName")
  valid_600773 = validateParameter(valid_600773, JString, required = true,
                                 default = nil)
  if valid_600773 != nil:
    section.add "ParameterGroupName", valid_600773
  var valid_600774 = query.getOrDefault("Action")
  valid_600774 = validateParameter(valid_600774, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_600774 != nil:
    section.add "Action", valid_600774
  var valid_600775 = query.getOrDefault("Version")
  valid_600775 = validateParameter(valid_600775, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600775 != nil:
    section.add "Version", valid_600775
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600776 = header.getOrDefault("X-Amz-Date")
  valid_600776 = validateParameter(valid_600776, JString, required = false,
                                 default = nil)
  if valid_600776 != nil:
    section.add "X-Amz-Date", valid_600776
  var valid_600777 = header.getOrDefault("X-Amz-Security-Token")
  valid_600777 = validateParameter(valid_600777, JString, required = false,
                                 default = nil)
  if valid_600777 != nil:
    section.add "X-Amz-Security-Token", valid_600777
  var valid_600778 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600778 = validateParameter(valid_600778, JString, required = false,
                                 default = nil)
  if valid_600778 != nil:
    section.add "X-Amz-Content-Sha256", valid_600778
  var valid_600779 = header.getOrDefault("X-Amz-Algorithm")
  valid_600779 = validateParameter(valid_600779, JString, required = false,
                                 default = nil)
  if valid_600779 != nil:
    section.add "X-Amz-Algorithm", valid_600779
  var valid_600780 = header.getOrDefault("X-Amz-Signature")
  valid_600780 = validateParameter(valid_600780, JString, required = false,
                                 default = nil)
  if valid_600780 != nil:
    section.add "X-Amz-Signature", valid_600780
  var valid_600781 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600781 = validateParameter(valid_600781, JString, required = false,
                                 default = nil)
  if valid_600781 != nil:
    section.add "X-Amz-SignedHeaders", valid_600781
  var valid_600782 = header.getOrDefault("X-Amz-Credential")
  valid_600782 = validateParameter(valid_600782, JString, required = false,
                                 default = nil)
  if valid_600782 != nil:
    section.add "X-Amz-Credential", valid_600782
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600783: Call_GetDeleteClusterParameterGroup_600770; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_600783.validator(path, query, header, formData, body)
  let scheme = call_600783.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600783.url(scheme.get, call_600783.host, call_600783.base,
                         call_600783.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600783, url, valid)

proc call*(call_600784: Call_GetDeleteClusterParameterGroup_600770;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_600785 = newJObject()
  add(query_600785, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_600785, "Action", newJString(Action))
  add(query_600785, "Version", newJString(Version))
  result = call_600784.call(nil, query_600785, nil, nil, nil)

var getDeleteClusterParameterGroup* = Call_GetDeleteClusterParameterGroup_600770(
    name: "getDeleteClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_GetDeleteClusterParameterGroup_600771, base: "/",
    url: url_GetDeleteClusterParameterGroup_600772,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSecurityGroup_600819 = ref object of OpenApiRestCall_599352
proc url_PostDeleteClusterSecurityGroup_600821(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSecurityGroup_600820(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600822 = query.getOrDefault("Action")
  valid_600822 = validateParameter(valid_600822, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_600822 != nil:
    section.add "Action", valid_600822
  var valid_600823 = query.getOrDefault("Version")
  valid_600823 = validateParameter(valid_600823, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600823 != nil:
    section.add "Version", valid_600823
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600824 = header.getOrDefault("X-Amz-Date")
  valid_600824 = validateParameter(valid_600824, JString, required = false,
                                 default = nil)
  if valid_600824 != nil:
    section.add "X-Amz-Date", valid_600824
  var valid_600825 = header.getOrDefault("X-Amz-Security-Token")
  valid_600825 = validateParameter(valid_600825, JString, required = false,
                                 default = nil)
  if valid_600825 != nil:
    section.add "X-Amz-Security-Token", valid_600825
  var valid_600826 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600826 = validateParameter(valid_600826, JString, required = false,
                                 default = nil)
  if valid_600826 != nil:
    section.add "X-Amz-Content-Sha256", valid_600826
  var valid_600827 = header.getOrDefault("X-Amz-Algorithm")
  valid_600827 = validateParameter(valid_600827, JString, required = false,
                                 default = nil)
  if valid_600827 != nil:
    section.add "X-Amz-Algorithm", valid_600827
  var valid_600828 = header.getOrDefault("X-Amz-Signature")
  valid_600828 = validateParameter(valid_600828, JString, required = false,
                                 default = nil)
  if valid_600828 != nil:
    section.add "X-Amz-Signature", valid_600828
  var valid_600829 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600829 = validateParameter(valid_600829, JString, required = false,
                                 default = nil)
  if valid_600829 != nil:
    section.add "X-Amz-SignedHeaders", valid_600829
  var valid_600830 = header.getOrDefault("X-Amz-Credential")
  valid_600830 = validateParameter(valid_600830, JString, required = false,
                                 default = nil)
  if valid_600830 != nil:
    section.add "X-Amz-Credential", valid_600830
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_600831 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_600831 = validateParameter(valid_600831, JString, required = true,
                                 default = nil)
  if valid_600831 != nil:
    section.add "ClusterSecurityGroupName", valid_600831
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600832: Call_PostDeleteClusterSecurityGroup_600819; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600832.validator(path, query, header, formData, body)
  let scheme = call_600832.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600832.url(scheme.get, call_600832.host, call_600832.base,
                         call_600832.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600832, url, valid)

proc call*(call_600833: Call_PostDeleteClusterSecurityGroup_600819;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  var query_600834 = newJObject()
  var formData_600835 = newJObject()
  add(query_600834, "Action", newJString(Action))
  add(query_600834, "Version", newJString(Version))
  add(formData_600835, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_600833.call(nil, query_600834, nil, formData_600835, nil)

var postDeleteClusterSecurityGroup* = Call_PostDeleteClusterSecurityGroup_600819(
    name: "postDeleteClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_PostDeleteClusterSecurityGroup_600820, base: "/",
    url: url_PostDeleteClusterSecurityGroup_600821,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSecurityGroup_600803 = ref object of OpenApiRestCall_599352
proc url_GetDeleteClusterSecurityGroup_600805(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSecurityGroup_600804(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_600806 = query.getOrDefault("ClusterSecurityGroupName")
  valid_600806 = validateParameter(valid_600806, JString, required = true,
                                 default = nil)
  if valid_600806 != nil:
    section.add "ClusterSecurityGroupName", valid_600806
  var valid_600807 = query.getOrDefault("Action")
  valid_600807 = validateParameter(valid_600807, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_600807 != nil:
    section.add "Action", valid_600807
  var valid_600808 = query.getOrDefault("Version")
  valid_600808 = validateParameter(valid_600808, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600808 != nil:
    section.add "Version", valid_600808
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600809 = header.getOrDefault("X-Amz-Date")
  valid_600809 = validateParameter(valid_600809, JString, required = false,
                                 default = nil)
  if valid_600809 != nil:
    section.add "X-Amz-Date", valid_600809
  var valid_600810 = header.getOrDefault("X-Amz-Security-Token")
  valid_600810 = validateParameter(valid_600810, JString, required = false,
                                 default = nil)
  if valid_600810 != nil:
    section.add "X-Amz-Security-Token", valid_600810
  var valid_600811 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600811 = validateParameter(valid_600811, JString, required = false,
                                 default = nil)
  if valid_600811 != nil:
    section.add "X-Amz-Content-Sha256", valid_600811
  var valid_600812 = header.getOrDefault("X-Amz-Algorithm")
  valid_600812 = validateParameter(valid_600812, JString, required = false,
                                 default = nil)
  if valid_600812 != nil:
    section.add "X-Amz-Algorithm", valid_600812
  var valid_600813 = header.getOrDefault("X-Amz-Signature")
  valid_600813 = validateParameter(valid_600813, JString, required = false,
                                 default = nil)
  if valid_600813 != nil:
    section.add "X-Amz-Signature", valid_600813
  var valid_600814 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600814 = validateParameter(valid_600814, JString, required = false,
                                 default = nil)
  if valid_600814 != nil:
    section.add "X-Amz-SignedHeaders", valid_600814
  var valid_600815 = header.getOrDefault("X-Amz-Credential")
  valid_600815 = validateParameter(valid_600815, JString, required = false,
                                 default = nil)
  if valid_600815 != nil:
    section.add "X-Amz-Credential", valid_600815
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600816: Call_GetDeleteClusterSecurityGroup_600803; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_600816.validator(path, query, header, formData, body)
  let scheme = call_600816.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600816.url(scheme.get, call_600816.host, call_600816.base,
                         call_600816.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600816, url, valid)

proc call*(call_600817: Call_GetDeleteClusterSecurityGroup_600803;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_600818 = newJObject()
  add(query_600818, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_600818, "Action", newJString(Action))
  add(query_600818, "Version", newJString(Version))
  result = call_600817.call(nil, query_600818, nil, nil, nil)

var getDeleteClusterSecurityGroup* = Call_GetDeleteClusterSecurityGroup_600803(
    name: "getDeleteClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_GetDeleteClusterSecurityGroup_600804, base: "/",
    url: url_GetDeleteClusterSecurityGroup_600805,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSnapshot_600853 = ref object of OpenApiRestCall_599352
proc url_PostDeleteClusterSnapshot_600855(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSnapshot_600854(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600856 = query.getOrDefault("Action")
  valid_600856 = validateParameter(valid_600856, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_600856 != nil:
    section.add "Action", valid_600856
  var valid_600857 = query.getOrDefault("Version")
  valid_600857 = validateParameter(valid_600857, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600857 != nil:
    section.add "Version", valid_600857
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600858 = header.getOrDefault("X-Amz-Date")
  valid_600858 = validateParameter(valid_600858, JString, required = false,
                                 default = nil)
  if valid_600858 != nil:
    section.add "X-Amz-Date", valid_600858
  var valid_600859 = header.getOrDefault("X-Amz-Security-Token")
  valid_600859 = validateParameter(valid_600859, JString, required = false,
                                 default = nil)
  if valid_600859 != nil:
    section.add "X-Amz-Security-Token", valid_600859
  var valid_600860 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600860 = validateParameter(valid_600860, JString, required = false,
                                 default = nil)
  if valid_600860 != nil:
    section.add "X-Amz-Content-Sha256", valid_600860
  var valid_600861 = header.getOrDefault("X-Amz-Algorithm")
  valid_600861 = validateParameter(valid_600861, JString, required = false,
                                 default = nil)
  if valid_600861 != nil:
    section.add "X-Amz-Algorithm", valid_600861
  var valid_600862 = header.getOrDefault("X-Amz-Signature")
  valid_600862 = validateParameter(valid_600862, JString, required = false,
                                 default = nil)
  if valid_600862 != nil:
    section.add "X-Amz-Signature", valid_600862
  var valid_600863 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600863 = validateParameter(valid_600863, JString, required = false,
                                 default = nil)
  if valid_600863 != nil:
    section.add "X-Amz-SignedHeaders", valid_600863
  var valid_600864 = header.getOrDefault("X-Amz-Credential")
  valid_600864 = validateParameter(valid_600864, JString, required = false,
                                 default = nil)
  if valid_600864 != nil:
    section.add "X-Amz-Credential", valid_600864
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  section = newJObject()
  var valid_600865 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_600865 = validateParameter(valid_600865, JString, required = false,
                                 default = nil)
  if valid_600865 != nil:
    section.add "SnapshotClusterIdentifier", valid_600865
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_600866 = formData.getOrDefault("SnapshotIdentifier")
  valid_600866 = validateParameter(valid_600866, JString, required = true,
                                 default = nil)
  if valid_600866 != nil:
    section.add "SnapshotIdentifier", valid_600866
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600867: Call_PostDeleteClusterSnapshot_600853; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_600867.validator(path, query, header, formData, body)
  let scheme = call_600867.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600867.url(scheme.get, call_600867.host, call_600867.base,
                         call_600867.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600867, url, valid)

proc call*(call_600868: Call_PostDeleteClusterSnapshot_600853;
          SnapshotIdentifier: string; SnapshotClusterIdentifier: string = "";
          Action: string = "DeleteClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: string (required)
  var query_600869 = newJObject()
  var formData_600870 = newJObject()
  add(formData_600870, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_600869, "Action", newJString(Action))
  add(formData_600870, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_600869, "Version", newJString(Version))
  result = call_600868.call(nil, query_600869, nil, formData_600870, nil)

var postDeleteClusterSnapshot* = Call_PostDeleteClusterSnapshot_600853(
    name: "postDeleteClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_PostDeleteClusterSnapshot_600854, base: "/",
    url: url_PostDeleteClusterSnapshot_600855,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSnapshot_600836 = ref object of OpenApiRestCall_599352
proc url_GetDeleteClusterSnapshot_600838(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSnapshot_600837(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600839 = query.getOrDefault("Action")
  valid_600839 = validateParameter(valid_600839, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_600839 != nil:
    section.add "Action", valid_600839
  var valid_600840 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_600840 = validateParameter(valid_600840, JString, required = false,
                                 default = nil)
  if valid_600840 != nil:
    section.add "SnapshotClusterIdentifier", valid_600840
  var valid_600841 = query.getOrDefault("SnapshotIdentifier")
  valid_600841 = validateParameter(valid_600841, JString, required = true,
                                 default = nil)
  if valid_600841 != nil:
    section.add "SnapshotIdentifier", valid_600841
  var valid_600842 = query.getOrDefault("Version")
  valid_600842 = validateParameter(valid_600842, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600842 != nil:
    section.add "Version", valid_600842
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600843 = header.getOrDefault("X-Amz-Date")
  valid_600843 = validateParameter(valid_600843, JString, required = false,
                                 default = nil)
  if valid_600843 != nil:
    section.add "X-Amz-Date", valid_600843
  var valid_600844 = header.getOrDefault("X-Amz-Security-Token")
  valid_600844 = validateParameter(valid_600844, JString, required = false,
                                 default = nil)
  if valid_600844 != nil:
    section.add "X-Amz-Security-Token", valid_600844
  var valid_600845 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600845 = validateParameter(valid_600845, JString, required = false,
                                 default = nil)
  if valid_600845 != nil:
    section.add "X-Amz-Content-Sha256", valid_600845
  var valid_600846 = header.getOrDefault("X-Amz-Algorithm")
  valid_600846 = validateParameter(valid_600846, JString, required = false,
                                 default = nil)
  if valid_600846 != nil:
    section.add "X-Amz-Algorithm", valid_600846
  var valid_600847 = header.getOrDefault("X-Amz-Signature")
  valid_600847 = validateParameter(valid_600847, JString, required = false,
                                 default = nil)
  if valid_600847 != nil:
    section.add "X-Amz-Signature", valid_600847
  var valid_600848 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600848 = validateParameter(valid_600848, JString, required = false,
                                 default = nil)
  if valid_600848 != nil:
    section.add "X-Amz-SignedHeaders", valid_600848
  var valid_600849 = header.getOrDefault("X-Amz-Credential")
  valid_600849 = validateParameter(valid_600849, JString, required = false,
                                 default = nil)
  if valid_600849 != nil:
    section.add "X-Amz-Credential", valid_600849
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600850: Call_GetDeleteClusterSnapshot_600836; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_600850.validator(path, query, header, formData, body)
  let scheme = call_600850.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600850.url(scheme.get, call_600850.host, call_600850.base,
                         call_600850.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600850, url, valid)

proc call*(call_600851: Call_GetDeleteClusterSnapshot_600836;
          SnapshotIdentifier: string; Action: string = "DeleteClusterSnapshot";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Version: string (required)
  var query_600852 = newJObject()
  add(query_600852, "Action", newJString(Action))
  add(query_600852, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_600852, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_600852, "Version", newJString(Version))
  result = call_600851.call(nil, query_600852, nil, nil, nil)

var getDeleteClusterSnapshot* = Call_GetDeleteClusterSnapshot_600836(
    name: "getDeleteClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_GetDeleteClusterSnapshot_600837, base: "/",
    url: url_GetDeleteClusterSnapshot_600838, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSubnetGroup_600887 = ref object of OpenApiRestCall_599352
proc url_PostDeleteClusterSubnetGroup_600889(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteClusterSubnetGroup_600888(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600890 = query.getOrDefault("Action")
  valid_600890 = validateParameter(valid_600890, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_600890 != nil:
    section.add "Action", valid_600890
  var valid_600891 = query.getOrDefault("Version")
  valid_600891 = validateParameter(valid_600891, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600891 != nil:
    section.add "Version", valid_600891
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600892 = header.getOrDefault("X-Amz-Date")
  valid_600892 = validateParameter(valid_600892, JString, required = false,
                                 default = nil)
  if valid_600892 != nil:
    section.add "X-Amz-Date", valid_600892
  var valid_600893 = header.getOrDefault("X-Amz-Security-Token")
  valid_600893 = validateParameter(valid_600893, JString, required = false,
                                 default = nil)
  if valid_600893 != nil:
    section.add "X-Amz-Security-Token", valid_600893
  var valid_600894 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600894 = validateParameter(valid_600894, JString, required = false,
                                 default = nil)
  if valid_600894 != nil:
    section.add "X-Amz-Content-Sha256", valid_600894
  var valid_600895 = header.getOrDefault("X-Amz-Algorithm")
  valid_600895 = validateParameter(valid_600895, JString, required = false,
                                 default = nil)
  if valid_600895 != nil:
    section.add "X-Amz-Algorithm", valid_600895
  var valid_600896 = header.getOrDefault("X-Amz-Signature")
  valid_600896 = validateParameter(valid_600896, JString, required = false,
                                 default = nil)
  if valid_600896 != nil:
    section.add "X-Amz-Signature", valid_600896
  var valid_600897 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600897 = validateParameter(valid_600897, JString, required = false,
                                 default = nil)
  if valid_600897 != nil:
    section.add "X-Amz-SignedHeaders", valid_600897
  var valid_600898 = header.getOrDefault("X-Amz-Credential")
  valid_600898 = validateParameter(valid_600898, JString, required = false,
                                 default = nil)
  if valid_600898 != nil:
    section.add "X-Amz-Credential", valid_600898
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_600899 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_600899 = validateParameter(valid_600899, JString, required = true,
                                 default = nil)
  if valid_600899 != nil:
    section.add "ClusterSubnetGroupName", valid_600899
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600900: Call_PostDeleteClusterSubnetGroup_600887; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_600900.validator(path, query, header, formData, body)
  let scheme = call_600900.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600900.url(scheme.get, call_600900.host, call_600900.base,
                         call_600900.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600900, url, valid)

proc call*(call_600901: Call_PostDeleteClusterSubnetGroup_600887;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  var query_600902 = newJObject()
  var formData_600903 = newJObject()
  add(query_600902, "Action", newJString(Action))
  add(query_600902, "Version", newJString(Version))
  add(formData_600903, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_600901.call(nil, query_600902, nil, formData_600903, nil)

var postDeleteClusterSubnetGroup* = Call_PostDeleteClusterSubnetGroup_600887(
    name: "postDeleteClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_PostDeleteClusterSubnetGroup_600888, base: "/",
    url: url_PostDeleteClusterSubnetGroup_600889,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSubnetGroup_600871 = ref object of OpenApiRestCall_599352
proc url_GetDeleteClusterSubnetGroup_600873(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteClusterSubnetGroup_600872(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_600874 = query.getOrDefault("ClusterSubnetGroupName")
  valid_600874 = validateParameter(valid_600874, JString, required = true,
                                 default = nil)
  if valid_600874 != nil:
    section.add "ClusterSubnetGroupName", valid_600874
  var valid_600875 = query.getOrDefault("Action")
  valid_600875 = validateParameter(valid_600875, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_600875 != nil:
    section.add "Action", valid_600875
  var valid_600876 = query.getOrDefault("Version")
  valid_600876 = validateParameter(valid_600876, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600876 != nil:
    section.add "Version", valid_600876
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600877 = header.getOrDefault("X-Amz-Date")
  valid_600877 = validateParameter(valid_600877, JString, required = false,
                                 default = nil)
  if valid_600877 != nil:
    section.add "X-Amz-Date", valid_600877
  var valid_600878 = header.getOrDefault("X-Amz-Security-Token")
  valid_600878 = validateParameter(valid_600878, JString, required = false,
                                 default = nil)
  if valid_600878 != nil:
    section.add "X-Amz-Security-Token", valid_600878
  var valid_600879 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600879 = validateParameter(valid_600879, JString, required = false,
                                 default = nil)
  if valid_600879 != nil:
    section.add "X-Amz-Content-Sha256", valid_600879
  var valid_600880 = header.getOrDefault("X-Amz-Algorithm")
  valid_600880 = validateParameter(valid_600880, JString, required = false,
                                 default = nil)
  if valid_600880 != nil:
    section.add "X-Amz-Algorithm", valid_600880
  var valid_600881 = header.getOrDefault("X-Amz-Signature")
  valid_600881 = validateParameter(valid_600881, JString, required = false,
                                 default = nil)
  if valid_600881 != nil:
    section.add "X-Amz-Signature", valid_600881
  var valid_600882 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600882 = validateParameter(valid_600882, JString, required = false,
                                 default = nil)
  if valid_600882 != nil:
    section.add "X-Amz-SignedHeaders", valid_600882
  var valid_600883 = header.getOrDefault("X-Amz-Credential")
  valid_600883 = validateParameter(valid_600883, JString, required = false,
                                 default = nil)
  if valid_600883 != nil:
    section.add "X-Amz-Credential", valid_600883
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600884: Call_GetDeleteClusterSubnetGroup_600871; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_600884.validator(path, query, header, formData, body)
  let scheme = call_600884.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600884.url(scheme.get, call_600884.host, call_600884.base,
                         call_600884.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600884, url, valid)

proc call*(call_600885: Call_GetDeleteClusterSubnetGroup_600871;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_600886 = newJObject()
  add(query_600886, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_600886, "Action", newJString(Action))
  add(query_600886, "Version", newJString(Version))
  result = call_600885.call(nil, query_600886, nil, nil, nil)

var getDeleteClusterSubnetGroup* = Call_GetDeleteClusterSubnetGroup_600871(
    name: "getDeleteClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_GetDeleteClusterSubnetGroup_600872, base: "/",
    url: url_GetDeleteClusterSubnetGroup_600873,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteEventSubscription_600920 = ref object of OpenApiRestCall_599352
proc url_PostDeleteEventSubscription_600922(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteEventSubscription_600921(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600923 = query.getOrDefault("Action")
  valid_600923 = validateParameter(valid_600923, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_600923 != nil:
    section.add "Action", valid_600923
  var valid_600924 = query.getOrDefault("Version")
  valid_600924 = validateParameter(valid_600924, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600924 != nil:
    section.add "Version", valid_600924
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600925 = header.getOrDefault("X-Amz-Date")
  valid_600925 = validateParameter(valid_600925, JString, required = false,
                                 default = nil)
  if valid_600925 != nil:
    section.add "X-Amz-Date", valid_600925
  var valid_600926 = header.getOrDefault("X-Amz-Security-Token")
  valid_600926 = validateParameter(valid_600926, JString, required = false,
                                 default = nil)
  if valid_600926 != nil:
    section.add "X-Amz-Security-Token", valid_600926
  var valid_600927 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600927 = validateParameter(valid_600927, JString, required = false,
                                 default = nil)
  if valid_600927 != nil:
    section.add "X-Amz-Content-Sha256", valid_600927
  var valid_600928 = header.getOrDefault("X-Amz-Algorithm")
  valid_600928 = validateParameter(valid_600928, JString, required = false,
                                 default = nil)
  if valid_600928 != nil:
    section.add "X-Amz-Algorithm", valid_600928
  var valid_600929 = header.getOrDefault("X-Amz-Signature")
  valid_600929 = validateParameter(valid_600929, JString, required = false,
                                 default = nil)
  if valid_600929 != nil:
    section.add "X-Amz-Signature", valid_600929
  var valid_600930 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600930 = validateParameter(valid_600930, JString, required = false,
                                 default = nil)
  if valid_600930 != nil:
    section.add "X-Amz-SignedHeaders", valid_600930
  var valid_600931 = header.getOrDefault("X-Amz-Credential")
  valid_600931 = validateParameter(valid_600931, JString, required = false,
                                 default = nil)
  if valid_600931 != nil:
    section.add "X-Amz-Credential", valid_600931
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_600932 = formData.getOrDefault("SubscriptionName")
  valid_600932 = validateParameter(valid_600932, JString, required = true,
                                 default = nil)
  if valid_600932 != nil:
    section.add "SubscriptionName", valid_600932
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600933: Call_PostDeleteEventSubscription_600920; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_600933.validator(path, query, header, formData, body)
  let scheme = call_600933.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600933.url(scheme.get, call_600933.host, call_600933.base,
                         call_600933.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600933, url, valid)

proc call*(call_600934: Call_PostDeleteEventSubscription_600920;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_600935 = newJObject()
  var formData_600936 = newJObject()
  add(formData_600936, "SubscriptionName", newJString(SubscriptionName))
  add(query_600935, "Action", newJString(Action))
  add(query_600935, "Version", newJString(Version))
  result = call_600934.call(nil, query_600935, nil, formData_600936, nil)

var postDeleteEventSubscription* = Call_PostDeleteEventSubscription_600920(
    name: "postDeleteEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_PostDeleteEventSubscription_600921, base: "/",
    url: url_PostDeleteEventSubscription_600922,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteEventSubscription_600904 = ref object of OpenApiRestCall_599352
proc url_GetDeleteEventSubscription_600906(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteEventSubscription_600905(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600907 = query.getOrDefault("Action")
  valid_600907 = validateParameter(valid_600907, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_600907 != nil:
    section.add "Action", valid_600907
  var valid_600908 = query.getOrDefault("SubscriptionName")
  valid_600908 = validateParameter(valid_600908, JString, required = true,
                                 default = nil)
  if valid_600908 != nil:
    section.add "SubscriptionName", valid_600908
  var valid_600909 = query.getOrDefault("Version")
  valid_600909 = validateParameter(valid_600909, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600909 != nil:
    section.add "Version", valid_600909
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600910 = header.getOrDefault("X-Amz-Date")
  valid_600910 = validateParameter(valid_600910, JString, required = false,
                                 default = nil)
  if valid_600910 != nil:
    section.add "X-Amz-Date", valid_600910
  var valid_600911 = header.getOrDefault("X-Amz-Security-Token")
  valid_600911 = validateParameter(valid_600911, JString, required = false,
                                 default = nil)
  if valid_600911 != nil:
    section.add "X-Amz-Security-Token", valid_600911
  var valid_600912 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600912 = validateParameter(valid_600912, JString, required = false,
                                 default = nil)
  if valid_600912 != nil:
    section.add "X-Amz-Content-Sha256", valid_600912
  var valid_600913 = header.getOrDefault("X-Amz-Algorithm")
  valid_600913 = validateParameter(valid_600913, JString, required = false,
                                 default = nil)
  if valid_600913 != nil:
    section.add "X-Amz-Algorithm", valid_600913
  var valid_600914 = header.getOrDefault("X-Amz-Signature")
  valid_600914 = validateParameter(valid_600914, JString, required = false,
                                 default = nil)
  if valid_600914 != nil:
    section.add "X-Amz-Signature", valid_600914
  var valid_600915 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600915 = validateParameter(valid_600915, JString, required = false,
                                 default = nil)
  if valid_600915 != nil:
    section.add "X-Amz-SignedHeaders", valid_600915
  var valid_600916 = header.getOrDefault("X-Amz-Credential")
  valid_600916 = validateParameter(valid_600916, JString, required = false,
                                 default = nil)
  if valid_600916 != nil:
    section.add "X-Amz-Credential", valid_600916
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600917: Call_GetDeleteEventSubscription_600904; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_600917.validator(path, query, header, formData, body)
  let scheme = call_600917.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600917.url(scheme.get, call_600917.host, call_600917.base,
                         call_600917.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600917, url, valid)

proc call*(call_600918: Call_GetDeleteEventSubscription_600904;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   Action: string (required)
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Version: string (required)
  var query_600919 = newJObject()
  add(query_600919, "Action", newJString(Action))
  add(query_600919, "SubscriptionName", newJString(SubscriptionName))
  add(query_600919, "Version", newJString(Version))
  result = call_600918.call(nil, query_600919, nil, nil, nil)

var getDeleteEventSubscription* = Call_GetDeleteEventSubscription_600904(
    name: "getDeleteEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_GetDeleteEventSubscription_600905, base: "/",
    url: url_GetDeleteEventSubscription_600906,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmClientCertificate_600953 = ref object of OpenApiRestCall_599352
proc url_PostDeleteHsmClientCertificate_600955(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmClientCertificate_600954(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600956 = query.getOrDefault("Action")
  valid_600956 = validateParameter(valid_600956, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_600956 != nil:
    section.add "Action", valid_600956
  var valid_600957 = query.getOrDefault("Version")
  valid_600957 = validateParameter(valid_600957, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600957 != nil:
    section.add "Version", valid_600957
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600958 = header.getOrDefault("X-Amz-Date")
  valid_600958 = validateParameter(valid_600958, JString, required = false,
                                 default = nil)
  if valid_600958 != nil:
    section.add "X-Amz-Date", valid_600958
  var valid_600959 = header.getOrDefault("X-Amz-Security-Token")
  valid_600959 = validateParameter(valid_600959, JString, required = false,
                                 default = nil)
  if valid_600959 != nil:
    section.add "X-Amz-Security-Token", valid_600959
  var valid_600960 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600960 = validateParameter(valid_600960, JString, required = false,
                                 default = nil)
  if valid_600960 != nil:
    section.add "X-Amz-Content-Sha256", valid_600960
  var valid_600961 = header.getOrDefault("X-Amz-Algorithm")
  valid_600961 = validateParameter(valid_600961, JString, required = false,
                                 default = nil)
  if valid_600961 != nil:
    section.add "X-Amz-Algorithm", valid_600961
  var valid_600962 = header.getOrDefault("X-Amz-Signature")
  valid_600962 = validateParameter(valid_600962, JString, required = false,
                                 default = nil)
  if valid_600962 != nil:
    section.add "X-Amz-Signature", valid_600962
  var valid_600963 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600963 = validateParameter(valid_600963, JString, required = false,
                                 default = nil)
  if valid_600963 != nil:
    section.add "X-Amz-SignedHeaders", valid_600963
  var valid_600964 = header.getOrDefault("X-Amz-Credential")
  valid_600964 = validateParameter(valid_600964, JString, required = false,
                                 default = nil)
  if valid_600964 != nil:
    section.add "X-Amz-Credential", valid_600964
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_600965 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_600965 = validateParameter(valid_600965, JString, required = true,
                                 default = nil)
  if valid_600965 != nil:
    section.add "HsmClientCertificateIdentifier", valid_600965
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600966: Call_PostDeleteHsmClientCertificate_600953; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_600966.validator(path, query, header, formData, body)
  let scheme = call_600966.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600966.url(scheme.get, call_600966.host, call_600966.base,
                         call_600966.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600966, url, valid)

proc call*(call_600967: Call_PostDeleteHsmClientCertificate_600953;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Version: string (required)
  var query_600968 = newJObject()
  var formData_600969 = newJObject()
  add(query_600968, "Action", newJString(Action))
  add(formData_600969, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_600968, "Version", newJString(Version))
  result = call_600967.call(nil, query_600968, nil, formData_600969, nil)

var postDeleteHsmClientCertificate* = Call_PostDeleteHsmClientCertificate_600953(
    name: "postDeleteHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_PostDeleteHsmClientCertificate_600954, base: "/",
    url: url_PostDeleteHsmClientCertificate_600955,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmClientCertificate_600937 = ref object of OpenApiRestCall_599352
proc url_GetDeleteHsmClientCertificate_600939(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmClientCertificate_600938(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_600940 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_600940 = validateParameter(valid_600940, JString, required = true,
                                 default = nil)
  if valid_600940 != nil:
    section.add "HsmClientCertificateIdentifier", valid_600940
  var valid_600941 = query.getOrDefault("Action")
  valid_600941 = validateParameter(valid_600941, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_600941 != nil:
    section.add "Action", valid_600941
  var valid_600942 = query.getOrDefault("Version")
  valid_600942 = validateParameter(valid_600942, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600942 != nil:
    section.add "Version", valid_600942
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600943 = header.getOrDefault("X-Amz-Date")
  valid_600943 = validateParameter(valid_600943, JString, required = false,
                                 default = nil)
  if valid_600943 != nil:
    section.add "X-Amz-Date", valid_600943
  var valid_600944 = header.getOrDefault("X-Amz-Security-Token")
  valid_600944 = validateParameter(valid_600944, JString, required = false,
                                 default = nil)
  if valid_600944 != nil:
    section.add "X-Amz-Security-Token", valid_600944
  var valid_600945 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600945 = validateParameter(valid_600945, JString, required = false,
                                 default = nil)
  if valid_600945 != nil:
    section.add "X-Amz-Content-Sha256", valid_600945
  var valid_600946 = header.getOrDefault("X-Amz-Algorithm")
  valid_600946 = validateParameter(valid_600946, JString, required = false,
                                 default = nil)
  if valid_600946 != nil:
    section.add "X-Amz-Algorithm", valid_600946
  var valid_600947 = header.getOrDefault("X-Amz-Signature")
  valid_600947 = validateParameter(valid_600947, JString, required = false,
                                 default = nil)
  if valid_600947 != nil:
    section.add "X-Amz-Signature", valid_600947
  var valid_600948 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600948 = validateParameter(valid_600948, JString, required = false,
                                 default = nil)
  if valid_600948 != nil:
    section.add "X-Amz-SignedHeaders", valid_600948
  var valid_600949 = header.getOrDefault("X-Amz-Credential")
  valid_600949 = validateParameter(valid_600949, JString, required = false,
                                 default = nil)
  if valid_600949 != nil:
    section.add "X-Amz-Credential", valid_600949
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600950: Call_GetDeleteHsmClientCertificate_600937; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_600950.validator(path, query, header, formData, body)
  let scheme = call_600950.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600950.url(scheme.get, call_600950.host, call_600950.base,
                         call_600950.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600950, url, valid)

proc call*(call_600951: Call_GetDeleteHsmClientCertificate_600937;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_600952 = newJObject()
  add(query_600952, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_600952, "Action", newJString(Action))
  add(query_600952, "Version", newJString(Version))
  result = call_600951.call(nil, query_600952, nil, nil, nil)

var getDeleteHsmClientCertificate* = Call_GetDeleteHsmClientCertificate_600937(
    name: "getDeleteHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_GetDeleteHsmClientCertificate_600938, base: "/",
    url: url_GetDeleteHsmClientCertificate_600939,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmConfiguration_600986 = ref object of OpenApiRestCall_599352
proc url_PostDeleteHsmConfiguration_600988(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteHsmConfiguration_600987(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_600989 = query.getOrDefault("Action")
  valid_600989 = validateParameter(valid_600989, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_600989 != nil:
    section.add "Action", valid_600989
  var valid_600990 = query.getOrDefault("Version")
  valid_600990 = validateParameter(valid_600990, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600990 != nil:
    section.add "Version", valid_600990
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600991 = header.getOrDefault("X-Amz-Date")
  valid_600991 = validateParameter(valid_600991, JString, required = false,
                                 default = nil)
  if valid_600991 != nil:
    section.add "X-Amz-Date", valid_600991
  var valid_600992 = header.getOrDefault("X-Amz-Security-Token")
  valid_600992 = validateParameter(valid_600992, JString, required = false,
                                 default = nil)
  if valid_600992 != nil:
    section.add "X-Amz-Security-Token", valid_600992
  var valid_600993 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600993 = validateParameter(valid_600993, JString, required = false,
                                 default = nil)
  if valid_600993 != nil:
    section.add "X-Amz-Content-Sha256", valid_600993
  var valid_600994 = header.getOrDefault("X-Amz-Algorithm")
  valid_600994 = validateParameter(valid_600994, JString, required = false,
                                 default = nil)
  if valid_600994 != nil:
    section.add "X-Amz-Algorithm", valid_600994
  var valid_600995 = header.getOrDefault("X-Amz-Signature")
  valid_600995 = validateParameter(valid_600995, JString, required = false,
                                 default = nil)
  if valid_600995 != nil:
    section.add "X-Amz-Signature", valid_600995
  var valid_600996 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600996 = validateParameter(valid_600996, JString, required = false,
                                 default = nil)
  if valid_600996 != nil:
    section.add "X-Amz-SignedHeaders", valid_600996
  var valid_600997 = header.getOrDefault("X-Amz-Credential")
  valid_600997 = validateParameter(valid_600997, JString, required = false,
                                 default = nil)
  if valid_600997 != nil:
    section.add "X-Amz-Credential", valid_600997
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_600998 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_600998 = validateParameter(valid_600998, JString, required = true,
                                 default = nil)
  if valid_600998 != nil:
    section.add "HsmConfigurationIdentifier", valid_600998
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600999: Call_PostDeleteHsmConfiguration_600986; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_600999.validator(path, query, header, formData, body)
  let scheme = call_600999.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600999.url(scheme.get, call_600999.host, call_600999.base,
                         call_600999.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600999, url, valid)

proc call*(call_601000: Call_PostDeleteHsmConfiguration_600986;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_601001 = newJObject()
  var formData_601002 = newJObject()
  add(formData_601002, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_601001, "Action", newJString(Action))
  add(query_601001, "Version", newJString(Version))
  result = call_601000.call(nil, query_601001, nil, formData_601002, nil)

var postDeleteHsmConfiguration* = Call_PostDeleteHsmConfiguration_600986(
    name: "postDeleteHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_PostDeleteHsmConfiguration_600987, base: "/",
    url: url_PostDeleteHsmConfiguration_600988,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmConfiguration_600970 = ref object of OpenApiRestCall_599352
proc url_GetDeleteHsmConfiguration_600972(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteHsmConfiguration_600971(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_600973 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_600973 = validateParameter(valid_600973, JString, required = true,
                                 default = nil)
  if valid_600973 != nil:
    section.add "HsmConfigurationIdentifier", valid_600973
  var valid_600974 = query.getOrDefault("Action")
  valid_600974 = validateParameter(valid_600974, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_600974 != nil:
    section.add "Action", valid_600974
  var valid_600975 = query.getOrDefault("Version")
  valid_600975 = validateParameter(valid_600975, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_600975 != nil:
    section.add "Version", valid_600975
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_600976 = header.getOrDefault("X-Amz-Date")
  valid_600976 = validateParameter(valid_600976, JString, required = false,
                                 default = nil)
  if valid_600976 != nil:
    section.add "X-Amz-Date", valid_600976
  var valid_600977 = header.getOrDefault("X-Amz-Security-Token")
  valid_600977 = validateParameter(valid_600977, JString, required = false,
                                 default = nil)
  if valid_600977 != nil:
    section.add "X-Amz-Security-Token", valid_600977
  var valid_600978 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_600978 = validateParameter(valid_600978, JString, required = false,
                                 default = nil)
  if valid_600978 != nil:
    section.add "X-Amz-Content-Sha256", valid_600978
  var valid_600979 = header.getOrDefault("X-Amz-Algorithm")
  valid_600979 = validateParameter(valid_600979, JString, required = false,
                                 default = nil)
  if valid_600979 != nil:
    section.add "X-Amz-Algorithm", valid_600979
  var valid_600980 = header.getOrDefault("X-Amz-Signature")
  valid_600980 = validateParameter(valid_600980, JString, required = false,
                                 default = nil)
  if valid_600980 != nil:
    section.add "X-Amz-Signature", valid_600980
  var valid_600981 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_600981 = validateParameter(valid_600981, JString, required = false,
                                 default = nil)
  if valid_600981 != nil:
    section.add "X-Amz-SignedHeaders", valid_600981
  var valid_600982 = header.getOrDefault("X-Amz-Credential")
  valid_600982 = validateParameter(valid_600982, JString, required = false,
                                 default = nil)
  if valid_600982 != nil:
    section.add "X-Amz-Credential", valid_600982
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_600983: Call_GetDeleteHsmConfiguration_600970; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_600983.validator(path, query, header, formData, body)
  let scheme = call_600983.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_600983.url(scheme.get, call_600983.host, call_600983.base,
                         call_600983.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_600983, url, valid)

proc call*(call_600984: Call_GetDeleteHsmConfiguration_600970;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_600985 = newJObject()
  add(query_600985, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_600985, "Action", newJString(Action))
  add(query_600985, "Version", newJString(Version))
  result = call_600984.call(nil, query_600985, nil, nil, nil)

var getDeleteHsmConfiguration* = Call_GetDeleteHsmConfiguration_600970(
    name: "getDeleteHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_GetDeleteHsmConfiguration_600971, base: "/",
    url: url_GetDeleteHsmConfiguration_600972,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteScheduledAction_601019 = ref object of OpenApiRestCall_599352
proc url_PostDeleteScheduledAction_601021(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteScheduledAction_601020(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601022 = query.getOrDefault("Action")
  valid_601022 = validateParameter(valid_601022, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_601022 != nil:
    section.add "Action", valid_601022
  var valid_601023 = query.getOrDefault("Version")
  valid_601023 = validateParameter(valid_601023, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601023 != nil:
    section.add "Version", valid_601023
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601024 = header.getOrDefault("X-Amz-Date")
  valid_601024 = validateParameter(valid_601024, JString, required = false,
                                 default = nil)
  if valid_601024 != nil:
    section.add "X-Amz-Date", valid_601024
  var valid_601025 = header.getOrDefault("X-Amz-Security-Token")
  valid_601025 = validateParameter(valid_601025, JString, required = false,
                                 default = nil)
  if valid_601025 != nil:
    section.add "X-Amz-Security-Token", valid_601025
  var valid_601026 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601026 = validateParameter(valid_601026, JString, required = false,
                                 default = nil)
  if valid_601026 != nil:
    section.add "X-Amz-Content-Sha256", valid_601026
  var valid_601027 = header.getOrDefault("X-Amz-Algorithm")
  valid_601027 = validateParameter(valid_601027, JString, required = false,
                                 default = nil)
  if valid_601027 != nil:
    section.add "X-Amz-Algorithm", valid_601027
  var valid_601028 = header.getOrDefault("X-Amz-Signature")
  valid_601028 = validateParameter(valid_601028, JString, required = false,
                                 default = nil)
  if valid_601028 != nil:
    section.add "X-Amz-Signature", valid_601028
  var valid_601029 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601029 = validateParameter(valid_601029, JString, required = false,
                                 default = nil)
  if valid_601029 != nil:
    section.add "X-Amz-SignedHeaders", valid_601029
  var valid_601030 = header.getOrDefault("X-Amz-Credential")
  valid_601030 = validateParameter(valid_601030, JString, required = false,
                                 default = nil)
  if valid_601030 != nil:
    section.add "X-Amz-Credential", valid_601030
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_601031 = formData.getOrDefault("ScheduledActionName")
  valid_601031 = validateParameter(valid_601031, JString, required = true,
                                 default = nil)
  if valid_601031 != nil:
    section.add "ScheduledActionName", valid_601031
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601032: Call_PostDeleteScheduledAction_601019; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_601032.validator(path, query, header, formData, body)
  let scheme = call_601032.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601032.url(scheme.get, call_601032.host, call_601032.base,
                         call_601032.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601032, url, valid)

proc call*(call_601033: Call_PostDeleteScheduledAction_601019;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   Action: string (required)
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Version: string (required)
  var query_601034 = newJObject()
  var formData_601035 = newJObject()
  add(query_601034, "Action", newJString(Action))
  add(formData_601035, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_601034, "Version", newJString(Version))
  result = call_601033.call(nil, query_601034, nil, formData_601035, nil)

var postDeleteScheduledAction* = Call_PostDeleteScheduledAction_601019(
    name: "postDeleteScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_PostDeleteScheduledAction_601020, base: "/",
    url: url_PostDeleteScheduledAction_601021,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteScheduledAction_601003 = ref object of OpenApiRestCall_599352
proc url_GetDeleteScheduledAction_601005(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteScheduledAction_601004(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_601006 = query.getOrDefault("ScheduledActionName")
  valid_601006 = validateParameter(valid_601006, JString, required = true,
                                 default = nil)
  if valid_601006 != nil:
    section.add "ScheduledActionName", valid_601006
  var valid_601007 = query.getOrDefault("Action")
  valid_601007 = validateParameter(valid_601007, JString, required = true,
                                 default = newJString("DeleteScheduledAction"))
  if valid_601007 != nil:
    section.add "Action", valid_601007
  var valid_601008 = query.getOrDefault("Version")
  valid_601008 = validateParameter(valid_601008, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601008 != nil:
    section.add "Version", valid_601008
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601009 = header.getOrDefault("X-Amz-Date")
  valid_601009 = validateParameter(valid_601009, JString, required = false,
                                 default = nil)
  if valid_601009 != nil:
    section.add "X-Amz-Date", valid_601009
  var valid_601010 = header.getOrDefault("X-Amz-Security-Token")
  valid_601010 = validateParameter(valid_601010, JString, required = false,
                                 default = nil)
  if valid_601010 != nil:
    section.add "X-Amz-Security-Token", valid_601010
  var valid_601011 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601011 = validateParameter(valid_601011, JString, required = false,
                                 default = nil)
  if valid_601011 != nil:
    section.add "X-Amz-Content-Sha256", valid_601011
  var valid_601012 = header.getOrDefault("X-Amz-Algorithm")
  valid_601012 = validateParameter(valid_601012, JString, required = false,
                                 default = nil)
  if valid_601012 != nil:
    section.add "X-Amz-Algorithm", valid_601012
  var valid_601013 = header.getOrDefault("X-Amz-Signature")
  valid_601013 = validateParameter(valid_601013, JString, required = false,
                                 default = nil)
  if valid_601013 != nil:
    section.add "X-Amz-Signature", valid_601013
  var valid_601014 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601014 = validateParameter(valid_601014, JString, required = false,
                                 default = nil)
  if valid_601014 != nil:
    section.add "X-Amz-SignedHeaders", valid_601014
  var valid_601015 = header.getOrDefault("X-Amz-Credential")
  valid_601015 = validateParameter(valid_601015, JString, required = false,
                                 default = nil)
  if valid_601015 != nil:
    section.add "X-Amz-Credential", valid_601015
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601016: Call_GetDeleteScheduledAction_601003; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a scheduled action. 
  ## 
  let valid = call_601016.validator(path, query, header, formData, body)
  let scheme = call_601016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601016.url(scheme.get, call_601016.host, call_601016.base,
                         call_601016.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601016, url, valid)

proc call*(call_601017: Call_GetDeleteScheduledAction_601003;
          ScheduledActionName: string; Action: string = "DeleteScheduledAction";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteScheduledAction
  ## Deletes a scheduled action. 
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to delete. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_601018 = newJObject()
  add(query_601018, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_601018, "Action", newJString(Action))
  add(query_601018, "Version", newJString(Version))
  result = call_601017.call(nil, query_601018, nil, nil, nil)

var getDeleteScheduledAction* = Call_GetDeleteScheduledAction_601003(
    name: "getDeleteScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteScheduledAction",
    validator: validate_GetDeleteScheduledAction_601004, base: "/",
    url: url_GetDeleteScheduledAction_601005, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotCopyGrant_601052 = ref object of OpenApiRestCall_599352
proc url_PostDeleteSnapshotCopyGrant_601054(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotCopyGrant_601053(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601055 = query.getOrDefault("Action")
  valid_601055 = validateParameter(valid_601055, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_601055 != nil:
    section.add "Action", valid_601055
  var valid_601056 = query.getOrDefault("Version")
  valid_601056 = validateParameter(valid_601056, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601056 != nil:
    section.add "Version", valid_601056
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601057 = header.getOrDefault("X-Amz-Date")
  valid_601057 = validateParameter(valid_601057, JString, required = false,
                                 default = nil)
  if valid_601057 != nil:
    section.add "X-Amz-Date", valid_601057
  var valid_601058 = header.getOrDefault("X-Amz-Security-Token")
  valid_601058 = validateParameter(valid_601058, JString, required = false,
                                 default = nil)
  if valid_601058 != nil:
    section.add "X-Amz-Security-Token", valid_601058
  var valid_601059 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601059 = validateParameter(valid_601059, JString, required = false,
                                 default = nil)
  if valid_601059 != nil:
    section.add "X-Amz-Content-Sha256", valid_601059
  var valid_601060 = header.getOrDefault("X-Amz-Algorithm")
  valid_601060 = validateParameter(valid_601060, JString, required = false,
                                 default = nil)
  if valid_601060 != nil:
    section.add "X-Amz-Algorithm", valid_601060
  var valid_601061 = header.getOrDefault("X-Amz-Signature")
  valid_601061 = validateParameter(valid_601061, JString, required = false,
                                 default = nil)
  if valid_601061 != nil:
    section.add "X-Amz-Signature", valid_601061
  var valid_601062 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601062 = validateParameter(valid_601062, JString, required = false,
                                 default = nil)
  if valid_601062 != nil:
    section.add "X-Amz-SignedHeaders", valid_601062
  var valid_601063 = header.getOrDefault("X-Amz-Credential")
  valid_601063 = validateParameter(valid_601063, JString, required = false,
                                 default = nil)
  if valid_601063 != nil:
    section.add "X-Amz-Credential", valid_601063
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_601064 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_601064 = validateParameter(valid_601064, JString, required = true,
                                 default = nil)
  if valid_601064 != nil:
    section.add "SnapshotCopyGrantName", valid_601064
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601065: Call_PostDeleteSnapshotCopyGrant_601052; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_601065.validator(path, query, header, formData, body)
  let scheme = call_601065.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601065.url(scheme.get, call_601065.host, call_601065.base,
                         call_601065.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601065, url, valid)

proc call*(call_601066: Call_PostDeleteSnapshotCopyGrant_601052;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_601067 = newJObject()
  var formData_601068 = newJObject()
  add(query_601067, "Action", newJString(Action))
  add(formData_601068, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_601067, "Version", newJString(Version))
  result = call_601066.call(nil, query_601067, nil, formData_601068, nil)

var postDeleteSnapshotCopyGrant* = Call_PostDeleteSnapshotCopyGrant_601052(
    name: "postDeleteSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_PostDeleteSnapshotCopyGrant_601053, base: "/",
    url: url_PostDeleteSnapshotCopyGrant_601054,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotCopyGrant_601036 = ref object of OpenApiRestCall_599352
proc url_GetDeleteSnapshotCopyGrant_601038(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotCopyGrant_601037(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601039 = query.getOrDefault("Action")
  valid_601039 = validateParameter(valid_601039, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_601039 != nil:
    section.add "Action", valid_601039
  var valid_601040 = query.getOrDefault("SnapshotCopyGrantName")
  valid_601040 = validateParameter(valid_601040, JString, required = true,
                                 default = nil)
  if valid_601040 != nil:
    section.add "SnapshotCopyGrantName", valid_601040
  var valid_601041 = query.getOrDefault("Version")
  valid_601041 = validateParameter(valid_601041, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601041 != nil:
    section.add "Version", valid_601041
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601042 = header.getOrDefault("X-Amz-Date")
  valid_601042 = validateParameter(valid_601042, JString, required = false,
                                 default = nil)
  if valid_601042 != nil:
    section.add "X-Amz-Date", valid_601042
  var valid_601043 = header.getOrDefault("X-Amz-Security-Token")
  valid_601043 = validateParameter(valid_601043, JString, required = false,
                                 default = nil)
  if valid_601043 != nil:
    section.add "X-Amz-Security-Token", valid_601043
  var valid_601044 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601044 = validateParameter(valid_601044, JString, required = false,
                                 default = nil)
  if valid_601044 != nil:
    section.add "X-Amz-Content-Sha256", valid_601044
  var valid_601045 = header.getOrDefault("X-Amz-Algorithm")
  valid_601045 = validateParameter(valid_601045, JString, required = false,
                                 default = nil)
  if valid_601045 != nil:
    section.add "X-Amz-Algorithm", valid_601045
  var valid_601046 = header.getOrDefault("X-Amz-Signature")
  valid_601046 = validateParameter(valid_601046, JString, required = false,
                                 default = nil)
  if valid_601046 != nil:
    section.add "X-Amz-Signature", valid_601046
  var valid_601047 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601047 = validateParameter(valid_601047, JString, required = false,
                                 default = nil)
  if valid_601047 != nil:
    section.add "X-Amz-SignedHeaders", valid_601047
  var valid_601048 = header.getOrDefault("X-Amz-Credential")
  valid_601048 = validateParameter(valid_601048, JString, required = false,
                                 default = nil)
  if valid_601048 != nil:
    section.add "X-Amz-Credential", valid_601048
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601049: Call_GetDeleteSnapshotCopyGrant_601036; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_601049.validator(path, query, header, formData, body)
  let scheme = call_601049.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601049.url(scheme.get, call_601049.host, call_601049.base,
                         call_601049.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601049, url, valid)

proc call*(call_601050: Call_GetDeleteSnapshotCopyGrant_601036;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_601051 = newJObject()
  add(query_601051, "Action", newJString(Action))
  add(query_601051, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_601051, "Version", newJString(Version))
  result = call_601050.call(nil, query_601051, nil, nil, nil)

var getDeleteSnapshotCopyGrant* = Call_GetDeleteSnapshotCopyGrant_601036(
    name: "getDeleteSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_GetDeleteSnapshotCopyGrant_601037, base: "/",
    url: url_GetDeleteSnapshotCopyGrant_601038,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotSchedule_601085 = ref object of OpenApiRestCall_599352
proc url_PostDeleteSnapshotSchedule_601087(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteSnapshotSchedule_601086(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601088 = query.getOrDefault("Action")
  valid_601088 = validateParameter(valid_601088, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_601088 != nil:
    section.add "Action", valid_601088
  var valid_601089 = query.getOrDefault("Version")
  valid_601089 = validateParameter(valid_601089, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601089 != nil:
    section.add "Version", valid_601089
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601090 = header.getOrDefault("X-Amz-Date")
  valid_601090 = validateParameter(valid_601090, JString, required = false,
                                 default = nil)
  if valid_601090 != nil:
    section.add "X-Amz-Date", valid_601090
  var valid_601091 = header.getOrDefault("X-Amz-Security-Token")
  valid_601091 = validateParameter(valid_601091, JString, required = false,
                                 default = nil)
  if valid_601091 != nil:
    section.add "X-Amz-Security-Token", valid_601091
  var valid_601092 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601092 = validateParameter(valid_601092, JString, required = false,
                                 default = nil)
  if valid_601092 != nil:
    section.add "X-Amz-Content-Sha256", valid_601092
  var valid_601093 = header.getOrDefault("X-Amz-Algorithm")
  valid_601093 = validateParameter(valid_601093, JString, required = false,
                                 default = nil)
  if valid_601093 != nil:
    section.add "X-Amz-Algorithm", valid_601093
  var valid_601094 = header.getOrDefault("X-Amz-Signature")
  valid_601094 = validateParameter(valid_601094, JString, required = false,
                                 default = nil)
  if valid_601094 != nil:
    section.add "X-Amz-Signature", valid_601094
  var valid_601095 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601095 = validateParameter(valid_601095, JString, required = false,
                                 default = nil)
  if valid_601095 != nil:
    section.add "X-Amz-SignedHeaders", valid_601095
  var valid_601096 = header.getOrDefault("X-Amz-Credential")
  valid_601096 = validateParameter(valid_601096, JString, required = false,
                                 default = nil)
  if valid_601096 != nil:
    section.add "X-Amz-Credential", valid_601096
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleIdentifier` field"
  var valid_601097 = formData.getOrDefault("ScheduleIdentifier")
  valid_601097 = validateParameter(valid_601097, JString, required = true,
                                 default = nil)
  if valid_601097 != nil:
    section.add "ScheduleIdentifier", valid_601097
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601098: Call_PostDeleteSnapshotSchedule_601085; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_601098.validator(path, query, header, formData, body)
  let scheme = call_601098.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601098.url(scheme.get, call_601098.host, call_601098.base,
                         call_601098.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601098, url, valid)

proc call*(call_601099: Call_PostDeleteSnapshotSchedule_601085;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_601100 = newJObject()
  var formData_601101 = newJObject()
  add(query_601100, "Action", newJString(Action))
  add(formData_601101, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_601100, "Version", newJString(Version))
  result = call_601099.call(nil, query_601100, nil, formData_601101, nil)

var postDeleteSnapshotSchedule* = Call_PostDeleteSnapshotSchedule_601085(
    name: "postDeleteSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_PostDeleteSnapshotSchedule_601086, base: "/",
    url: url_PostDeleteSnapshotSchedule_601087,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotSchedule_601069 = ref object of OpenApiRestCall_599352
proc url_GetDeleteSnapshotSchedule_601071(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteSnapshotSchedule_601070(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601072 = query.getOrDefault("Action")
  valid_601072 = validateParameter(valid_601072, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_601072 != nil:
    section.add "Action", valid_601072
  var valid_601073 = query.getOrDefault("ScheduleIdentifier")
  valid_601073 = validateParameter(valid_601073, JString, required = true,
                                 default = nil)
  if valid_601073 != nil:
    section.add "ScheduleIdentifier", valid_601073
  var valid_601074 = query.getOrDefault("Version")
  valid_601074 = validateParameter(valid_601074, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601074 != nil:
    section.add "Version", valid_601074
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601075 = header.getOrDefault("X-Amz-Date")
  valid_601075 = validateParameter(valid_601075, JString, required = false,
                                 default = nil)
  if valid_601075 != nil:
    section.add "X-Amz-Date", valid_601075
  var valid_601076 = header.getOrDefault("X-Amz-Security-Token")
  valid_601076 = validateParameter(valid_601076, JString, required = false,
                                 default = nil)
  if valid_601076 != nil:
    section.add "X-Amz-Security-Token", valid_601076
  var valid_601077 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601077 = validateParameter(valid_601077, JString, required = false,
                                 default = nil)
  if valid_601077 != nil:
    section.add "X-Amz-Content-Sha256", valid_601077
  var valid_601078 = header.getOrDefault("X-Amz-Algorithm")
  valid_601078 = validateParameter(valid_601078, JString, required = false,
                                 default = nil)
  if valid_601078 != nil:
    section.add "X-Amz-Algorithm", valid_601078
  var valid_601079 = header.getOrDefault("X-Amz-Signature")
  valid_601079 = validateParameter(valid_601079, JString, required = false,
                                 default = nil)
  if valid_601079 != nil:
    section.add "X-Amz-Signature", valid_601079
  var valid_601080 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601080 = validateParameter(valid_601080, JString, required = false,
                                 default = nil)
  if valid_601080 != nil:
    section.add "X-Amz-SignedHeaders", valid_601080
  var valid_601081 = header.getOrDefault("X-Amz-Credential")
  valid_601081 = validateParameter(valid_601081, JString, required = false,
                                 default = nil)
  if valid_601081 != nil:
    section.add "X-Amz-Credential", valid_601081
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601082: Call_GetDeleteSnapshotSchedule_601069; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_601082.validator(path, query, header, formData, body)
  let scheme = call_601082.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601082.url(scheme.get, call_601082.host, call_601082.base,
                         call_601082.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601082, url, valid)

proc call*(call_601083: Call_GetDeleteSnapshotSchedule_601069;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_601084 = newJObject()
  add(query_601084, "Action", newJString(Action))
  add(query_601084, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_601084, "Version", newJString(Version))
  result = call_601083.call(nil, query_601084, nil, nil, nil)

var getDeleteSnapshotSchedule* = Call_GetDeleteSnapshotSchedule_601069(
    name: "getDeleteSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_GetDeleteSnapshotSchedule_601070, base: "/",
    url: url_GetDeleteSnapshotSchedule_601071,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteTags_601119 = ref object of OpenApiRestCall_599352
proc url_PostDeleteTags_601121(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDeleteTags_601120(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601122 = query.getOrDefault("Action")
  valid_601122 = validateParameter(valid_601122, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_601122 != nil:
    section.add "Action", valid_601122
  var valid_601123 = query.getOrDefault("Version")
  valid_601123 = validateParameter(valid_601123, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601123 != nil:
    section.add "Version", valid_601123
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601124 = header.getOrDefault("X-Amz-Date")
  valid_601124 = validateParameter(valid_601124, JString, required = false,
                                 default = nil)
  if valid_601124 != nil:
    section.add "X-Amz-Date", valid_601124
  var valid_601125 = header.getOrDefault("X-Amz-Security-Token")
  valid_601125 = validateParameter(valid_601125, JString, required = false,
                                 default = nil)
  if valid_601125 != nil:
    section.add "X-Amz-Security-Token", valid_601125
  var valid_601126 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601126 = validateParameter(valid_601126, JString, required = false,
                                 default = nil)
  if valid_601126 != nil:
    section.add "X-Amz-Content-Sha256", valid_601126
  var valid_601127 = header.getOrDefault("X-Amz-Algorithm")
  valid_601127 = validateParameter(valid_601127, JString, required = false,
                                 default = nil)
  if valid_601127 != nil:
    section.add "X-Amz-Algorithm", valid_601127
  var valid_601128 = header.getOrDefault("X-Amz-Signature")
  valid_601128 = validateParameter(valid_601128, JString, required = false,
                                 default = nil)
  if valid_601128 != nil:
    section.add "X-Amz-Signature", valid_601128
  var valid_601129 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601129 = validateParameter(valid_601129, JString, required = false,
                                 default = nil)
  if valid_601129 != nil:
    section.add "X-Amz-SignedHeaders", valid_601129
  var valid_601130 = header.getOrDefault("X-Amz-Credential")
  valid_601130 = validateParameter(valid_601130, JString, required = false,
                                 default = nil)
  if valid_601130 != nil:
    section.add "X-Amz-Credential", valid_601130
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `TagKeys` field"
  var valid_601131 = formData.getOrDefault("TagKeys")
  valid_601131 = validateParameter(valid_601131, JArray, required = true, default = nil)
  if valid_601131 != nil:
    section.add "TagKeys", valid_601131
  var valid_601132 = formData.getOrDefault("ResourceName")
  valid_601132 = validateParameter(valid_601132, JString, required = true,
                                 default = nil)
  if valid_601132 != nil:
    section.add "ResourceName", valid_601132
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601133: Call_PostDeleteTags_601119; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_601133.validator(path, query, header, formData, body)
  let scheme = call_601133.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601133.url(scheme.get, call_601133.host, call_601133.base,
                         call_601133.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601133, url, valid)

proc call*(call_601134: Call_PostDeleteTags_601119; TagKeys: JsonNode;
          ResourceName: string; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   Action: string (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Version: string (required)
  var query_601135 = newJObject()
  var formData_601136 = newJObject()
  add(query_601135, "Action", newJString(Action))
  if TagKeys != nil:
    formData_601136.add "TagKeys", TagKeys
  add(formData_601136, "ResourceName", newJString(ResourceName))
  add(query_601135, "Version", newJString(Version))
  result = call_601134.call(nil, query_601135, nil, formData_601136, nil)

var postDeleteTags* = Call_PostDeleteTags_601119(name: "postDeleteTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_PostDeleteTags_601120,
    base: "/", url: url_PostDeleteTags_601121, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteTags_601102 = ref object of OpenApiRestCall_599352
proc url_GetDeleteTags_601104(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDeleteTags_601103(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `ResourceName` field"
  var valid_601105 = query.getOrDefault("ResourceName")
  valid_601105 = validateParameter(valid_601105, JString, required = true,
                                 default = nil)
  if valid_601105 != nil:
    section.add "ResourceName", valid_601105
  var valid_601106 = query.getOrDefault("Action")
  valid_601106 = validateParameter(valid_601106, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_601106 != nil:
    section.add "Action", valid_601106
  var valid_601107 = query.getOrDefault("TagKeys")
  valid_601107 = validateParameter(valid_601107, JArray, required = true, default = nil)
  if valid_601107 != nil:
    section.add "TagKeys", valid_601107
  var valid_601108 = query.getOrDefault("Version")
  valid_601108 = validateParameter(valid_601108, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601108 != nil:
    section.add "Version", valid_601108
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601109 = header.getOrDefault("X-Amz-Date")
  valid_601109 = validateParameter(valid_601109, JString, required = false,
                                 default = nil)
  if valid_601109 != nil:
    section.add "X-Amz-Date", valid_601109
  var valid_601110 = header.getOrDefault("X-Amz-Security-Token")
  valid_601110 = validateParameter(valid_601110, JString, required = false,
                                 default = nil)
  if valid_601110 != nil:
    section.add "X-Amz-Security-Token", valid_601110
  var valid_601111 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601111 = validateParameter(valid_601111, JString, required = false,
                                 default = nil)
  if valid_601111 != nil:
    section.add "X-Amz-Content-Sha256", valid_601111
  var valid_601112 = header.getOrDefault("X-Amz-Algorithm")
  valid_601112 = validateParameter(valid_601112, JString, required = false,
                                 default = nil)
  if valid_601112 != nil:
    section.add "X-Amz-Algorithm", valid_601112
  var valid_601113 = header.getOrDefault("X-Amz-Signature")
  valid_601113 = validateParameter(valid_601113, JString, required = false,
                                 default = nil)
  if valid_601113 != nil:
    section.add "X-Amz-Signature", valid_601113
  var valid_601114 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601114 = validateParameter(valid_601114, JString, required = false,
                                 default = nil)
  if valid_601114 != nil:
    section.add "X-Amz-SignedHeaders", valid_601114
  var valid_601115 = header.getOrDefault("X-Amz-Credential")
  valid_601115 = validateParameter(valid_601115, JString, required = false,
                                 default = nil)
  if valid_601115 != nil:
    section.add "X-Amz-Credential", valid_601115
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601116: Call_GetDeleteTags_601102; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_601116.validator(path, query, header, formData, body)
  let scheme = call_601116.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601116.url(scheme.get, call_601116.host, call_601116.base,
                         call_601116.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601116, url, valid)

proc call*(call_601117: Call_GetDeleteTags_601102; ResourceName: string;
          TagKeys: JsonNode; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Version: string (required)
  var query_601118 = newJObject()
  add(query_601118, "ResourceName", newJString(ResourceName))
  add(query_601118, "Action", newJString(Action))
  if TagKeys != nil:
    query_601118.add "TagKeys", TagKeys
  add(query_601118, "Version", newJString(Version))
  result = call_601117.call(nil, query_601118, nil, nil, nil)

var getDeleteTags* = Call_GetDeleteTags_601102(name: "getDeleteTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_GetDeleteTags_601103,
    base: "/", url: url_GetDeleteTags_601104, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeAccountAttributes_601153 = ref object of OpenApiRestCall_599352
proc url_PostDescribeAccountAttributes_601155(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeAccountAttributes_601154(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601156 = query.getOrDefault("Action")
  valid_601156 = validateParameter(valid_601156, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_601156 != nil:
    section.add "Action", valid_601156
  var valid_601157 = query.getOrDefault("Version")
  valid_601157 = validateParameter(valid_601157, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601157 != nil:
    section.add "Version", valid_601157
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601158 = header.getOrDefault("X-Amz-Date")
  valid_601158 = validateParameter(valid_601158, JString, required = false,
                                 default = nil)
  if valid_601158 != nil:
    section.add "X-Amz-Date", valid_601158
  var valid_601159 = header.getOrDefault("X-Amz-Security-Token")
  valid_601159 = validateParameter(valid_601159, JString, required = false,
                                 default = nil)
  if valid_601159 != nil:
    section.add "X-Amz-Security-Token", valid_601159
  var valid_601160 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601160 = validateParameter(valid_601160, JString, required = false,
                                 default = nil)
  if valid_601160 != nil:
    section.add "X-Amz-Content-Sha256", valid_601160
  var valid_601161 = header.getOrDefault("X-Amz-Algorithm")
  valid_601161 = validateParameter(valid_601161, JString, required = false,
                                 default = nil)
  if valid_601161 != nil:
    section.add "X-Amz-Algorithm", valid_601161
  var valid_601162 = header.getOrDefault("X-Amz-Signature")
  valid_601162 = validateParameter(valid_601162, JString, required = false,
                                 default = nil)
  if valid_601162 != nil:
    section.add "X-Amz-Signature", valid_601162
  var valid_601163 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601163 = validateParameter(valid_601163, JString, required = false,
                                 default = nil)
  if valid_601163 != nil:
    section.add "X-Amz-SignedHeaders", valid_601163
  var valid_601164 = header.getOrDefault("X-Amz-Credential")
  valid_601164 = validateParameter(valid_601164, JString, required = false,
                                 default = nil)
  if valid_601164 != nil:
    section.add "X-Amz-Credential", valid_601164
  result.add "header", section
  ## parameters in `formData` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  section = newJObject()
  var valid_601165 = formData.getOrDefault("AttributeNames")
  valid_601165 = validateParameter(valid_601165, JArray, required = false,
                                 default = nil)
  if valid_601165 != nil:
    section.add "AttributeNames", valid_601165
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601166: Call_PostDescribeAccountAttributes_601153; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_601166.validator(path, query, header, formData, body)
  let scheme = call_601166.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601166.url(scheme.get, call_601166.host, call_601166.base,
                         call_601166.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601166, url, valid)

proc call*(call_601167: Call_PostDescribeAccountAttributes_601153;
          Action: string = "DescribeAccountAttributes";
          AttributeNames: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   Action: string (required)
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Version: string (required)
  var query_601168 = newJObject()
  var formData_601169 = newJObject()
  add(query_601168, "Action", newJString(Action))
  if AttributeNames != nil:
    formData_601169.add "AttributeNames", AttributeNames
  add(query_601168, "Version", newJString(Version))
  result = call_601167.call(nil, query_601168, nil, formData_601169, nil)

var postDescribeAccountAttributes* = Call_PostDescribeAccountAttributes_601153(
    name: "postDescribeAccountAttributes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_PostDescribeAccountAttributes_601154, base: "/",
    url: url_PostDescribeAccountAttributes_601155,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeAccountAttributes_601137 = ref object of OpenApiRestCall_599352
proc url_GetDescribeAccountAttributes_601139(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeAccountAttributes_601138(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_601140 = query.getOrDefault("AttributeNames")
  valid_601140 = validateParameter(valid_601140, JArray, required = false,
                                 default = nil)
  if valid_601140 != nil:
    section.add "AttributeNames", valid_601140
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601141 = query.getOrDefault("Action")
  valid_601141 = validateParameter(valid_601141, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_601141 != nil:
    section.add "Action", valid_601141
  var valid_601142 = query.getOrDefault("Version")
  valid_601142 = validateParameter(valid_601142, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601142 != nil:
    section.add "Version", valid_601142
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601143 = header.getOrDefault("X-Amz-Date")
  valid_601143 = validateParameter(valid_601143, JString, required = false,
                                 default = nil)
  if valid_601143 != nil:
    section.add "X-Amz-Date", valid_601143
  var valid_601144 = header.getOrDefault("X-Amz-Security-Token")
  valid_601144 = validateParameter(valid_601144, JString, required = false,
                                 default = nil)
  if valid_601144 != nil:
    section.add "X-Amz-Security-Token", valid_601144
  var valid_601145 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601145 = validateParameter(valid_601145, JString, required = false,
                                 default = nil)
  if valid_601145 != nil:
    section.add "X-Amz-Content-Sha256", valid_601145
  var valid_601146 = header.getOrDefault("X-Amz-Algorithm")
  valid_601146 = validateParameter(valid_601146, JString, required = false,
                                 default = nil)
  if valid_601146 != nil:
    section.add "X-Amz-Algorithm", valid_601146
  var valid_601147 = header.getOrDefault("X-Amz-Signature")
  valid_601147 = validateParameter(valid_601147, JString, required = false,
                                 default = nil)
  if valid_601147 != nil:
    section.add "X-Amz-Signature", valid_601147
  var valid_601148 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601148 = validateParameter(valid_601148, JString, required = false,
                                 default = nil)
  if valid_601148 != nil:
    section.add "X-Amz-SignedHeaders", valid_601148
  var valid_601149 = header.getOrDefault("X-Amz-Credential")
  valid_601149 = validateParameter(valid_601149, JString, required = false,
                                 default = nil)
  if valid_601149 != nil:
    section.add "X-Amz-Credential", valid_601149
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601150: Call_GetDescribeAccountAttributes_601137; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_601150.validator(path, query, header, formData, body)
  let scheme = call_601150.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601150.url(scheme.get, call_601150.host, call_601150.base,
                         call_601150.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601150, url, valid)

proc call*(call_601151: Call_GetDescribeAccountAttributes_601137;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_601152 = newJObject()
  if AttributeNames != nil:
    query_601152.add "AttributeNames", AttributeNames
  add(query_601152, "Action", newJString(Action))
  add(query_601152, "Version", newJString(Version))
  result = call_601151.call(nil, query_601152, nil, nil, nil)

var getDescribeAccountAttributes* = Call_GetDescribeAccountAttributes_601137(
    name: "getDescribeAccountAttributes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_GetDescribeAccountAttributes_601138, base: "/",
    url: url_GetDescribeAccountAttributes_601139,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterDbRevisions_601188 = ref object of OpenApiRestCall_599352
proc url_PostDescribeClusterDbRevisions_601190(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterDbRevisions_601189(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601191 = query.getOrDefault("Action")
  valid_601191 = validateParameter(valid_601191, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_601191 != nil:
    section.add "Action", valid_601191
  var valid_601192 = query.getOrDefault("Version")
  valid_601192 = validateParameter(valid_601192, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601192 != nil:
    section.add "Version", valid_601192
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601193 = header.getOrDefault("X-Amz-Date")
  valid_601193 = validateParameter(valid_601193, JString, required = false,
                                 default = nil)
  if valid_601193 != nil:
    section.add "X-Amz-Date", valid_601193
  var valid_601194 = header.getOrDefault("X-Amz-Security-Token")
  valid_601194 = validateParameter(valid_601194, JString, required = false,
                                 default = nil)
  if valid_601194 != nil:
    section.add "X-Amz-Security-Token", valid_601194
  var valid_601195 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601195 = validateParameter(valid_601195, JString, required = false,
                                 default = nil)
  if valid_601195 != nil:
    section.add "X-Amz-Content-Sha256", valid_601195
  var valid_601196 = header.getOrDefault("X-Amz-Algorithm")
  valid_601196 = validateParameter(valid_601196, JString, required = false,
                                 default = nil)
  if valid_601196 != nil:
    section.add "X-Amz-Algorithm", valid_601196
  var valid_601197 = header.getOrDefault("X-Amz-Signature")
  valid_601197 = validateParameter(valid_601197, JString, required = false,
                                 default = nil)
  if valid_601197 != nil:
    section.add "X-Amz-Signature", valid_601197
  var valid_601198 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601198 = validateParameter(valid_601198, JString, required = false,
                                 default = nil)
  if valid_601198 != nil:
    section.add "X-Amz-SignedHeaders", valid_601198
  var valid_601199 = header.getOrDefault("X-Amz-Credential")
  valid_601199 = validateParameter(valid_601199, JString, required = false,
                                 default = nil)
  if valid_601199 != nil:
    section.add "X-Amz-Credential", valid_601199
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_601200 = formData.getOrDefault("Marker")
  valid_601200 = validateParameter(valid_601200, JString, required = false,
                                 default = nil)
  if valid_601200 != nil:
    section.add "Marker", valid_601200
  var valid_601201 = formData.getOrDefault("ClusterIdentifier")
  valid_601201 = validateParameter(valid_601201, JString, required = false,
                                 default = nil)
  if valid_601201 != nil:
    section.add "ClusterIdentifier", valid_601201
  var valid_601202 = formData.getOrDefault("MaxRecords")
  valid_601202 = validateParameter(valid_601202, JInt, required = false, default = nil)
  if valid_601202 != nil:
    section.add "MaxRecords", valid_601202
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601203: Call_PostDescribeClusterDbRevisions_601188; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_601203.validator(path, query, header, formData, body)
  let scheme = call_601203.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601203.url(scheme.get, call_601203.host, call_601203.base,
                         call_601203.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601203, url, valid)

proc call*(call_601204: Call_PostDescribeClusterDbRevisions_601188;
          Marker: string = ""; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_601205 = newJObject()
  var formData_601206 = newJObject()
  add(formData_601206, "Marker", newJString(Marker))
  add(query_601205, "Action", newJString(Action))
  add(formData_601206, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_601206, "MaxRecords", newJInt(MaxRecords))
  add(query_601205, "Version", newJString(Version))
  result = call_601204.call(nil, query_601205, nil, formData_601206, nil)

var postDescribeClusterDbRevisions* = Call_PostDescribeClusterDbRevisions_601188(
    name: "postDescribeClusterDbRevisions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_PostDescribeClusterDbRevisions_601189, base: "/",
    url: url_PostDescribeClusterDbRevisions_601190,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterDbRevisions_601170 = ref object of OpenApiRestCall_599352
proc url_GetDescribeClusterDbRevisions_601172(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterDbRevisions_601171(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_601173 = query.getOrDefault("MaxRecords")
  valid_601173 = validateParameter(valid_601173, JInt, required = false, default = nil)
  if valid_601173 != nil:
    section.add "MaxRecords", valid_601173
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601174 = query.getOrDefault("Action")
  valid_601174 = validateParameter(valid_601174, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_601174 != nil:
    section.add "Action", valid_601174
  var valid_601175 = query.getOrDefault("ClusterIdentifier")
  valid_601175 = validateParameter(valid_601175, JString, required = false,
                                 default = nil)
  if valid_601175 != nil:
    section.add "ClusterIdentifier", valid_601175
  var valid_601176 = query.getOrDefault("Marker")
  valid_601176 = validateParameter(valid_601176, JString, required = false,
                                 default = nil)
  if valid_601176 != nil:
    section.add "Marker", valid_601176
  var valid_601177 = query.getOrDefault("Version")
  valid_601177 = validateParameter(valid_601177, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601177 != nil:
    section.add "Version", valid_601177
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601178 = header.getOrDefault("X-Amz-Date")
  valid_601178 = validateParameter(valid_601178, JString, required = false,
                                 default = nil)
  if valid_601178 != nil:
    section.add "X-Amz-Date", valid_601178
  var valid_601179 = header.getOrDefault("X-Amz-Security-Token")
  valid_601179 = validateParameter(valid_601179, JString, required = false,
                                 default = nil)
  if valid_601179 != nil:
    section.add "X-Amz-Security-Token", valid_601179
  var valid_601180 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601180 = validateParameter(valid_601180, JString, required = false,
                                 default = nil)
  if valid_601180 != nil:
    section.add "X-Amz-Content-Sha256", valid_601180
  var valid_601181 = header.getOrDefault("X-Amz-Algorithm")
  valid_601181 = validateParameter(valid_601181, JString, required = false,
                                 default = nil)
  if valid_601181 != nil:
    section.add "X-Amz-Algorithm", valid_601181
  var valid_601182 = header.getOrDefault("X-Amz-Signature")
  valid_601182 = validateParameter(valid_601182, JString, required = false,
                                 default = nil)
  if valid_601182 != nil:
    section.add "X-Amz-Signature", valid_601182
  var valid_601183 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601183 = validateParameter(valid_601183, JString, required = false,
                                 default = nil)
  if valid_601183 != nil:
    section.add "X-Amz-SignedHeaders", valid_601183
  var valid_601184 = header.getOrDefault("X-Amz-Credential")
  valid_601184 = validateParameter(valid_601184, JString, required = false,
                                 default = nil)
  if valid_601184 != nil:
    section.add "X-Amz-Credential", valid_601184
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601185: Call_GetDescribeClusterDbRevisions_601170; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_601185.validator(path, query, header, formData, body)
  let scheme = call_601185.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601185.url(scheme.get, call_601185.host, call_601185.base,
                         call_601185.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601185, url, valid)

proc call*(call_601186: Call_GetDescribeClusterDbRevisions_601170;
          MaxRecords: int = 0; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Version: string (required)
  var query_601187 = newJObject()
  add(query_601187, "MaxRecords", newJInt(MaxRecords))
  add(query_601187, "Action", newJString(Action))
  add(query_601187, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_601187, "Marker", newJString(Marker))
  add(query_601187, "Version", newJString(Version))
  result = call_601186.call(nil, query_601187, nil, nil, nil)

var getDescribeClusterDbRevisions* = Call_GetDescribeClusterDbRevisions_601170(
    name: "getDescribeClusterDbRevisions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_GetDescribeClusterDbRevisions_601171, base: "/",
    url: url_GetDescribeClusterDbRevisions_601172,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameterGroups_601227 = ref object of OpenApiRestCall_599352
proc url_PostDescribeClusterParameterGroups_601229(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameterGroups_601228(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601230 = query.getOrDefault("Action")
  valid_601230 = validateParameter(valid_601230, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_601230 != nil:
    section.add "Action", valid_601230
  var valid_601231 = query.getOrDefault("Version")
  valid_601231 = validateParameter(valid_601231, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601231 != nil:
    section.add "Version", valid_601231
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601232 = header.getOrDefault("X-Amz-Date")
  valid_601232 = validateParameter(valid_601232, JString, required = false,
                                 default = nil)
  if valid_601232 != nil:
    section.add "X-Amz-Date", valid_601232
  var valid_601233 = header.getOrDefault("X-Amz-Security-Token")
  valid_601233 = validateParameter(valid_601233, JString, required = false,
                                 default = nil)
  if valid_601233 != nil:
    section.add "X-Amz-Security-Token", valid_601233
  var valid_601234 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601234 = validateParameter(valid_601234, JString, required = false,
                                 default = nil)
  if valid_601234 != nil:
    section.add "X-Amz-Content-Sha256", valid_601234
  var valid_601235 = header.getOrDefault("X-Amz-Algorithm")
  valid_601235 = validateParameter(valid_601235, JString, required = false,
                                 default = nil)
  if valid_601235 != nil:
    section.add "X-Amz-Algorithm", valid_601235
  var valid_601236 = header.getOrDefault("X-Amz-Signature")
  valid_601236 = validateParameter(valid_601236, JString, required = false,
                                 default = nil)
  if valid_601236 != nil:
    section.add "X-Amz-Signature", valid_601236
  var valid_601237 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601237 = validateParameter(valid_601237, JString, required = false,
                                 default = nil)
  if valid_601237 != nil:
    section.add "X-Amz-SignedHeaders", valid_601237
  var valid_601238 = header.getOrDefault("X-Amz-Credential")
  valid_601238 = validateParameter(valid_601238, JString, required = false,
                                 default = nil)
  if valid_601238 != nil:
    section.add "X-Amz-Credential", valid_601238
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_601239 = formData.getOrDefault("ParameterGroupName")
  valid_601239 = validateParameter(valid_601239, JString, required = false,
                                 default = nil)
  if valid_601239 != nil:
    section.add "ParameterGroupName", valid_601239
  var valid_601240 = formData.getOrDefault("Marker")
  valid_601240 = validateParameter(valid_601240, JString, required = false,
                                 default = nil)
  if valid_601240 != nil:
    section.add "Marker", valid_601240
  var valid_601241 = formData.getOrDefault("TagKeys")
  valid_601241 = validateParameter(valid_601241, JArray, required = false,
                                 default = nil)
  if valid_601241 != nil:
    section.add "TagKeys", valid_601241
  var valid_601242 = formData.getOrDefault("MaxRecords")
  valid_601242 = validateParameter(valid_601242, JInt, required = false, default = nil)
  if valid_601242 != nil:
    section.add "MaxRecords", valid_601242
  var valid_601243 = formData.getOrDefault("TagValues")
  valid_601243 = validateParameter(valid_601243, JArray, required = false,
                                 default = nil)
  if valid_601243 != nil:
    section.add "TagValues", valid_601243
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601244: Call_PostDescribeClusterParameterGroups_601227;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601244.validator(path, query, header, formData, body)
  let scheme = call_601244.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601244.url(scheme.get, call_601244.host, call_601244.base,
                         call_601244.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601244, url, valid)

proc call*(call_601245: Call_PostDescribeClusterParameterGroups_601227;
          ParameterGroupName: string = ""; Marker: string = "";
          Action: string = "DescribeClusterParameterGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_601246 = newJObject()
  var formData_601247 = newJObject()
  add(formData_601247, "ParameterGroupName", newJString(ParameterGroupName))
  add(formData_601247, "Marker", newJString(Marker))
  add(query_601246, "Action", newJString(Action))
  if TagKeys != nil:
    formData_601247.add "TagKeys", TagKeys
  add(formData_601247, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_601247.add "TagValues", TagValues
  add(query_601246, "Version", newJString(Version))
  result = call_601245.call(nil, query_601246, nil, formData_601247, nil)

var postDescribeClusterParameterGroups* = Call_PostDescribeClusterParameterGroups_601227(
    name: "postDescribeClusterParameterGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_PostDescribeClusterParameterGroups_601228, base: "/",
    url: url_PostDescribeClusterParameterGroups_601229,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameterGroups_601207 = ref object of OpenApiRestCall_599352
proc url_GetDescribeClusterParameterGroups_601209(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameterGroups_601208(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_601210 = query.getOrDefault("TagValues")
  valid_601210 = validateParameter(valid_601210, JArray, required = false,
                                 default = nil)
  if valid_601210 != nil:
    section.add "TagValues", valid_601210
  var valid_601211 = query.getOrDefault("MaxRecords")
  valid_601211 = validateParameter(valid_601211, JInt, required = false, default = nil)
  if valid_601211 != nil:
    section.add "MaxRecords", valid_601211
  var valid_601212 = query.getOrDefault("ParameterGroupName")
  valid_601212 = validateParameter(valid_601212, JString, required = false,
                                 default = nil)
  if valid_601212 != nil:
    section.add "ParameterGroupName", valid_601212
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601213 = query.getOrDefault("Action")
  valid_601213 = validateParameter(valid_601213, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_601213 != nil:
    section.add "Action", valid_601213
  var valid_601214 = query.getOrDefault("Marker")
  valid_601214 = validateParameter(valid_601214, JString, required = false,
                                 default = nil)
  if valid_601214 != nil:
    section.add "Marker", valid_601214
  var valid_601215 = query.getOrDefault("TagKeys")
  valid_601215 = validateParameter(valid_601215, JArray, required = false,
                                 default = nil)
  if valid_601215 != nil:
    section.add "TagKeys", valid_601215
  var valid_601216 = query.getOrDefault("Version")
  valid_601216 = validateParameter(valid_601216, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601216 != nil:
    section.add "Version", valid_601216
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601217 = header.getOrDefault("X-Amz-Date")
  valid_601217 = validateParameter(valid_601217, JString, required = false,
                                 default = nil)
  if valid_601217 != nil:
    section.add "X-Amz-Date", valid_601217
  var valid_601218 = header.getOrDefault("X-Amz-Security-Token")
  valid_601218 = validateParameter(valid_601218, JString, required = false,
                                 default = nil)
  if valid_601218 != nil:
    section.add "X-Amz-Security-Token", valid_601218
  var valid_601219 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601219 = validateParameter(valid_601219, JString, required = false,
                                 default = nil)
  if valid_601219 != nil:
    section.add "X-Amz-Content-Sha256", valid_601219
  var valid_601220 = header.getOrDefault("X-Amz-Algorithm")
  valid_601220 = validateParameter(valid_601220, JString, required = false,
                                 default = nil)
  if valid_601220 != nil:
    section.add "X-Amz-Algorithm", valid_601220
  var valid_601221 = header.getOrDefault("X-Amz-Signature")
  valid_601221 = validateParameter(valid_601221, JString, required = false,
                                 default = nil)
  if valid_601221 != nil:
    section.add "X-Amz-Signature", valid_601221
  var valid_601222 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601222 = validateParameter(valid_601222, JString, required = false,
                                 default = nil)
  if valid_601222 != nil:
    section.add "X-Amz-SignedHeaders", valid_601222
  var valid_601223 = header.getOrDefault("X-Amz-Credential")
  valid_601223 = validateParameter(valid_601223, JString, required = false,
                                 default = nil)
  if valid_601223 != nil:
    section.add "X-Amz-Credential", valid_601223
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601224: Call_GetDescribeClusterParameterGroups_601207;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601224.validator(path, query, header, formData, body)
  let scheme = call_601224.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601224.url(scheme.get, call_601224.host, call_601224.base,
                         call_601224.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601224, url, valid)

proc call*(call_601225: Call_GetDescribeClusterParameterGroups_601207;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          ParameterGroupName: string = "";
          Action: string = "DescribeClusterParameterGroups"; Marker: string = "";
          TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_601226 = newJObject()
  if TagValues != nil:
    query_601226.add "TagValues", TagValues
  add(query_601226, "MaxRecords", newJInt(MaxRecords))
  add(query_601226, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_601226, "Action", newJString(Action))
  add(query_601226, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_601226.add "TagKeys", TagKeys
  add(query_601226, "Version", newJString(Version))
  result = call_601225.call(nil, query_601226, nil, nil, nil)

var getDescribeClusterParameterGroups* = Call_GetDescribeClusterParameterGroups_601207(
    name: "getDescribeClusterParameterGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_GetDescribeClusterParameterGroups_601208, base: "/",
    url: url_GetDescribeClusterParameterGroups_601209,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameters_601267 = ref object of OpenApiRestCall_599352
proc url_PostDescribeClusterParameters_601269(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterParameters_601268(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601270 = query.getOrDefault("Action")
  valid_601270 = validateParameter(valid_601270, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_601270 != nil:
    section.add "Action", valid_601270
  var valid_601271 = query.getOrDefault("Version")
  valid_601271 = validateParameter(valid_601271, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601271 != nil:
    section.add "Version", valid_601271
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601272 = header.getOrDefault("X-Amz-Date")
  valid_601272 = validateParameter(valid_601272, JString, required = false,
                                 default = nil)
  if valid_601272 != nil:
    section.add "X-Amz-Date", valid_601272
  var valid_601273 = header.getOrDefault("X-Amz-Security-Token")
  valid_601273 = validateParameter(valid_601273, JString, required = false,
                                 default = nil)
  if valid_601273 != nil:
    section.add "X-Amz-Security-Token", valid_601273
  var valid_601274 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601274 = validateParameter(valid_601274, JString, required = false,
                                 default = nil)
  if valid_601274 != nil:
    section.add "X-Amz-Content-Sha256", valid_601274
  var valid_601275 = header.getOrDefault("X-Amz-Algorithm")
  valid_601275 = validateParameter(valid_601275, JString, required = false,
                                 default = nil)
  if valid_601275 != nil:
    section.add "X-Amz-Algorithm", valid_601275
  var valid_601276 = header.getOrDefault("X-Amz-Signature")
  valid_601276 = validateParameter(valid_601276, JString, required = false,
                                 default = nil)
  if valid_601276 != nil:
    section.add "X-Amz-Signature", valid_601276
  var valid_601277 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601277 = validateParameter(valid_601277, JString, required = false,
                                 default = nil)
  if valid_601277 != nil:
    section.add "X-Amz-SignedHeaders", valid_601277
  var valid_601278 = header.getOrDefault("X-Amz-Credential")
  valid_601278 = validateParameter(valid_601278, JString, required = false,
                                 default = nil)
  if valid_601278 != nil:
    section.add "X-Amz-Credential", valid_601278
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_601279 = formData.getOrDefault("ParameterGroupName")
  valid_601279 = validateParameter(valid_601279, JString, required = true,
                                 default = nil)
  if valid_601279 != nil:
    section.add "ParameterGroupName", valid_601279
  var valid_601280 = formData.getOrDefault("Marker")
  valid_601280 = validateParameter(valid_601280, JString, required = false,
                                 default = nil)
  if valid_601280 != nil:
    section.add "Marker", valid_601280
  var valid_601281 = formData.getOrDefault("MaxRecords")
  valid_601281 = validateParameter(valid_601281, JInt, required = false, default = nil)
  if valid_601281 != nil:
    section.add "MaxRecords", valid_601281
  var valid_601282 = formData.getOrDefault("Source")
  valid_601282 = validateParameter(valid_601282, JString, required = false,
                                 default = nil)
  if valid_601282 != nil:
    section.add "Source", valid_601282
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601283: Call_PostDescribeClusterParameters_601267; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_601283.validator(path, query, header, formData, body)
  let scheme = call_601283.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601283.url(scheme.get, call_601283.host, call_601283.base,
                         call_601283.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601283, url, valid)

proc call*(call_601284: Call_PostDescribeClusterParameters_601267;
          ParameterGroupName: string; Marker: string = "";
          Action: string = "DescribeClusterParameters"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; Source: string = ""): Recallable =
  ## postDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  var query_601285 = newJObject()
  var formData_601286 = newJObject()
  add(formData_601286, "ParameterGroupName", newJString(ParameterGroupName))
  add(formData_601286, "Marker", newJString(Marker))
  add(query_601285, "Action", newJString(Action))
  add(formData_601286, "MaxRecords", newJInt(MaxRecords))
  add(query_601285, "Version", newJString(Version))
  add(formData_601286, "Source", newJString(Source))
  result = call_601284.call(nil, query_601285, nil, formData_601286, nil)

var postDescribeClusterParameters* = Call_PostDescribeClusterParameters_601267(
    name: "postDescribeClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_PostDescribeClusterParameters_601268, base: "/",
    url: url_PostDescribeClusterParameters_601269,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameters_601248 = ref object of OpenApiRestCall_599352
proc url_GetDescribeClusterParameters_601250(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterParameters_601249(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_601251 = query.getOrDefault("MaxRecords")
  valid_601251 = validateParameter(valid_601251, JInt, required = false, default = nil)
  if valid_601251 != nil:
    section.add "MaxRecords", valid_601251
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_601252 = query.getOrDefault("ParameterGroupName")
  valid_601252 = validateParameter(valid_601252, JString, required = true,
                                 default = nil)
  if valid_601252 != nil:
    section.add "ParameterGroupName", valid_601252
  var valid_601253 = query.getOrDefault("Action")
  valid_601253 = validateParameter(valid_601253, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_601253 != nil:
    section.add "Action", valid_601253
  var valid_601254 = query.getOrDefault("Marker")
  valid_601254 = validateParameter(valid_601254, JString, required = false,
                                 default = nil)
  if valid_601254 != nil:
    section.add "Marker", valid_601254
  var valid_601255 = query.getOrDefault("Source")
  valid_601255 = validateParameter(valid_601255, JString, required = false,
                                 default = nil)
  if valid_601255 != nil:
    section.add "Source", valid_601255
  var valid_601256 = query.getOrDefault("Version")
  valid_601256 = validateParameter(valid_601256, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601256 != nil:
    section.add "Version", valid_601256
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601257 = header.getOrDefault("X-Amz-Date")
  valid_601257 = validateParameter(valid_601257, JString, required = false,
                                 default = nil)
  if valid_601257 != nil:
    section.add "X-Amz-Date", valid_601257
  var valid_601258 = header.getOrDefault("X-Amz-Security-Token")
  valid_601258 = validateParameter(valid_601258, JString, required = false,
                                 default = nil)
  if valid_601258 != nil:
    section.add "X-Amz-Security-Token", valid_601258
  var valid_601259 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601259 = validateParameter(valid_601259, JString, required = false,
                                 default = nil)
  if valid_601259 != nil:
    section.add "X-Amz-Content-Sha256", valid_601259
  var valid_601260 = header.getOrDefault("X-Amz-Algorithm")
  valid_601260 = validateParameter(valid_601260, JString, required = false,
                                 default = nil)
  if valid_601260 != nil:
    section.add "X-Amz-Algorithm", valid_601260
  var valid_601261 = header.getOrDefault("X-Amz-Signature")
  valid_601261 = validateParameter(valid_601261, JString, required = false,
                                 default = nil)
  if valid_601261 != nil:
    section.add "X-Amz-Signature", valid_601261
  var valid_601262 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601262 = validateParameter(valid_601262, JString, required = false,
                                 default = nil)
  if valid_601262 != nil:
    section.add "X-Amz-SignedHeaders", valid_601262
  var valid_601263 = header.getOrDefault("X-Amz-Credential")
  valid_601263 = validateParameter(valid_601263, JString, required = false,
                                 default = nil)
  if valid_601263 != nil:
    section.add "X-Amz-Credential", valid_601263
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601264: Call_GetDescribeClusterParameters_601248; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_601264.validator(path, query, header, formData, body)
  let scheme = call_601264.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601264.url(scheme.get, call_601264.host, call_601264.base,
                         call_601264.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601264, url, valid)

proc call*(call_601265: Call_GetDescribeClusterParameters_601248;
          ParameterGroupName: string; MaxRecords: int = 0;
          Action: string = "DescribeClusterParameters"; Marker: string = "";
          Source: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Version: string (required)
  var query_601266 = newJObject()
  add(query_601266, "MaxRecords", newJInt(MaxRecords))
  add(query_601266, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_601266, "Action", newJString(Action))
  add(query_601266, "Marker", newJString(Marker))
  add(query_601266, "Source", newJString(Source))
  add(query_601266, "Version", newJString(Version))
  result = call_601265.call(nil, query_601266, nil, nil, nil)

var getDescribeClusterParameters* = Call_GetDescribeClusterParameters_601248(
    name: "getDescribeClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_GetDescribeClusterParameters_601249, base: "/",
    url: url_GetDescribeClusterParameters_601250,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSecurityGroups_601307 = ref object of OpenApiRestCall_599352
proc url_PostDescribeClusterSecurityGroups_601309(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSecurityGroups_601308(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601310 = query.getOrDefault("Action")
  valid_601310 = validateParameter(valid_601310, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_601310 != nil:
    section.add "Action", valid_601310
  var valid_601311 = query.getOrDefault("Version")
  valid_601311 = validateParameter(valid_601311, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601311 != nil:
    section.add "Version", valid_601311
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601312 = header.getOrDefault("X-Amz-Date")
  valid_601312 = validateParameter(valid_601312, JString, required = false,
                                 default = nil)
  if valid_601312 != nil:
    section.add "X-Amz-Date", valid_601312
  var valid_601313 = header.getOrDefault("X-Amz-Security-Token")
  valid_601313 = validateParameter(valid_601313, JString, required = false,
                                 default = nil)
  if valid_601313 != nil:
    section.add "X-Amz-Security-Token", valid_601313
  var valid_601314 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601314 = validateParameter(valid_601314, JString, required = false,
                                 default = nil)
  if valid_601314 != nil:
    section.add "X-Amz-Content-Sha256", valid_601314
  var valid_601315 = header.getOrDefault("X-Amz-Algorithm")
  valid_601315 = validateParameter(valid_601315, JString, required = false,
                                 default = nil)
  if valid_601315 != nil:
    section.add "X-Amz-Algorithm", valid_601315
  var valid_601316 = header.getOrDefault("X-Amz-Signature")
  valid_601316 = validateParameter(valid_601316, JString, required = false,
                                 default = nil)
  if valid_601316 != nil:
    section.add "X-Amz-Signature", valid_601316
  var valid_601317 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601317 = validateParameter(valid_601317, JString, required = false,
                                 default = nil)
  if valid_601317 != nil:
    section.add "X-Amz-SignedHeaders", valid_601317
  var valid_601318 = header.getOrDefault("X-Amz-Credential")
  valid_601318 = validateParameter(valid_601318, JString, required = false,
                                 default = nil)
  if valid_601318 != nil:
    section.add "X-Amz-Credential", valid_601318
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  section = newJObject()
  var valid_601319 = formData.getOrDefault("Marker")
  valid_601319 = validateParameter(valid_601319, JString, required = false,
                                 default = nil)
  if valid_601319 != nil:
    section.add "Marker", valid_601319
  var valid_601320 = formData.getOrDefault("TagKeys")
  valid_601320 = validateParameter(valid_601320, JArray, required = false,
                                 default = nil)
  if valid_601320 != nil:
    section.add "TagKeys", valid_601320
  var valid_601321 = formData.getOrDefault("MaxRecords")
  valid_601321 = validateParameter(valid_601321, JInt, required = false, default = nil)
  if valid_601321 != nil:
    section.add "MaxRecords", valid_601321
  var valid_601322 = formData.getOrDefault("TagValues")
  valid_601322 = validateParameter(valid_601322, JArray, required = false,
                                 default = nil)
  if valid_601322 != nil:
    section.add "TagValues", valid_601322
  var valid_601323 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_601323 = validateParameter(valid_601323, JString, required = false,
                                 default = nil)
  if valid_601323 != nil:
    section.add "ClusterSecurityGroupName", valid_601323
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601324: Call_PostDescribeClusterSecurityGroups_601307;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601324.validator(path, query, header, formData, body)
  let scheme = call_601324.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601324.url(scheme.get, call_601324.host, call_601324.base,
                         call_601324.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601324, url, valid)

proc call*(call_601325: Call_PostDescribeClusterSecurityGroups_601307;
          Marker: string = ""; Action: string = "DescribeClusterSecurityGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"; ClusterSecurityGroupName: string = ""): Recallable =
  ## postDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  var query_601326 = newJObject()
  var formData_601327 = newJObject()
  add(formData_601327, "Marker", newJString(Marker))
  add(query_601326, "Action", newJString(Action))
  if TagKeys != nil:
    formData_601327.add "TagKeys", TagKeys
  add(formData_601327, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_601327.add "TagValues", TagValues
  add(query_601326, "Version", newJString(Version))
  add(formData_601327, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_601325.call(nil, query_601326, nil, formData_601327, nil)

var postDescribeClusterSecurityGroups* = Call_PostDescribeClusterSecurityGroups_601307(
    name: "postDescribeClusterSecurityGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_PostDescribeClusterSecurityGroups_601308, base: "/",
    url: url_PostDescribeClusterSecurityGroups_601309,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSecurityGroups_601287 = ref object of OpenApiRestCall_599352
proc url_GetDescribeClusterSecurityGroups_601289(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSecurityGroups_601288(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_601290 = query.getOrDefault("TagValues")
  valid_601290 = validateParameter(valid_601290, JArray, required = false,
                                 default = nil)
  if valid_601290 != nil:
    section.add "TagValues", valid_601290
  var valid_601291 = query.getOrDefault("ClusterSecurityGroupName")
  valid_601291 = validateParameter(valid_601291, JString, required = false,
                                 default = nil)
  if valid_601291 != nil:
    section.add "ClusterSecurityGroupName", valid_601291
  var valid_601292 = query.getOrDefault("MaxRecords")
  valid_601292 = validateParameter(valid_601292, JInt, required = false, default = nil)
  if valid_601292 != nil:
    section.add "MaxRecords", valid_601292
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601293 = query.getOrDefault("Action")
  valid_601293 = validateParameter(valid_601293, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_601293 != nil:
    section.add "Action", valid_601293
  var valid_601294 = query.getOrDefault("Marker")
  valid_601294 = validateParameter(valid_601294, JString, required = false,
                                 default = nil)
  if valid_601294 != nil:
    section.add "Marker", valid_601294
  var valid_601295 = query.getOrDefault("TagKeys")
  valid_601295 = validateParameter(valid_601295, JArray, required = false,
                                 default = nil)
  if valid_601295 != nil:
    section.add "TagKeys", valid_601295
  var valid_601296 = query.getOrDefault("Version")
  valid_601296 = validateParameter(valid_601296, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601296 != nil:
    section.add "Version", valid_601296
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601297 = header.getOrDefault("X-Amz-Date")
  valid_601297 = validateParameter(valid_601297, JString, required = false,
                                 default = nil)
  if valid_601297 != nil:
    section.add "X-Amz-Date", valid_601297
  var valid_601298 = header.getOrDefault("X-Amz-Security-Token")
  valid_601298 = validateParameter(valid_601298, JString, required = false,
                                 default = nil)
  if valid_601298 != nil:
    section.add "X-Amz-Security-Token", valid_601298
  var valid_601299 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601299 = validateParameter(valid_601299, JString, required = false,
                                 default = nil)
  if valid_601299 != nil:
    section.add "X-Amz-Content-Sha256", valid_601299
  var valid_601300 = header.getOrDefault("X-Amz-Algorithm")
  valid_601300 = validateParameter(valid_601300, JString, required = false,
                                 default = nil)
  if valid_601300 != nil:
    section.add "X-Amz-Algorithm", valid_601300
  var valid_601301 = header.getOrDefault("X-Amz-Signature")
  valid_601301 = validateParameter(valid_601301, JString, required = false,
                                 default = nil)
  if valid_601301 != nil:
    section.add "X-Amz-Signature", valid_601301
  var valid_601302 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601302 = validateParameter(valid_601302, JString, required = false,
                                 default = nil)
  if valid_601302 != nil:
    section.add "X-Amz-SignedHeaders", valid_601302
  var valid_601303 = header.getOrDefault("X-Amz-Credential")
  valid_601303 = validateParameter(valid_601303, JString, required = false,
                                 default = nil)
  if valid_601303 != nil:
    section.add "X-Amz-Credential", valid_601303
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601304: Call_GetDescribeClusterSecurityGroups_601287;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601304.validator(path, query, header, formData, body)
  let scheme = call_601304.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601304.url(scheme.get, call_601304.host, call_601304.base,
                         call_601304.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601304, url, valid)

proc call*(call_601305: Call_GetDescribeClusterSecurityGroups_601287;
          TagValues: JsonNode = nil; ClusterSecurityGroupName: string = "";
          MaxRecords: int = 0; Action: string = "DescribeClusterSecurityGroups";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_601306 = newJObject()
  if TagValues != nil:
    query_601306.add "TagValues", TagValues
  add(query_601306, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_601306, "MaxRecords", newJInt(MaxRecords))
  add(query_601306, "Action", newJString(Action))
  add(query_601306, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_601306.add "TagKeys", TagKeys
  add(query_601306, "Version", newJString(Version))
  result = call_601305.call(nil, query_601306, nil, nil, nil)

var getDescribeClusterSecurityGroups* = Call_GetDescribeClusterSecurityGroups_601287(
    name: "getDescribeClusterSecurityGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_GetDescribeClusterSecurityGroups_601288, base: "/",
    url: url_GetDescribeClusterSecurityGroups_601289,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSnapshots_601355 = ref object of OpenApiRestCall_599352
proc url_PostDescribeClusterSnapshots_601357(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSnapshots_601356(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601358 = query.getOrDefault("Action")
  valid_601358 = validateParameter(valid_601358, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_601358 != nil:
    section.add "Action", valid_601358
  var valid_601359 = query.getOrDefault("Version")
  valid_601359 = validateParameter(valid_601359, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601359 != nil:
    section.add "Version", valid_601359
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601360 = header.getOrDefault("X-Amz-Date")
  valid_601360 = validateParameter(valid_601360, JString, required = false,
                                 default = nil)
  if valid_601360 != nil:
    section.add "X-Amz-Date", valid_601360
  var valid_601361 = header.getOrDefault("X-Amz-Security-Token")
  valid_601361 = validateParameter(valid_601361, JString, required = false,
                                 default = nil)
  if valid_601361 != nil:
    section.add "X-Amz-Security-Token", valid_601361
  var valid_601362 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601362 = validateParameter(valid_601362, JString, required = false,
                                 default = nil)
  if valid_601362 != nil:
    section.add "X-Amz-Content-Sha256", valid_601362
  var valid_601363 = header.getOrDefault("X-Amz-Algorithm")
  valid_601363 = validateParameter(valid_601363, JString, required = false,
                                 default = nil)
  if valid_601363 != nil:
    section.add "X-Amz-Algorithm", valid_601363
  var valid_601364 = header.getOrDefault("X-Amz-Signature")
  valid_601364 = validateParameter(valid_601364, JString, required = false,
                                 default = nil)
  if valid_601364 != nil:
    section.add "X-Amz-Signature", valid_601364
  var valid_601365 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601365 = validateParameter(valid_601365, JString, required = false,
                                 default = nil)
  if valid_601365 != nil:
    section.add "X-Amz-SignedHeaders", valid_601365
  var valid_601366 = header.getOrDefault("X-Amz-Credential")
  valid_601366 = validateParameter(valid_601366, JString, required = false,
                                 default = nil)
  if valid_601366 != nil:
    section.add "X-Amz-Credential", valid_601366
  result.add "header", section
  ## parameters in `formData` object:
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_601367 = formData.getOrDefault("SortingEntities")
  valid_601367 = validateParameter(valid_601367, JArray, required = false,
                                 default = nil)
  if valid_601367 != nil:
    section.add "SortingEntities", valid_601367
  var valid_601368 = formData.getOrDefault("SnapshotType")
  valid_601368 = validateParameter(valid_601368, JString, required = false,
                                 default = nil)
  if valid_601368 != nil:
    section.add "SnapshotType", valid_601368
  var valid_601369 = formData.getOrDefault("Marker")
  valid_601369 = validateParameter(valid_601369, JString, required = false,
                                 default = nil)
  if valid_601369 != nil:
    section.add "Marker", valid_601369
  var valid_601370 = formData.getOrDefault("StartTime")
  valid_601370 = validateParameter(valid_601370, JString, required = false,
                                 default = nil)
  if valid_601370 != nil:
    section.add "StartTime", valid_601370
  var valid_601371 = formData.getOrDefault("OwnerAccount")
  valid_601371 = validateParameter(valid_601371, JString, required = false,
                                 default = nil)
  if valid_601371 != nil:
    section.add "OwnerAccount", valid_601371
  var valid_601372 = formData.getOrDefault("ClusterIdentifier")
  valid_601372 = validateParameter(valid_601372, JString, required = false,
                                 default = nil)
  if valid_601372 != nil:
    section.add "ClusterIdentifier", valid_601372
  var valid_601373 = formData.getOrDefault("TagKeys")
  valid_601373 = validateParameter(valid_601373, JArray, required = false,
                                 default = nil)
  if valid_601373 != nil:
    section.add "TagKeys", valid_601373
  var valid_601374 = formData.getOrDefault("EndTime")
  valid_601374 = validateParameter(valid_601374, JString, required = false,
                                 default = nil)
  if valid_601374 != nil:
    section.add "EndTime", valid_601374
  var valid_601375 = formData.getOrDefault("ClusterExists")
  valid_601375 = validateParameter(valid_601375, JBool, required = false, default = nil)
  if valid_601375 != nil:
    section.add "ClusterExists", valid_601375
  var valid_601376 = formData.getOrDefault("SnapshotIdentifier")
  valid_601376 = validateParameter(valid_601376, JString, required = false,
                                 default = nil)
  if valid_601376 != nil:
    section.add "SnapshotIdentifier", valid_601376
  var valid_601377 = formData.getOrDefault("MaxRecords")
  valid_601377 = validateParameter(valid_601377, JInt, required = false, default = nil)
  if valid_601377 != nil:
    section.add "MaxRecords", valid_601377
  var valid_601378 = formData.getOrDefault("TagValues")
  valid_601378 = validateParameter(valid_601378, JArray, required = false,
                                 default = nil)
  if valid_601378 != nil:
    section.add "TagValues", valid_601378
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601379: Call_PostDescribeClusterSnapshots_601355; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601379.validator(path, query, header, formData, body)
  let scheme = call_601379.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601379.url(scheme.get, call_601379.host, call_601379.base,
                         call_601379.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601379, url, valid)

proc call*(call_601380: Call_PostDescribeClusterSnapshots_601355;
          SortingEntities: JsonNode = nil; SnapshotType: string = "";
          Marker: string = ""; StartTime: string = "";
          Action: string = "DescribeClusterSnapshots"; OwnerAccount: string = "";
          ClusterIdentifier: string = ""; TagKeys: JsonNode = nil; EndTime: string = "";
          ClusterExists: bool = false; SnapshotIdentifier: string = "";
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_601381 = newJObject()
  var formData_601382 = newJObject()
  if SortingEntities != nil:
    formData_601382.add "SortingEntities", SortingEntities
  add(formData_601382, "SnapshotType", newJString(SnapshotType))
  add(formData_601382, "Marker", newJString(Marker))
  add(formData_601382, "StartTime", newJString(StartTime))
  add(query_601381, "Action", newJString(Action))
  add(formData_601382, "OwnerAccount", newJString(OwnerAccount))
  add(formData_601382, "ClusterIdentifier", newJString(ClusterIdentifier))
  if TagKeys != nil:
    formData_601382.add "TagKeys", TagKeys
  add(formData_601382, "EndTime", newJString(EndTime))
  add(formData_601382, "ClusterExists", newJBool(ClusterExists))
  add(formData_601382, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_601382, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_601382.add "TagValues", TagValues
  add(query_601381, "Version", newJString(Version))
  result = call_601380.call(nil, query_601381, nil, formData_601382, nil)

var postDescribeClusterSnapshots* = Call_PostDescribeClusterSnapshots_601355(
    name: "postDescribeClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_PostDescribeClusterSnapshots_601356, base: "/",
    url: url_PostDescribeClusterSnapshots_601357,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSnapshots_601328 = ref object of OpenApiRestCall_599352
proc url_GetDescribeClusterSnapshots_601330(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSnapshots_601329(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_601331 = query.getOrDefault("TagValues")
  valid_601331 = validateParameter(valid_601331, JArray, required = false,
                                 default = nil)
  if valid_601331 != nil:
    section.add "TagValues", valid_601331
  var valid_601332 = query.getOrDefault("SortingEntities")
  valid_601332 = validateParameter(valid_601332, JArray, required = false,
                                 default = nil)
  if valid_601332 != nil:
    section.add "SortingEntities", valid_601332
  var valid_601333 = query.getOrDefault("MaxRecords")
  valid_601333 = validateParameter(valid_601333, JInt, required = false, default = nil)
  if valid_601333 != nil:
    section.add "MaxRecords", valid_601333
  var valid_601334 = query.getOrDefault("StartTime")
  valid_601334 = validateParameter(valid_601334, JString, required = false,
                                 default = nil)
  if valid_601334 != nil:
    section.add "StartTime", valid_601334
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601335 = query.getOrDefault("Action")
  valid_601335 = validateParameter(valid_601335, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_601335 != nil:
    section.add "Action", valid_601335
  var valid_601336 = query.getOrDefault("ClusterIdentifier")
  valid_601336 = validateParameter(valid_601336, JString, required = false,
                                 default = nil)
  if valid_601336 != nil:
    section.add "ClusterIdentifier", valid_601336
  var valid_601337 = query.getOrDefault("Marker")
  valid_601337 = validateParameter(valid_601337, JString, required = false,
                                 default = nil)
  if valid_601337 != nil:
    section.add "Marker", valid_601337
  var valid_601338 = query.getOrDefault("OwnerAccount")
  valid_601338 = validateParameter(valid_601338, JString, required = false,
                                 default = nil)
  if valid_601338 != nil:
    section.add "OwnerAccount", valid_601338
  var valid_601339 = query.getOrDefault("ClusterExists")
  valid_601339 = validateParameter(valid_601339, JBool, required = false, default = nil)
  if valid_601339 != nil:
    section.add "ClusterExists", valid_601339
  var valid_601340 = query.getOrDefault("SnapshotIdentifier")
  valid_601340 = validateParameter(valid_601340, JString, required = false,
                                 default = nil)
  if valid_601340 != nil:
    section.add "SnapshotIdentifier", valid_601340
  var valid_601341 = query.getOrDefault("TagKeys")
  valid_601341 = validateParameter(valid_601341, JArray, required = false,
                                 default = nil)
  if valid_601341 != nil:
    section.add "TagKeys", valid_601341
  var valid_601342 = query.getOrDefault("SnapshotType")
  valid_601342 = validateParameter(valid_601342, JString, required = false,
                                 default = nil)
  if valid_601342 != nil:
    section.add "SnapshotType", valid_601342
  var valid_601343 = query.getOrDefault("EndTime")
  valid_601343 = validateParameter(valid_601343, JString, required = false,
                                 default = nil)
  if valid_601343 != nil:
    section.add "EndTime", valid_601343
  var valid_601344 = query.getOrDefault("Version")
  valid_601344 = validateParameter(valid_601344, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601344 != nil:
    section.add "Version", valid_601344
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601345 = header.getOrDefault("X-Amz-Date")
  valid_601345 = validateParameter(valid_601345, JString, required = false,
                                 default = nil)
  if valid_601345 != nil:
    section.add "X-Amz-Date", valid_601345
  var valid_601346 = header.getOrDefault("X-Amz-Security-Token")
  valid_601346 = validateParameter(valid_601346, JString, required = false,
                                 default = nil)
  if valid_601346 != nil:
    section.add "X-Amz-Security-Token", valid_601346
  var valid_601347 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601347 = validateParameter(valid_601347, JString, required = false,
                                 default = nil)
  if valid_601347 != nil:
    section.add "X-Amz-Content-Sha256", valid_601347
  var valid_601348 = header.getOrDefault("X-Amz-Algorithm")
  valid_601348 = validateParameter(valid_601348, JString, required = false,
                                 default = nil)
  if valid_601348 != nil:
    section.add "X-Amz-Algorithm", valid_601348
  var valid_601349 = header.getOrDefault("X-Amz-Signature")
  valid_601349 = validateParameter(valid_601349, JString, required = false,
                                 default = nil)
  if valid_601349 != nil:
    section.add "X-Amz-Signature", valid_601349
  var valid_601350 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601350 = validateParameter(valid_601350, JString, required = false,
                                 default = nil)
  if valid_601350 != nil:
    section.add "X-Amz-SignedHeaders", valid_601350
  var valid_601351 = header.getOrDefault("X-Amz-Credential")
  valid_601351 = validateParameter(valid_601351, JString, required = false,
                                 default = nil)
  if valid_601351 != nil:
    section.add "X-Amz-Credential", valid_601351
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601352: Call_GetDescribeClusterSnapshots_601328; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601352.validator(path, query, header, formData, body)
  let scheme = call_601352.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601352.url(scheme.get, call_601352.host, call_601352.base,
                         call_601352.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601352, url, valid)

proc call*(call_601353: Call_GetDescribeClusterSnapshots_601328;
          TagValues: JsonNode = nil; SortingEntities: JsonNode = nil;
          MaxRecords: int = 0; StartTime: string = "";
          Action: string = "DescribeClusterSnapshots";
          ClusterIdentifier: string = ""; Marker: string = "";
          OwnerAccount: string = ""; ClusterExists: bool = false;
          SnapshotIdentifier: string = ""; TagKeys: JsonNode = nil;
          SnapshotType: string = ""; EndTime: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   Version: string (required)
  var query_601354 = newJObject()
  if TagValues != nil:
    query_601354.add "TagValues", TagValues
  if SortingEntities != nil:
    query_601354.add "SortingEntities", SortingEntities
  add(query_601354, "MaxRecords", newJInt(MaxRecords))
  add(query_601354, "StartTime", newJString(StartTime))
  add(query_601354, "Action", newJString(Action))
  add(query_601354, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_601354, "Marker", newJString(Marker))
  add(query_601354, "OwnerAccount", newJString(OwnerAccount))
  add(query_601354, "ClusterExists", newJBool(ClusterExists))
  add(query_601354, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  if TagKeys != nil:
    query_601354.add "TagKeys", TagKeys
  add(query_601354, "SnapshotType", newJString(SnapshotType))
  add(query_601354, "EndTime", newJString(EndTime))
  add(query_601354, "Version", newJString(Version))
  result = call_601353.call(nil, query_601354, nil, nil, nil)

var getDescribeClusterSnapshots* = Call_GetDescribeClusterSnapshots_601328(
    name: "getDescribeClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_GetDescribeClusterSnapshots_601329, base: "/",
    url: url_GetDescribeClusterSnapshots_601330,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSubnetGroups_601403 = ref object of OpenApiRestCall_599352
proc url_PostDescribeClusterSubnetGroups_601405(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterSubnetGroups_601404(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601406 = query.getOrDefault("Action")
  valid_601406 = validateParameter(valid_601406, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_601406 != nil:
    section.add "Action", valid_601406
  var valid_601407 = query.getOrDefault("Version")
  valid_601407 = validateParameter(valid_601407, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601407 != nil:
    section.add "Version", valid_601407
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601408 = header.getOrDefault("X-Amz-Date")
  valid_601408 = validateParameter(valid_601408, JString, required = false,
                                 default = nil)
  if valid_601408 != nil:
    section.add "X-Amz-Date", valid_601408
  var valid_601409 = header.getOrDefault("X-Amz-Security-Token")
  valid_601409 = validateParameter(valid_601409, JString, required = false,
                                 default = nil)
  if valid_601409 != nil:
    section.add "X-Amz-Security-Token", valid_601409
  var valid_601410 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601410 = validateParameter(valid_601410, JString, required = false,
                                 default = nil)
  if valid_601410 != nil:
    section.add "X-Amz-Content-Sha256", valid_601410
  var valid_601411 = header.getOrDefault("X-Amz-Algorithm")
  valid_601411 = validateParameter(valid_601411, JString, required = false,
                                 default = nil)
  if valid_601411 != nil:
    section.add "X-Amz-Algorithm", valid_601411
  var valid_601412 = header.getOrDefault("X-Amz-Signature")
  valid_601412 = validateParameter(valid_601412, JString, required = false,
                                 default = nil)
  if valid_601412 != nil:
    section.add "X-Amz-Signature", valid_601412
  var valid_601413 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601413 = validateParameter(valid_601413, JString, required = false,
                                 default = nil)
  if valid_601413 != nil:
    section.add "X-Amz-SignedHeaders", valid_601413
  var valid_601414 = header.getOrDefault("X-Amz-Credential")
  valid_601414 = validateParameter(valid_601414, JString, required = false,
                                 default = nil)
  if valid_601414 != nil:
    section.add "X-Amz-Credential", valid_601414
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  section = newJObject()
  var valid_601415 = formData.getOrDefault("Marker")
  valid_601415 = validateParameter(valid_601415, JString, required = false,
                                 default = nil)
  if valid_601415 != nil:
    section.add "Marker", valid_601415
  var valid_601416 = formData.getOrDefault("TagKeys")
  valid_601416 = validateParameter(valid_601416, JArray, required = false,
                                 default = nil)
  if valid_601416 != nil:
    section.add "TagKeys", valid_601416
  var valid_601417 = formData.getOrDefault("MaxRecords")
  valid_601417 = validateParameter(valid_601417, JInt, required = false, default = nil)
  if valid_601417 != nil:
    section.add "MaxRecords", valid_601417
  var valid_601418 = formData.getOrDefault("TagValues")
  valid_601418 = validateParameter(valid_601418, JArray, required = false,
                                 default = nil)
  if valid_601418 != nil:
    section.add "TagValues", valid_601418
  var valid_601419 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_601419 = validateParameter(valid_601419, JString, required = false,
                                 default = nil)
  if valid_601419 != nil:
    section.add "ClusterSubnetGroupName", valid_601419
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601420: Call_PostDescribeClusterSubnetGroups_601403;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601420.validator(path, query, header, formData, body)
  let scheme = call_601420.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601420.url(scheme.get, call_601420.host, call_601420.base,
                         call_601420.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601420, url, valid)

proc call*(call_601421: Call_PostDescribeClusterSubnetGroups_601403;
          Marker: string = ""; Action: string = "DescribeClusterSubnetGroups";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"; ClusterSubnetGroupName: string = ""): Recallable =
  ## postDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   Version: string (required)
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  var query_601422 = newJObject()
  var formData_601423 = newJObject()
  add(formData_601423, "Marker", newJString(Marker))
  add(query_601422, "Action", newJString(Action))
  if TagKeys != nil:
    formData_601423.add "TagKeys", TagKeys
  add(formData_601423, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_601423.add "TagValues", TagValues
  add(query_601422, "Version", newJString(Version))
  add(formData_601423, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_601421.call(nil, query_601422, nil, formData_601423, nil)

var postDescribeClusterSubnetGroups* = Call_PostDescribeClusterSubnetGroups_601403(
    name: "postDescribeClusterSubnetGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_PostDescribeClusterSubnetGroups_601404, base: "/",
    url: url_PostDescribeClusterSubnetGroups_601405,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSubnetGroups_601383 = ref object of OpenApiRestCall_599352
proc url_GetDescribeClusterSubnetGroups_601385(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterSubnetGroups_601384(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_601386 = query.getOrDefault("TagValues")
  valid_601386 = validateParameter(valid_601386, JArray, required = false,
                                 default = nil)
  if valid_601386 != nil:
    section.add "TagValues", valid_601386
  var valid_601387 = query.getOrDefault("ClusterSubnetGroupName")
  valid_601387 = validateParameter(valid_601387, JString, required = false,
                                 default = nil)
  if valid_601387 != nil:
    section.add "ClusterSubnetGroupName", valid_601387
  var valid_601388 = query.getOrDefault("MaxRecords")
  valid_601388 = validateParameter(valid_601388, JInt, required = false, default = nil)
  if valid_601388 != nil:
    section.add "MaxRecords", valid_601388
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601389 = query.getOrDefault("Action")
  valid_601389 = validateParameter(valid_601389, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_601389 != nil:
    section.add "Action", valid_601389
  var valid_601390 = query.getOrDefault("Marker")
  valid_601390 = validateParameter(valid_601390, JString, required = false,
                                 default = nil)
  if valid_601390 != nil:
    section.add "Marker", valid_601390
  var valid_601391 = query.getOrDefault("TagKeys")
  valid_601391 = validateParameter(valid_601391, JArray, required = false,
                                 default = nil)
  if valid_601391 != nil:
    section.add "TagKeys", valid_601391
  var valid_601392 = query.getOrDefault("Version")
  valid_601392 = validateParameter(valid_601392, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601392 != nil:
    section.add "Version", valid_601392
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601393 = header.getOrDefault("X-Amz-Date")
  valid_601393 = validateParameter(valid_601393, JString, required = false,
                                 default = nil)
  if valid_601393 != nil:
    section.add "X-Amz-Date", valid_601393
  var valid_601394 = header.getOrDefault("X-Amz-Security-Token")
  valid_601394 = validateParameter(valid_601394, JString, required = false,
                                 default = nil)
  if valid_601394 != nil:
    section.add "X-Amz-Security-Token", valid_601394
  var valid_601395 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601395 = validateParameter(valid_601395, JString, required = false,
                                 default = nil)
  if valid_601395 != nil:
    section.add "X-Amz-Content-Sha256", valid_601395
  var valid_601396 = header.getOrDefault("X-Amz-Algorithm")
  valid_601396 = validateParameter(valid_601396, JString, required = false,
                                 default = nil)
  if valid_601396 != nil:
    section.add "X-Amz-Algorithm", valid_601396
  var valid_601397 = header.getOrDefault("X-Amz-Signature")
  valid_601397 = validateParameter(valid_601397, JString, required = false,
                                 default = nil)
  if valid_601397 != nil:
    section.add "X-Amz-Signature", valid_601397
  var valid_601398 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601398 = validateParameter(valid_601398, JString, required = false,
                                 default = nil)
  if valid_601398 != nil:
    section.add "X-Amz-SignedHeaders", valid_601398
  var valid_601399 = header.getOrDefault("X-Amz-Credential")
  valid_601399 = validateParameter(valid_601399, JString, required = false,
                                 default = nil)
  if valid_601399 != nil:
    section.add "X-Amz-Credential", valid_601399
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601400: Call_GetDescribeClusterSubnetGroups_601383; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601400.validator(path, query, header, formData, body)
  let scheme = call_601400.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601400.url(scheme.get, call_601400.host, call_601400.base,
                         call_601400.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601400, url, valid)

proc call*(call_601401: Call_GetDescribeClusterSubnetGroups_601383;
          TagValues: JsonNode = nil; ClusterSubnetGroupName: string = "";
          MaxRecords: int = 0; Action: string = "DescribeClusterSubnetGroups";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_601402 = newJObject()
  if TagValues != nil:
    query_601402.add "TagValues", TagValues
  add(query_601402, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_601402, "MaxRecords", newJInt(MaxRecords))
  add(query_601402, "Action", newJString(Action))
  add(query_601402, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_601402.add "TagKeys", TagKeys
  add(query_601402, "Version", newJString(Version))
  result = call_601401.call(nil, query_601402, nil, nil, nil)

var getDescribeClusterSubnetGroups* = Call_GetDescribeClusterSubnetGroups_601383(
    name: "getDescribeClusterSubnetGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_GetDescribeClusterSubnetGroups_601384, base: "/",
    url: url_GetDescribeClusterSubnetGroups_601385,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterTracks_601442 = ref object of OpenApiRestCall_599352
proc url_PostDescribeClusterTracks_601444(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterTracks_601443(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601445 = query.getOrDefault("Action")
  valid_601445 = validateParameter(valid_601445, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_601445 != nil:
    section.add "Action", valid_601445
  var valid_601446 = query.getOrDefault("Version")
  valid_601446 = validateParameter(valid_601446, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601446 != nil:
    section.add "Version", valid_601446
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601447 = header.getOrDefault("X-Amz-Date")
  valid_601447 = validateParameter(valid_601447, JString, required = false,
                                 default = nil)
  if valid_601447 != nil:
    section.add "X-Amz-Date", valid_601447
  var valid_601448 = header.getOrDefault("X-Amz-Security-Token")
  valid_601448 = validateParameter(valid_601448, JString, required = false,
                                 default = nil)
  if valid_601448 != nil:
    section.add "X-Amz-Security-Token", valid_601448
  var valid_601449 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601449 = validateParameter(valid_601449, JString, required = false,
                                 default = nil)
  if valid_601449 != nil:
    section.add "X-Amz-Content-Sha256", valid_601449
  var valid_601450 = header.getOrDefault("X-Amz-Algorithm")
  valid_601450 = validateParameter(valid_601450, JString, required = false,
                                 default = nil)
  if valid_601450 != nil:
    section.add "X-Amz-Algorithm", valid_601450
  var valid_601451 = header.getOrDefault("X-Amz-Signature")
  valid_601451 = validateParameter(valid_601451, JString, required = false,
                                 default = nil)
  if valid_601451 != nil:
    section.add "X-Amz-Signature", valid_601451
  var valid_601452 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601452 = validateParameter(valid_601452, JString, required = false,
                                 default = nil)
  if valid_601452 != nil:
    section.add "X-Amz-SignedHeaders", valid_601452
  var valid_601453 = header.getOrDefault("X-Amz-Credential")
  valid_601453 = validateParameter(valid_601453, JString, required = false,
                                 default = nil)
  if valid_601453 != nil:
    section.add "X-Amz-Credential", valid_601453
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  section = newJObject()
  var valid_601454 = formData.getOrDefault("Marker")
  valid_601454 = validateParameter(valid_601454, JString, required = false,
                                 default = nil)
  if valid_601454 != nil:
    section.add "Marker", valid_601454
  var valid_601455 = formData.getOrDefault("MaxRecords")
  valid_601455 = validateParameter(valid_601455, JInt, required = false, default = nil)
  if valid_601455 != nil:
    section.add "MaxRecords", valid_601455
  var valid_601456 = formData.getOrDefault("MaintenanceTrackName")
  valid_601456 = validateParameter(valid_601456, JString, required = false,
                                 default = nil)
  if valid_601456 != nil:
    section.add "MaintenanceTrackName", valid_601456
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601457: Call_PostDescribeClusterTracks_601442; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_601457.validator(path, query, header, formData, body)
  let scheme = call_601457.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601457.url(scheme.get, call_601457.host, call_601457.base,
                         call_601457.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601457, url, valid)

proc call*(call_601458: Call_PostDescribeClusterTracks_601442; Marker: string = "";
          Action: string = "DescribeClusterTracks"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; MaintenanceTrackName: string = ""): Recallable =
  ## postDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Version: string (required)
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  var query_601459 = newJObject()
  var formData_601460 = newJObject()
  add(formData_601460, "Marker", newJString(Marker))
  add(query_601459, "Action", newJString(Action))
  add(formData_601460, "MaxRecords", newJInt(MaxRecords))
  add(query_601459, "Version", newJString(Version))
  add(formData_601460, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  result = call_601458.call(nil, query_601459, nil, formData_601460, nil)

var postDescribeClusterTracks* = Call_PostDescribeClusterTracks_601442(
    name: "postDescribeClusterTracks", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_PostDescribeClusterTracks_601443, base: "/",
    url: url_PostDescribeClusterTracks_601444,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterTracks_601424 = ref object of OpenApiRestCall_599352
proc url_GetDescribeClusterTracks_601426(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterTracks_601425(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_601427 = query.getOrDefault("MaintenanceTrackName")
  valid_601427 = validateParameter(valid_601427, JString, required = false,
                                 default = nil)
  if valid_601427 != nil:
    section.add "MaintenanceTrackName", valid_601427
  var valid_601428 = query.getOrDefault("MaxRecords")
  valid_601428 = validateParameter(valid_601428, JInt, required = false, default = nil)
  if valid_601428 != nil:
    section.add "MaxRecords", valid_601428
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601429 = query.getOrDefault("Action")
  valid_601429 = validateParameter(valid_601429, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_601429 != nil:
    section.add "Action", valid_601429
  var valid_601430 = query.getOrDefault("Marker")
  valid_601430 = validateParameter(valid_601430, JString, required = false,
                                 default = nil)
  if valid_601430 != nil:
    section.add "Marker", valid_601430
  var valid_601431 = query.getOrDefault("Version")
  valid_601431 = validateParameter(valid_601431, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601431 != nil:
    section.add "Version", valid_601431
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601432 = header.getOrDefault("X-Amz-Date")
  valid_601432 = validateParameter(valid_601432, JString, required = false,
                                 default = nil)
  if valid_601432 != nil:
    section.add "X-Amz-Date", valid_601432
  var valid_601433 = header.getOrDefault("X-Amz-Security-Token")
  valid_601433 = validateParameter(valid_601433, JString, required = false,
                                 default = nil)
  if valid_601433 != nil:
    section.add "X-Amz-Security-Token", valid_601433
  var valid_601434 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601434 = validateParameter(valid_601434, JString, required = false,
                                 default = nil)
  if valid_601434 != nil:
    section.add "X-Amz-Content-Sha256", valid_601434
  var valid_601435 = header.getOrDefault("X-Amz-Algorithm")
  valid_601435 = validateParameter(valid_601435, JString, required = false,
                                 default = nil)
  if valid_601435 != nil:
    section.add "X-Amz-Algorithm", valid_601435
  var valid_601436 = header.getOrDefault("X-Amz-Signature")
  valid_601436 = validateParameter(valid_601436, JString, required = false,
                                 default = nil)
  if valid_601436 != nil:
    section.add "X-Amz-Signature", valid_601436
  var valid_601437 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601437 = validateParameter(valid_601437, JString, required = false,
                                 default = nil)
  if valid_601437 != nil:
    section.add "X-Amz-SignedHeaders", valid_601437
  var valid_601438 = header.getOrDefault("X-Amz-Credential")
  valid_601438 = validateParameter(valid_601438, JString, required = false,
                                 default = nil)
  if valid_601438 != nil:
    section.add "X-Amz-Credential", valid_601438
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601439: Call_GetDescribeClusterTracks_601424; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_601439.validator(path, query, header, formData, body)
  let scheme = call_601439.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601439.url(scheme.get, call_601439.host, call_601439.base,
                         call_601439.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601439, url, valid)

proc call*(call_601440: Call_GetDescribeClusterTracks_601424;
          MaintenanceTrackName: string = ""; MaxRecords: int = 0;
          Action: string = "DescribeClusterTracks"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  var query_601441 = newJObject()
  add(query_601441, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_601441, "MaxRecords", newJInt(MaxRecords))
  add(query_601441, "Action", newJString(Action))
  add(query_601441, "Marker", newJString(Marker))
  add(query_601441, "Version", newJString(Version))
  result = call_601440.call(nil, query_601441, nil, nil, nil)

var getDescribeClusterTracks* = Call_GetDescribeClusterTracks_601424(
    name: "getDescribeClusterTracks", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_GetDescribeClusterTracks_601425, base: "/",
    url: url_GetDescribeClusterTracks_601426, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterVersions_601480 = ref object of OpenApiRestCall_599352
proc url_PostDescribeClusterVersions_601482(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusterVersions_601481(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601483 = query.getOrDefault("Action")
  valid_601483 = validateParameter(valid_601483, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_601483 != nil:
    section.add "Action", valid_601483
  var valid_601484 = query.getOrDefault("Version")
  valid_601484 = validateParameter(valid_601484, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601484 != nil:
    section.add "Version", valid_601484
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601485 = header.getOrDefault("X-Amz-Date")
  valid_601485 = validateParameter(valid_601485, JString, required = false,
                                 default = nil)
  if valid_601485 != nil:
    section.add "X-Amz-Date", valid_601485
  var valid_601486 = header.getOrDefault("X-Amz-Security-Token")
  valid_601486 = validateParameter(valid_601486, JString, required = false,
                                 default = nil)
  if valid_601486 != nil:
    section.add "X-Amz-Security-Token", valid_601486
  var valid_601487 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601487 = validateParameter(valid_601487, JString, required = false,
                                 default = nil)
  if valid_601487 != nil:
    section.add "X-Amz-Content-Sha256", valid_601487
  var valid_601488 = header.getOrDefault("X-Amz-Algorithm")
  valid_601488 = validateParameter(valid_601488, JString, required = false,
                                 default = nil)
  if valid_601488 != nil:
    section.add "X-Amz-Algorithm", valid_601488
  var valid_601489 = header.getOrDefault("X-Amz-Signature")
  valid_601489 = validateParameter(valid_601489, JString, required = false,
                                 default = nil)
  if valid_601489 != nil:
    section.add "X-Amz-Signature", valid_601489
  var valid_601490 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601490 = validateParameter(valid_601490, JString, required = false,
                                 default = nil)
  if valid_601490 != nil:
    section.add "X-Amz-SignedHeaders", valid_601490
  var valid_601491 = header.getOrDefault("X-Amz-Credential")
  valid_601491 = validateParameter(valid_601491, JString, required = false,
                                 default = nil)
  if valid_601491 != nil:
    section.add "X-Amz-Credential", valid_601491
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_601492 = formData.getOrDefault("ClusterVersion")
  valid_601492 = validateParameter(valid_601492, JString, required = false,
                                 default = nil)
  if valid_601492 != nil:
    section.add "ClusterVersion", valid_601492
  var valid_601493 = formData.getOrDefault("Marker")
  valid_601493 = validateParameter(valid_601493, JString, required = false,
                                 default = nil)
  if valid_601493 != nil:
    section.add "Marker", valid_601493
  var valid_601494 = formData.getOrDefault("ClusterParameterGroupFamily")
  valid_601494 = validateParameter(valid_601494, JString, required = false,
                                 default = nil)
  if valid_601494 != nil:
    section.add "ClusterParameterGroupFamily", valid_601494
  var valid_601495 = formData.getOrDefault("MaxRecords")
  valid_601495 = validateParameter(valid_601495, JInt, required = false, default = nil)
  if valid_601495 != nil:
    section.add "MaxRecords", valid_601495
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601496: Call_PostDescribeClusterVersions_601480; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_601496.validator(path, query, header, formData, body)
  let scheme = call_601496.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601496.url(scheme.get, call_601496.host, call_601496.base,
                         call_601496.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601496, url, valid)

proc call*(call_601497: Call_PostDescribeClusterVersions_601480;
          ClusterVersion: string = ""; Marker: string = "";
          Action: string = "DescribeClusterVersions";
          ClusterParameterGroupFamily: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_601498 = newJObject()
  var formData_601499 = newJObject()
  add(formData_601499, "ClusterVersion", newJString(ClusterVersion))
  add(formData_601499, "Marker", newJString(Marker))
  add(query_601498, "Action", newJString(Action))
  add(formData_601499, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(formData_601499, "MaxRecords", newJInt(MaxRecords))
  add(query_601498, "Version", newJString(Version))
  result = call_601497.call(nil, query_601498, nil, formData_601499, nil)

var postDescribeClusterVersions* = Call_PostDescribeClusterVersions_601480(
    name: "postDescribeClusterVersions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_PostDescribeClusterVersions_601481, base: "/",
    url: url_PostDescribeClusterVersions_601482,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterVersions_601461 = ref object of OpenApiRestCall_599352
proc url_GetDescribeClusterVersions_601463(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusterVersions_601462(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  section = newJObject()
  var valid_601464 = query.getOrDefault("MaxRecords")
  valid_601464 = validateParameter(valid_601464, JInt, required = false, default = nil)
  if valid_601464 != nil:
    section.add "MaxRecords", valid_601464
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601465 = query.getOrDefault("Action")
  valid_601465 = validateParameter(valid_601465, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_601465 != nil:
    section.add "Action", valid_601465
  var valid_601466 = query.getOrDefault("Marker")
  valid_601466 = validateParameter(valid_601466, JString, required = false,
                                 default = nil)
  if valid_601466 != nil:
    section.add "Marker", valid_601466
  var valid_601467 = query.getOrDefault("ClusterVersion")
  valid_601467 = validateParameter(valid_601467, JString, required = false,
                                 default = nil)
  if valid_601467 != nil:
    section.add "ClusterVersion", valid_601467
  var valid_601468 = query.getOrDefault("Version")
  valid_601468 = validateParameter(valid_601468, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601468 != nil:
    section.add "Version", valid_601468
  var valid_601469 = query.getOrDefault("ClusterParameterGroupFamily")
  valid_601469 = validateParameter(valid_601469, JString, required = false,
                                 default = nil)
  if valid_601469 != nil:
    section.add "ClusterParameterGroupFamily", valid_601469
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601470 = header.getOrDefault("X-Amz-Date")
  valid_601470 = validateParameter(valid_601470, JString, required = false,
                                 default = nil)
  if valid_601470 != nil:
    section.add "X-Amz-Date", valid_601470
  var valid_601471 = header.getOrDefault("X-Amz-Security-Token")
  valid_601471 = validateParameter(valid_601471, JString, required = false,
                                 default = nil)
  if valid_601471 != nil:
    section.add "X-Amz-Security-Token", valid_601471
  var valid_601472 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601472 = validateParameter(valid_601472, JString, required = false,
                                 default = nil)
  if valid_601472 != nil:
    section.add "X-Amz-Content-Sha256", valid_601472
  var valid_601473 = header.getOrDefault("X-Amz-Algorithm")
  valid_601473 = validateParameter(valid_601473, JString, required = false,
                                 default = nil)
  if valid_601473 != nil:
    section.add "X-Amz-Algorithm", valid_601473
  var valid_601474 = header.getOrDefault("X-Amz-Signature")
  valid_601474 = validateParameter(valid_601474, JString, required = false,
                                 default = nil)
  if valid_601474 != nil:
    section.add "X-Amz-Signature", valid_601474
  var valid_601475 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601475 = validateParameter(valid_601475, JString, required = false,
                                 default = nil)
  if valid_601475 != nil:
    section.add "X-Amz-SignedHeaders", valid_601475
  var valid_601476 = header.getOrDefault("X-Amz-Credential")
  valid_601476 = validateParameter(valid_601476, JString, required = false,
                                 default = nil)
  if valid_601476 != nil:
    section.add "X-Amz-Credential", valid_601476
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601477: Call_GetDescribeClusterVersions_601461; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_601477.validator(path, query, header, formData, body)
  let scheme = call_601477.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601477.url(scheme.get, call_601477.host, call_601477.base,
                         call_601477.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601477, url, valid)

proc call*(call_601478: Call_GetDescribeClusterVersions_601461;
          MaxRecords: int = 0; Action: string = "DescribeClusterVersions";
          Marker: string = ""; ClusterVersion: string = "";
          Version: string = "2012-12-01"; ClusterParameterGroupFamily: string = ""): Recallable =
  ## getDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  var query_601479 = newJObject()
  add(query_601479, "MaxRecords", newJInt(MaxRecords))
  add(query_601479, "Action", newJString(Action))
  add(query_601479, "Marker", newJString(Marker))
  add(query_601479, "ClusterVersion", newJString(ClusterVersion))
  add(query_601479, "Version", newJString(Version))
  add(query_601479, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  result = call_601478.call(nil, query_601479, nil, nil, nil)

var getDescribeClusterVersions* = Call_GetDescribeClusterVersions_601461(
    name: "getDescribeClusterVersions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_GetDescribeClusterVersions_601462, base: "/",
    url: url_GetDescribeClusterVersions_601463,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusters_601520 = ref object of OpenApiRestCall_599352
proc url_PostDescribeClusters_601522(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeClusters_601521(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601523 = query.getOrDefault("Action")
  valid_601523 = validateParameter(valid_601523, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_601523 != nil:
    section.add "Action", valid_601523
  var valid_601524 = query.getOrDefault("Version")
  valid_601524 = validateParameter(valid_601524, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601524 != nil:
    section.add "Version", valid_601524
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601525 = header.getOrDefault("X-Amz-Date")
  valid_601525 = validateParameter(valid_601525, JString, required = false,
                                 default = nil)
  if valid_601525 != nil:
    section.add "X-Amz-Date", valid_601525
  var valid_601526 = header.getOrDefault("X-Amz-Security-Token")
  valid_601526 = validateParameter(valid_601526, JString, required = false,
                                 default = nil)
  if valid_601526 != nil:
    section.add "X-Amz-Security-Token", valid_601526
  var valid_601527 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601527 = validateParameter(valid_601527, JString, required = false,
                                 default = nil)
  if valid_601527 != nil:
    section.add "X-Amz-Content-Sha256", valid_601527
  var valid_601528 = header.getOrDefault("X-Amz-Algorithm")
  valid_601528 = validateParameter(valid_601528, JString, required = false,
                                 default = nil)
  if valid_601528 != nil:
    section.add "X-Amz-Algorithm", valid_601528
  var valid_601529 = header.getOrDefault("X-Amz-Signature")
  valid_601529 = validateParameter(valid_601529, JString, required = false,
                                 default = nil)
  if valid_601529 != nil:
    section.add "X-Amz-Signature", valid_601529
  var valid_601530 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601530 = validateParameter(valid_601530, JString, required = false,
                                 default = nil)
  if valid_601530 != nil:
    section.add "X-Amz-SignedHeaders", valid_601530
  var valid_601531 = header.getOrDefault("X-Amz-Credential")
  valid_601531 = validateParameter(valid_601531, JString, required = false,
                                 default = nil)
  if valid_601531 != nil:
    section.add "X-Amz-Credential", valid_601531
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_601532 = formData.getOrDefault("Marker")
  valid_601532 = validateParameter(valid_601532, JString, required = false,
                                 default = nil)
  if valid_601532 != nil:
    section.add "Marker", valid_601532
  var valid_601533 = formData.getOrDefault("ClusterIdentifier")
  valid_601533 = validateParameter(valid_601533, JString, required = false,
                                 default = nil)
  if valid_601533 != nil:
    section.add "ClusterIdentifier", valid_601533
  var valid_601534 = formData.getOrDefault("TagKeys")
  valid_601534 = validateParameter(valid_601534, JArray, required = false,
                                 default = nil)
  if valid_601534 != nil:
    section.add "TagKeys", valid_601534
  var valid_601535 = formData.getOrDefault("MaxRecords")
  valid_601535 = validateParameter(valid_601535, JInt, required = false, default = nil)
  if valid_601535 != nil:
    section.add "MaxRecords", valid_601535
  var valid_601536 = formData.getOrDefault("TagValues")
  valid_601536 = validateParameter(valid_601536, JArray, required = false,
                                 default = nil)
  if valid_601536 != nil:
    section.add "TagValues", valid_601536
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601537: Call_PostDescribeClusters_601520; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601537.validator(path, query, header, formData, body)
  let scheme = call_601537.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601537.url(scheme.get, call_601537.host, call_601537.base,
                         call_601537.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601537, url, valid)

proc call*(call_601538: Call_PostDescribeClusters_601520; Marker: string = "";
          Action: string = "DescribeClusters"; ClusterIdentifier: string = "";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_601539 = newJObject()
  var formData_601540 = newJObject()
  add(formData_601540, "Marker", newJString(Marker))
  add(query_601539, "Action", newJString(Action))
  add(formData_601540, "ClusterIdentifier", newJString(ClusterIdentifier))
  if TagKeys != nil:
    formData_601540.add "TagKeys", TagKeys
  add(formData_601540, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_601540.add "TagValues", TagValues
  add(query_601539, "Version", newJString(Version))
  result = call_601538.call(nil, query_601539, nil, formData_601540, nil)

var postDescribeClusters* = Call_PostDescribeClusters_601520(
    name: "postDescribeClusters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_PostDescribeClusters_601521, base: "/",
    url: url_PostDescribeClusters_601522, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusters_601500 = ref object of OpenApiRestCall_599352
proc url_GetDescribeClusters_601502(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeClusters_601501(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_601503 = query.getOrDefault("TagValues")
  valid_601503 = validateParameter(valid_601503, JArray, required = false,
                                 default = nil)
  if valid_601503 != nil:
    section.add "TagValues", valid_601503
  var valid_601504 = query.getOrDefault("MaxRecords")
  valid_601504 = validateParameter(valid_601504, JInt, required = false, default = nil)
  if valid_601504 != nil:
    section.add "MaxRecords", valid_601504
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601505 = query.getOrDefault("Action")
  valid_601505 = validateParameter(valid_601505, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_601505 != nil:
    section.add "Action", valid_601505
  var valid_601506 = query.getOrDefault("ClusterIdentifier")
  valid_601506 = validateParameter(valid_601506, JString, required = false,
                                 default = nil)
  if valid_601506 != nil:
    section.add "ClusterIdentifier", valid_601506
  var valid_601507 = query.getOrDefault("Marker")
  valid_601507 = validateParameter(valid_601507, JString, required = false,
                                 default = nil)
  if valid_601507 != nil:
    section.add "Marker", valid_601507
  var valid_601508 = query.getOrDefault("TagKeys")
  valid_601508 = validateParameter(valid_601508, JArray, required = false,
                                 default = nil)
  if valid_601508 != nil:
    section.add "TagKeys", valid_601508
  var valid_601509 = query.getOrDefault("Version")
  valid_601509 = validateParameter(valid_601509, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601509 != nil:
    section.add "Version", valid_601509
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601510 = header.getOrDefault("X-Amz-Date")
  valid_601510 = validateParameter(valid_601510, JString, required = false,
                                 default = nil)
  if valid_601510 != nil:
    section.add "X-Amz-Date", valid_601510
  var valid_601511 = header.getOrDefault("X-Amz-Security-Token")
  valid_601511 = validateParameter(valid_601511, JString, required = false,
                                 default = nil)
  if valid_601511 != nil:
    section.add "X-Amz-Security-Token", valid_601511
  var valid_601512 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601512 = validateParameter(valid_601512, JString, required = false,
                                 default = nil)
  if valid_601512 != nil:
    section.add "X-Amz-Content-Sha256", valid_601512
  var valid_601513 = header.getOrDefault("X-Amz-Algorithm")
  valid_601513 = validateParameter(valid_601513, JString, required = false,
                                 default = nil)
  if valid_601513 != nil:
    section.add "X-Amz-Algorithm", valid_601513
  var valid_601514 = header.getOrDefault("X-Amz-Signature")
  valid_601514 = validateParameter(valid_601514, JString, required = false,
                                 default = nil)
  if valid_601514 != nil:
    section.add "X-Amz-Signature", valid_601514
  var valid_601515 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601515 = validateParameter(valid_601515, JString, required = false,
                                 default = nil)
  if valid_601515 != nil:
    section.add "X-Amz-SignedHeaders", valid_601515
  var valid_601516 = header.getOrDefault("X-Amz-Credential")
  valid_601516 = validateParameter(valid_601516, JString, required = false,
                                 default = nil)
  if valid_601516 != nil:
    section.add "X-Amz-Credential", valid_601516
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601517: Call_GetDescribeClusters_601500; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601517.validator(path, query, header, formData, body)
  let scheme = call_601517.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601517.url(scheme.get, call_601517.host, call_601517.base,
                         call_601517.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601517, url, valid)

proc call*(call_601518: Call_GetDescribeClusters_601500; TagValues: JsonNode = nil;
          MaxRecords: int = 0; Action: string = "DescribeClusters";
          ClusterIdentifier: string = ""; Marker: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_601519 = newJObject()
  if TagValues != nil:
    query_601519.add "TagValues", TagValues
  add(query_601519, "MaxRecords", newJInt(MaxRecords))
  add(query_601519, "Action", newJString(Action))
  add(query_601519, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_601519, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_601519.add "TagKeys", TagKeys
  add(query_601519, "Version", newJString(Version))
  result = call_601518.call(nil, query_601519, nil, nil, nil)

var getDescribeClusters* = Call_GetDescribeClusters_601500(
    name: "getDescribeClusters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_GetDescribeClusters_601501, base: "/",
    url: url_GetDescribeClusters_601502, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeDefaultClusterParameters_601559 = ref object of OpenApiRestCall_599352
proc url_PostDescribeDefaultClusterParameters_601561(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeDefaultClusterParameters_601560(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601562 = query.getOrDefault("Action")
  valid_601562 = validateParameter(valid_601562, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_601562 != nil:
    section.add "Action", valid_601562
  var valid_601563 = query.getOrDefault("Version")
  valid_601563 = validateParameter(valid_601563, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601563 != nil:
    section.add "Version", valid_601563
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601564 = header.getOrDefault("X-Amz-Date")
  valid_601564 = validateParameter(valid_601564, JString, required = false,
                                 default = nil)
  if valid_601564 != nil:
    section.add "X-Amz-Date", valid_601564
  var valid_601565 = header.getOrDefault("X-Amz-Security-Token")
  valid_601565 = validateParameter(valid_601565, JString, required = false,
                                 default = nil)
  if valid_601565 != nil:
    section.add "X-Amz-Security-Token", valid_601565
  var valid_601566 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601566 = validateParameter(valid_601566, JString, required = false,
                                 default = nil)
  if valid_601566 != nil:
    section.add "X-Amz-Content-Sha256", valid_601566
  var valid_601567 = header.getOrDefault("X-Amz-Algorithm")
  valid_601567 = validateParameter(valid_601567, JString, required = false,
                                 default = nil)
  if valid_601567 != nil:
    section.add "X-Amz-Algorithm", valid_601567
  var valid_601568 = header.getOrDefault("X-Amz-Signature")
  valid_601568 = validateParameter(valid_601568, JString, required = false,
                                 default = nil)
  if valid_601568 != nil:
    section.add "X-Amz-Signature", valid_601568
  var valid_601569 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601569 = validateParameter(valid_601569, JString, required = false,
                                 default = nil)
  if valid_601569 != nil:
    section.add "X-Amz-SignedHeaders", valid_601569
  var valid_601570 = header.getOrDefault("X-Amz-Credential")
  valid_601570 = validateParameter(valid_601570, JString, required = false,
                                 default = nil)
  if valid_601570 != nil:
    section.add "X-Amz-Credential", valid_601570
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_601571 = formData.getOrDefault("Marker")
  valid_601571 = validateParameter(valid_601571, JString, required = false,
                                 default = nil)
  if valid_601571 != nil:
    section.add "Marker", valid_601571
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupFamily` field"
  var valid_601572 = formData.getOrDefault("ParameterGroupFamily")
  valid_601572 = validateParameter(valid_601572, JString, required = true,
                                 default = nil)
  if valid_601572 != nil:
    section.add "ParameterGroupFamily", valid_601572
  var valid_601573 = formData.getOrDefault("MaxRecords")
  valid_601573 = validateParameter(valid_601573, JInt, required = false, default = nil)
  if valid_601573 != nil:
    section.add "MaxRecords", valid_601573
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601574: Call_PostDescribeDefaultClusterParameters_601559;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_601574.validator(path, query, header, formData, body)
  let scheme = call_601574.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601574.url(scheme.get, call_601574.host, call_601574.base,
                         call_601574.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601574, url, valid)

proc call*(call_601575: Call_PostDescribeDefaultClusterParameters_601559;
          ParameterGroupFamily: string; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_601576 = newJObject()
  var formData_601577 = newJObject()
  add(formData_601577, "Marker", newJString(Marker))
  add(query_601576, "Action", newJString(Action))
  add(formData_601577, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(formData_601577, "MaxRecords", newJInt(MaxRecords))
  add(query_601576, "Version", newJString(Version))
  result = call_601575.call(nil, query_601576, nil, formData_601577, nil)

var postDescribeDefaultClusterParameters* = Call_PostDescribeDefaultClusterParameters_601559(
    name: "postDescribeDefaultClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_PostDescribeDefaultClusterParameters_601560, base: "/",
    url: url_PostDescribeDefaultClusterParameters_601561,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeDefaultClusterParameters_601541 = ref object of OpenApiRestCall_599352
proc url_GetDescribeDefaultClusterParameters_601543(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeDefaultClusterParameters_601542(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   Version: JString (required)
  section = newJObject()
  var valid_601544 = query.getOrDefault("MaxRecords")
  valid_601544 = validateParameter(valid_601544, JInt, required = false, default = nil)
  if valid_601544 != nil:
    section.add "MaxRecords", valid_601544
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601545 = query.getOrDefault("Action")
  valid_601545 = validateParameter(valid_601545, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_601545 != nil:
    section.add "Action", valid_601545
  var valid_601546 = query.getOrDefault("Marker")
  valid_601546 = validateParameter(valid_601546, JString, required = false,
                                 default = nil)
  if valid_601546 != nil:
    section.add "Marker", valid_601546
  var valid_601547 = query.getOrDefault("ParameterGroupFamily")
  valid_601547 = validateParameter(valid_601547, JString, required = true,
                                 default = nil)
  if valid_601547 != nil:
    section.add "ParameterGroupFamily", valid_601547
  var valid_601548 = query.getOrDefault("Version")
  valid_601548 = validateParameter(valid_601548, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601548 != nil:
    section.add "Version", valid_601548
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601549 = header.getOrDefault("X-Amz-Date")
  valid_601549 = validateParameter(valid_601549, JString, required = false,
                                 default = nil)
  if valid_601549 != nil:
    section.add "X-Amz-Date", valid_601549
  var valid_601550 = header.getOrDefault("X-Amz-Security-Token")
  valid_601550 = validateParameter(valid_601550, JString, required = false,
                                 default = nil)
  if valid_601550 != nil:
    section.add "X-Amz-Security-Token", valid_601550
  var valid_601551 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601551 = validateParameter(valid_601551, JString, required = false,
                                 default = nil)
  if valid_601551 != nil:
    section.add "X-Amz-Content-Sha256", valid_601551
  var valid_601552 = header.getOrDefault("X-Amz-Algorithm")
  valid_601552 = validateParameter(valid_601552, JString, required = false,
                                 default = nil)
  if valid_601552 != nil:
    section.add "X-Amz-Algorithm", valid_601552
  var valid_601553 = header.getOrDefault("X-Amz-Signature")
  valid_601553 = validateParameter(valid_601553, JString, required = false,
                                 default = nil)
  if valid_601553 != nil:
    section.add "X-Amz-Signature", valid_601553
  var valid_601554 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601554 = validateParameter(valid_601554, JString, required = false,
                                 default = nil)
  if valid_601554 != nil:
    section.add "X-Amz-SignedHeaders", valid_601554
  var valid_601555 = header.getOrDefault("X-Amz-Credential")
  valid_601555 = validateParameter(valid_601555, JString, required = false,
                                 default = nil)
  if valid_601555 != nil:
    section.add "X-Amz-Credential", valid_601555
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601556: Call_GetDescribeDefaultClusterParameters_601541;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_601556.validator(path, query, header, formData, body)
  let scheme = call_601556.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601556.url(scheme.get, call_601556.host, call_601556.base,
                         call_601556.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601556, url, valid)

proc call*(call_601557: Call_GetDescribeDefaultClusterParameters_601541;
          ParameterGroupFamily: string; MaxRecords: int = 0;
          Action: string = "DescribeDefaultClusterParameters"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Version: string (required)
  var query_601558 = newJObject()
  add(query_601558, "MaxRecords", newJInt(MaxRecords))
  add(query_601558, "Action", newJString(Action))
  add(query_601558, "Marker", newJString(Marker))
  add(query_601558, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_601558, "Version", newJString(Version))
  result = call_601557.call(nil, query_601558, nil, nil, nil)

var getDescribeDefaultClusterParameters* = Call_GetDescribeDefaultClusterParameters_601541(
    name: "getDescribeDefaultClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_GetDescribeDefaultClusterParameters_601542, base: "/",
    url: url_GetDescribeDefaultClusterParameters_601543,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventCategories_601594 = ref object of OpenApiRestCall_599352
proc url_PostDescribeEventCategories_601596(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventCategories_601595(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601597 = query.getOrDefault("Action")
  valid_601597 = validateParameter(valid_601597, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_601597 != nil:
    section.add "Action", valid_601597
  var valid_601598 = query.getOrDefault("Version")
  valid_601598 = validateParameter(valid_601598, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601598 != nil:
    section.add "Version", valid_601598
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601599 = header.getOrDefault("X-Amz-Date")
  valid_601599 = validateParameter(valid_601599, JString, required = false,
                                 default = nil)
  if valid_601599 != nil:
    section.add "X-Amz-Date", valid_601599
  var valid_601600 = header.getOrDefault("X-Amz-Security-Token")
  valid_601600 = validateParameter(valid_601600, JString, required = false,
                                 default = nil)
  if valid_601600 != nil:
    section.add "X-Amz-Security-Token", valid_601600
  var valid_601601 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601601 = validateParameter(valid_601601, JString, required = false,
                                 default = nil)
  if valid_601601 != nil:
    section.add "X-Amz-Content-Sha256", valid_601601
  var valid_601602 = header.getOrDefault("X-Amz-Algorithm")
  valid_601602 = validateParameter(valid_601602, JString, required = false,
                                 default = nil)
  if valid_601602 != nil:
    section.add "X-Amz-Algorithm", valid_601602
  var valid_601603 = header.getOrDefault("X-Amz-Signature")
  valid_601603 = validateParameter(valid_601603, JString, required = false,
                                 default = nil)
  if valid_601603 != nil:
    section.add "X-Amz-Signature", valid_601603
  var valid_601604 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601604 = validateParameter(valid_601604, JString, required = false,
                                 default = nil)
  if valid_601604 != nil:
    section.add "X-Amz-SignedHeaders", valid_601604
  var valid_601605 = header.getOrDefault("X-Amz-Credential")
  valid_601605 = validateParameter(valid_601605, JString, required = false,
                                 default = nil)
  if valid_601605 != nil:
    section.add "X-Amz-Credential", valid_601605
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  section = newJObject()
  var valid_601606 = formData.getOrDefault("SourceType")
  valid_601606 = validateParameter(valid_601606, JString, required = false,
                                 default = nil)
  if valid_601606 != nil:
    section.add "SourceType", valid_601606
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601607: Call_PostDescribeEventCategories_601594; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_601607.validator(path, query, header, formData, body)
  let scheme = call_601607.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601607.url(scheme.get, call_601607.host, call_601607.base,
                         call_601607.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601607, url, valid)

proc call*(call_601608: Call_PostDescribeEventCategories_601594;
          Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  var query_601609 = newJObject()
  var formData_601610 = newJObject()
  add(query_601609, "Action", newJString(Action))
  add(query_601609, "Version", newJString(Version))
  add(formData_601610, "SourceType", newJString(SourceType))
  result = call_601608.call(nil, query_601609, nil, formData_601610, nil)

var postDescribeEventCategories* = Call_PostDescribeEventCategories_601594(
    name: "postDescribeEventCategories", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_PostDescribeEventCategories_601595, base: "/",
    url: url_PostDescribeEventCategories_601596,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventCategories_601578 = ref object of OpenApiRestCall_599352
proc url_GetDescribeEventCategories_601580(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventCategories_601579(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_601581 = query.getOrDefault("SourceType")
  valid_601581 = validateParameter(valid_601581, JString, required = false,
                                 default = nil)
  if valid_601581 != nil:
    section.add "SourceType", valid_601581
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601582 = query.getOrDefault("Action")
  valid_601582 = validateParameter(valid_601582, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_601582 != nil:
    section.add "Action", valid_601582
  var valid_601583 = query.getOrDefault("Version")
  valid_601583 = validateParameter(valid_601583, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601583 != nil:
    section.add "Version", valid_601583
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601584 = header.getOrDefault("X-Amz-Date")
  valid_601584 = validateParameter(valid_601584, JString, required = false,
                                 default = nil)
  if valid_601584 != nil:
    section.add "X-Amz-Date", valid_601584
  var valid_601585 = header.getOrDefault("X-Amz-Security-Token")
  valid_601585 = validateParameter(valid_601585, JString, required = false,
                                 default = nil)
  if valid_601585 != nil:
    section.add "X-Amz-Security-Token", valid_601585
  var valid_601586 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601586 = validateParameter(valid_601586, JString, required = false,
                                 default = nil)
  if valid_601586 != nil:
    section.add "X-Amz-Content-Sha256", valid_601586
  var valid_601587 = header.getOrDefault("X-Amz-Algorithm")
  valid_601587 = validateParameter(valid_601587, JString, required = false,
                                 default = nil)
  if valid_601587 != nil:
    section.add "X-Amz-Algorithm", valid_601587
  var valid_601588 = header.getOrDefault("X-Amz-Signature")
  valid_601588 = validateParameter(valid_601588, JString, required = false,
                                 default = nil)
  if valid_601588 != nil:
    section.add "X-Amz-Signature", valid_601588
  var valid_601589 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601589 = validateParameter(valid_601589, JString, required = false,
                                 default = nil)
  if valid_601589 != nil:
    section.add "X-Amz-SignedHeaders", valid_601589
  var valid_601590 = header.getOrDefault("X-Amz-Credential")
  valid_601590 = validateParameter(valid_601590, JString, required = false,
                                 default = nil)
  if valid_601590 != nil:
    section.add "X-Amz-Credential", valid_601590
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601591: Call_GetDescribeEventCategories_601578; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_601591.validator(path, query, header, formData, body)
  let scheme = call_601591.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601591.url(scheme.get, call_601591.host, call_601591.base,
                         call_601591.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601591, url, valid)

proc call*(call_601592: Call_GetDescribeEventCategories_601578;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_601593 = newJObject()
  add(query_601593, "SourceType", newJString(SourceType))
  add(query_601593, "Action", newJString(Action))
  add(query_601593, "Version", newJString(Version))
  result = call_601592.call(nil, query_601593, nil, nil, nil)

var getDescribeEventCategories* = Call_GetDescribeEventCategories_601578(
    name: "getDescribeEventCategories", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_GetDescribeEventCategories_601579, base: "/",
    url: url_GetDescribeEventCategories_601580,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventSubscriptions_601631 = ref object of OpenApiRestCall_599352
proc url_PostDescribeEventSubscriptions_601633(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEventSubscriptions_601632(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601634 = query.getOrDefault("Action")
  valid_601634 = validateParameter(valid_601634, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_601634 != nil:
    section.add "Action", valid_601634
  var valid_601635 = query.getOrDefault("Version")
  valid_601635 = validateParameter(valid_601635, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601635 != nil:
    section.add "Version", valid_601635
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601636 = header.getOrDefault("X-Amz-Date")
  valid_601636 = validateParameter(valid_601636, JString, required = false,
                                 default = nil)
  if valid_601636 != nil:
    section.add "X-Amz-Date", valid_601636
  var valid_601637 = header.getOrDefault("X-Amz-Security-Token")
  valid_601637 = validateParameter(valid_601637, JString, required = false,
                                 default = nil)
  if valid_601637 != nil:
    section.add "X-Amz-Security-Token", valid_601637
  var valid_601638 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601638 = validateParameter(valid_601638, JString, required = false,
                                 default = nil)
  if valid_601638 != nil:
    section.add "X-Amz-Content-Sha256", valid_601638
  var valid_601639 = header.getOrDefault("X-Amz-Algorithm")
  valid_601639 = validateParameter(valid_601639, JString, required = false,
                                 default = nil)
  if valid_601639 != nil:
    section.add "X-Amz-Algorithm", valid_601639
  var valid_601640 = header.getOrDefault("X-Amz-Signature")
  valid_601640 = validateParameter(valid_601640, JString, required = false,
                                 default = nil)
  if valid_601640 != nil:
    section.add "X-Amz-Signature", valid_601640
  var valid_601641 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601641 = validateParameter(valid_601641, JString, required = false,
                                 default = nil)
  if valid_601641 != nil:
    section.add "X-Amz-SignedHeaders", valid_601641
  var valid_601642 = header.getOrDefault("X-Amz-Credential")
  valid_601642 = validateParameter(valid_601642, JString, required = false,
                                 default = nil)
  if valid_601642 != nil:
    section.add "X-Amz-Credential", valid_601642
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_601643 = formData.getOrDefault("Marker")
  valid_601643 = validateParameter(valid_601643, JString, required = false,
                                 default = nil)
  if valid_601643 != nil:
    section.add "Marker", valid_601643
  var valid_601644 = formData.getOrDefault("SubscriptionName")
  valid_601644 = validateParameter(valid_601644, JString, required = false,
                                 default = nil)
  if valid_601644 != nil:
    section.add "SubscriptionName", valid_601644
  var valid_601645 = formData.getOrDefault("TagKeys")
  valid_601645 = validateParameter(valid_601645, JArray, required = false,
                                 default = nil)
  if valid_601645 != nil:
    section.add "TagKeys", valid_601645
  var valid_601646 = formData.getOrDefault("MaxRecords")
  valid_601646 = validateParameter(valid_601646, JInt, required = false, default = nil)
  if valid_601646 != nil:
    section.add "MaxRecords", valid_601646
  var valid_601647 = formData.getOrDefault("TagValues")
  valid_601647 = validateParameter(valid_601647, JArray, required = false,
                                 default = nil)
  if valid_601647 != nil:
    section.add "TagValues", valid_601647
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601648: Call_PostDescribeEventSubscriptions_601631; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601648.validator(path, query, header, formData, body)
  let scheme = call_601648.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601648.url(scheme.get, call_601648.host, call_601648.base,
                         call_601648.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601648, url, valid)

proc call*(call_601649: Call_PostDescribeEventSubscriptions_601631;
          Marker: string = ""; SubscriptionName: string = "";
          Action: string = "DescribeEventSubscriptions"; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_601650 = newJObject()
  var formData_601651 = newJObject()
  add(formData_601651, "Marker", newJString(Marker))
  add(formData_601651, "SubscriptionName", newJString(SubscriptionName))
  add(query_601650, "Action", newJString(Action))
  if TagKeys != nil:
    formData_601651.add "TagKeys", TagKeys
  add(formData_601651, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_601651.add "TagValues", TagValues
  add(query_601650, "Version", newJString(Version))
  result = call_601649.call(nil, query_601650, nil, formData_601651, nil)

var postDescribeEventSubscriptions* = Call_PostDescribeEventSubscriptions_601631(
    name: "postDescribeEventSubscriptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_PostDescribeEventSubscriptions_601632, base: "/",
    url: url_PostDescribeEventSubscriptions_601633,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventSubscriptions_601611 = ref object of OpenApiRestCall_599352
proc url_GetDescribeEventSubscriptions_601613(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEventSubscriptions_601612(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_601614 = query.getOrDefault("TagValues")
  valid_601614 = validateParameter(valid_601614, JArray, required = false,
                                 default = nil)
  if valid_601614 != nil:
    section.add "TagValues", valid_601614
  var valid_601615 = query.getOrDefault("MaxRecords")
  valid_601615 = validateParameter(valid_601615, JInt, required = false, default = nil)
  if valid_601615 != nil:
    section.add "MaxRecords", valid_601615
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601616 = query.getOrDefault("Action")
  valid_601616 = validateParameter(valid_601616, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_601616 != nil:
    section.add "Action", valid_601616
  var valid_601617 = query.getOrDefault("Marker")
  valid_601617 = validateParameter(valid_601617, JString, required = false,
                                 default = nil)
  if valid_601617 != nil:
    section.add "Marker", valid_601617
  var valid_601618 = query.getOrDefault("SubscriptionName")
  valid_601618 = validateParameter(valid_601618, JString, required = false,
                                 default = nil)
  if valid_601618 != nil:
    section.add "SubscriptionName", valid_601618
  var valid_601619 = query.getOrDefault("TagKeys")
  valid_601619 = validateParameter(valid_601619, JArray, required = false,
                                 default = nil)
  if valid_601619 != nil:
    section.add "TagKeys", valid_601619
  var valid_601620 = query.getOrDefault("Version")
  valid_601620 = validateParameter(valid_601620, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601620 != nil:
    section.add "Version", valid_601620
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601621 = header.getOrDefault("X-Amz-Date")
  valid_601621 = validateParameter(valid_601621, JString, required = false,
                                 default = nil)
  if valid_601621 != nil:
    section.add "X-Amz-Date", valid_601621
  var valid_601622 = header.getOrDefault("X-Amz-Security-Token")
  valid_601622 = validateParameter(valid_601622, JString, required = false,
                                 default = nil)
  if valid_601622 != nil:
    section.add "X-Amz-Security-Token", valid_601622
  var valid_601623 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601623 = validateParameter(valid_601623, JString, required = false,
                                 default = nil)
  if valid_601623 != nil:
    section.add "X-Amz-Content-Sha256", valid_601623
  var valid_601624 = header.getOrDefault("X-Amz-Algorithm")
  valid_601624 = validateParameter(valid_601624, JString, required = false,
                                 default = nil)
  if valid_601624 != nil:
    section.add "X-Amz-Algorithm", valid_601624
  var valid_601625 = header.getOrDefault("X-Amz-Signature")
  valid_601625 = validateParameter(valid_601625, JString, required = false,
                                 default = nil)
  if valid_601625 != nil:
    section.add "X-Amz-Signature", valid_601625
  var valid_601626 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601626 = validateParameter(valid_601626, JString, required = false,
                                 default = nil)
  if valid_601626 != nil:
    section.add "X-Amz-SignedHeaders", valid_601626
  var valid_601627 = header.getOrDefault("X-Amz-Credential")
  valid_601627 = validateParameter(valid_601627, JString, required = false,
                                 default = nil)
  if valid_601627 != nil:
    section.add "X-Amz-Credential", valid_601627
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601628: Call_GetDescribeEventSubscriptions_601611; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601628.validator(path, query, header, formData, body)
  let scheme = call_601628.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601628.url(scheme.get, call_601628.host, call_601628.base,
                         call_601628.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601628, url, valid)

proc call*(call_601629: Call_GetDescribeEventSubscriptions_601611;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeEventSubscriptions"; Marker: string = "";
          SubscriptionName: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_601630 = newJObject()
  if TagValues != nil:
    query_601630.add "TagValues", TagValues
  add(query_601630, "MaxRecords", newJInt(MaxRecords))
  add(query_601630, "Action", newJString(Action))
  add(query_601630, "Marker", newJString(Marker))
  add(query_601630, "SubscriptionName", newJString(SubscriptionName))
  if TagKeys != nil:
    query_601630.add "TagKeys", TagKeys
  add(query_601630, "Version", newJString(Version))
  result = call_601629.call(nil, query_601630, nil, nil, nil)

var getDescribeEventSubscriptions* = Call_GetDescribeEventSubscriptions_601611(
    name: "getDescribeEventSubscriptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_GetDescribeEventSubscriptions_601612, base: "/",
    url: url_GetDescribeEventSubscriptions_601613,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEvents_601674 = ref object of OpenApiRestCall_599352
proc url_PostDescribeEvents_601676(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeEvents_601675(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601677 = query.getOrDefault("Action")
  valid_601677 = validateParameter(valid_601677, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_601677 != nil:
    section.add "Action", valid_601677
  var valid_601678 = query.getOrDefault("Version")
  valid_601678 = validateParameter(valid_601678, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601678 != nil:
    section.add "Version", valid_601678
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601679 = header.getOrDefault("X-Amz-Date")
  valid_601679 = validateParameter(valid_601679, JString, required = false,
                                 default = nil)
  if valid_601679 != nil:
    section.add "X-Amz-Date", valid_601679
  var valid_601680 = header.getOrDefault("X-Amz-Security-Token")
  valid_601680 = validateParameter(valid_601680, JString, required = false,
                                 default = nil)
  if valid_601680 != nil:
    section.add "X-Amz-Security-Token", valid_601680
  var valid_601681 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601681 = validateParameter(valid_601681, JString, required = false,
                                 default = nil)
  if valid_601681 != nil:
    section.add "X-Amz-Content-Sha256", valid_601681
  var valid_601682 = header.getOrDefault("X-Amz-Algorithm")
  valid_601682 = validateParameter(valid_601682, JString, required = false,
                                 default = nil)
  if valid_601682 != nil:
    section.add "X-Amz-Algorithm", valid_601682
  var valid_601683 = header.getOrDefault("X-Amz-Signature")
  valid_601683 = validateParameter(valid_601683, JString, required = false,
                                 default = nil)
  if valid_601683 != nil:
    section.add "X-Amz-Signature", valid_601683
  var valid_601684 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601684 = validateParameter(valid_601684, JString, required = false,
                                 default = nil)
  if valid_601684 != nil:
    section.add "X-Amz-SignedHeaders", valid_601684
  var valid_601685 = header.getOrDefault("X-Amz-Credential")
  valid_601685 = validateParameter(valid_601685, JString, required = false,
                                 default = nil)
  if valid_601685 != nil:
    section.add "X-Amz-Credential", valid_601685
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  section = newJObject()
  var valid_601686 = formData.getOrDefault("SourceIdentifier")
  valid_601686 = validateParameter(valid_601686, JString, required = false,
                                 default = nil)
  if valid_601686 != nil:
    section.add "SourceIdentifier", valid_601686
  var valid_601687 = formData.getOrDefault("Marker")
  valid_601687 = validateParameter(valid_601687, JString, required = false,
                                 default = nil)
  if valid_601687 != nil:
    section.add "Marker", valid_601687
  var valid_601688 = formData.getOrDefault("StartTime")
  valid_601688 = validateParameter(valid_601688, JString, required = false,
                                 default = nil)
  if valid_601688 != nil:
    section.add "StartTime", valid_601688
  var valid_601689 = formData.getOrDefault("Duration")
  valid_601689 = validateParameter(valid_601689, JInt, required = false, default = nil)
  if valid_601689 != nil:
    section.add "Duration", valid_601689
  var valid_601690 = formData.getOrDefault("EndTime")
  valid_601690 = validateParameter(valid_601690, JString, required = false,
                                 default = nil)
  if valid_601690 != nil:
    section.add "EndTime", valid_601690
  var valid_601691 = formData.getOrDefault("MaxRecords")
  valid_601691 = validateParameter(valid_601691, JInt, required = false, default = nil)
  if valid_601691 != nil:
    section.add "MaxRecords", valid_601691
  var valid_601692 = formData.getOrDefault("SourceType")
  valid_601692 = validateParameter(valid_601692, JString, required = false,
                                 default = newJString("cluster"))
  if valid_601692 != nil:
    section.add "SourceType", valid_601692
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601693: Call_PostDescribeEvents_601674; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_601693.validator(path, query, header, formData, body)
  let scheme = call_601693.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601693.url(scheme.get, call_601693.host, call_601693.base,
                         call_601693.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601693, url, valid)

proc call*(call_601694: Call_PostDescribeEvents_601674;
          SourceIdentifier: string = ""; Marker: string = ""; StartTime: string = "";
          Action: string = "DescribeEvents"; Duration: int = 0; EndTime: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01";
          SourceType: string = "cluster"): Recallable =
  ## postDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  var query_601695 = newJObject()
  var formData_601696 = newJObject()
  add(formData_601696, "SourceIdentifier", newJString(SourceIdentifier))
  add(formData_601696, "Marker", newJString(Marker))
  add(formData_601696, "StartTime", newJString(StartTime))
  add(query_601695, "Action", newJString(Action))
  add(formData_601696, "Duration", newJInt(Duration))
  add(formData_601696, "EndTime", newJString(EndTime))
  add(formData_601696, "MaxRecords", newJInt(MaxRecords))
  add(query_601695, "Version", newJString(Version))
  add(formData_601696, "SourceType", newJString(SourceType))
  result = call_601694.call(nil, query_601695, nil, formData_601696, nil)

var postDescribeEvents* = Call_PostDescribeEvents_601674(
    name: "postDescribeEvents", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEvents",
    validator: validate_PostDescribeEvents_601675, base: "/",
    url: url_PostDescribeEvents_601676, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEvents_601652 = ref object of OpenApiRestCall_599352
proc url_GetDescribeEvents_601654(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeEvents_601653(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: JString (required)
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_601655 = query.getOrDefault("SourceType")
  valid_601655 = validateParameter(valid_601655, JString, required = false,
                                 default = newJString("cluster"))
  if valid_601655 != nil:
    section.add "SourceType", valid_601655
  var valid_601656 = query.getOrDefault("MaxRecords")
  valid_601656 = validateParameter(valid_601656, JInt, required = false, default = nil)
  if valid_601656 != nil:
    section.add "MaxRecords", valid_601656
  var valid_601657 = query.getOrDefault("StartTime")
  valid_601657 = validateParameter(valid_601657, JString, required = false,
                                 default = nil)
  if valid_601657 != nil:
    section.add "StartTime", valid_601657
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601658 = query.getOrDefault("Action")
  valid_601658 = validateParameter(valid_601658, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_601658 != nil:
    section.add "Action", valid_601658
  var valid_601659 = query.getOrDefault("SourceIdentifier")
  valid_601659 = validateParameter(valid_601659, JString, required = false,
                                 default = nil)
  if valid_601659 != nil:
    section.add "SourceIdentifier", valid_601659
  var valid_601660 = query.getOrDefault("Marker")
  valid_601660 = validateParameter(valid_601660, JString, required = false,
                                 default = nil)
  if valid_601660 != nil:
    section.add "Marker", valid_601660
  var valid_601661 = query.getOrDefault("Duration")
  valid_601661 = validateParameter(valid_601661, JInt, required = false, default = nil)
  if valid_601661 != nil:
    section.add "Duration", valid_601661
  var valid_601662 = query.getOrDefault("EndTime")
  valid_601662 = validateParameter(valid_601662, JString, required = false,
                                 default = nil)
  if valid_601662 != nil:
    section.add "EndTime", valid_601662
  var valid_601663 = query.getOrDefault("Version")
  valid_601663 = validateParameter(valid_601663, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601663 != nil:
    section.add "Version", valid_601663
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601664 = header.getOrDefault("X-Amz-Date")
  valid_601664 = validateParameter(valid_601664, JString, required = false,
                                 default = nil)
  if valid_601664 != nil:
    section.add "X-Amz-Date", valid_601664
  var valid_601665 = header.getOrDefault("X-Amz-Security-Token")
  valid_601665 = validateParameter(valid_601665, JString, required = false,
                                 default = nil)
  if valid_601665 != nil:
    section.add "X-Amz-Security-Token", valid_601665
  var valid_601666 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601666 = validateParameter(valid_601666, JString, required = false,
                                 default = nil)
  if valid_601666 != nil:
    section.add "X-Amz-Content-Sha256", valid_601666
  var valid_601667 = header.getOrDefault("X-Amz-Algorithm")
  valid_601667 = validateParameter(valid_601667, JString, required = false,
                                 default = nil)
  if valid_601667 != nil:
    section.add "X-Amz-Algorithm", valid_601667
  var valid_601668 = header.getOrDefault("X-Amz-Signature")
  valid_601668 = validateParameter(valid_601668, JString, required = false,
                                 default = nil)
  if valid_601668 != nil:
    section.add "X-Amz-Signature", valid_601668
  var valid_601669 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601669 = validateParameter(valid_601669, JString, required = false,
                                 default = nil)
  if valid_601669 != nil:
    section.add "X-Amz-SignedHeaders", valid_601669
  var valid_601670 = header.getOrDefault("X-Amz-Credential")
  valid_601670 = validateParameter(valid_601670, JString, required = false,
                                 default = nil)
  if valid_601670 != nil:
    section.add "X-Amz-Credential", valid_601670
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601671: Call_GetDescribeEvents_601652; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_601671.validator(path, query, header, formData, body)
  let scheme = call_601671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601671.url(scheme.get, call_601671.host, call_601671.base,
                         call_601671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601671, url, valid)

proc call*(call_601672: Call_GetDescribeEvents_601652;
          SourceType: string = "cluster"; MaxRecords: int = 0; StartTime: string = "";
          Action: string = "DescribeEvents"; SourceIdentifier: string = "";
          Marker: string = ""; Duration: int = 0; EndTime: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: string (required)
  var query_601673 = newJObject()
  add(query_601673, "SourceType", newJString(SourceType))
  add(query_601673, "MaxRecords", newJInt(MaxRecords))
  add(query_601673, "StartTime", newJString(StartTime))
  add(query_601673, "Action", newJString(Action))
  add(query_601673, "SourceIdentifier", newJString(SourceIdentifier))
  add(query_601673, "Marker", newJString(Marker))
  add(query_601673, "Duration", newJInt(Duration))
  add(query_601673, "EndTime", newJString(EndTime))
  add(query_601673, "Version", newJString(Version))
  result = call_601672.call(nil, query_601673, nil, nil, nil)

var getDescribeEvents* = Call_GetDescribeEvents_601652(name: "getDescribeEvents",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeEvents", validator: validate_GetDescribeEvents_601653,
    base: "/", url: url_GetDescribeEvents_601654,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmClientCertificates_601717 = ref object of OpenApiRestCall_599352
proc url_PostDescribeHsmClientCertificates_601719(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmClientCertificates_601718(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601720 = query.getOrDefault("Action")
  valid_601720 = validateParameter(valid_601720, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_601720 != nil:
    section.add "Action", valid_601720
  var valid_601721 = query.getOrDefault("Version")
  valid_601721 = validateParameter(valid_601721, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601721 != nil:
    section.add "Version", valid_601721
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601722 = header.getOrDefault("X-Amz-Date")
  valid_601722 = validateParameter(valid_601722, JString, required = false,
                                 default = nil)
  if valid_601722 != nil:
    section.add "X-Amz-Date", valid_601722
  var valid_601723 = header.getOrDefault("X-Amz-Security-Token")
  valid_601723 = validateParameter(valid_601723, JString, required = false,
                                 default = nil)
  if valid_601723 != nil:
    section.add "X-Amz-Security-Token", valid_601723
  var valid_601724 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601724 = validateParameter(valid_601724, JString, required = false,
                                 default = nil)
  if valid_601724 != nil:
    section.add "X-Amz-Content-Sha256", valid_601724
  var valid_601725 = header.getOrDefault("X-Amz-Algorithm")
  valid_601725 = validateParameter(valid_601725, JString, required = false,
                                 default = nil)
  if valid_601725 != nil:
    section.add "X-Amz-Algorithm", valid_601725
  var valid_601726 = header.getOrDefault("X-Amz-Signature")
  valid_601726 = validateParameter(valid_601726, JString, required = false,
                                 default = nil)
  if valid_601726 != nil:
    section.add "X-Amz-Signature", valid_601726
  var valid_601727 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601727 = validateParameter(valid_601727, JString, required = false,
                                 default = nil)
  if valid_601727 != nil:
    section.add "X-Amz-SignedHeaders", valid_601727
  var valid_601728 = header.getOrDefault("X-Amz-Credential")
  valid_601728 = validateParameter(valid_601728, JString, required = false,
                                 default = nil)
  if valid_601728 != nil:
    section.add "X-Amz-Credential", valid_601728
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_601729 = formData.getOrDefault("Marker")
  valid_601729 = validateParameter(valid_601729, JString, required = false,
                                 default = nil)
  if valid_601729 != nil:
    section.add "Marker", valid_601729
  var valid_601730 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_601730 = validateParameter(valid_601730, JString, required = false,
                                 default = nil)
  if valid_601730 != nil:
    section.add "HsmClientCertificateIdentifier", valid_601730
  var valid_601731 = formData.getOrDefault("TagKeys")
  valid_601731 = validateParameter(valid_601731, JArray, required = false,
                                 default = nil)
  if valid_601731 != nil:
    section.add "TagKeys", valid_601731
  var valid_601732 = formData.getOrDefault("MaxRecords")
  valid_601732 = validateParameter(valid_601732, JInt, required = false, default = nil)
  if valid_601732 != nil:
    section.add "MaxRecords", valid_601732
  var valid_601733 = formData.getOrDefault("TagValues")
  valid_601733 = validateParameter(valid_601733, JArray, required = false,
                                 default = nil)
  if valid_601733 != nil:
    section.add "TagValues", valid_601733
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601734: Call_PostDescribeHsmClientCertificates_601717;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601734.validator(path, query, header, formData, body)
  let scheme = call_601734.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601734.url(scheme.get, call_601734.host, call_601734.base,
                         call_601734.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601734, url, valid)

proc call*(call_601735: Call_PostDescribeHsmClientCertificates_601717;
          Marker: string = ""; Action: string = "DescribeHsmClientCertificates";
          HsmClientCertificateIdentifier: string = ""; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_601736 = newJObject()
  var formData_601737 = newJObject()
  add(formData_601737, "Marker", newJString(Marker))
  add(query_601736, "Action", newJString(Action))
  add(formData_601737, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if TagKeys != nil:
    formData_601737.add "TagKeys", TagKeys
  add(formData_601737, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_601737.add "TagValues", TagValues
  add(query_601736, "Version", newJString(Version))
  result = call_601735.call(nil, query_601736, nil, formData_601737, nil)

var postDescribeHsmClientCertificates* = Call_PostDescribeHsmClientCertificates_601717(
    name: "postDescribeHsmClientCertificates", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_PostDescribeHsmClientCertificates_601718, base: "/",
    url: url_PostDescribeHsmClientCertificates_601719,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmClientCertificates_601697 = ref object of OpenApiRestCall_599352
proc url_GetDescribeHsmClientCertificates_601699(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmClientCertificates_601698(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_601700 = query.getOrDefault("TagValues")
  valid_601700 = validateParameter(valid_601700, JArray, required = false,
                                 default = nil)
  if valid_601700 != nil:
    section.add "TagValues", valid_601700
  var valid_601701 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_601701 = validateParameter(valid_601701, JString, required = false,
                                 default = nil)
  if valid_601701 != nil:
    section.add "HsmClientCertificateIdentifier", valid_601701
  var valid_601702 = query.getOrDefault("MaxRecords")
  valid_601702 = validateParameter(valid_601702, JInt, required = false, default = nil)
  if valid_601702 != nil:
    section.add "MaxRecords", valid_601702
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601703 = query.getOrDefault("Action")
  valid_601703 = validateParameter(valid_601703, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_601703 != nil:
    section.add "Action", valid_601703
  var valid_601704 = query.getOrDefault("Marker")
  valid_601704 = validateParameter(valid_601704, JString, required = false,
                                 default = nil)
  if valid_601704 != nil:
    section.add "Marker", valid_601704
  var valid_601705 = query.getOrDefault("TagKeys")
  valid_601705 = validateParameter(valid_601705, JArray, required = false,
                                 default = nil)
  if valid_601705 != nil:
    section.add "TagKeys", valid_601705
  var valid_601706 = query.getOrDefault("Version")
  valid_601706 = validateParameter(valid_601706, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601706 != nil:
    section.add "Version", valid_601706
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601707 = header.getOrDefault("X-Amz-Date")
  valid_601707 = validateParameter(valid_601707, JString, required = false,
                                 default = nil)
  if valid_601707 != nil:
    section.add "X-Amz-Date", valid_601707
  var valid_601708 = header.getOrDefault("X-Amz-Security-Token")
  valid_601708 = validateParameter(valid_601708, JString, required = false,
                                 default = nil)
  if valid_601708 != nil:
    section.add "X-Amz-Security-Token", valid_601708
  var valid_601709 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601709 = validateParameter(valid_601709, JString, required = false,
                                 default = nil)
  if valid_601709 != nil:
    section.add "X-Amz-Content-Sha256", valid_601709
  var valid_601710 = header.getOrDefault("X-Amz-Algorithm")
  valid_601710 = validateParameter(valid_601710, JString, required = false,
                                 default = nil)
  if valid_601710 != nil:
    section.add "X-Amz-Algorithm", valid_601710
  var valid_601711 = header.getOrDefault("X-Amz-Signature")
  valid_601711 = validateParameter(valid_601711, JString, required = false,
                                 default = nil)
  if valid_601711 != nil:
    section.add "X-Amz-Signature", valid_601711
  var valid_601712 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601712 = validateParameter(valid_601712, JString, required = false,
                                 default = nil)
  if valid_601712 != nil:
    section.add "X-Amz-SignedHeaders", valid_601712
  var valid_601713 = header.getOrDefault("X-Amz-Credential")
  valid_601713 = validateParameter(valid_601713, JString, required = false,
                                 default = nil)
  if valid_601713 != nil:
    section.add "X-Amz-Credential", valid_601713
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601714: Call_GetDescribeHsmClientCertificates_601697;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601714.validator(path, query, header, formData, body)
  let scheme = call_601714.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601714.url(scheme.get, call_601714.host, call_601714.base,
                         call_601714.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601714, url, valid)

proc call*(call_601715: Call_GetDescribeHsmClientCertificates_601697;
          TagValues: JsonNode = nil; HsmClientCertificateIdentifier: string = "";
          MaxRecords: int = 0; Action: string = "DescribeHsmClientCertificates";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_601716 = newJObject()
  if TagValues != nil:
    query_601716.add "TagValues", TagValues
  add(query_601716, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_601716, "MaxRecords", newJInt(MaxRecords))
  add(query_601716, "Action", newJString(Action))
  add(query_601716, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_601716.add "TagKeys", TagKeys
  add(query_601716, "Version", newJString(Version))
  result = call_601715.call(nil, query_601716, nil, nil, nil)

var getDescribeHsmClientCertificates* = Call_GetDescribeHsmClientCertificates_601697(
    name: "getDescribeHsmClientCertificates", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_GetDescribeHsmClientCertificates_601698, base: "/",
    url: url_GetDescribeHsmClientCertificates_601699,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmConfigurations_601758 = ref object of OpenApiRestCall_599352
proc url_PostDescribeHsmConfigurations_601760(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeHsmConfigurations_601759(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601761 = query.getOrDefault("Action")
  valid_601761 = validateParameter(valid_601761, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_601761 != nil:
    section.add "Action", valid_601761
  var valid_601762 = query.getOrDefault("Version")
  valid_601762 = validateParameter(valid_601762, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601762 != nil:
    section.add "Version", valid_601762
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601763 = header.getOrDefault("X-Amz-Date")
  valid_601763 = validateParameter(valid_601763, JString, required = false,
                                 default = nil)
  if valid_601763 != nil:
    section.add "X-Amz-Date", valid_601763
  var valid_601764 = header.getOrDefault("X-Amz-Security-Token")
  valid_601764 = validateParameter(valid_601764, JString, required = false,
                                 default = nil)
  if valid_601764 != nil:
    section.add "X-Amz-Security-Token", valid_601764
  var valid_601765 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601765 = validateParameter(valid_601765, JString, required = false,
                                 default = nil)
  if valid_601765 != nil:
    section.add "X-Amz-Content-Sha256", valid_601765
  var valid_601766 = header.getOrDefault("X-Amz-Algorithm")
  valid_601766 = validateParameter(valid_601766, JString, required = false,
                                 default = nil)
  if valid_601766 != nil:
    section.add "X-Amz-Algorithm", valid_601766
  var valid_601767 = header.getOrDefault("X-Amz-Signature")
  valid_601767 = validateParameter(valid_601767, JString, required = false,
                                 default = nil)
  if valid_601767 != nil:
    section.add "X-Amz-Signature", valid_601767
  var valid_601768 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601768 = validateParameter(valid_601768, JString, required = false,
                                 default = nil)
  if valid_601768 != nil:
    section.add "X-Amz-SignedHeaders", valid_601768
  var valid_601769 = header.getOrDefault("X-Amz-Credential")
  valid_601769 = validateParameter(valid_601769, JString, required = false,
                                 default = nil)
  if valid_601769 != nil:
    section.add "X-Amz-Credential", valid_601769
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_601770 = formData.getOrDefault("Marker")
  valid_601770 = validateParameter(valid_601770, JString, required = false,
                                 default = nil)
  if valid_601770 != nil:
    section.add "Marker", valid_601770
  var valid_601771 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_601771 = validateParameter(valid_601771, JString, required = false,
                                 default = nil)
  if valid_601771 != nil:
    section.add "HsmConfigurationIdentifier", valid_601771
  var valid_601772 = formData.getOrDefault("TagKeys")
  valid_601772 = validateParameter(valid_601772, JArray, required = false,
                                 default = nil)
  if valid_601772 != nil:
    section.add "TagKeys", valid_601772
  var valid_601773 = formData.getOrDefault("MaxRecords")
  valid_601773 = validateParameter(valid_601773, JInt, required = false, default = nil)
  if valid_601773 != nil:
    section.add "MaxRecords", valid_601773
  var valid_601774 = formData.getOrDefault("TagValues")
  valid_601774 = validateParameter(valid_601774, JArray, required = false,
                                 default = nil)
  if valid_601774 != nil:
    section.add "TagValues", valid_601774
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601775: Call_PostDescribeHsmConfigurations_601758; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601775.validator(path, query, header, formData, body)
  let scheme = call_601775.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601775.url(scheme.get, call_601775.host, call_601775.base,
                         call_601775.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601775, url, valid)

proc call*(call_601776: Call_PostDescribeHsmConfigurations_601758;
          Marker: string = ""; HsmConfigurationIdentifier: string = "";
          Action: string = "DescribeHsmConfigurations"; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: string (required)
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_601777 = newJObject()
  var formData_601778 = newJObject()
  add(formData_601778, "Marker", newJString(Marker))
  add(formData_601778, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_601777, "Action", newJString(Action))
  if TagKeys != nil:
    formData_601778.add "TagKeys", TagKeys
  add(formData_601778, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_601778.add "TagValues", TagValues
  add(query_601777, "Version", newJString(Version))
  result = call_601776.call(nil, query_601777, nil, formData_601778, nil)

var postDescribeHsmConfigurations* = Call_PostDescribeHsmConfigurations_601758(
    name: "postDescribeHsmConfigurations", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_PostDescribeHsmConfigurations_601759, base: "/",
    url: url_PostDescribeHsmConfigurations_601760,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmConfigurations_601738 = ref object of OpenApiRestCall_599352
proc url_GetDescribeHsmConfigurations_601740(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeHsmConfigurations_601739(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_601741 = query.getOrDefault("TagValues")
  valid_601741 = validateParameter(valid_601741, JArray, required = false,
                                 default = nil)
  if valid_601741 != nil:
    section.add "TagValues", valid_601741
  var valid_601742 = query.getOrDefault("MaxRecords")
  valid_601742 = validateParameter(valid_601742, JInt, required = false, default = nil)
  if valid_601742 != nil:
    section.add "MaxRecords", valid_601742
  var valid_601743 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_601743 = validateParameter(valid_601743, JString, required = false,
                                 default = nil)
  if valid_601743 != nil:
    section.add "HsmConfigurationIdentifier", valid_601743
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601744 = query.getOrDefault("Action")
  valid_601744 = validateParameter(valid_601744, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_601744 != nil:
    section.add "Action", valid_601744
  var valid_601745 = query.getOrDefault("Marker")
  valid_601745 = validateParameter(valid_601745, JString, required = false,
                                 default = nil)
  if valid_601745 != nil:
    section.add "Marker", valid_601745
  var valid_601746 = query.getOrDefault("TagKeys")
  valid_601746 = validateParameter(valid_601746, JArray, required = false,
                                 default = nil)
  if valid_601746 != nil:
    section.add "TagKeys", valid_601746
  var valid_601747 = query.getOrDefault("Version")
  valid_601747 = validateParameter(valid_601747, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601747 != nil:
    section.add "Version", valid_601747
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601748 = header.getOrDefault("X-Amz-Date")
  valid_601748 = validateParameter(valid_601748, JString, required = false,
                                 default = nil)
  if valid_601748 != nil:
    section.add "X-Amz-Date", valid_601748
  var valid_601749 = header.getOrDefault("X-Amz-Security-Token")
  valid_601749 = validateParameter(valid_601749, JString, required = false,
                                 default = nil)
  if valid_601749 != nil:
    section.add "X-Amz-Security-Token", valid_601749
  var valid_601750 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601750 = validateParameter(valid_601750, JString, required = false,
                                 default = nil)
  if valid_601750 != nil:
    section.add "X-Amz-Content-Sha256", valid_601750
  var valid_601751 = header.getOrDefault("X-Amz-Algorithm")
  valid_601751 = validateParameter(valid_601751, JString, required = false,
                                 default = nil)
  if valid_601751 != nil:
    section.add "X-Amz-Algorithm", valid_601751
  var valid_601752 = header.getOrDefault("X-Amz-Signature")
  valid_601752 = validateParameter(valid_601752, JString, required = false,
                                 default = nil)
  if valid_601752 != nil:
    section.add "X-Amz-Signature", valid_601752
  var valid_601753 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601753 = validateParameter(valid_601753, JString, required = false,
                                 default = nil)
  if valid_601753 != nil:
    section.add "X-Amz-SignedHeaders", valid_601753
  var valid_601754 = header.getOrDefault("X-Amz-Credential")
  valid_601754 = validateParameter(valid_601754, JString, required = false,
                                 default = nil)
  if valid_601754 != nil:
    section.add "X-Amz-Credential", valid_601754
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601755: Call_GetDescribeHsmConfigurations_601738; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_601755.validator(path, query, header, formData, body)
  let scheme = call_601755.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601755.url(scheme.get, call_601755.host, call_601755.base,
                         call_601755.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601755, url, valid)

proc call*(call_601756: Call_GetDescribeHsmConfigurations_601738;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          HsmConfigurationIdentifier: string = "";
          Action: string = "DescribeHsmConfigurations"; Marker: string = "";
          TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_601757 = newJObject()
  if TagValues != nil:
    query_601757.add "TagValues", TagValues
  add(query_601757, "MaxRecords", newJInt(MaxRecords))
  add(query_601757, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_601757, "Action", newJString(Action))
  add(query_601757, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_601757.add "TagKeys", TagKeys
  add(query_601757, "Version", newJString(Version))
  result = call_601756.call(nil, query_601757, nil, nil, nil)

var getDescribeHsmConfigurations* = Call_GetDescribeHsmConfigurations_601738(
    name: "getDescribeHsmConfigurations", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_GetDescribeHsmConfigurations_601739, base: "/",
    url: url_GetDescribeHsmConfigurations_601740,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeLoggingStatus_601795 = ref object of OpenApiRestCall_599352
proc url_PostDescribeLoggingStatus_601797(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeLoggingStatus_601796(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601798 = query.getOrDefault("Action")
  valid_601798 = validateParameter(valid_601798, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_601798 != nil:
    section.add "Action", valid_601798
  var valid_601799 = query.getOrDefault("Version")
  valid_601799 = validateParameter(valid_601799, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601799 != nil:
    section.add "Version", valid_601799
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601800 = header.getOrDefault("X-Amz-Date")
  valid_601800 = validateParameter(valid_601800, JString, required = false,
                                 default = nil)
  if valid_601800 != nil:
    section.add "X-Amz-Date", valid_601800
  var valid_601801 = header.getOrDefault("X-Amz-Security-Token")
  valid_601801 = validateParameter(valid_601801, JString, required = false,
                                 default = nil)
  if valid_601801 != nil:
    section.add "X-Amz-Security-Token", valid_601801
  var valid_601802 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601802 = validateParameter(valid_601802, JString, required = false,
                                 default = nil)
  if valid_601802 != nil:
    section.add "X-Amz-Content-Sha256", valid_601802
  var valid_601803 = header.getOrDefault("X-Amz-Algorithm")
  valid_601803 = validateParameter(valid_601803, JString, required = false,
                                 default = nil)
  if valid_601803 != nil:
    section.add "X-Amz-Algorithm", valid_601803
  var valid_601804 = header.getOrDefault("X-Amz-Signature")
  valid_601804 = validateParameter(valid_601804, JString, required = false,
                                 default = nil)
  if valid_601804 != nil:
    section.add "X-Amz-Signature", valid_601804
  var valid_601805 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601805 = validateParameter(valid_601805, JString, required = false,
                                 default = nil)
  if valid_601805 != nil:
    section.add "X-Amz-SignedHeaders", valid_601805
  var valid_601806 = header.getOrDefault("X-Amz-Credential")
  valid_601806 = validateParameter(valid_601806, JString, required = false,
                                 default = nil)
  if valid_601806 != nil:
    section.add "X-Amz-Credential", valid_601806
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_601807 = formData.getOrDefault("ClusterIdentifier")
  valid_601807 = validateParameter(valid_601807, JString, required = true,
                                 default = nil)
  if valid_601807 != nil:
    section.add "ClusterIdentifier", valid_601807
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601808: Call_PostDescribeLoggingStatus_601795; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_601808.validator(path, query, header, formData, body)
  let scheme = call_601808.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601808.url(scheme.get, call_601808.host, call_601808.base,
                         call_601808.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601808, url, valid)

proc call*(call_601809: Call_PostDescribeLoggingStatus_601795;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_601810 = newJObject()
  var formData_601811 = newJObject()
  add(query_601810, "Action", newJString(Action))
  add(formData_601811, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_601810, "Version", newJString(Version))
  result = call_601809.call(nil, query_601810, nil, formData_601811, nil)

var postDescribeLoggingStatus* = Call_PostDescribeLoggingStatus_601795(
    name: "postDescribeLoggingStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_PostDescribeLoggingStatus_601796, base: "/",
    url: url_PostDescribeLoggingStatus_601797,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeLoggingStatus_601779 = ref object of OpenApiRestCall_599352
proc url_GetDescribeLoggingStatus_601781(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeLoggingStatus_601780(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601782 = query.getOrDefault("Action")
  valid_601782 = validateParameter(valid_601782, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_601782 != nil:
    section.add "Action", valid_601782
  var valid_601783 = query.getOrDefault("ClusterIdentifier")
  valid_601783 = validateParameter(valid_601783, JString, required = true,
                                 default = nil)
  if valid_601783 != nil:
    section.add "ClusterIdentifier", valid_601783
  var valid_601784 = query.getOrDefault("Version")
  valid_601784 = validateParameter(valid_601784, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601784 != nil:
    section.add "Version", valid_601784
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601785 = header.getOrDefault("X-Amz-Date")
  valid_601785 = validateParameter(valid_601785, JString, required = false,
                                 default = nil)
  if valid_601785 != nil:
    section.add "X-Amz-Date", valid_601785
  var valid_601786 = header.getOrDefault("X-Amz-Security-Token")
  valid_601786 = validateParameter(valid_601786, JString, required = false,
                                 default = nil)
  if valid_601786 != nil:
    section.add "X-Amz-Security-Token", valid_601786
  var valid_601787 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601787 = validateParameter(valid_601787, JString, required = false,
                                 default = nil)
  if valid_601787 != nil:
    section.add "X-Amz-Content-Sha256", valid_601787
  var valid_601788 = header.getOrDefault("X-Amz-Algorithm")
  valid_601788 = validateParameter(valid_601788, JString, required = false,
                                 default = nil)
  if valid_601788 != nil:
    section.add "X-Amz-Algorithm", valid_601788
  var valid_601789 = header.getOrDefault("X-Amz-Signature")
  valid_601789 = validateParameter(valid_601789, JString, required = false,
                                 default = nil)
  if valid_601789 != nil:
    section.add "X-Amz-Signature", valid_601789
  var valid_601790 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601790 = validateParameter(valid_601790, JString, required = false,
                                 default = nil)
  if valid_601790 != nil:
    section.add "X-Amz-SignedHeaders", valid_601790
  var valid_601791 = header.getOrDefault("X-Amz-Credential")
  valid_601791 = validateParameter(valid_601791, JString, required = false,
                                 default = nil)
  if valid_601791 != nil:
    section.add "X-Amz-Credential", valid_601791
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601792: Call_GetDescribeLoggingStatus_601779; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_601792.validator(path, query, header, formData, body)
  let scheme = call_601792.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601792.url(scheme.get, call_601792.host, call_601792.base,
                         call_601792.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601792, url, valid)

proc call*(call_601793: Call_GetDescribeLoggingStatus_601779;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_601794 = newJObject()
  add(query_601794, "Action", newJString(Action))
  add(query_601794, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_601794, "Version", newJString(Version))
  result = call_601793.call(nil, query_601794, nil, nil, nil)

var getDescribeLoggingStatus* = Call_GetDescribeLoggingStatus_601779(
    name: "getDescribeLoggingStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_GetDescribeLoggingStatus_601780, base: "/",
    url: url_GetDescribeLoggingStatus_601781, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeNodeConfigurationOptions_601834 = ref object of OpenApiRestCall_599352
proc url_PostDescribeNodeConfigurationOptions_601836(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeNodeConfigurationOptions_601835(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601837 = query.getOrDefault("Action")
  valid_601837 = validateParameter(valid_601837, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_601837 != nil:
    section.add "Action", valid_601837
  var valid_601838 = query.getOrDefault("Version")
  valid_601838 = validateParameter(valid_601838, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601838 != nil:
    section.add "Version", valid_601838
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601839 = header.getOrDefault("X-Amz-Date")
  valid_601839 = validateParameter(valid_601839, JString, required = false,
                                 default = nil)
  if valid_601839 != nil:
    section.add "X-Amz-Date", valid_601839
  var valid_601840 = header.getOrDefault("X-Amz-Security-Token")
  valid_601840 = validateParameter(valid_601840, JString, required = false,
                                 default = nil)
  if valid_601840 != nil:
    section.add "X-Amz-Security-Token", valid_601840
  var valid_601841 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601841 = validateParameter(valid_601841, JString, required = false,
                                 default = nil)
  if valid_601841 != nil:
    section.add "X-Amz-Content-Sha256", valid_601841
  var valid_601842 = header.getOrDefault("X-Amz-Algorithm")
  valid_601842 = validateParameter(valid_601842, JString, required = false,
                                 default = nil)
  if valid_601842 != nil:
    section.add "X-Amz-Algorithm", valid_601842
  var valid_601843 = header.getOrDefault("X-Amz-Signature")
  valid_601843 = validateParameter(valid_601843, JString, required = false,
                                 default = nil)
  if valid_601843 != nil:
    section.add "X-Amz-Signature", valid_601843
  var valid_601844 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601844 = validateParameter(valid_601844, JString, required = false,
                                 default = nil)
  if valid_601844 != nil:
    section.add "X-Amz-SignedHeaders", valid_601844
  var valid_601845 = header.getOrDefault("X-Amz-Credential")
  valid_601845 = validateParameter(valid_601845, JString, required = false,
                                 default = nil)
  if valid_601845 != nil:
    section.add "X-Amz-Credential", valid_601845
  result.add "header", section
  ## parameters in `formData` object:
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  section = newJObject()
  var valid_601846 = formData.getOrDefault("Filter")
  valid_601846 = validateParameter(valid_601846, JArray, required = false,
                                 default = nil)
  if valid_601846 != nil:
    section.add "Filter", valid_601846
  var valid_601847 = formData.getOrDefault("Marker")
  valid_601847 = validateParameter(valid_601847, JString, required = false,
                                 default = nil)
  if valid_601847 != nil:
    section.add "Marker", valid_601847
  var valid_601848 = formData.getOrDefault("OwnerAccount")
  valid_601848 = validateParameter(valid_601848, JString, required = false,
                                 default = nil)
  if valid_601848 != nil:
    section.add "OwnerAccount", valid_601848
  assert formData != nil,
        "formData argument is necessary due to required `ActionType` field"
  var valid_601849 = formData.getOrDefault("ActionType")
  valid_601849 = validateParameter(valid_601849, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_601849 != nil:
    section.add "ActionType", valid_601849
  var valid_601850 = formData.getOrDefault("ClusterIdentifier")
  valid_601850 = validateParameter(valid_601850, JString, required = false,
                                 default = nil)
  if valid_601850 != nil:
    section.add "ClusterIdentifier", valid_601850
  var valid_601851 = formData.getOrDefault("SnapshotIdentifier")
  valid_601851 = validateParameter(valid_601851, JString, required = false,
                                 default = nil)
  if valid_601851 != nil:
    section.add "SnapshotIdentifier", valid_601851
  var valid_601852 = formData.getOrDefault("MaxRecords")
  valid_601852 = validateParameter(valid_601852, JInt, required = false, default = nil)
  if valid_601852 != nil:
    section.add "MaxRecords", valid_601852
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601853: Call_PostDescribeNodeConfigurationOptions_601834;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_601853.validator(path, query, header, formData, body)
  let scheme = call_601853.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601853.url(scheme.get, call_601853.host, call_601853.base,
                         call_601853.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601853, url, valid)

proc call*(call_601854: Call_PostDescribeNodeConfigurationOptions_601834;
          Filter: JsonNode = nil; Marker: string = "";
          Action: string = "DescribeNodeConfigurationOptions";
          OwnerAccount: string = ""; ActionType: string = "restore-cluster";
          ClusterIdentifier: string = ""; SnapshotIdentifier: string = "";
          MaxRecords: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Version: string (required)
  var query_601855 = newJObject()
  var formData_601856 = newJObject()
  if Filter != nil:
    formData_601856.add "Filter", Filter
  add(formData_601856, "Marker", newJString(Marker))
  add(query_601855, "Action", newJString(Action))
  add(formData_601856, "OwnerAccount", newJString(OwnerAccount))
  add(formData_601856, "ActionType", newJString(ActionType))
  add(formData_601856, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_601856, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_601856, "MaxRecords", newJInt(MaxRecords))
  add(query_601855, "Version", newJString(Version))
  result = call_601854.call(nil, query_601855, nil, formData_601856, nil)

var postDescribeNodeConfigurationOptions* = Call_PostDescribeNodeConfigurationOptions_601834(
    name: "postDescribeNodeConfigurationOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_PostDescribeNodeConfigurationOptions_601835, base: "/",
    url: url_PostDescribeNodeConfigurationOptions_601836,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeNodeConfigurationOptions_601812 = ref object of OpenApiRestCall_599352
proc url_GetDescribeNodeConfigurationOptions_601814(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeNodeConfigurationOptions_601813(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Version: JString (required)
  section = newJObject()
  var valid_601815 = query.getOrDefault("MaxRecords")
  valid_601815 = validateParameter(valid_601815, JInt, required = false, default = nil)
  if valid_601815 != nil:
    section.add "MaxRecords", valid_601815
  var valid_601816 = query.getOrDefault("Filter")
  valid_601816 = validateParameter(valid_601816, JArray, required = false,
                                 default = nil)
  if valid_601816 != nil:
    section.add "Filter", valid_601816
  assert query != nil,
        "query argument is necessary due to required `ActionType` field"
  var valid_601817 = query.getOrDefault("ActionType")
  valid_601817 = validateParameter(valid_601817, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_601817 != nil:
    section.add "ActionType", valid_601817
  var valid_601818 = query.getOrDefault("Action")
  valid_601818 = validateParameter(valid_601818, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_601818 != nil:
    section.add "Action", valid_601818
  var valid_601819 = query.getOrDefault("ClusterIdentifier")
  valid_601819 = validateParameter(valid_601819, JString, required = false,
                                 default = nil)
  if valid_601819 != nil:
    section.add "ClusterIdentifier", valid_601819
  var valid_601820 = query.getOrDefault("OwnerAccount")
  valid_601820 = validateParameter(valid_601820, JString, required = false,
                                 default = nil)
  if valid_601820 != nil:
    section.add "OwnerAccount", valid_601820
  var valid_601821 = query.getOrDefault("Marker")
  valid_601821 = validateParameter(valid_601821, JString, required = false,
                                 default = nil)
  if valid_601821 != nil:
    section.add "Marker", valid_601821
  var valid_601822 = query.getOrDefault("SnapshotIdentifier")
  valid_601822 = validateParameter(valid_601822, JString, required = false,
                                 default = nil)
  if valid_601822 != nil:
    section.add "SnapshotIdentifier", valid_601822
  var valid_601823 = query.getOrDefault("Version")
  valid_601823 = validateParameter(valid_601823, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601823 != nil:
    section.add "Version", valid_601823
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601824 = header.getOrDefault("X-Amz-Date")
  valid_601824 = validateParameter(valid_601824, JString, required = false,
                                 default = nil)
  if valid_601824 != nil:
    section.add "X-Amz-Date", valid_601824
  var valid_601825 = header.getOrDefault("X-Amz-Security-Token")
  valid_601825 = validateParameter(valid_601825, JString, required = false,
                                 default = nil)
  if valid_601825 != nil:
    section.add "X-Amz-Security-Token", valid_601825
  var valid_601826 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601826 = validateParameter(valid_601826, JString, required = false,
                                 default = nil)
  if valid_601826 != nil:
    section.add "X-Amz-Content-Sha256", valid_601826
  var valid_601827 = header.getOrDefault("X-Amz-Algorithm")
  valid_601827 = validateParameter(valid_601827, JString, required = false,
                                 default = nil)
  if valid_601827 != nil:
    section.add "X-Amz-Algorithm", valid_601827
  var valid_601828 = header.getOrDefault("X-Amz-Signature")
  valid_601828 = validateParameter(valid_601828, JString, required = false,
                                 default = nil)
  if valid_601828 != nil:
    section.add "X-Amz-Signature", valid_601828
  var valid_601829 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601829 = validateParameter(valid_601829, JString, required = false,
                                 default = nil)
  if valid_601829 != nil:
    section.add "X-Amz-SignedHeaders", valid_601829
  var valid_601830 = header.getOrDefault("X-Amz-Credential")
  valid_601830 = validateParameter(valid_601830, JString, required = false,
                                 default = nil)
  if valid_601830 != nil:
    section.add "X-Amz-Credential", valid_601830
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601831: Call_GetDescribeNodeConfigurationOptions_601812;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_601831.validator(path, query, header, formData, body)
  let scheme = call_601831.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601831.url(scheme.get, call_601831.host, call_601831.base,
                         call_601831.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601831, url, valid)

proc call*(call_601832: Call_GetDescribeNodeConfigurationOptions_601812;
          MaxRecords: int = 0; Filter: JsonNode = nil;
          ActionType: string = "restore-cluster";
          Action: string = "DescribeNodeConfigurationOptions";
          ClusterIdentifier: string = ""; OwnerAccount: string = "";
          Marker: string = ""; SnapshotIdentifier: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Specify "restore-cluster" to get configuration combinations based on an existing snapshot. Specify "recommend-node-config" to get configuration recommendations based on an existing cluster or snapshot. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster to evaluate for possible node configurations.
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Version: string (required)
  var query_601833 = newJObject()
  add(query_601833, "MaxRecords", newJInt(MaxRecords))
  if Filter != nil:
    query_601833.add "Filter", Filter
  add(query_601833, "ActionType", newJString(ActionType))
  add(query_601833, "Action", newJString(Action))
  add(query_601833, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_601833, "OwnerAccount", newJString(OwnerAccount))
  add(query_601833, "Marker", newJString(Marker))
  add(query_601833, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_601833, "Version", newJString(Version))
  result = call_601832.call(nil, query_601833, nil, nil, nil)

var getDescribeNodeConfigurationOptions* = Call_GetDescribeNodeConfigurationOptions_601812(
    name: "getDescribeNodeConfigurationOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_GetDescribeNodeConfigurationOptions_601813, base: "/",
    url: url_GetDescribeNodeConfigurationOptions_601814,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeOrderableClusterOptions_601876 = ref object of OpenApiRestCall_599352
proc url_PostDescribeOrderableClusterOptions_601878(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeOrderableClusterOptions_601877(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601879 = query.getOrDefault("Action")
  valid_601879 = validateParameter(valid_601879, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_601879 != nil:
    section.add "Action", valid_601879
  var valid_601880 = query.getOrDefault("Version")
  valid_601880 = validateParameter(valid_601880, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601880 != nil:
    section.add "Version", valid_601880
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601881 = header.getOrDefault("X-Amz-Date")
  valid_601881 = validateParameter(valid_601881, JString, required = false,
                                 default = nil)
  if valid_601881 != nil:
    section.add "X-Amz-Date", valid_601881
  var valid_601882 = header.getOrDefault("X-Amz-Security-Token")
  valid_601882 = validateParameter(valid_601882, JString, required = false,
                                 default = nil)
  if valid_601882 != nil:
    section.add "X-Amz-Security-Token", valid_601882
  var valid_601883 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601883 = validateParameter(valid_601883, JString, required = false,
                                 default = nil)
  if valid_601883 != nil:
    section.add "X-Amz-Content-Sha256", valid_601883
  var valid_601884 = header.getOrDefault("X-Amz-Algorithm")
  valid_601884 = validateParameter(valid_601884, JString, required = false,
                                 default = nil)
  if valid_601884 != nil:
    section.add "X-Amz-Algorithm", valid_601884
  var valid_601885 = header.getOrDefault("X-Amz-Signature")
  valid_601885 = validateParameter(valid_601885, JString, required = false,
                                 default = nil)
  if valid_601885 != nil:
    section.add "X-Amz-Signature", valid_601885
  var valid_601886 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601886 = validateParameter(valid_601886, JString, required = false,
                                 default = nil)
  if valid_601886 != nil:
    section.add "X-Amz-SignedHeaders", valid_601886
  var valid_601887 = header.getOrDefault("X-Amz-Credential")
  valid_601887 = validateParameter(valid_601887, JString, required = false,
                                 default = nil)
  if valid_601887 != nil:
    section.add "X-Amz-Credential", valid_601887
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  section = newJObject()
  var valid_601888 = formData.getOrDefault("ClusterVersion")
  valid_601888 = validateParameter(valid_601888, JString, required = false,
                                 default = nil)
  if valid_601888 != nil:
    section.add "ClusterVersion", valid_601888
  var valid_601889 = formData.getOrDefault("Marker")
  valid_601889 = validateParameter(valid_601889, JString, required = false,
                                 default = nil)
  if valid_601889 != nil:
    section.add "Marker", valid_601889
  var valid_601890 = formData.getOrDefault("MaxRecords")
  valid_601890 = validateParameter(valid_601890, JInt, required = false, default = nil)
  if valid_601890 != nil:
    section.add "MaxRecords", valid_601890
  var valid_601891 = formData.getOrDefault("NodeType")
  valid_601891 = validateParameter(valid_601891, JString, required = false,
                                 default = nil)
  if valid_601891 != nil:
    section.add "NodeType", valid_601891
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601892: Call_PostDescribeOrderableClusterOptions_601876;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_601892.validator(path, query, header, formData, body)
  let scheme = call_601892.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601892.url(scheme.get, call_601892.host, call_601892.base,
                         call_601892.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601892, url, valid)

proc call*(call_601893: Call_PostDescribeOrderableClusterOptions_601876;
          ClusterVersion: string = ""; Marker: string = "";
          Action: string = "DescribeOrderableClusterOptions"; MaxRecords: int = 0;
          Version: string = "2012-12-01"; NodeType: string = ""): Recallable =
  ## postDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  var query_601894 = newJObject()
  var formData_601895 = newJObject()
  add(formData_601895, "ClusterVersion", newJString(ClusterVersion))
  add(formData_601895, "Marker", newJString(Marker))
  add(query_601894, "Action", newJString(Action))
  add(formData_601895, "MaxRecords", newJInt(MaxRecords))
  add(query_601894, "Version", newJString(Version))
  add(formData_601895, "NodeType", newJString(NodeType))
  result = call_601893.call(nil, query_601894, nil, formData_601895, nil)

var postDescribeOrderableClusterOptions* = Call_PostDescribeOrderableClusterOptions_601876(
    name: "postDescribeOrderableClusterOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_PostDescribeOrderableClusterOptions_601877, base: "/",
    url: url_PostDescribeOrderableClusterOptions_601878,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeOrderableClusterOptions_601857 = ref object of OpenApiRestCall_599352
proc url_GetDescribeOrderableClusterOptions_601859(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeOrderableClusterOptions_601858(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_601860 = query.getOrDefault("MaxRecords")
  valid_601860 = validateParameter(valid_601860, JInt, required = false, default = nil)
  if valid_601860 != nil:
    section.add "MaxRecords", valid_601860
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601861 = query.getOrDefault("Action")
  valid_601861 = validateParameter(valid_601861, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_601861 != nil:
    section.add "Action", valid_601861
  var valid_601862 = query.getOrDefault("Marker")
  valid_601862 = validateParameter(valid_601862, JString, required = false,
                                 default = nil)
  if valid_601862 != nil:
    section.add "Marker", valid_601862
  var valid_601863 = query.getOrDefault("NodeType")
  valid_601863 = validateParameter(valid_601863, JString, required = false,
                                 default = nil)
  if valid_601863 != nil:
    section.add "NodeType", valid_601863
  var valid_601864 = query.getOrDefault("ClusterVersion")
  valid_601864 = validateParameter(valid_601864, JString, required = false,
                                 default = nil)
  if valid_601864 != nil:
    section.add "ClusterVersion", valid_601864
  var valid_601865 = query.getOrDefault("Version")
  valid_601865 = validateParameter(valid_601865, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601865 != nil:
    section.add "Version", valid_601865
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601866 = header.getOrDefault("X-Amz-Date")
  valid_601866 = validateParameter(valid_601866, JString, required = false,
                                 default = nil)
  if valid_601866 != nil:
    section.add "X-Amz-Date", valid_601866
  var valid_601867 = header.getOrDefault("X-Amz-Security-Token")
  valid_601867 = validateParameter(valid_601867, JString, required = false,
                                 default = nil)
  if valid_601867 != nil:
    section.add "X-Amz-Security-Token", valid_601867
  var valid_601868 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601868 = validateParameter(valid_601868, JString, required = false,
                                 default = nil)
  if valid_601868 != nil:
    section.add "X-Amz-Content-Sha256", valid_601868
  var valid_601869 = header.getOrDefault("X-Amz-Algorithm")
  valid_601869 = validateParameter(valid_601869, JString, required = false,
                                 default = nil)
  if valid_601869 != nil:
    section.add "X-Amz-Algorithm", valid_601869
  var valid_601870 = header.getOrDefault("X-Amz-Signature")
  valid_601870 = validateParameter(valid_601870, JString, required = false,
                                 default = nil)
  if valid_601870 != nil:
    section.add "X-Amz-Signature", valid_601870
  var valid_601871 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601871 = validateParameter(valid_601871, JString, required = false,
                                 default = nil)
  if valid_601871 != nil:
    section.add "X-Amz-SignedHeaders", valid_601871
  var valid_601872 = header.getOrDefault("X-Amz-Credential")
  valid_601872 = validateParameter(valid_601872, JString, required = false,
                                 default = nil)
  if valid_601872 != nil:
    section.add "X-Amz-Credential", valid_601872
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601873: Call_GetDescribeOrderableClusterOptions_601857;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_601873.validator(path, query, header, formData, body)
  let scheme = call_601873.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601873.url(scheme.get, call_601873.host, call_601873.base,
                         call_601873.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601873, url, valid)

proc call*(call_601874: Call_GetDescribeOrderableClusterOptions_601857;
          MaxRecords: int = 0; Action: string = "DescribeOrderableClusterOptions";
          Marker: string = ""; NodeType: string = ""; ClusterVersion: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: string (required)
  var query_601875 = newJObject()
  add(query_601875, "MaxRecords", newJInt(MaxRecords))
  add(query_601875, "Action", newJString(Action))
  add(query_601875, "Marker", newJString(Marker))
  add(query_601875, "NodeType", newJString(NodeType))
  add(query_601875, "ClusterVersion", newJString(ClusterVersion))
  add(query_601875, "Version", newJString(Version))
  result = call_601874.call(nil, query_601875, nil, nil, nil)

var getDescribeOrderableClusterOptions* = Call_GetDescribeOrderableClusterOptions_601857(
    name: "getDescribeOrderableClusterOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_GetDescribeOrderableClusterOptions_601858, base: "/",
    url: url_GetDescribeOrderableClusterOptions_601859,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodeOfferings_601914 = ref object of OpenApiRestCall_599352
proc url_PostDescribeReservedNodeOfferings_601916(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodeOfferings_601915(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601917 = query.getOrDefault("Action")
  valid_601917 = validateParameter(valid_601917, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_601917 != nil:
    section.add "Action", valid_601917
  var valid_601918 = query.getOrDefault("Version")
  valid_601918 = validateParameter(valid_601918, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601918 != nil:
    section.add "Version", valid_601918
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601919 = header.getOrDefault("X-Amz-Date")
  valid_601919 = validateParameter(valid_601919, JString, required = false,
                                 default = nil)
  if valid_601919 != nil:
    section.add "X-Amz-Date", valid_601919
  var valid_601920 = header.getOrDefault("X-Amz-Security-Token")
  valid_601920 = validateParameter(valid_601920, JString, required = false,
                                 default = nil)
  if valid_601920 != nil:
    section.add "X-Amz-Security-Token", valid_601920
  var valid_601921 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601921 = validateParameter(valid_601921, JString, required = false,
                                 default = nil)
  if valid_601921 != nil:
    section.add "X-Amz-Content-Sha256", valid_601921
  var valid_601922 = header.getOrDefault("X-Amz-Algorithm")
  valid_601922 = validateParameter(valid_601922, JString, required = false,
                                 default = nil)
  if valid_601922 != nil:
    section.add "X-Amz-Algorithm", valid_601922
  var valid_601923 = header.getOrDefault("X-Amz-Signature")
  valid_601923 = validateParameter(valid_601923, JString, required = false,
                                 default = nil)
  if valid_601923 != nil:
    section.add "X-Amz-Signature", valid_601923
  var valid_601924 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601924 = validateParameter(valid_601924, JString, required = false,
                                 default = nil)
  if valid_601924 != nil:
    section.add "X-Amz-SignedHeaders", valid_601924
  var valid_601925 = header.getOrDefault("X-Amz-Credential")
  valid_601925 = validateParameter(valid_601925, JString, required = false,
                                 default = nil)
  if valid_601925 != nil:
    section.add "X-Amz-Credential", valid_601925
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_601926 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_601926 = validateParameter(valid_601926, JString, required = false,
                                 default = nil)
  if valid_601926 != nil:
    section.add "ReservedNodeOfferingId", valid_601926
  var valid_601927 = formData.getOrDefault("Marker")
  valid_601927 = validateParameter(valid_601927, JString, required = false,
                                 default = nil)
  if valid_601927 != nil:
    section.add "Marker", valid_601927
  var valid_601928 = formData.getOrDefault("MaxRecords")
  valid_601928 = validateParameter(valid_601928, JInt, required = false, default = nil)
  if valid_601928 != nil:
    section.add "MaxRecords", valid_601928
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601929: Call_PostDescribeReservedNodeOfferings_601914;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_601929.validator(path, query, header, formData, body)
  let scheme = call_601929.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601929.url(scheme.get, call_601929.host, call_601929.base,
                         call_601929.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601929, url, valid)

proc call*(call_601930: Call_PostDescribeReservedNodeOfferings_601914;
          ReservedNodeOfferingId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodeOfferings"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_601931 = newJObject()
  var formData_601932 = newJObject()
  add(formData_601932, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_601932, "Marker", newJString(Marker))
  add(query_601931, "Action", newJString(Action))
  add(formData_601932, "MaxRecords", newJInt(MaxRecords))
  add(query_601931, "Version", newJString(Version))
  result = call_601930.call(nil, query_601931, nil, formData_601932, nil)

var postDescribeReservedNodeOfferings* = Call_PostDescribeReservedNodeOfferings_601914(
    name: "postDescribeReservedNodeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_PostDescribeReservedNodeOfferings_601915, base: "/",
    url: url_PostDescribeReservedNodeOfferings_601916,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodeOfferings_601896 = ref object of OpenApiRestCall_599352
proc url_GetDescribeReservedNodeOfferings_601898(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodeOfferings_601897(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_601899 = query.getOrDefault("MaxRecords")
  valid_601899 = validateParameter(valid_601899, JInt, required = false, default = nil)
  if valid_601899 != nil:
    section.add "MaxRecords", valid_601899
  var valid_601900 = query.getOrDefault("ReservedNodeOfferingId")
  valid_601900 = validateParameter(valid_601900, JString, required = false,
                                 default = nil)
  if valid_601900 != nil:
    section.add "ReservedNodeOfferingId", valid_601900
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601901 = query.getOrDefault("Action")
  valid_601901 = validateParameter(valid_601901, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_601901 != nil:
    section.add "Action", valid_601901
  var valid_601902 = query.getOrDefault("Marker")
  valid_601902 = validateParameter(valid_601902, JString, required = false,
                                 default = nil)
  if valid_601902 != nil:
    section.add "Marker", valid_601902
  var valid_601903 = query.getOrDefault("Version")
  valid_601903 = validateParameter(valid_601903, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601903 != nil:
    section.add "Version", valid_601903
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601904 = header.getOrDefault("X-Amz-Date")
  valid_601904 = validateParameter(valid_601904, JString, required = false,
                                 default = nil)
  if valid_601904 != nil:
    section.add "X-Amz-Date", valid_601904
  var valid_601905 = header.getOrDefault("X-Amz-Security-Token")
  valid_601905 = validateParameter(valid_601905, JString, required = false,
                                 default = nil)
  if valid_601905 != nil:
    section.add "X-Amz-Security-Token", valid_601905
  var valid_601906 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601906 = validateParameter(valid_601906, JString, required = false,
                                 default = nil)
  if valid_601906 != nil:
    section.add "X-Amz-Content-Sha256", valid_601906
  var valid_601907 = header.getOrDefault("X-Amz-Algorithm")
  valid_601907 = validateParameter(valid_601907, JString, required = false,
                                 default = nil)
  if valid_601907 != nil:
    section.add "X-Amz-Algorithm", valid_601907
  var valid_601908 = header.getOrDefault("X-Amz-Signature")
  valid_601908 = validateParameter(valid_601908, JString, required = false,
                                 default = nil)
  if valid_601908 != nil:
    section.add "X-Amz-Signature", valid_601908
  var valid_601909 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601909 = validateParameter(valid_601909, JString, required = false,
                                 default = nil)
  if valid_601909 != nil:
    section.add "X-Amz-SignedHeaders", valid_601909
  var valid_601910 = header.getOrDefault("X-Amz-Credential")
  valid_601910 = validateParameter(valid_601910, JString, required = false,
                                 default = nil)
  if valid_601910 != nil:
    section.add "X-Amz-Credential", valid_601910
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601911: Call_GetDescribeReservedNodeOfferings_601896;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_601911.validator(path, query, header, formData, body)
  let scheme = call_601911.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601911.url(scheme.get, call_601911.host, call_601911.base,
                         call_601911.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601911, url, valid)

proc call*(call_601912: Call_GetDescribeReservedNodeOfferings_601896;
          MaxRecords: int = 0; ReservedNodeOfferingId: string = "";
          Action: string = "DescribeReservedNodeOfferings"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  var query_601913 = newJObject()
  add(query_601913, "MaxRecords", newJInt(MaxRecords))
  add(query_601913, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_601913, "Action", newJString(Action))
  add(query_601913, "Marker", newJString(Marker))
  add(query_601913, "Version", newJString(Version))
  result = call_601912.call(nil, query_601913, nil, nil, nil)

var getDescribeReservedNodeOfferings* = Call_GetDescribeReservedNodeOfferings_601896(
    name: "getDescribeReservedNodeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_GetDescribeReservedNodeOfferings_601897, base: "/",
    url: url_GetDescribeReservedNodeOfferings_601898,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodes_601951 = ref object of OpenApiRestCall_599352
proc url_PostDescribeReservedNodes_601953(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeReservedNodes_601952(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601954 = query.getOrDefault("Action")
  valid_601954 = validateParameter(valid_601954, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_601954 != nil:
    section.add "Action", valid_601954
  var valid_601955 = query.getOrDefault("Version")
  valid_601955 = validateParameter(valid_601955, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601955 != nil:
    section.add "Version", valid_601955
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601956 = header.getOrDefault("X-Amz-Date")
  valid_601956 = validateParameter(valid_601956, JString, required = false,
                                 default = nil)
  if valid_601956 != nil:
    section.add "X-Amz-Date", valid_601956
  var valid_601957 = header.getOrDefault("X-Amz-Security-Token")
  valid_601957 = validateParameter(valid_601957, JString, required = false,
                                 default = nil)
  if valid_601957 != nil:
    section.add "X-Amz-Security-Token", valid_601957
  var valid_601958 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601958 = validateParameter(valid_601958, JString, required = false,
                                 default = nil)
  if valid_601958 != nil:
    section.add "X-Amz-Content-Sha256", valid_601958
  var valid_601959 = header.getOrDefault("X-Amz-Algorithm")
  valid_601959 = validateParameter(valid_601959, JString, required = false,
                                 default = nil)
  if valid_601959 != nil:
    section.add "X-Amz-Algorithm", valid_601959
  var valid_601960 = header.getOrDefault("X-Amz-Signature")
  valid_601960 = validateParameter(valid_601960, JString, required = false,
                                 default = nil)
  if valid_601960 != nil:
    section.add "X-Amz-Signature", valid_601960
  var valid_601961 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601961 = validateParameter(valid_601961, JString, required = false,
                                 default = nil)
  if valid_601961 != nil:
    section.add "X-Amz-SignedHeaders", valid_601961
  var valid_601962 = header.getOrDefault("X-Amz-Credential")
  valid_601962 = validateParameter(valid_601962, JString, required = false,
                                 default = nil)
  if valid_601962 != nil:
    section.add "X-Amz-Credential", valid_601962
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_601963 = formData.getOrDefault("ReservedNodeId")
  valid_601963 = validateParameter(valid_601963, JString, required = false,
                                 default = nil)
  if valid_601963 != nil:
    section.add "ReservedNodeId", valid_601963
  var valid_601964 = formData.getOrDefault("Marker")
  valid_601964 = validateParameter(valid_601964, JString, required = false,
                                 default = nil)
  if valid_601964 != nil:
    section.add "Marker", valid_601964
  var valid_601965 = formData.getOrDefault("MaxRecords")
  valid_601965 = validateParameter(valid_601965, JInt, required = false, default = nil)
  if valid_601965 != nil:
    section.add "MaxRecords", valid_601965
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601966: Call_PostDescribeReservedNodes_601951; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_601966.validator(path, query, header, formData, body)
  let scheme = call_601966.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601966.url(scheme.get, call_601966.host, call_601966.base,
                         call_601966.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601966, url, valid)

proc call*(call_601967: Call_PostDescribeReservedNodes_601951;
          ReservedNodeId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodes"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  var query_601968 = newJObject()
  var formData_601969 = newJObject()
  add(formData_601969, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_601969, "Marker", newJString(Marker))
  add(query_601968, "Action", newJString(Action))
  add(formData_601969, "MaxRecords", newJInt(MaxRecords))
  add(query_601968, "Version", newJString(Version))
  result = call_601967.call(nil, query_601968, nil, formData_601969, nil)

var postDescribeReservedNodes* = Call_PostDescribeReservedNodes_601951(
    name: "postDescribeReservedNodes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_PostDescribeReservedNodes_601952, base: "/",
    url: url_PostDescribeReservedNodes_601953,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodes_601933 = ref object of OpenApiRestCall_599352
proc url_GetDescribeReservedNodes_601935(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeReservedNodes_601934(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: JString (required)
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  section = newJObject()
  var valid_601936 = query.getOrDefault("MaxRecords")
  valid_601936 = validateParameter(valid_601936, JInt, required = false, default = nil)
  if valid_601936 != nil:
    section.add "MaxRecords", valid_601936
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601937 = query.getOrDefault("Action")
  valid_601937 = validateParameter(valid_601937, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_601937 != nil:
    section.add "Action", valid_601937
  var valid_601938 = query.getOrDefault("Marker")
  valid_601938 = validateParameter(valid_601938, JString, required = false,
                                 default = nil)
  if valid_601938 != nil:
    section.add "Marker", valid_601938
  var valid_601939 = query.getOrDefault("Version")
  valid_601939 = validateParameter(valid_601939, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601939 != nil:
    section.add "Version", valid_601939
  var valid_601940 = query.getOrDefault("ReservedNodeId")
  valid_601940 = validateParameter(valid_601940, JString, required = false,
                                 default = nil)
  if valid_601940 != nil:
    section.add "ReservedNodeId", valid_601940
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601941 = header.getOrDefault("X-Amz-Date")
  valid_601941 = validateParameter(valid_601941, JString, required = false,
                                 default = nil)
  if valid_601941 != nil:
    section.add "X-Amz-Date", valid_601941
  var valid_601942 = header.getOrDefault("X-Amz-Security-Token")
  valid_601942 = validateParameter(valid_601942, JString, required = false,
                                 default = nil)
  if valid_601942 != nil:
    section.add "X-Amz-Security-Token", valid_601942
  var valid_601943 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601943 = validateParameter(valid_601943, JString, required = false,
                                 default = nil)
  if valid_601943 != nil:
    section.add "X-Amz-Content-Sha256", valid_601943
  var valid_601944 = header.getOrDefault("X-Amz-Algorithm")
  valid_601944 = validateParameter(valid_601944, JString, required = false,
                                 default = nil)
  if valid_601944 != nil:
    section.add "X-Amz-Algorithm", valid_601944
  var valid_601945 = header.getOrDefault("X-Amz-Signature")
  valid_601945 = validateParameter(valid_601945, JString, required = false,
                                 default = nil)
  if valid_601945 != nil:
    section.add "X-Amz-Signature", valid_601945
  var valid_601946 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601946 = validateParameter(valid_601946, JString, required = false,
                                 default = nil)
  if valid_601946 != nil:
    section.add "X-Amz-SignedHeaders", valid_601946
  var valid_601947 = header.getOrDefault("X-Amz-Credential")
  valid_601947 = validateParameter(valid_601947, JString, required = false,
                                 default = nil)
  if valid_601947 != nil:
    section.add "X-Amz-Credential", valid_601947
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601948: Call_GetDescribeReservedNodes_601933; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_601948.validator(path, query, header, formData, body)
  let scheme = call_601948.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601948.url(scheme.get, call_601948.host, call_601948.base,
                         call_601948.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601948, url, valid)

proc call*(call_601949: Call_GetDescribeReservedNodes_601933; MaxRecords: int = 0;
          Action: string = "DescribeReservedNodes"; Marker: string = "";
          Version: string = "2012-12-01"; ReservedNodeId: string = ""): Recallable =
  ## getDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Version: string (required)
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  var query_601950 = newJObject()
  add(query_601950, "MaxRecords", newJInt(MaxRecords))
  add(query_601950, "Action", newJString(Action))
  add(query_601950, "Marker", newJString(Marker))
  add(query_601950, "Version", newJString(Version))
  add(query_601950, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_601949.call(nil, query_601950, nil, nil, nil)

var getDescribeReservedNodes* = Call_GetDescribeReservedNodes_601933(
    name: "getDescribeReservedNodes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_GetDescribeReservedNodes_601934, base: "/",
    url: url_GetDescribeReservedNodes_601935, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeResize_601986 = ref object of OpenApiRestCall_599352
proc url_PostDescribeResize_601988(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeResize_601987(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601989 = query.getOrDefault("Action")
  valid_601989 = validateParameter(valid_601989, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_601989 != nil:
    section.add "Action", valid_601989
  var valid_601990 = query.getOrDefault("Version")
  valid_601990 = validateParameter(valid_601990, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601990 != nil:
    section.add "Version", valid_601990
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601991 = header.getOrDefault("X-Amz-Date")
  valid_601991 = validateParameter(valid_601991, JString, required = false,
                                 default = nil)
  if valid_601991 != nil:
    section.add "X-Amz-Date", valid_601991
  var valid_601992 = header.getOrDefault("X-Amz-Security-Token")
  valid_601992 = validateParameter(valid_601992, JString, required = false,
                                 default = nil)
  if valid_601992 != nil:
    section.add "X-Amz-Security-Token", valid_601992
  var valid_601993 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601993 = validateParameter(valid_601993, JString, required = false,
                                 default = nil)
  if valid_601993 != nil:
    section.add "X-Amz-Content-Sha256", valid_601993
  var valid_601994 = header.getOrDefault("X-Amz-Algorithm")
  valid_601994 = validateParameter(valid_601994, JString, required = false,
                                 default = nil)
  if valid_601994 != nil:
    section.add "X-Amz-Algorithm", valid_601994
  var valid_601995 = header.getOrDefault("X-Amz-Signature")
  valid_601995 = validateParameter(valid_601995, JString, required = false,
                                 default = nil)
  if valid_601995 != nil:
    section.add "X-Amz-Signature", valid_601995
  var valid_601996 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601996 = validateParameter(valid_601996, JString, required = false,
                                 default = nil)
  if valid_601996 != nil:
    section.add "X-Amz-SignedHeaders", valid_601996
  var valid_601997 = header.getOrDefault("X-Amz-Credential")
  valid_601997 = validateParameter(valid_601997, JString, required = false,
                                 default = nil)
  if valid_601997 != nil:
    section.add "X-Amz-Credential", valid_601997
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_601998 = formData.getOrDefault("ClusterIdentifier")
  valid_601998 = validateParameter(valid_601998, JString, required = true,
                                 default = nil)
  if valid_601998 != nil:
    section.add "ClusterIdentifier", valid_601998
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601999: Call_PostDescribeResize_601986; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_601999.validator(path, query, header, formData, body)
  let scheme = call_601999.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601999.url(scheme.get, call_601999.host, call_601999.base,
                         call_601999.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601999, url, valid)

proc call*(call_602000: Call_PostDescribeResize_601986; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_602001 = newJObject()
  var formData_602002 = newJObject()
  add(query_602001, "Action", newJString(Action))
  add(formData_602002, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602001, "Version", newJString(Version))
  result = call_602000.call(nil, query_602001, nil, formData_602002, nil)

var postDescribeResize* = Call_PostDescribeResize_601986(
    name: "postDescribeResize", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeResize",
    validator: validate_PostDescribeResize_601987, base: "/",
    url: url_PostDescribeResize_601988, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeResize_601970 = ref object of OpenApiRestCall_599352
proc url_GetDescribeResize_601972(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeResize_601971(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_601973 = query.getOrDefault("Action")
  valid_601973 = validateParameter(valid_601973, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_601973 != nil:
    section.add "Action", valid_601973
  var valid_601974 = query.getOrDefault("ClusterIdentifier")
  valid_601974 = validateParameter(valid_601974, JString, required = true,
                                 default = nil)
  if valid_601974 != nil:
    section.add "ClusterIdentifier", valid_601974
  var valid_601975 = query.getOrDefault("Version")
  valid_601975 = validateParameter(valid_601975, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_601975 != nil:
    section.add "Version", valid_601975
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_601976 = header.getOrDefault("X-Amz-Date")
  valid_601976 = validateParameter(valid_601976, JString, required = false,
                                 default = nil)
  if valid_601976 != nil:
    section.add "X-Amz-Date", valid_601976
  var valid_601977 = header.getOrDefault("X-Amz-Security-Token")
  valid_601977 = validateParameter(valid_601977, JString, required = false,
                                 default = nil)
  if valid_601977 != nil:
    section.add "X-Amz-Security-Token", valid_601977
  var valid_601978 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_601978 = validateParameter(valid_601978, JString, required = false,
                                 default = nil)
  if valid_601978 != nil:
    section.add "X-Amz-Content-Sha256", valid_601978
  var valid_601979 = header.getOrDefault("X-Amz-Algorithm")
  valid_601979 = validateParameter(valid_601979, JString, required = false,
                                 default = nil)
  if valid_601979 != nil:
    section.add "X-Amz-Algorithm", valid_601979
  var valid_601980 = header.getOrDefault("X-Amz-Signature")
  valid_601980 = validateParameter(valid_601980, JString, required = false,
                                 default = nil)
  if valid_601980 != nil:
    section.add "X-Amz-Signature", valid_601980
  var valid_601981 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_601981 = validateParameter(valid_601981, JString, required = false,
                                 default = nil)
  if valid_601981 != nil:
    section.add "X-Amz-SignedHeaders", valid_601981
  var valid_601982 = header.getOrDefault("X-Amz-Credential")
  valid_601982 = validateParameter(valid_601982, JString, required = false,
                                 default = nil)
  if valid_601982 != nil:
    section.add "X-Amz-Credential", valid_601982
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_601983: Call_GetDescribeResize_601970; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_601983.validator(path, query, header, formData, body)
  let scheme = call_601983.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_601983.url(scheme.get, call_601983.host, call_601983.base,
                         call_601983.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_601983, url, valid)

proc call*(call_601984: Call_GetDescribeResize_601970; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_601985 = newJObject()
  add(query_601985, "Action", newJString(Action))
  add(query_601985, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_601985, "Version", newJString(Version))
  result = call_601984.call(nil, query_601985, nil, nil, nil)

var getDescribeResize* = Call_GetDescribeResize_601970(name: "getDescribeResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeResize", validator: validate_GetDescribeResize_601971,
    base: "/", url: url_GetDescribeResize_601972,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeScheduledActions_602026 = ref object of OpenApiRestCall_599352
proc url_PostDescribeScheduledActions_602028(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeScheduledActions_602027(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602029 = query.getOrDefault("Action")
  valid_602029 = validateParameter(valid_602029, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_602029 != nil:
    section.add "Action", valid_602029
  var valid_602030 = query.getOrDefault("Version")
  valid_602030 = validateParameter(valid_602030, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602030 != nil:
    section.add "Version", valid_602030
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602031 = header.getOrDefault("X-Amz-Date")
  valid_602031 = validateParameter(valid_602031, JString, required = false,
                                 default = nil)
  if valid_602031 != nil:
    section.add "X-Amz-Date", valid_602031
  var valid_602032 = header.getOrDefault("X-Amz-Security-Token")
  valid_602032 = validateParameter(valid_602032, JString, required = false,
                                 default = nil)
  if valid_602032 != nil:
    section.add "X-Amz-Security-Token", valid_602032
  var valid_602033 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602033 = validateParameter(valid_602033, JString, required = false,
                                 default = nil)
  if valid_602033 != nil:
    section.add "X-Amz-Content-Sha256", valid_602033
  var valid_602034 = header.getOrDefault("X-Amz-Algorithm")
  valid_602034 = validateParameter(valid_602034, JString, required = false,
                                 default = nil)
  if valid_602034 != nil:
    section.add "X-Amz-Algorithm", valid_602034
  var valid_602035 = header.getOrDefault("X-Amz-Signature")
  valid_602035 = validateParameter(valid_602035, JString, required = false,
                                 default = nil)
  if valid_602035 != nil:
    section.add "X-Amz-Signature", valid_602035
  var valid_602036 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602036 = validateParameter(valid_602036, JString, required = false,
                                 default = nil)
  if valid_602036 != nil:
    section.add "X-Amz-SignedHeaders", valid_602036
  var valid_602037 = header.getOrDefault("X-Amz-Credential")
  valid_602037 = validateParameter(valid_602037, JString, required = false,
                                 default = nil)
  if valid_602037 != nil:
    section.add "X-Amz-Credential", valid_602037
  result.add "header", section
  ## parameters in `formData` object:
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  section = newJObject()
  var valid_602038 = formData.getOrDefault("Active")
  valid_602038 = validateParameter(valid_602038, JBool, required = false, default = nil)
  if valid_602038 != nil:
    section.add "Active", valid_602038
  var valid_602039 = formData.getOrDefault("Marker")
  valid_602039 = validateParameter(valid_602039, JString, required = false,
                                 default = nil)
  if valid_602039 != nil:
    section.add "Marker", valid_602039
  var valid_602040 = formData.getOrDefault("StartTime")
  valid_602040 = validateParameter(valid_602040, JString, required = false,
                                 default = nil)
  if valid_602040 != nil:
    section.add "StartTime", valid_602040
  var valid_602041 = formData.getOrDefault("ScheduledActionName")
  valid_602041 = validateParameter(valid_602041, JString, required = false,
                                 default = nil)
  if valid_602041 != nil:
    section.add "ScheduledActionName", valid_602041
  var valid_602042 = formData.getOrDefault("Filters")
  valid_602042 = validateParameter(valid_602042, JArray, required = false,
                                 default = nil)
  if valid_602042 != nil:
    section.add "Filters", valid_602042
  var valid_602043 = formData.getOrDefault("EndTime")
  valid_602043 = validateParameter(valid_602043, JString, required = false,
                                 default = nil)
  if valid_602043 != nil:
    section.add "EndTime", valid_602043
  var valid_602044 = formData.getOrDefault("MaxRecords")
  valid_602044 = validateParameter(valid_602044, JInt, required = false, default = nil)
  if valid_602044 != nil:
    section.add "MaxRecords", valid_602044
  var valid_602045 = formData.getOrDefault("TargetActionType")
  valid_602045 = validateParameter(valid_602045, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_602045 != nil:
    section.add "TargetActionType", valid_602045
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602046: Call_PostDescribeScheduledActions_602026; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_602046.validator(path, query, header, formData, body)
  let scheme = call_602046.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602046.url(scheme.get, call_602046.host, call_602046.base,
                         call_602046.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602046, url, valid)

proc call*(call_602047: Call_PostDescribeScheduledActions_602026;
          Active: bool = false; Marker: string = ""; StartTime: string = "";
          Action: string = "DescribeScheduledActions";
          ScheduledActionName: string = ""; Filters: JsonNode = nil;
          EndTime: string = ""; MaxRecords: int = 0; Version: string = "2012-12-01";
          TargetActionType: string = "ResizeCluster"): Recallable =
  ## postDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Action: string (required)
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Version: string (required)
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  var query_602048 = newJObject()
  var formData_602049 = newJObject()
  add(formData_602049, "Active", newJBool(Active))
  add(formData_602049, "Marker", newJString(Marker))
  add(formData_602049, "StartTime", newJString(StartTime))
  add(query_602048, "Action", newJString(Action))
  add(formData_602049, "ScheduledActionName", newJString(ScheduledActionName))
  if Filters != nil:
    formData_602049.add "Filters", Filters
  add(formData_602049, "EndTime", newJString(EndTime))
  add(formData_602049, "MaxRecords", newJInt(MaxRecords))
  add(query_602048, "Version", newJString(Version))
  add(formData_602049, "TargetActionType", newJString(TargetActionType))
  result = call_602047.call(nil, query_602048, nil, formData_602049, nil)

var postDescribeScheduledActions* = Call_PostDescribeScheduledActions_602026(
    name: "postDescribeScheduledActions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_PostDescribeScheduledActions_602027, base: "/",
    url: url_PostDescribeScheduledActions_602028,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeScheduledActions_602003 = ref object of OpenApiRestCall_599352
proc url_GetDescribeScheduledActions_602005(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeScheduledActions_602004(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes properties of scheduled actions. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TargetActionType: JString
  ##                   : The type of the scheduled actions to retrieve. 
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: JString
  ##                      : The name of the scheduled action to retrieve. 
  ##   StartTime: JString
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   Action: JString (required)
  ##   Active: JBool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   EndTime: JString
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: JString (required)
  section = newJObject()
  var valid_602006 = query.getOrDefault("TargetActionType")
  valid_602006 = validateParameter(valid_602006, JString, required = false,
                                 default = newJString("ResizeCluster"))
  if valid_602006 != nil:
    section.add "TargetActionType", valid_602006
  var valid_602007 = query.getOrDefault("MaxRecords")
  valid_602007 = validateParameter(valid_602007, JInt, required = false, default = nil)
  if valid_602007 != nil:
    section.add "MaxRecords", valid_602007
  var valid_602008 = query.getOrDefault("ScheduledActionName")
  valid_602008 = validateParameter(valid_602008, JString, required = false,
                                 default = nil)
  if valid_602008 != nil:
    section.add "ScheduledActionName", valid_602008
  var valid_602009 = query.getOrDefault("StartTime")
  valid_602009 = validateParameter(valid_602009, JString, required = false,
                                 default = nil)
  if valid_602009 != nil:
    section.add "StartTime", valid_602009
  var valid_602010 = query.getOrDefault("Filters")
  valid_602010 = validateParameter(valid_602010, JArray, required = false,
                                 default = nil)
  if valid_602010 != nil:
    section.add "Filters", valid_602010
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602011 = query.getOrDefault("Action")
  valid_602011 = validateParameter(valid_602011, JString, required = true, default = newJString(
      "DescribeScheduledActions"))
  if valid_602011 != nil:
    section.add "Action", valid_602011
  var valid_602012 = query.getOrDefault("Active")
  valid_602012 = validateParameter(valid_602012, JBool, required = false, default = nil)
  if valid_602012 != nil:
    section.add "Active", valid_602012
  var valid_602013 = query.getOrDefault("Marker")
  valid_602013 = validateParameter(valid_602013, JString, required = false,
                                 default = nil)
  if valid_602013 != nil:
    section.add "Marker", valid_602013
  var valid_602014 = query.getOrDefault("EndTime")
  valid_602014 = validateParameter(valid_602014, JString, required = false,
                                 default = nil)
  if valid_602014 != nil:
    section.add "EndTime", valid_602014
  var valid_602015 = query.getOrDefault("Version")
  valid_602015 = validateParameter(valid_602015, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602015 != nil:
    section.add "Version", valid_602015
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602016 = header.getOrDefault("X-Amz-Date")
  valid_602016 = validateParameter(valid_602016, JString, required = false,
                                 default = nil)
  if valid_602016 != nil:
    section.add "X-Amz-Date", valid_602016
  var valid_602017 = header.getOrDefault("X-Amz-Security-Token")
  valid_602017 = validateParameter(valid_602017, JString, required = false,
                                 default = nil)
  if valid_602017 != nil:
    section.add "X-Amz-Security-Token", valid_602017
  var valid_602018 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602018 = validateParameter(valid_602018, JString, required = false,
                                 default = nil)
  if valid_602018 != nil:
    section.add "X-Amz-Content-Sha256", valid_602018
  var valid_602019 = header.getOrDefault("X-Amz-Algorithm")
  valid_602019 = validateParameter(valid_602019, JString, required = false,
                                 default = nil)
  if valid_602019 != nil:
    section.add "X-Amz-Algorithm", valid_602019
  var valid_602020 = header.getOrDefault("X-Amz-Signature")
  valid_602020 = validateParameter(valid_602020, JString, required = false,
                                 default = nil)
  if valid_602020 != nil:
    section.add "X-Amz-Signature", valid_602020
  var valid_602021 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602021 = validateParameter(valid_602021, JString, required = false,
                                 default = nil)
  if valid_602021 != nil:
    section.add "X-Amz-SignedHeaders", valid_602021
  var valid_602022 = header.getOrDefault("X-Amz-Credential")
  valid_602022 = validateParameter(valid_602022, JString, required = false,
                                 default = nil)
  if valid_602022 != nil:
    section.add "X-Amz-Credential", valid_602022
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602023: Call_GetDescribeScheduledActions_602003; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes properties of scheduled actions. 
  ## 
  let valid = call_602023.validator(path, query, header, formData, body)
  let scheme = call_602023.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602023.url(scheme.get, call_602023.host, call_602023.base,
                         call_602023.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602023, url, valid)

proc call*(call_602024: Call_GetDescribeScheduledActions_602003;
          TargetActionType: string = "ResizeCluster"; MaxRecords: int = 0;
          ScheduledActionName: string = ""; StartTime: string = "";
          Filters: JsonNode = nil; Action: string = "DescribeScheduledActions";
          Active: bool = false; Marker: string = ""; EndTime: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeScheduledActions
  ## Describes properties of scheduled actions. 
  ##   TargetActionType: string
  ##                   : The type of the scheduled actions to retrieve. 
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ScheduledActionName: string
  ##                      : The name of the scheduled action to retrieve. 
  ##   StartTime: string
  ##            : The start time in UTC of the scheduled actions to retrieve. Only active scheduled actions that have invocations after this time are retrieved.
  ##   Filters: JArray
  ##          : List of scheduled action filters. 
  ##   Action: string (required)
  ##   Active: bool
  ##         : If true, retrieve only active scheduled actions. If false, retrieve only disabled scheduled actions. 
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeScheduledActions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   EndTime: string
  ##          : The end time in UTC of the scheduled action to retrieve. Only active scheduled actions that have invocations before this time are retrieved.
  ##   Version: string (required)
  var query_602025 = newJObject()
  add(query_602025, "TargetActionType", newJString(TargetActionType))
  add(query_602025, "MaxRecords", newJInt(MaxRecords))
  add(query_602025, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_602025, "StartTime", newJString(StartTime))
  if Filters != nil:
    query_602025.add "Filters", Filters
  add(query_602025, "Action", newJString(Action))
  add(query_602025, "Active", newJBool(Active))
  add(query_602025, "Marker", newJString(Marker))
  add(query_602025, "EndTime", newJString(EndTime))
  add(query_602025, "Version", newJString(Version))
  result = call_602024.call(nil, query_602025, nil, nil, nil)

var getDescribeScheduledActions* = Call_GetDescribeScheduledActions_602003(
    name: "getDescribeScheduledActions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeScheduledActions",
    validator: validate_GetDescribeScheduledActions_602004, base: "/",
    url: url_GetDescribeScheduledActions_602005,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotCopyGrants_602070 = ref object of OpenApiRestCall_599352
proc url_PostDescribeSnapshotCopyGrants_602072(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotCopyGrants_602071(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602073 = query.getOrDefault("Action")
  valid_602073 = validateParameter(valid_602073, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_602073 != nil:
    section.add "Action", valid_602073
  var valid_602074 = query.getOrDefault("Version")
  valid_602074 = validateParameter(valid_602074, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602074 != nil:
    section.add "Version", valid_602074
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602075 = header.getOrDefault("X-Amz-Date")
  valid_602075 = validateParameter(valid_602075, JString, required = false,
                                 default = nil)
  if valid_602075 != nil:
    section.add "X-Amz-Date", valid_602075
  var valid_602076 = header.getOrDefault("X-Amz-Security-Token")
  valid_602076 = validateParameter(valid_602076, JString, required = false,
                                 default = nil)
  if valid_602076 != nil:
    section.add "X-Amz-Security-Token", valid_602076
  var valid_602077 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602077 = validateParameter(valid_602077, JString, required = false,
                                 default = nil)
  if valid_602077 != nil:
    section.add "X-Amz-Content-Sha256", valid_602077
  var valid_602078 = header.getOrDefault("X-Amz-Algorithm")
  valid_602078 = validateParameter(valid_602078, JString, required = false,
                                 default = nil)
  if valid_602078 != nil:
    section.add "X-Amz-Algorithm", valid_602078
  var valid_602079 = header.getOrDefault("X-Amz-Signature")
  valid_602079 = validateParameter(valid_602079, JString, required = false,
                                 default = nil)
  if valid_602079 != nil:
    section.add "X-Amz-Signature", valid_602079
  var valid_602080 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602080 = validateParameter(valid_602080, JString, required = false,
                                 default = nil)
  if valid_602080 != nil:
    section.add "X-Amz-SignedHeaders", valid_602080
  var valid_602081 = header.getOrDefault("X-Amz-Credential")
  valid_602081 = validateParameter(valid_602081, JString, required = false,
                                 default = nil)
  if valid_602081 != nil:
    section.add "X-Amz-Credential", valid_602081
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_602082 = formData.getOrDefault("Marker")
  valid_602082 = validateParameter(valid_602082, JString, required = false,
                                 default = nil)
  if valid_602082 != nil:
    section.add "Marker", valid_602082
  var valid_602083 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_602083 = validateParameter(valid_602083, JString, required = false,
                                 default = nil)
  if valid_602083 != nil:
    section.add "SnapshotCopyGrantName", valid_602083
  var valid_602084 = formData.getOrDefault("TagKeys")
  valid_602084 = validateParameter(valid_602084, JArray, required = false,
                                 default = nil)
  if valid_602084 != nil:
    section.add "TagKeys", valid_602084
  var valid_602085 = formData.getOrDefault("MaxRecords")
  valid_602085 = validateParameter(valid_602085, JInt, required = false, default = nil)
  if valid_602085 != nil:
    section.add "MaxRecords", valid_602085
  var valid_602086 = formData.getOrDefault("TagValues")
  valid_602086 = validateParameter(valid_602086, JArray, required = false,
                                 default = nil)
  if valid_602086 != nil:
    section.add "TagValues", valid_602086
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602087: Call_PostDescribeSnapshotCopyGrants_602070; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_602087.validator(path, query, header, formData, body)
  let scheme = call_602087.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602087.url(scheme.get, call_602087.host, call_602087.base,
                         call_602087.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602087, url, valid)

proc call*(call_602088: Call_PostDescribeSnapshotCopyGrants_602070;
          Marker: string = ""; Action: string = "DescribeSnapshotCopyGrants";
          SnapshotCopyGrantName: string = ""; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_602089 = newJObject()
  var formData_602090 = newJObject()
  add(formData_602090, "Marker", newJString(Marker))
  add(query_602089, "Action", newJString(Action))
  add(formData_602090, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  if TagKeys != nil:
    formData_602090.add "TagKeys", TagKeys
  add(formData_602090, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_602090.add "TagValues", TagValues
  add(query_602089, "Version", newJString(Version))
  result = call_602088.call(nil, query_602089, nil, formData_602090, nil)

var postDescribeSnapshotCopyGrants* = Call_PostDescribeSnapshotCopyGrants_602070(
    name: "postDescribeSnapshotCopyGrants", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_PostDescribeSnapshotCopyGrants_602071, base: "/",
    url: url_PostDescribeSnapshotCopyGrants_602072,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotCopyGrants_602050 = ref object of OpenApiRestCall_599352
proc url_GetDescribeSnapshotCopyGrants_602052(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotCopyGrants_602051(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Version: JString (required)
  section = newJObject()
  var valid_602053 = query.getOrDefault("TagValues")
  valid_602053 = validateParameter(valid_602053, JArray, required = false,
                                 default = nil)
  if valid_602053 != nil:
    section.add "TagValues", valid_602053
  var valid_602054 = query.getOrDefault("MaxRecords")
  valid_602054 = validateParameter(valid_602054, JInt, required = false, default = nil)
  if valid_602054 != nil:
    section.add "MaxRecords", valid_602054
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602055 = query.getOrDefault("Action")
  valid_602055 = validateParameter(valid_602055, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_602055 != nil:
    section.add "Action", valid_602055
  var valid_602056 = query.getOrDefault("Marker")
  valid_602056 = validateParameter(valid_602056, JString, required = false,
                                 default = nil)
  if valid_602056 != nil:
    section.add "Marker", valid_602056
  var valid_602057 = query.getOrDefault("SnapshotCopyGrantName")
  valid_602057 = validateParameter(valid_602057, JString, required = false,
                                 default = nil)
  if valid_602057 != nil:
    section.add "SnapshotCopyGrantName", valid_602057
  var valid_602058 = query.getOrDefault("TagKeys")
  valid_602058 = validateParameter(valid_602058, JArray, required = false,
                                 default = nil)
  if valid_602058 != nil:
    section.add "TagKeys", valid_602058
  var valid_602059 = query.getOrDefault("Version")
  valid_602059 = validateParameter(valid_602059, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602059 != nil:
    section.add "Version", valid_602059
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602060 = header.getOrDefault("X-Amz-Date")
  valid_602060 = validateParameter(valid_602060, JString, required = false,
                                 default = nil)
  if valid_602060 != nil:
    section.add "X-Amz-Date", valid_602060
  var valid_602061 = header.getOrDefault("X-Amz-Security-Token")
  valid_602061 = validateParameter(valid_602061, JString, required = false,
                                 default = nil)
  if valid_602061 != nil:
    section.add "X-Amz-Security-Token", valid_602061
  var valid_602062 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602062 = validateParameter(valid_602062, JString, required = false,
                                 default = nil)
  if valid_602062 != nil:
    section.add "X-Amz-Content-Sha256", valid_602062
  var valid_602063 = header.getOrDefault("X-Amz-Algorithm")
  valid_602063 = validateParameter(valid_602063, JString, required = false,
                                 default = nil)
  if valid_602063 != nil:
    section.add "X-Amz-Algorithm", valid_602063
  var valid_602064 = header.getOrDefault("X-Amz-Signature")
  valid_602064 = validateParameter(valid_602064, JString, required = false,
                                 default = nil)
  if valid_602064 != nil:
    section.add "X-Amz-Signature", valid_602064
  var valid_602065 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602065 = validateParameter(valid_602065, JString, required = false,
                                 default = nil)
  if valid_602065 != nil:
    section.add "X-Amz-SignedHeaders", valid_602065
  var valid_602066 = header.getOrDefault("X-Amz-Credential")
  valid_602066 = validateParameter(valid_602066, JString, required = false,
                                 default = nil)
  if valid_602066 != nil:
    section.add "X-Amz-Credential", valid_602066
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602067: Call_GetDescribeSnapshotCopyGrants_602050; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_602067.validator(path, query, header, formData, body)
  let scheme = call_602067.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602067.url(scheme.get, call_602067.host, call_602067.base,
                         call_602067.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602067, url, valid)

proc call*(call_602068: Call_GetDescribeSnapshotCopyGrants_602050;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeSnapshotCopyGrants"; Marker: string = "";
          SnapshotCopyGrantName: string = ""; TagKeys: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Action: string (required)
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Version: string (required)
  var query_602069 = newJObject()
  if TagValues != nil:
    query_602069.add "TagValues", TagValues
  add(query_602069, "MaxRecords", newJInt(MaxRecords))
  add(query_602069, "Action", newJString(Action))
  add(query_602069, "Marker", newJString(Marker))
  add(query_602069, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  if TagKeys != nil:
    query_602069.add "TagKeys", TagKeys
  add(query_602069, "Version", newJString(Version))
  result = call_602068.call(nil, query_602069, nil, nil, nil)

var getDescribeSnapshotCopyGrants* = Call_GetDescribeSnapshotCopyGrants_602050(
    name: "getDescribeSnapshotCopyGrants", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_GetDescribeSnapshotCopyGrants_602051, base: "/",
    url: url_GetDescribeSnapshotCopyGrants_602052,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotSchedules_602112 = ref object of OpenApiRestCall_599352
proc url_PostDescribeSnapshotSchedules_602114(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeSnapshotSchedules_602113(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602115 = query.getOrDefault("Action")
  valid_602115 = validateParameter(valid_602115, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_602115 != nil:
    section.add "Action", valid_602115
  var valid_602116 = query.getOrDefault("Version")
  valid_602116 = validateParameter(valid_602116, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602116 != nil:
    section.add "Version", valid_602116
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602117 = header.getOrDefault("X-Amz-Date")
  valid_602117 = validateParameter(valid_602117, JString, required = false,
                                 default = nil)
  if valid_602117 != nil:
    section.add "X-Amz-Date", valid_602117
  var valid_602118 = header.getOrDefault("X-Amz-Security-Token")
  valid_602118 = validateParameter(valid_602118, JString, required = false,
                                 default = nil)
  if valid_602118 != nil:
    section.add "X-Amz-Security-Token", valid_602118
  var valid_602119 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602119 = validateParameter(valid_602119, JString, required = false,
                                 default = nil)
  if valid_602119 != nil:
    section.add "X-Amz-Content-Sha256", valid_602119
  var valid_602120 = header.getOrDefault("X-Amz-Algorithm")
  valid_602120 = validateParameter(valid_602120, JString, required = false,
                                 default = nil)
  if valid_602120 != nil:
    section.add "X-Amz-Algorithm", valid_602120
  var valid_602121 = header.getOrDefault("X-Amz-Signature")
  valid_602121 = validateParameter(valid_602121, JString, required = false,
                                 default = nil)
  if valid_602121 != nil:
    section.add "X-Amz-Signature", valid_602121
  var valid_602122 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602122 = validateParameter(valid_602122, JString, required = false,
                                 default = nil)
  if valid_602122 != nil:
    section.add "X-Amz-SignedHeaders", valid_602122
  var valid_602123 = header.getOrDefault("X-Amz-Credential")
  valid_602123 = validateParameter(valid_602123, JString, required = false,
                                 default = nil)
  if valid_602123 != nil:
    section.add "X-Amz-Credential", valid_602123
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  section = newJObject()
  var valid_602124 = formData.getOrDefault("Marker")
  valid_602124 = validateParameter(valid_602124, JString, required = false,
                                 default = nil)
  if valid_602124 != nil:
    section.add "Marker", valid_602124
  var valid_602125 = formData.getOrDefault("ClusterIdentifier")
  valid_602125 = validateParameter(valid_602125, JString, required = false,
                                 default = nil)
  if valid_602125 != nil:
    section.add "ClusterIdentifier", valid_602125
  var valid_602126 = formData.getOrDefault("ScheduleIdentifier")
  valid_602126 = validateParameter(valid_602126, JString, required = false,
                                 default = nil)
  if valid_602126 != nil:
    section.add "ScheduleIdentifier", valid_602126
  var valid_602127 = formData.getOrDefault("TagKeys")
  valid_602127 = validateParameter(valid_602127, JArray, required = false,
                                 default = nil)
  if valid_602127 != nil:
    section.add "TagKeys", valid_602127
  var valid_602128 = formData.getOrDefault("MaxRecords")
  valid_602128 = validateParameter(valid_602128, JInt, required = false, default = nil)
  if valid_602128 != nil:
    section.add "MaxRecords", valid_602128
  var valid_602129 = formData.getOrDefault("TagValues")
  valid_602129 = validateParameter(valid_602129, JArray, required = false,
                                 default = nil)
  if valid_602129 != nil:
    section.add "TagValues", valid_602129
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602130: Call_PostDescribeSnapshotSchedules_602112; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_602130.validator(path, query, header, formData, body)
  let scheme = call_602130.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602130.url(scheme.get, call_602130.host, call_602130.base,
                         call_602130.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602130, url, valid)

proc call*(call_602131: Call_PostDescribeSnapshotSchedules_602112;
          Marker: string = ""; Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; ScheduleIdentifier: string = "";
          TagKeys: JsonNode = nil; MaxRecords: int = 0; TagValues: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   Version: string (required)
  var query_602132 = newJObject()
  var formData_602133 = newJObject()
  add(formData_602133, "Marker", newJString(Marker))
  add(query_602132, "Action", newJString(Action))
  add(formData_602133, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_602133, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if TagKeys != nil:
    formData_602133.add "TagKeys", TagKeys
  add(formData_602133, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_602133.add "TagValues", TagValues
  add(query_602132, "Version", newJString(Version))
  result = call_602131.call(nil, query_602132, nil, formData_602133, nil)

var postDescribeSnapshotSchedules* = Call_PostDescribeSnapshotSchedules_602112(
    name: "postDescribeSnapshotSchedules", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_PostDescribeSnapshotSchedules_602113, base: "/",
    url: url_PostDescribeSnapshotSchedules_602114,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotSchedules_602091 = ref object of OpenApiRestCall_599352
proc url_GetDescribeSnapshotSchedules_602093(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeSnapshotSchedules_602092(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Version: JString (required)
  section = newJObject()
  var valid_602094 = query.getOrDefault("TagValues")
  valid_602094 = validateParameter(valid_602094, JArray, required = false,
                                 default = nil)
  if valid_602094 != nil:
    section.add "TagValues", valid_602094
  var valid_602095 = query.getOrDefault("MaxRecords")
  valid_602095 = validateParameter(valid_602095, JInt, required = false, default = nil)
  if valid_602095 != nil:
    section.add "MaxRecords", valid_602095
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602096 = query.getOrDefault("Action")
  valid_602096 = validateParameter(valid_602096, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_602096 != nil:
    section.add "Action", valid_602096
  var valid_602097 = query.getOrDefault("ClusterIdentifier")
  valid_602097 = validateParameter(valid_602097, JString, required = false,
                                 default = nil)
  if valid_602097 != nil:
    section.add "ClusterIdentifier", valid_602097
  var valid_602098 = query.getOrDefault("ScheduleIdentifier")
  valid_602098 = validateParameter(valid_602098, JString, required = false,
                                 default = nil)
  if valid_602098 != nil:
    section.add "ScheduleIdentifier", valid_602098
  var valid_602099 = query.getOrDefault("Marker")
  valid_602099 = validateParameter(valid_602099, JString, required = false,
                                 default = nil)
  if valid_602099 != nil:
    section.add "Marker", valid_602099
  var valid_602100 = query.getOrDefault("TagKeys")
  valid_602100 = validateParameter(valid_602100, JArray, required = false,
                                 default = nil)
  if valid_602100 != nil:
    section.add "TagKeys", valid_602100
  var valid_602101 = query.getOrDefault("Version")
  valid_602101 = validateParameter(valid_602101, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602101 != nil:
    section.add "Version", valid_602101
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602102 = header.getOrDefault("X-Amz-Date")
  valid_602102 = validateParameter(valid_602102, JString, required = false,
                                 default = nil)
  if valid_602102 != nil:
    section.add "X-Amz-Date", valid_602102
  var valid_602103 = header.getOrDefault("X-Amz-Security-Token")
  valid_602103 = validateParameter(valid_602103, JString, required = false,
                                 default = nil)
  if valid_602103 != nil:
    section.add "X-Amz-Security-Token", valid_602103
  var valid_602104 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602104 = validateParameter(valid_602104, JString, required = false,
                                 default = nil)
  if valid_602104 != nil:
    section.add "X-Amz-Content-Sha256", valid_602104
  var valid_602105 = header.getOrDefault("X-Amz-Algorithm")
  valid_602105 = validateParameter(valid_602105, JString, required = false,
                                 default = nil)
  if valid_602105 != nil:
    section.add "X-Amz-Algorithm", valid_602105
  var valid_602106 = header.getOrDefault("X-Amz-Signature")
  valid_602106 = validateParameter(valid_602106, JString, required = false,
                                 default = nil)
  if valid_602106 != nil:
    section.add "X-Amz-Signature", valid_602106
  var valid_602107 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602107 = validateParameter(valid_602107, JString, required = false,
                                 default = nil)
  if valid_602107 != nil:
    section.add "X-Amz-SignedHeaders", valid_602107
  var valid_602108 = header.getOrDefault("X-Amz-Credential")
  valid_602108 = validateParameter(valid_602108, JString, required = false,
                                 default = nil)
  if valid_602108 != nil:
    section.add "X-Amz-Credential", valid_602108
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602109: Call_GetDescribeSnapshotSchedules_602091; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_602109.validator(path, query, header, formData, body)
  let scheme = call_602109.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602109.url(scheme.get, call_602109.host, call_602109.base,
                         call_602109.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602109, url, valid)

proc call*(call_602110: Call_GetDescribeSnapshotSchedules_602091;
          TagValues: JsonNode = nil; MaxRecords: int = 0;
          Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; ScheduleIdentifier: string = "";
          Marker: string = ""; TagKeys: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## getDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Version: string (required)
  var query_602111 = newJObject()
  if TagValues != nil:
    query_602111.add "TagValues", TagValues
  add(query_602111, "MaxRecords", newJInt(MaxRecords))
  add(query_602111, "Action", newJString(Action))
  add(query_602111, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602111, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_602111, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_602111.add "TagKeys", TagKeys
  add(query_602111, "Version", newJString(Version))
  result = call_602110.call(nil, query_602111, nil, nil, nil)

var getDescribeSnapshotSchedules* = Call_GetDescribeSnapshotSchedules_602091(
    name: "getDescribeSnapshotSchedules", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_GetDescribeSnapshotSchedules_602092, base: "/",
    url: url_GetDescribeSnapshotSchedules_602093,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeStorage_602149 = ref object of OpenApiRestCall_599352
proc url_PostDescribeStorage_602151(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeStorage_602150(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602152 = query.getOrDefault("Action")
  valid_602152 = validateParameter(valid_602152, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_602152 != nil:
    section.add "Action", valid_602152
  var valid_602153 = query.getOrDefault("Version")
  valid_602153 = validateParameter(valid_602153, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602153 != nil:
    section.add "Version", valid_602153
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602154 = header.getOrDefault("X-Amz-Date")
  valid_602154 = validateParameter(valid_602154, JString, required = false,
                                 default = nil)
  if valid_602154 != nil:
    section.add "X-Amz-Date", valid_602154
  var valid_602155 = header.getOrDefault("X-Amz-Security-Token")
  valid_602155 = validateParameter(valid_602155, JString, required = false,
                                 default = nil)
  if valid_602155 != nil:
    section.add "X-Amz-Security-Token", valid_602155
  var valid_602156 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602156 = validateParameter(valid_602156, JString, required = false,
                                 default = nil)
  if valid_602156 != nil:
    section.add "X-Amz-Content-Sha256", valid_602156
  var valid_602157 = header.getOrDefault("X-Amz-Algorithm")
  valid_602157 = validateParameter(valid_602157, JString, required = false,
                                 default = nil)
  if valid_602157 != nil:
    section.add "X-Amz-Algorithm", valid_602157
  var valid_602158 = header.getOrDefault("X-Amz-Signature")
  valid_602158 = validateParameter(valid_602158, JString, required = false,
                                 default = nil)
  if valid_602158 != nil:
    section.add "X-Amz-Signature", valid_602158
  var valid_602159 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602159 = validateParameter(valid_602159, JString, required = false,
                                 default = nil)
  if valid_602159 != nil:
    section.add "X-Amz-SignedHeaders", valid_602159
  var valid_602160 = header.getOrDefault("X-Amz-Credential")
  valid_602160 = validateParameter(valid_602160, JString, required = false,
                                 default = nil)
  if valid_602160 != nil:
    section.add "X-Amz-Credential", valid_602160
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602161: Call_PostDescribeStorage_602149; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_602161.validator(path, query, header, formData, body)
  let scheme = call_602161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602161.url(scheme.get, call_602161.host, call_602161.base,
                         call_602161.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602161, url, valid)

proc call*(call_602162: Call_PostDescribeStorage_602149;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602163 = newJObject()
  add(query_602163, "Action", newJString(Action))
  add(query_602163, "Version", newJString(Version))
  result = call_602162.call(nil, query_602163, nil, nil, nil)

var postDescribeStorage* = Call_PostDescribeStorage_602149(
    name: "postDescribeStorage", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_PostDescribeStorage_602150, base: "/",
    url: url_PostDescribeStorage_602151, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeStorage_602134 = ref object of OpenApiRestCall_599352
proc url_GetDescribeStorage_602136(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeStorage_602135(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602137 = query.getOrDefault("Action")
  valid_602137 = validateParameter(valid_602137, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_602137 != nil:
    section.add "Action", valid_602137
  var valid_602138 = query.getOrDefault("Version")
  valid_602138 = validateParameter(valid_602138, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602138 != nil:
    section.add "Version", valid_602138
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602139 = header.getOrDefault("X-Amz-Date")
  valid_602139 = validateParameter(valid_602139, JString, required = false,
                                 default = nil)
  if valid_602139 != nil:
    section.add "X-Amz-Date", valid_602139
  var valid_602140 = header.getOrDefault("X-Amz-Security-Token")
  valid_602140 = validateParameter(valid_602140, JString, required = false,
                                 default = nil)
  if valid_602140 != nil:
    section.add "X-Amz-Security-Token", valid_602140
  var valid_602141 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602141 = validateParameter(valid_602141, JString, required = false,
                                 default = nil)
  if valid_602141 != nil:
    section.add "X-Amz-Content-Sha256", valid_602141
  var valid_602142 = header.getOrDefault("X-Amz-Algorithm")
  valid_602142 = validateParameter(valid_602142, JString, required = false,
                                 default = nil)
  if valid_602142 != nil:
    section.add "X-Amz-Algorithm", valid_602142
  var valid_602143 = header.getOrDefault("X-Amz-Signature")
  valid_602143 = validateParameter(valid_602143, JString, required = false,
                                 default = nil)
  if valid_602143 != nil:
    section.add "X-Amz-Signature", valid_602143
  var valid_602144 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602144 = validateParameter(valid_602144, JString, required = false,
                                 default = nil)
  if valid_602144 != nil:
    section.add "X-Amz-SignedHeaders", valid_602144
  var valid_602145 = header.getOrDefault("X-Amz-Credential")
  valid_602145 = validateParameter(valid_602145, JString, required = false,
                                 default = nil)
  if valid_602145 != nil:
    section.add "X-Amz-Credential", valid_602145
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602146: Call_GetDescribeStorage_602134; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_602146.validator(path, query, header, formData, body)
  let scheme = call_602146.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602146.url(scheme.get, call_602146.host, call_602146.base,
                         call_602146.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602146, url, valid)

proc call*(call_602147: Call_GetDescribeStorage_602134;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602148 = newJObject()
  add(query_602148, "Action", newJString(Action))
  add(query_602148, "Version", newJString(Version))
  result = call_602147.call(nil, query_602148, nil, nil, nil)

var getDescribeStorage* = Call_GetDescribeStorage_602134(
    name: "getDescribeStorage", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_GetDescribeStorage_602135, base: "/",
    url: url_GetDescribeStorage_602136, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTableRestoreStatus_602183 = ref object of OpenApiRestCall_599352
proc url_PostDescribeTableRestoreStatus_602185(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTableRestoreStatus_602184(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602186 = query.getOrDefault("Action")
  valid_602186 = validateParameter(valid_602186, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_602186 != nil:
    section.add "Action", valid_602186
  var valid_602187 = query.getOrDefault("Version")
  valid_602187 = validateParameter(valid_602187, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602187 != nil:
    section.add "Version", valid_602187
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602188 = header.getOrDefault("X-Amz-Date")
  valid_602188 = validateParameter(valid_602188, JString, required = false,
                                 default = nil)
  if valid_602188 != nil:
    section.add "X-Amz-Date", valid_602188
  var valid_602189 = header.getOrDefault("X-Amz-Security-Token")
  valid_602189 = validateParameter(valid_602189, JString, required = false,
                                 default = nil)
  if valid_602189 != nil:
    section.add "X-Amz-Security-Token", valid_602189
  var valid_602190 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602190 = validateParameter(valid_602190, JString, required = false,
                                 default = nil)
  if valid_602190 != nil:
    section.add "X-Amz-Content-Sha256", valid_602190
  var valid_602191 = header.getOrDefault("X-Amz-Algorithm")
  valid_602191 = validateParameter(valid_602191, JString, required = false,
                                 default = nil)
  if valid_602191 != nil:
    section.add "X-Amz-Algorithm", valid_602191
  var valid_602192 = header.getOrDefault("X-Amz-Signature")
  valid_602192 = validateParameter(valid_602192, JString, required = false,
                                 default = nil)
  if valid_602192 != nil:
    section.add "X-Amz-Signature", valid_602192
  var valid_602193 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602193 = validateParameter(valid_602193, JString, required = false,
                                 default = nil)
  if valid_602193 != nil:
    section.add "X-Amz-SignedHeaders", valid_602193
  var valid_602194 = header.getOrDefault("X-Amz-Credential")
  valid_602194 = validateParameter(valid_602194, JString, required = false,
                                 default = nil)
  if valid_602194 != nil:
    section.add "X-Amz-Credential", valid_602194
  result.add "header", section
  ## parameters in `formData` object:
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  section = newJObject()
  var valid_602195 = formData.getOrDefault("TableRestoreRequestId")
  valid_602195 = validateParameter(valid_602195, JString, required = false,
                                 default = nil)
  if valid_602195 != nil:
    section.add "TableRestoreRequestId", valid_602195
  var valid_602196 = formData.getOrDefault("Marker")
  valid_602196 = validateParameter(valid_602196, JString, required = false,
                                 default = nil)
  if valid_602196 != nil:
    section.add "Marker", valid_602196
  var valid_602197 = formData.getOrDefault("ClusterIdentifier")
  valid_602197 = validateParameter(valid_602197, JString, required = false,
                                 default = nil)
  if valid_602197 != nil:
    section.add "ClusterIdentifier", valid_602197
  var valid_602198 = formData.getOrDefault("MaxRecords")
  valid_602198 = validateParameter(valid_602198, JInt, required = false, default = nil)
  if valid_602198 != nil:
    section.add "MaxRecords", valid_602198
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602199: Call_PostDescribeTableRestoreStatus_602183; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_602199.validator(path, query, header, formData, body)
  let scheme = call_602199.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602199.url(scheme.get, call_602199.host, call_602199.base,
                         call_602199.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602199, url, valid)

proc call*(call_602200: Call_PostDescribeTableRestoreStatus_602183;
          TableRestoreRequestId: string = ""; Marker: string = "";
          Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Version: string (required)
  var query_602201 = newJObject()
  var formData_602202 = newJObject()
  add(formData_602202, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(formData_602202, "Marker", newJString(Marker))
  add(query_602201, "Action", newJString(Action))
  add(formData_602202, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_602202, "MaxRecords", newJInt(MaxRecords))
  add(query_602201, "Version", newJString(Version))
  result = call_602200.call(nil, query_602201, nil, formData_602202, nil)

var postDescribeTableRestoreStatus* = Call_PostDescribeTableRestoreStatus_602183(
    name: "postDescribeTableRestoreStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_PostDescribeTableRestoreStatus_602184, base: "/",
    url: url_PostDescribeTableRestoreStatus_602185,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTableRestoreStatus_602164 = ref object of OpenApiRestCall_599352
proc url_GetDescribeTableRestoreStatus_602166(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTableRestoreStatus_602165(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Version: JString (required)
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  section = newJObject()
  var valid_602167 = query.getOrDefault("MaxRecords")
  valid_602167 = validateParameter(valid_602167, JInt, required = false, default = nil)
  if valid_602167 != nil:
    section.add "MaxRecords", valid_602167
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602168 = query.getOrDefault("Action")
  valid_602168 = validateParameter(valid_602168, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_602168 != nil:
    section.add "Action", valid_602168
  var valid_602169 = query.getOrDefault("ClusterIdentifier")
  valid_602169 = validateParameter(valid_602169, JString, required = false,
                                 default = nil)
  if valid_602169 != nil:
    section.add "ClusterIdentifier", valid_602169
  var valid_602170 = query.getOrDefault("Marker")
  valid_602170 = validateParameter(valid_602170, JString, required = false,
                                 default = nil)
  if valid_602170 != nil:
    section.add "Marker", valid_602170
  var valid_602171 = query.getOrDefault("Version")
  valid_602171 = validateParameter(valid_602171, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602171 != nil:
    section.add "Version", valid_602171
  var valid_602172 = query.getOrDefault("TableRestoreRequestId")
  valid_602172 = validateParameter(valid_602172, JString, required = false,
                                 default = nil)
  if valid_602172 != nil:
    section.add "TableRestoreRequestId", valid_602172
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602173 = header.getOrDefault("X-Amz-Date")
  valid_602173 = validateParameter(valid_602173, JString, required = false,
                                 default = nil)
  if valid_602173 != nil:
    section.add "X-Amz-Date", valid_602173
  var valid_602174 = header.getOrDefault("X-Amz-Security-Token")
  valid_602174 = validateParameter(valid_602174, JString, required = false,
                                 default = nil)
  if valid_602174 != nil:
    section.add "X-Amz-Security-Token", valid_602174
  var valid_602175 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602175 = validateParameter(valid_602175, JString, required = false,
                                 default = nil)
  if valid_602175 != nil:
    section.add "X-Amz-Content-Sha256", valid_602175
  var valid_602176 = header.getOrDefault("X-Amz-Algorithm")
  valid_602176 = validateParameter(valid_602176, JString, required = false,
                                 default = nil)
  if valid_602176 != nil:
    section.add "X-Amz-Algorithm", valid_602176
  var valid_602177 = header.getOrDefault("X-Amz-Signature")
  valid_602177 = validateParameter(valid_602177, JString, required = false,
                                 default = nil)
  if valid_602177 != nil:
    section.add "X-Amz-Signature", valid_602177
  var valid_602178 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602178 = validateParameter(valid_602178, JString, required = false,
                                 default = nil)
  if valid_602178 != nil:
    section.add "X-Amz-SignedHeaders", valid_602178
  var valid_602179 = header.getOrDefault("X-Amz-Credential")
  valid_602179 = validateParameter(valid_602179, JString, required = false,
                                 default = nil)
  if valid_602179 != nil:
    section.add "X-Amz-Credential", valid_602179
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602180: Call_GetDescribeTableRestoreStatus_602164; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_602180.validator(path, query, header, formData, body)
  let scheme = call_602180.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602180.url(scheme.get, call_602180.host, call_602180.base,
                         call_602180.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602180, url, valid)

proc call*(call_602181: Call_GetDescribeTableRestoreStatus_602164;
          MaxRecords: int = 0; Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; Marker: string = "";
          Version: string = "2012-12-01"; TableRestoreRequestId: string = ""): Recallable =
  ## getDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Version: string (required)
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  var query_602182 = newJObject()
  add(query_602182, "MaxRecords", newJInt(MaxRecords))
  add(query_602182, "Action", newJString(Action))
  add(query_602182, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602182, "Marker", newJString(Marker))
  add(query_602182, "Version", newJString(Version))
  add(query_602182, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  result = call_602181.call(nil, query_602182, nil, nil, nil)

var getDescribeTableRestoreStatus* = Call_GetDescribeTableRestoreStatus_602164(
    name: "getDescribeTableRestoreStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_GetDescribeTableRestoreStatus_602165, base: "/",
    url: url_GetDescribeTableRestoreStatus_602166,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTags_602224 = ref object of OpenApiRestCall_599352
proc url_PostDescribeTags_602226(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDescribeTags_602225(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602227 = query.getOrDefault("Action")
  valid_602227 = validateParameter(valid_602227, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_602227 != nil:
    section.add "Action", valid_602227
  var valid_602228 = query.getOrDefault("Version")
  valid_602228 = validateParameter(valid_602228, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602228 != nil:
    section.add "Version", valid_602228
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602229 = header.getOrDefault("X-Amz-Date")
  valid_602229 = validateParameter(valid_602229, JString, required = false,
                                 default = nil)
  if valid_602229 != nil:
    section.add "X-Amz-Date", valid_602229
  var valid_602230 = header.getOrDefault("X-Amz-Security-Token")
  valid_602230 = validateParameter(valid_602230, JString, required = false,
                                 default = nil)
  if valid_602230 != nil:
    section.add "X-Amz-Security-Token", valid_602230
  var valid_602231 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602231 = validateParameter(valid_602231, JString, required = false,
                                 default = nil)
  if valid_602231 != nil:
    section.add "X-Amz-Content-Sha256", valid_602231
  var valid_602232 = header.getOrDefault("X-Amz-Algorithm")
  valid_602232 = validateParameter(valid_602232, JString, required = false,
                                 default = nil)
  if valid_602232 != nil:
    section.add "X-Amz-Algorithm", valid_602232
  var valid_602233 = header.getOrDefault("X-Amz-Signature")
  valid_602233 = validateParameter(valid_602233, JString, required = false,
                                 default = nil)
  if valid_602233 != nil:
    section.add "X-Amz-Signature", valid_602233
  var valid_602234 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602234 = validateParameter(valid_602234, JString, required = false,
                                 default = nil)
  if valid_602234 != nil:
    section.add "X-Amz-SignedHeaders", valid_602234
  var valid_602235 = header.getOrDefault("X-Amz-Credential")
  valid_602235 = validateParameter(valid_602235, JString, required = false,
                                 default = nil)
  if valid_602235 != nil:
    section.add "X-Amz-Credential", valid_602235
  result.add "header", section
  ## parameters in `formData` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_602236 = formData.getOrDefault("Marker")
  valid_602236 = validateParameter(valid_602236, JString, required = false,
                                 default = nil)
  if valid_602236 != nil:
    section.add "Marker", valid_602236
  var valid_602237 = formData.getOrDefault("ResourceType")
  valid_602237 = validateParameter(valid_602237, JString, required = false,
                                 default = nil)
  if valid_602237 != nil:
    section.add "ResourceType", valid_602237
  var valid_602238 = formData.getOrDefault("TagKeys")
  valid_602238 = validateParameter(valid_602238, JArray, required = false,
                                 default = nil)
  if valid_602238 != nil:
    section.add "TagKeys", valid_602238
  var valid_602239 = formData.getOrDefault("ResourceName")
  valid_602239 = validateParameter(valid_602239, JString, required = false,
                                 default = nil)
  if valid_602239 != nil:
    section.add "ResourceName", valid_602239
  var valid_602240 = formData.getOrDefault("MaxRecords")
  valid_602240 = validateParameter(valid_602240, JInt, required = false, default = nil)
  if valid_602240 != nil:
    section.add "MaxRecords", valid_602240
  var valid_602241 = formData.getOrDefault("TagValues")
  valid_602241 = validateParameter(valid_602241, JArray, required = false,
                                 default = nil)
  if valid_602241 != nil:
    section.add "TagValues", valid_602241
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602242: Call_PostDescribeTags_602224; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_602242.validator(path, query, header, formData, body)
  let scheme = call_602242.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602242.url(scheme.get, call_602242.host, call_602242.base,
                         call_602242.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602242, url, valid)

proc call*(call_602243: Call_PostDescribeTags_602224; Marker: string = "";
          Action: string = "DescribeTags"; ResourceType: string = "";
          TagKeys: JsonNode = nil; ResourceName: string = ""; MaxRecords: int = 0;
          TagValues: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   Action: string (required)
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Version: string (required)
  var query_602244 = newJObject()
  var formData_602245 = newJObject()
  add(formData_602245, "Marker", newJString(Marker))
  add(query_602244, "Action", newJString(Action))
  add(formData_602245, "ResourceType", newJString(ResourceType))
  if TagKeys != nil:
    formData_602245.add "TagKeys", TagKeys
  add(formData_602245, "ResourceName", newJString(ResourceName))
  add(formData_602245, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    formData_602245.add "TagValues", TagValues
  add(query_602244, "Version", newJString(Version))
  result = call_602243.call(nil, query_602244, nil, formData_602245, nil)

var postDescribeTags* = Call_PostDescribeTags_602224(name: "postDescribeTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_PostDescribeTags_602225,
    base: "/", url: url_PostDescribeTags_602226,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTags_602203 = ref object of OpenApiRestCall_599352
proc url_GetDescribeTags_602205(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDescribeTags_602204(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_602206 = query.getOrDefault("TagValues")
  valid_602206 = validateParameter(valid_602206, JArray, required = false,
                                 default = nil)
  if valid_602206 != nil:
    section.add "TagValues", valid_602206
  var valid_602207 = query.getOrDefault("MaxRecords")
  valid_602207 = validateParameter(valid_602207, JInt, required = false, default = nil)
  if valid_602207 != nil:
    section.add "MaxRecords", valid_602207
  var valid_602208 = query.getOrDefault("ResourceName")
  valid_602208 = validateParameter(valid_602208, JString, required = false,
                                 default = nil)
  if valid_602208 != nil:
    section.add "ResourceName", valid_602208
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602209 = query.getOrDefault("Action")
  valid_602209 = validateParameter(valid_602209, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_602209 != nil:
    section.add "Action", valid_602209
  var valid_602210 = query.getOrDefault("Marker")
  valid_602210 = validateParameter(valid_602210, JString, required = false,
                                 default = nil)
  if valid_602210 != nil:
    section.add "Marker", valid_602210
  var valid_602211 = query.getOrDefault("TagKeys")
  valid_602211 = validateParameter(valid_602211, JArray, required = false,
                                 default = nil)
  if valid_602211 != nil:
    section.add "TagKeys", valid_602211
  var valid_602212 = query.getOrDefault("ResourceType")
  valid_602212 = validateParameter(valid_602212, JString, required = false,
                                 default = nil)
  if valid_602212 != nil:
    section.add "ResourceType", valid_602212
  var valid_602213 = query.getOrDefault("Version")
  valid_602213 = validateParameter(valid_602213, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602213 != nil:
    section.add "Version", valid_602213
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602214 = header.getOrDefault("X-Amz-Date")
  valid_602214 = validateParameter(valid_602214, JString, required = false,
                                 default = nil)
  if valid_602214 != nil:
    section.add "X-Amz-Date", valid_602214
  var valid_602215 = header.getOrDefault("X-Amz-Security-Token")
  valid_602215 = validateParameter(valid_602215, JString, required = false,
                                 default = nil)
  if valid_602215 != nil:
    section.add "X-Amz-Security-Token", valid_602215
  var valid_602216 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602216 = validateParameter(valid_602216, JString, required = false,
                                 default = nil)
  if valid_602216 != nil:
    section.add "X-Amz-Content-Sha256", valid_602216
  var valid_602217 = header.getOrDefault("X-Amz-Algorithm")
  valid_602217 = validateParameter(valid_602217, JString, required = false,
                                 default = nil)
  if valid_602217 != nil:
    section.add "X-Amz-Algorithm", valid_602217
  var valid_602218 = header.getOrDefault("X-Amz-Signature")
  valid_602218 = validateParameter(valid_602218, JString, required = false,
                                 default = nil)
  if valid_602218 != nil:
    section.add "X-Amz-Signature", valid_602218
  var valid_602219 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602219 = validateParameter(valid_602219, JString, required = false,
                                 default = nil)
  if valid_602219 != nil:
    section.add "X-Amz-SignedHeaders", valid_602219
  var valid_602220 = header.getOrDefault("X-Amz-Credential")
  valid_602220 = validateParameter(valid_602220, JString, required = false,
                                 default = nil)
  if valid_602220 != nil:
    section.add "X-Amz-Credential", valid_602220
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602221: Call_GetDescribeTags_602203; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_602221.validator(path, query, header, formData, body)
  let scheme = call_602221.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602221.url(scheme.get, call_602221.host, call_602221.base,
                         call_602221.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602221, url, valid)

proc call*(call_602222: Call_GetDescribeTags_602203; TagValues: JsonNode = nil;
          MaxRecords: int = 0; ResourceName: string = "";
          Action: string = "DescribeTags"; Marker: string = ""; TagKeys: JsonNode = nil;
          ResourceType: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Version: string (required)
  var query_602223 = newJObject()
  if TagValues != nil:
    query_602223.add "TagValues", TagValues
  add(query_602223, "MaxRecords", newJInt(MaxRecords))
  add(query_602223, "ResourceName", newJString(ResourceName))
  add(query_602223, "Action", newJString(Action))
  add(query_602223, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_602223.add "TagKeys", TagKeys
  add(query_602223, "ResourceType", newJString(ResourceType))
  add(query_602223, "Version", newJString(Version))
  result = call_602222.call(nil, query_602223, nil, nil, nil)

var getDescribeTags* = Call_GetDescribeTags_602203(name: "getDescribeTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_GetDescribeTags_602204,
    base: "/", url: url_GetDescribeTags_602205, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableLogging_602262 = ref object of OpenApiRestCall_599352
proc url_PostDisableLogging_602264(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableLogging_602263(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602265 = query.getOrDefault("Action")
  valid_602265 = validateParameter(valid_602265, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_602265 != nil:
    section.add "Action", valid_602265
  var valid_602266 = query.getOrDefault("Version")
  valid_602266 = validateParameter(valid_602266, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602266 != nil:
    section.add "Version", valid_602266
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602267 = header.getOrDefault("X-Amz-Date")
  valid_602267 = validateParameter(valid_602267, JString, required = false,
                                 default = nil)
  if valid_602267 != nil:
    section.add "X-Amz-Date", valid_602267
  var valid_602268 = header.getOrDefault("X-Amz-Security-Token")
  valid_602268 = validateParameter(valid_602268, JString, required = false,
                                 default = nil)
  if valid_602268 != nil:
    section.add "X-Amz-Security-Token", valid_602268
  var valid_602269 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602269 = validateParameter(valid_602269, JString, required = false,
                                 default = nil)
  if valid_602269 != nil:
    section.add "X-Amz-Content-Sha256", valid_602269
  var valid_602270 = header.getOrDefault("X-Amz-Algorithm")
  valid_602270 = validateParameter(valid_602270, JString, required = false,
                                 default = nil)
  if valid_602270 != nil:
    section.add "X-Amz-Algorithm", valid_602270
  var valid_602271 = header.getOrDefault("X-Amz-Signature")
  valid_602271 = validateParameter(valid_602271, JString, required = false,
                                 default = nil)
  if valid_602271 != nil:
    section.add "X-Amz-Signature", valid_602271
  var valid_602272 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602272 = validateParameter(valid_602272, JString, required = false,
                                 default = nil)
  if valid_602272 != nil:
    section.add "X-Amz-SignedHeaders", valid_602272
  var valid_602273 = header.getOrDefault("X-Amz-Credential")
  valid_602273 = validateParameter(valid_602273, JString, required = false,
                                 default = nil)
  if valid_602273 != nil:
    section.add "X-Amz-Credential", valid_602273
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_602274 = formData.getOrDefault("ClusterIdentifier")
  valid_602274 = validateParameter(valid_602274, JString, required = true,
                                 default = nil)
  if valid_602274 != nil:
    section.add "ClusterIdentifier", valid_602274
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602275: Call_PostDisableLogging_602262; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_602275.validator(path, query, header, formData, body)
  let scheme = call_602275.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602275.url(scheme.get, call_602275.host, call_602275.base,
                         call_602275.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602275, url, valid)

proc call*(call_602276: Call_PostDisableLogging_602262; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_602277 = newJObject()
  var formData_602278 = newJObject()
  add(query_602277, "Action", newJString(Action))
  add(formData_602278, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602277, "Version", newJString(Version))
  result = call_602276.call(nil, query_602277, nil, formData_602278, nil)

var postDisableLogging* = Call_PostDisableLogging_602262(
    name: "postDisableLogging", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableLogging",
    validator: validate_PostDisableLogging_602263, base: "/",
    url: url_PostDisableLogging_602264, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableLogging_602246 = ref object of OpenApiRestCall_599352
proc url_GetDisableLogging_602248(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableLogging_602247(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602249 = query.getOrDefault("Action")
  valid_602249 = validateParameter(valid_602249, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_602249 != nil:
    section.add "Action", valid_602249
  var valid_602250 = query.getOrDefault("ClusterIdentifier")
  valid_602250 = validateParameter(valid_602250, JString, required = true,
                                 default = nil)
  if valid_602250 != nil:
    section.add "ClusterIdentifier", valid_602250
  var valid_602251 = query.getOrDefault("Version")
  valid_602251 = validateParameter(valid_602251, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602251 != nil:
    section.add "Version", valid_602251
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602252 = header.getOrDefault("X-Amz-Date")
  valid_602252 = validateParameter(valid_602252, JString, required = false,
                                 default = nil)
  if valid_602252 != nil:
    section.add "X-Amz-Date", valid_602252
  var valid_602253 = header.getOrDefault("X-Amz-Security-Token")
  valid_602253 = validateParameter(valid_602253, JString, required = false,
                                 default = nil)
  if valid_602253 != nil:
    section.add "X-Amz-Security-Token", valid_602253
  var valid_602254 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602254 = validateParameter(valid_602254, JString, required = false,
                                 default = nil)
  if valid_602254 != nil:
    section.add "X-Amz-Content-Sha256", valid_602254
  var valid_602255 = header.getOrDefault("X-Amz-Algorithm")
  valid_602255 = validateParameter(valid_602255, JString, required = false,
                                 default = nil)
  if valid_602255 != nil:
    section.add "X-Amz-Algorithm", valid_602255
  var valid_602256 = header.getOrDefault("X-Amz-Signature")
  valid_602256 = validateParameter(valid_602256, JString, required = false,
                                 default = nil)
  if valid_602256 != nil:
    section.add "X-Amz-Signature", valid_602256
  var valid_602257 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602257 = validateParameter(valid_602257, JString, required = false,
                                 default = nil)
  if valid_602257 != nil:
    section.add "X-Amz-SignedHeaders", valid_602257
  var valid_602258 = header.getOrDefault("X-Amz-Credential")
  valid_602258 = validateParameter(valid_602258, JString, required = false,
                                 default = nil)
  if valid_602258 != nil:
    section.add "X-Amz-Credential", valid_602258
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602259: Call_GetDisableLogging_602246; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_602259.validator(path, query, header, formData, body)
  let scheme = call_602259.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602259.url(scheme.get, call_602259.host, call_602259.base,
                         call_602259.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602259, url, valid)

proc call*(call_602260: Call_GetDisableLogging_602246; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_602261 = newJObject()
  add(query_602261, "Action", newJString(Action))
  add(query_602261, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602261, "Version", newJString(Version))
  result = call_602260.call(nil, query_602261, nil, nil, nil)

var getDisableLogging* = Call_GetDisableLogging_602246(name: "getDisableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DisableLogging", validator: validate_GetDisableLogging_602247,
    base: "/", url: url_GetDisableLogging_602248,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableSnapshotCopy_602295 = ref object of OpenApiRestCall_599352
proc url_PostDisableSnapshotCopy_602297(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostDisableSnapshotCopy_602296(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602298 = query.getOrDefault("Action")
  valid_602298 = validateParameter(valid_602298, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_602298 != nil:
    section.add "Action", valid_602298
  var valid_602299 = query.getOrDefault("Version")
  valid_602299 = validateParameter(valid_602299, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602299 != nil:
    section.add "Version", valid_602299
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602300 = header.getOrDefault("X-Amz-Date")
  valid_602300 = validateParameter(valid_602300, JString, required = false,
                                 default = nil)
  if valid_602300 != nil:
    section.add "X-Amz-Date", valid_602300
  var valid_602301 = header.getOrDefault("X-Amz-Security-Token")
  valid_602301 = validateParameter(valid_602301, JString, required = false,
                                 default = nil)
  if valid_602301 != nil:
    section.add "X-Amz-Security-Token", valid_602301
  var valid_602302 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602302 = validateParameter(valid_602302, JString, required = false,
                                 default = nil)
  if valid_602302 != nil:
    section.add "X-Amz-Content-Sha256", valid_602302
  var valid_602303 = header.getOrDefault("X-Amz-Algorithm")
  valid_602303 = validateParameter(valid_602303, JString, required = false,
                                 default = nil)
  if valid_602303 != nil:
    section.add "X-Amz-Algorithm", valid_602303
  var valid_602304 = header.getOrDefault("X-Amz-Signature")
  valid_602304 = validateParameter(valid_602304, JString, required = false,
                                 default = nil)
  if valid_602304 != nil:
    section.add "X-Amz-Signature", valid_602304
  var valid_602305 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602305 = validateParameter(valid_602305, JString, required = false,
                                 default = nil)
  if valid_602305 != nil:
    section.add "X-Amz-SignedHeaders", valid_602305
  var valid_602306 = header.getOrDefault("X-Amz-Credential")
  valid_602306 = validateParameter(valid_602306, JString, required = false,
                                 default = nil)
  if valid_602306 != nil:
    section.add "X-Amz-Credential", valid_602306
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_602307 = formData.getOrDefault("ClusterIdentifier")
  valid_602307 = validateParameter(valid_602307, JString, required = true,
                                 default = nil)
  if valid_602307 != nil:
    section.add "ClusterIdentifier", valid_602307
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602308: Call_PostDisableSnapshotCopy_602295; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_602308.validator(path, query, header, formData, body)
  let scheme = call_602308.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602308.url(scheme.get, call_602308.host, call_602308.base,
                         call_602308.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602308, url, valid)

proc call*(call_602309: Call_PostDisableSnapshotCopy_602295;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## postDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_602310 = newJObject()
  var formData_602311 = newJObject()
  add(query_602310, "Action", newJString(Action))
  add(formData_602311, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602310, "Version", newJString(Version))
  result = call_602309.call(nil, query_602310, nil, formData_602311, nil)

var postDisableSnapshotCopy* = Call_PostDisableSnapshotCopy_602295(
    name: "postDisableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_PostDisableSnapshotCopy_602296, base: "/",
    url: url_PostDisableSnapshotCopy_602297, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableSnapshotCopy_602279 = ref object of OpenApiRestCall_599352
proc url_GetDisableSnapshotCopy_602281(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetDisableSnapshotCopy_602280(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602282 = query.getOrDefault("Action")
  valid_602282 = validateParameter(valid_602282, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_602282 != nil:
    section.add "Action", valid_602282
  var valid_602283 = query.getOrDefault("ClusterIdentifier")
  valid_602283 = validateParameter(valid_602283, JString, required = true,
                                 default = nil)
  if valid_602283 != nil:
    section.add "ClusterIdentifier", valid_602283
  var valid_602284 = query.getOrDefault("Version")
  valid_602284 = validateParameter(valid_602284, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602284 != nil:
    section.add "Version", valid_602284
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602285 = header.getOrDefault("X-Amz-Date")
  valid_602285 = validateParameter(valid_602285, JString, required = false,
                                 default = nil)
  if valid_602285 != nil:
    section.add "X-Amz-Date", valid_602285
  var valid_602286 = header.getOrDefault("X-Amz-Security-Token")
  valid_602286 = validateParameter(valid_602286, JString, required = false,
                                 default = nil)
  if valid_602286 != nil:
    section.add "X-Amz-Security-Token", valid_602286
  var valid_602287 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602287 = validateParameter(valid_602287, JString, required = false,
                                 default = nil)
  if valid_602287 != nil:
    section.add "X-Amz-Content-Sha256", valid_602287
  var valid_602288 = header.getOrDefault("X-Amz-Algorithm")
  valid_602288 = validateParameter(valid_602288, JString, required = false,
                                 default = nil)
  if valid_602288 != nil:
    section.add "X-Amz-Algorithm", valid_602288
  var valid_602289 = header.getOrDefault("X-Amz-Signature")
  valid_602289 = validateParameter(valid_602289, JString, required = false,
                                 default = nil)
  if valid_602289 != nil:
    section.add "X-Amz-Signature", valid_602289
  var valid_602290 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602290 = validateParameter(valid_602290, JString, required = false,
                                 default = nil)
  if valid_602290 != nil:
    section.add "X-Amz-SignedHeaders", valid_602290
  var valid_602291 = header.getOrDefault("X-Amz-Credential")
  valid_602291 = validateParameter(valid_602291, JString, required = false,
                                 default = nil)
  if valid_602291 != nil:
    section.add "X-Amz-Credential", valid_602291
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602292: Call_GetDisableSnapshotCopy_602279; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_602292.validator(path, query, header, formData, body)
  let scheme = call_602292.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602292.url(scheme.get, call_602292.host, call_602292.base,
                         call_602292.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602292, url, valid)

proc call*(call_602293: Call_GetDisableSnapshotCopy_602279;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## getDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_602294 = newJObject()
  add(query_602294, "Action", newJString(Action))
  add(query_602294, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602294, "Version", newJString(Version))
  result = call_602293.call(nil, query_602294, nil, nil, nil)

var getDisableSnapshotCopy* = Call_GetDisableSnapshotCopy_602279(
    name: "getDisableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_GetDisableSnapshotCopy_602280, base: "/",
    url: url_GetDisableSnapshotCopy_602281, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableLogging_602330 = ref object of OpenApiRestCall_599352
proc url_PostEnableLogging_602332(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableLogging_602331(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602333 = query.getOrDefault("Action")
  valid_602333 = validateParameter(valid_602333, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_602333 != nil:
    section.add "Action", valid_602333
  var valid_602334 = query.getOrDefault("Version")
  valid_602334 = validateParameter(valid_602334, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602334 != nil:
    section.add "Version", valid_602334
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602335 = header.getOrDefault("X-Amz-Date")
  valid_602335 = validateParameter(valid_602335, JString, required = false,
                                 default = nil)
  if valid_602335 != nil:
    section.add "X-Amz-Date", valid_602335
  var valid_602336 = header.getOrDefault("X-Amz-Security-Token")
  valid_602336 = validateParameter(valid_602336, JString, required = false,
                                 default = nil)
  if valid_602336 != nil:
    section.add "X-Amz-Security-Token", valid_602336
  var valid_602337 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602337 = validateParameter(valid_602337, JString, required = false,
                                 default = nil)
  if valid_602337 != nil:
    section.add "X-Amz-Content-Sha256", valid_602337
  var valid_602338 = header.getOrDefault("X-Amz-Algorithm")
  valid_602338 = validateParameter(valid_602338, JString, required = false,
                                 default = nil)
  if valid_602338 != nil:
    section.add "X-Amz-Algorithm", valid_602338
  var valid_602339 = header.getOrDefault("X-Amz-Signature")
  valid_602339 = validateParameter(valid_602339, JString, required = false,
                                 default = nil)
  if valid_602339 != nil:
    section.add "X-Amz-Signature", valid_602339
  var valid_602340 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602340 = validateParameter(valid_602340, JString, required = false,
                                 default = nil)
  if valid_602340 != nil:
    section.add "X-Amz-SignedHeaders", valid_602340
  var valid_602341 = header.getOrDefault("X-Amz-Credential")
  valid_602341 = validateParameter(valid_602341, JString, required = false,
                                 default = nil)
  if valid_602341 != nil:
    section.add "X-Amz-Credential", valid_602341
  result.add "header", section
  ## parameters in `formData` object:
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  var valid_602342 = formData.getOrDefault("S3KeyPrefix")
  valid_602342 = validateParameter(valid_602342, JString, required = false,
                                 default = nil)
  if valid_602342 != nil:
    section.add "S3KeyPrefix", valid_602342
  assert formData != nil,
        "formData argument is necessary due to required `BucketName` field"
  var valid_602343 = formData.getOrDefault("BucketName")
  valid_602343 = validateParameter(valid_602343, JString, required = true,
                                 default = nil)
  if valid_602343 != nil:
    section.add "BucketName", valid_602343
  var valid_602344 = formData.getOrDefault("ClusterIdentifier")
  valid_602344 = validateParameter(valid_602344, JString, required = true,
                                 default = nil)
  if valid_602344 != nil:
    section.add "ClusterIdentifier", valid_602344
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602345: Call_PostEnableLogging_602330; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_602345.validator(path, query, header, formData, body)
  let scheme = call_602345.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602345.url(scheme.get, call_602345.host, call_602345.base,
                         call_602345.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602345, url, valid)

proc call*(call_602346: Call_PostEnableLogging_602330; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_602347 = newJObject()
  var formData_602348 = newJObject()
  add(formData_602348, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(formData_602348, "BucketName", newJString(BucketName))
  add(query_602347, "Action", newJString(Action))
  add(formData_602348, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602347, "Version", newJString(Version))
  result = call_602346.call(nil, query_602347, nil, formData_602348, nil)

var postEnableLogging* = Call_PostEnableLogging_602330(name: "postEnableLogging",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_PostEnableLogging_602331,
    base: "/", url: url_PostEnableLogging_602332,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableLogging_602312 = ref object of OpenApiRestCall_599352
proc url_GetEnableLogging_602314(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableLogging_602313(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_602315 = query.getOrDefault("S3KeyPrefix")
  valid_602315 = validateParameter(valid_602315, JString, required = false,
                                 default = nil)
  if valid_602315 != nil:
    section.add "S3KeyPrefix", valid_602315
  assert query != nil,
        "query argument is necessary due to required `BucketName` field"
  var valid_602316 = query.getOrDefault("BucketName")
  valid_602316 = validateParameter(valid_602316, JString, required = true,
                                 default = nil)
  if valid_602316 != nil:
    section.add "BucketName", valid_602316
  var valid_602317 = query.getOrDefault("Action")
  valid_602317 = validateParameter(valid_602317, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_602317 != nil:
    section.add "Action", valid_602317
  var valid_602318 = query.getOrDefault("ClusterIdentifier")
  valid_602318 = validateParameter(valid_602318, JString, required = true,
                                 default = nil)
  if valid_602318 != nil:
    section.add "ClusterIdentifier", valid_602318
  var valid_602319 = query.getOrDefault("Version")
  valid_602319 = validateParameter(valid_602319, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602319 != nil:
    section.add "Version", valid_602319
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602320 = header.getOrDefault("X-Amz-Date")
  valid_602320 = validateParameter(valid_602320, JString, required = false,
                                 default = nil)
  if valid_602320 != nil:
    section.add "X-Amz-Date", valid_602320
  var valid_602321 = header.getOrDefault("X-Amz-Security-Token")
  valid_602321 = validateParameter(valid_602321, JString, required = false,
                                 default = nil)
  if valid_602321 != nil:
    section.add "X-Amz-Security-Token", valid_602321
  var valid_602322 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602322 = validateParameter(valid_602322, JString, required = false,
                                 default = nil)
  if valid_602322 != nil:
    section.add "X-Amz-Content-Sha256", valid_602322
  var valid_602323 = header.getOrDefault("X-Amz-Algorithm")
  valid_602323 = validateParameter(valid_602323, JString, required = false,
                                 default = nil)
  if valid_602323 != nil:
    section.add "X-Amz-Algorithm", valid_602323
  var valid_602324 = header.getOrDefault("X-Amz-Signature")
  valid_602324 = validateParameter(valid_602324, JString, required = false,
                                 default = nil)
  if valid_602324 != nil:
    section.add "X-Amz-Signature", valid_602324
  var valid_602325 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602325 = validateParameter(valid_602325, JString, required = false,
                                 default = nil)
  if valid_602325 != nil:
    section.add "X-Amz-SignedHeaders", valid_602325
  var valid_602326 = header.getOrDefault("X-Amz-Credential")
  valid_602326 = validateParameter(valid_602326, JString, required = false,
                                 default = nil)
  if valid_602326 != nil:
    section.add "X-Amz-Credential", valid_602326
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602327: Call_GetEnableLogging_602312; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_602327.validator(path, query, header, formData, body)
  let scheme = call_602327.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602327.url(scheme.get, call_602327.host, call_602327.base,
                         call_602327.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602327, url, valid)

proc call*(call_602328: Call_GetEnableLogging_602312; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_602329 = newJObject()
  add(query_602329, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(query_602329, "BucketName", newJString(BucketName))
  add(query_602329, "Action", newJString(Action))
  add(query_602329, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602329, "Version", newJString(Version))
  result = call_602328.call(nil, query_602329, nil, nil, nil)

var getEnableLogging* = Call_GetEnableLogging_602312(name: "getEnableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_GetEnableLogging_602313,
    base: "/", url: url_GetEnableLogging_602314,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableSnapshotCopy_602369 = ref object of OpenApiRestCall_599352
proc url_PostEnableSnapshotCopy_602371(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostEnableSnapshotCopy_602370(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602372 = query.getOrDefault("Action")
  valid_602372 = validateParameter(valid_602372, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_602372 != nil:
    section.add "Action", valid_602372
  var valid_602373 = query.getOrDefault("Version")
  valid_602373 = validateParameter(valid_602373, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602373 != nil:
    section.add "Version", valid_602373
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602374 = header.getOrDefault("X-Amz-Date")
  valid_602374 = validateParameter(valid_602374, JString, required = false,
                                 default = nil)
  if valid_602374 != nil:
    section.add "X-Amz-Date", valid_602374
  var valid_602375 = header.getOrDefault("X-Amz-Security-Token")
  valid_602375 = validateParameter(valid_602375, JString, required = false,
                                 default = nil)
  if valid_602375 != nil:
    section.add "X-Amz-Security-Token", valid_602375
  var valid_602376 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602376 = validateParameter(valid_602376, JString, required = false,
                                 default = nil)
  if valid_602376 != nil:
    section.add "X-Amz-Content-Sha256", valid_602376
  var valid_602377 = header.getOrDefault("X-Amz-Algorithm")
  valid_602377 = validateParameter(valid_602377, JString, required = false,
                                 default = nil)
  if valid_602377 != nil:
    section.add "X-Amz-Algorithm", valid_602377
  var valid_602378 = header.getOrDefault("X-Amz-Signature")
  valid_602378 = validateParameter(valid_602378, JString, required = false,
                                 default = nil)
  if valid_602378 != nil:
    section.add "X-Amz-Signature", valid_602378
  var valid_602379 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602379 = validateParameter(valid_602379, JString, required = false,
                                 default = nil)
  if valid_602379 != nil:
    section.add "X-Amz-SignedHeaders", valid_602379
  var valid_602380 = header.getOrDefault("X-Amz-Credential")
  valid_602380 = validateParameter(valid_602380, JString, required = false,
                                 default = nil)
  if valid_602380 != nil:
    section.add "X-Amz-Credential", valid_602380
  result.add "header", section
  ## parameters in `formData` object:
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_602381 = formData.getOrDefault("RetentionPeriod")
  valid_602381 = validateParameter(valid_602381, JInt, required = false, default = nil)
  if valid_602381 != nil:
    section.add "RetentionPeriod", valid_602381
  var valid_602382 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_602382 = validateParameter(valid_602382, JString, required = false,
                                 default = nil)
  if valid_602382 != nil:
    section.add "SnapshotCopyGrantName", valid_602382
  assert formData != nil, "formData argument is necessary due to required `DestinationRegion` field"
  var valid_602383 = formData.getOrDefault("DestinationRegion")
  valid_602383 = validateParameter(valid_602383, JString, required = true,
                                 default = nil)
  if valid_602383 != nil:
    section.add "DestinationRegion", valid_602383
  var valid_602384 = formData.getOrDefault("ClusterIdentifier")
  valid_602384 = validateParameter(valid_602384, JString, required = true,
                                 default = nil)
  if valid_602384 != nil:
    section.add "ClusterIdentifier", valid_602384
  var valid_602385 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602385 = validateParameter(valid_602385, JInt, required = false, default = nil)
  if valid_602385 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602385
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602386: Call_PostEnableSnapshotCopy_602369; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_602386.validator(path, query, header, formData, body)
  let scheme = call_602386.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602386.url(scheme.get, call_602386.host, call_602386.base,
                         call_602386.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602386, url, valid)

proc call*(call_602387: Call_PostEnableSnapshotCopy_602369;
          DestinationRegion: string; ClusterIdentifier: string;
          RetentionPeriod: int = 0; Action: string = "EnableSnapshotCopy";
          SnapshotCopyGrantName: string = "";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Version: string (required)
  var query_602388 = newJObject()
  var formData_602389 = newJObject()
  add(formData_602389, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_602388, "Action", newJString(Action))
  add(formData_602389, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(formData_602389, "DestinationRegion", newJString(DestinationRegion))
  add(formData_602389, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_602389, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_602388, "Version", newJString(Version))
  result = call_602387.call(nil, query_602388, nil, formData_602389, nil)

var postEnableSnapshotCopy* = Call_PostEnableSnapshotCopy_602369(
    name: "postEnableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_PostEnableSnapshotCopy_602370, base: "/",
    url: url_PostEnableSnapshotCopy_602371, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableSnapshotCopy_602349 = ref object of OpenApiRestCall_599352
proc url_GetEnableSnapshotCopy_602351(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetEnableSnapshotCopy_602350(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `DestinationRegion` field"
  var valid_602352 = query.getOrDefault("DestinationRegion")
  valid_602352 = validateParameter(valid_602352, JString, required = true,
                                 default = nil)
  if valid_602352 != nil:
    section.add "DestinationRegion", valid_602352
  var valid_602353 = query.getOrDefault("Action")
  valid_602353 = validateParameter(valid_602353, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_602353 != nil:
    section.add "Action", valid_602353
  var valid_602354 = query.getOrDefault("ClusterIdentifier")
  valid_602354 = validateParameter(valid_602354, JString, required = true,
                                 default = nil)
  if valid_602354 != nil:
    section.add "ClusterIdentifier", valid_602354
  var valid_602355 = query.getOrDefault("SnapshotCopyGrantName")
  valid_602355 = validateParameter(valid_602355, JString, required = false,
                                 default = nil)
  if valid_602355 != nil:
    section.add "SnapshotCopyGrantName", valid_602355
  var valid_602356 = query.getOrDefault("RetentionPeriod")
  valid_602356 = validateParameter(valid_602356, JInt, required = false, default = nil)
  if valid_602356 != nil:
    section.add "RetentionPeriod", valid_602356
  var valid_602357 = query.getOrDefault("Version")
  valid_602357 = validateParameter(valid_602357, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602357 != nil:
    section.add "Version", valid_602357
  var valid_602358 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602358 = validateParameter(valid_602358, JInt, required = false, default = nil)
  if valid_602358 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602358
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602359 = header.getOrDefault("X-Amz-Date")
  valid_602359 = validateParameter(valid_602359, JString, required = false,
                                 default = nil)
  if valid_602359 != nil:
    section.add "X-Amz-Date", valid_602359
  var valid_602360 = header.getOrDefault("X-Amz-Security-Token")
  valid_602360 = validateParameter(valid_602360, JString, required = false,
                                 default = nil)
  if valid_602360 != nil:
    section.add "X-Amz-Security-Token", valid_602360
  var valid_602361 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602361 = validateParameter(valid_602361, JString, required = false,
                                 default = nil)
  if valid_602361 != nil:
    section.add "X-Amz-Content-Sha256", valid_602361
  var valid_602362 = header.getOrDefault("X-Amz-Algorithm")
  valid_602362 = validateParameter(valid_602362, JString, required = false,
                                 default = nil)
  if valid_602362 != nil:
    section.add "X-Amz-Algorithm", valid_602362
  var valid_602363 = header.getOrDefault("X-Amz-Signature")
  valid_602363 = validateParameter(valid_602363, JString, required = false,
                                 default = nil)
  if valid_602363 != nil:
    section.add "X-Amz-Signature", valid_602363
  var valid_602364 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602364 = validateParameter(valid_602364, JString, required = false,
                                 default = nil)
  if valid_602364 != nil:
    section.add "X-Amz-SignedHeaders", valid_602364
  var valid_602365 = header.getOrDefault("X-Amz-Credential")
  valid_602365 = validateParameter(valid_602365, JString, required = false,
                                 default = nil)
  if valid_602365 != nil:
    section.add "X-Amz-Credential", valid_602365
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602366: Call_GetEnableSnapshotCopy_602349; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_602366.validator(path, query, header, formData, body)
  let scheme = call_602366.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602366.url(scheme.get, call_602366.host, call_602366.base,
                         call_602366.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602366, url, valid)

proc call*(call_602367: Call_GetEnableSnapshotCopy_602349;
          DestinationRegion: string; ClusterIdentifier: string;
          Action: string = "EnableSnapshotCopy"; SnapshotCopyGrantName: string = "";
          RetentionPeriod: int = 0; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_602368 = newJObject()
  add(query_602368, "DestinationRegion", newJString(DestinationRegion))
  add(query_602368, "Action", newJString(Action))
  add(query_602368, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602368, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_602368, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_602368, "Version", newJString(Version))
  add(query_602368, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_602367.call(nil, query_602368, nil, nil, nil)

var getEnableSnapshotCopy* = Call_GetEnableSnapshotCopy_602349(
    name: "getEnableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_GetEnableSnapshotCopy_602350, base: "/",
    url: url_GetEnableSnapshotCopy_602351, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetClusterCredentials_602411 = ref object of OpenApiRestCall_599352
proc url_PostGetClusterCredentials_602413(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetClusterCredentials_602412(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602414 = query.getOrDefault("Action")
  valid_602414 = validateParameter(valid_602414, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_602414 != nil:
    section.add "Action", valid_602414
  var valid_602415 = query.getOrDefault("Version")
  valid_602415 = validateParameter(valid_602415, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602415 != nil:
    section.add "Version", valid_602415
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602416 = header.getOrDefault("X-Amz-Date")
  valid_602416 = validateParameter(valid_602416, JString, required = false,
                                 default = nil)
  if valid_602416 != nil:
    section.add "X-Amz-Date", valid_602416
  var valid_602417 = header.getOrDefault("X-Amz-Security-Token")
  valid_602417 = validateParameter(valid_602417, JString, required = false,
                                 default = nil)
  if valid_602417 != nil:
    section.add "X-Amz-Security-Token", valid_602417
  var valid_602418 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602418 = validateParameter(valid_602418, JString, required = false,
                                 default = nil)
  if valid_602418 != nil:
    section.add "X-Amz-Content-Sha256", valid_602418
  var valid_602419 = header.getOrDefault("X-Amz-Algorithm")
  valid_602419 = validateParameter(valid_602419, JString, required = false,
                                 default = nil)
  if valid_602419 != nil:
    section.add "X-Amz-Algorithm", valid_602419
  var valid_602420 = header.getOrDefault("X-Amz-Signature")
  valid_602420 = validateParameter(valid_602420, JString, required = false,
                                 default = nil)
  if valid_602420 != nil:
    section.add "X-Amz-Signature", valid_602420
  var valid_602421 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602421 = validateParameter(valid_602421, JString, required = false,
                                 default = nil)
  if valid_602421 != nil:
    section.add "X-Amz-SignedHeaders", valid_602421
  var valid_602422 = header.getOrDefault("X-Amz-Credential")
  valid_602422 = validateParameter(valid_602422, JString, required = false,
                                 default = nil)
  if valid_602422 != nil:
    section.add "X-Amz-Credential", valid_602422
  result.add "header", section
  ## parameters in `formData` object:
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `DbUser` field"
  var valid_602423 = formData.getOrDefault("DbUser")
  valid_602423 = validateParameter(valid_602423, JString, required = true,
                                 default = nil)
  if valid_602423 != nil:
    section.add "DbUser", valid_602423
  var valid_602424 = formData.getOrDefault("AutoCreate")
  valid_602424 = validateParameter(valid_602424, JBool, required = false, default = nil)
  if valid_602424 != nil:
    section.add "AutoCreate", valid_602424
  var valid_602425 = formData.getOrDefault("ClusterIdentifier")
  valid_602425 = validateParameter(valid_602425, JString, required = true,
                                 default = nil)
  if valid_602425 != nil:
    section.add "ClusterIdentifier", valid_602425
  var valid_602426 = formData.getOrDefault("DbName")
  valid_602426 = validateParameter(valid_602426, JString, required = false,
                                 default = nil)
  if valid_602426 != nil:
    section.add "DbName", valid_602426
  var valid_602427 = formData.getOrDefault("DbGroups")
  valid_602427 = validateParameter(valid_602427, JArray, required = false,
                                 default = nil)
  if valid_602427 != nil:
    section.add "DbGroups", valid_602427
  var valid_602428 = formData.getOrDefault("DurationSeconds")
  valid_602428 = validateParameter(valid_602428, JInt, required = false, default = nil)
  if valid_602428 != nil:
    section.add "DurationSeconds", valid_602428
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602429: Call_PostGetClusterCredentials_602411; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_602429.validator(path, query, header, formData, body)
  let scheme = call_602429.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602429.url(scheme.get, call_602429.host, call_602429.base,
                         call_602429.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602429, url, valid)

proc call*(call_602430: Call_PostGetClusterCredentials_602411; DbUser: string;
          ClusterIdentifier: string; Action: string = "GetClusterCredentials";
          AutoCreate: bool = false; DbName: string = ""; DbGroups: JsonNode = nil;
          Version: string = "2012-12-01"; DurationSeconds: int = 0): Recallable =
  ## postGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: string (required)
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  var query_602431 = newJObject()
  var formData_602432 = newJObject()
  add(formData_602432, "DbUser", newJString(DbUser))
  add(query_602431, "Action", newJString(Action))
  add(formData_602432, "AutoCreate", newJBool(AutoCreate))
  add(formData_602432, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_602432, "DbName", newJString(DbName))
  if DbGroups != nil:
    formData_602432.add "DbGroups", DbGroups
  add(query_602431, "Version", newJString(Version))
  add(formData_602432, "DurationSeconds", newJInt(DurationSeconds))
  result = call_602430.call(nil, query_602431, nil, formData_602432, nil)

var postGetClusterCredentials* = Call_PostGetClusterCredentials_602411(
    name: "postGetClusterCredentials", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_PostGetClusterCredentials_602412, base: "/",
    url: url_PostGetClusterCredentials_602413,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetClusterCredentials_602390 = ref object of OpenApiRestCall_599352
proc url_GetGetClusterCredentials_602392(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetClusterCredentials_602391(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  var valid_602393 = query.getOrDefault("DbGroups")
  valid_602393 = validateParameter(valid_602393, JArray, required = false,
                                 default = nil)
  if valid_602393 != nil:
    section.add "DbGroups", valid_602393
  var valid_602394 = query.getOrDefault("DurationSeconds")
  valid_602394 = validateParameter(valid_602394, JInt, required = false, default = nil)
  if valid_602394 != nil:
    section.add "DurationSeconds", valid_602394
  var valid_602395 = query.getOrDefault("DbName")
  valid_602395 = validateParameter(valid_602395, JString, required = false,
                                 default = nil)
  if valid_602395 != nil:
    section.add "DbName", valid_602395
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602396 = query.getOrDefault("Action")
  valid_602396 = validateParameter(valid_602396, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_602396 != nil:
    section.add "Action", valid_602396
  var valid_602397 = query.getOrDefault("ClusterIdentifier")
  valid_602397 = validateParameter(valid_602397, JString, required = true,
                                 default = nil)
  if valid_602397 != nil:
    section.add "ClusterIdentifier", valid_602397
  var valid_602398 = query.getOrDefault("AutoCreate")
  valid_602398 = validateParameter(valid_602398, JBool, required = false, default = nil)
  if valid_602398 != nil:
    section.add "AutoCreate", valid_602398
  var valid_602399 = query.getOrDefault("DbUser")
  valid_602399 = validateParameter(valid_602399, JString, required = true,
                                 default = nil)
  if valid_602399 != nil:
    section.add "DbUser", valid_602399
  var valid_602400 = query.getOrDefault("Version")
  valid_602400 = validateParameter(valid_602400, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602400 != nil:
    section.add "Version", valid_602400
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602401 = header.getOrDefault("X-Amz-Date")
  valid_602401 = validateParameter(valid_602401, JString, required = false,
                                 default = nil)
  if valid_602401 != nil:
    section.add "X-Amz-Date", valid_602401
  var valid_602402 = header.getOrDefault("X-Amz-Security-Token")
  valid_602402 = validateParameter(valid_602402, JString, required = false,
                                 default = nil)
  if valid_602402 != nil:
    section.add "X-Amz-Security-Token", valid_602402
  var valid_602403 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602403 = validateParameter(valid_602403, JString, required = false,
                                 default = nil)
  if valid_602403 != nil:
    section.add "X-Amz-Content-Sha256", valid_602403
  var valid_602404 = header.getOrDefault("X-Amz-Algorithm")
  valid_602404 = validateParameter(valid_602404, JString, required = false,
                                 default = nil)
  if valid_602404 != nil:
    section.add "X-Amz-Algorithm", valid_602404
  var valid_602405 = header.getOrDefault("X-Amz-Signature")
  valid_602405 = validateParameter(valid_602405, JString, required = false,
                                 default = nil)
  if valid_602405 != nil:
    section.add "X-Amz-Signature", valid_602405
  var valid_602406 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602406 = validateParameter(valid_602406, JString, required = false,
                                 default = nil)
  if valid_602406 != nil:
    section.add "X-Amz-SignedHeaders", valid_602406
  var valid_602407 = header.getOrDefault("X-Amz-Credential")
  valid_602407 = validateParameter(valid_602407, JString, required = false,
                                 default = nil)
  if valid_602407 != nil:
    section.add "X-Amz-Credential", valid_602407
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602408: Call_GetGetClusterCredentials_602390; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_602408.validator(path, query, header, formData, body)
  let scheme = call_602408.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602408.url(scheme.get, call_602408.host, call_602408.base,
                         call_602408.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602408, url, valid)

proc call*(call_602409: Call_GetGetClusterCredentials_602390;
          ClusterIdentifier: string; DbUser: string; DbGroups: JsonNode = nil;
          DurationSeconds: int = 0; DbName: string = "";
          Action: string = "GetClusterCredentials"; AutoCreate: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## getGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Version: string (required)
  var query_602410 = newJObject()
  if DbGroups != nil:
    query_602410.add "DbGroups", DbGroups
  add(query_602410, "DurationSeconds", newJInt(DurationSeconds))
  add(query_602410, "DbName", newJString(DbName))
  add(query_602410, "Action", newJString(Action))
  add(query_602410, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602410, "AutoCreate", newJBool(AutoCreate))
  add(query_602410, "DbUser", newJString(DbUser))
  add(query_602410, "Version", newJString(Version))
  result = call_602409.call(nil, query_602410, nil, nil, nil)

var getGetClusterCredentials* = Call_GetGetClusterCredentials_602390(
    name: "getGetClusterCredentials", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_GetGetClusterCredentials_602391, base: "/",
    url: url_GetGetClusterCredentials_602392, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetReservedNodeExchangeOfferings_602451 = ref object of OpenApiRestCall_599352
proc url_PostGetReservedNodeExchangeOfferings_602453(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostGetReservedNodeExchangeOfferings_602452(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602454 = query.getOrDefault("Action")
  valid_602454 = validateParameter(valid_602454, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_602454 != nil:
    section.add "Action", valid_602454
  var valid_602455 = query.getOrDefault("Version")
  valid_602455 = validateParameter(valid_602455, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602455 != nil:
    section.add "Version", valid_602455
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602456 = header.getOrDefault("X-Amz-Date")
  valid_602456 = validateParameter(valid_602456, JString, required = false,
                                 default = nil)
  if valid_602456 != nil:
    section.add "X-Amz-Date", valid_602456
  var valid_602457 = header.getOrDefault("X-Amz-Security-Token")
  valid_602457 = validateParameter(valid_602457, JString, required = false,
                                 default = nil)
  if valid_602457 != nil:
    section.add "X-Amz-Security-Token", valid_602457
  var valid_602458 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602458 = validateParameter(valid_602458, JString, required = false,
                                 default = nil)
  if valid_602458 != nil:
    section.add "X-Amz-Content-Sha256", valid_602458
  var valid_602459 = header.getOrDefault("X-Amz-Algorithm")
  valid_602459 = validateParameter(valid_602459, JString, required = false,
                                 default = nil)
  if valid_602459 != nil:
    section.add "X-Amz-Algorithm", valid_602459
  var valid_602460 = header.getOrDefault("X-Amz-Signature")
  valid_602460 = validateParameter(valid_602460, JString, required = false,
                                 default = nil)
  if valid_602460 != nil:
    section.add "X-Amz-Signature", valid_602460
  var valid_602461 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602461 = validateParameter(valid_602461, JString, required = false,
                                 default = nil)
  if valid_602461 != nil:
    section.add "X-Amz-SignedHeaders", valid_602461
  var valid_602462 = header.getOrDefault("X-Amz-Credential")
  valid_602462 = validateParameter(valid_602462, JString, required = false,
                                 default = nil)
  if valid_602462 != nil:
    section.add "X-Amz-Credential", valid_602462
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_602463 = formData.getOrDefault("ReservedNodeId")
  valid_602463 = validateParameter(valid_602463, JString, required = true,
                                 default = nil)
  if valid_602463 != nil:
    section.add "ReservedNodeId", valid_602463
  var valid_602464 = formData.getOrDefault("Marker")
  valid_602464 = validateParameter(valid_602464, JString, required = false,
                                 default = nil)
  if valid_602464 != nil:
    section.add "Marker", valid_602464
  var valid_602465 = formData.getOrDefault("MaxRecords")
  valid_602465 = validateParameter(valid_602465, JInt, required = false, default = nil)
  if valid_602465 != nil:
    section.add "MaxRecords", valid_602465
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602466: Call_PostGetReservedNodeExchangeOfferings_602451;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_602466.validator(path, query, header, formData, body)
  let scheme = call_602466.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602466.url(scheme.get, call_602466.host, call_602466.base,
                         call_602466.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602466, url, valid)

proc call*(call_602467: Call_PostGetReservedNodeExchangeOfferings_602451;
          ReservedNodeId: string; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings"; MaxRecords: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## postGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Version: string (required)
  var query_602468 = newJObject()
  var formData_602469 = newJObject()
  add(formData_602469, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_602469, "Marker", newJString(Marker))
  add(query_602468, "Action", newJString(Action))
  add(formData_602469, "MaxRecords", newJInt(MaxRecords))
  add(query_602468, "Version", newJString(Version))
  result = call_602467.call(nil, query_602468, nil, formData_602469, nil)

var postGetReservedNodeExchangeOfferings* = Call_PostGetReservedNodeExchangeOfferings_602451(
    name: "postGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_PostGetReservedNodeExchangeOfferings_602452, base: "/",
    url: url_PostGetReservedNodeExchangeOfferings_602453,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetReservedNodeExchangeOfferings_602433 = ref object of OpenApiRestCall_599352
proc url_GetGetReservedNodeExchangeOfferings_602435(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetGetReservedNodeExchangeOfferings_602434(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Action: JString (required)
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Version: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  section = newJObject()
  var valid_602436 = query.getOrDefault("MaxRecords")
  valid_602436 = validateParameter(valid_602436, JInt, required = false, default = nil)
  if valid_602436 != nil:
    section.add "MaxRecords", valid_602436
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602437 = query.getOrDefault("Action")
  valid_602437 = validateParameter(valid_602437, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_602437 != nil:
    section.add "Action", valid_602437
  var valid_602438 = query.getOrDefault("Marker")
  valid_602438 = validateParameter(valid_602438, JString, required = false,
                                 default = nil)
  if valid_602438 != nil:
    section.add "Marker", valid_602438
  var valid_602439 = query.getOrDefault("Version")
  valid_602439 = validateParameter(valid_602439, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602439 != nil:
    section.add "Version", valid_602439
  var valid_602440 = query.getOrDefault("ReservedNodeId")
  valid_602440 = validateParameter(valid_602440, JString, required = true,
                                 default = nil)
  if valid_602440 != nil:
    section.add "ReservedNodeId", valid_602440
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602441 = header.getOrDefault("X-Amz-Date")
  valid_602441 = validateParameter(valid_602441, JString, required = false,
                                 default = nil)
  if valid_602441 != nil:
    section.add "X-Amz-Date", valid_602441
  var valid_602442 = header.getOrDefault("X-Amz-Security-Token")
  valid_602442 = validateParameter(valid_602442, JString, required = false,
                                 default = nil)
  if valid_602442 != nil:
    section.add "X-Amz-Security-Token", valid_602442
  var valid_602443 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602443 = validateParameter(valid_602443, JString, required = false,
                                 default = nil)
  if valid_602443 != nil:
    section.add "X-Amz-Content-Sha256", valid_602443
  var valid_602444 = header.getOrDefault("X-Amz-Algorithm")
  valid_602444 = validateParameter(valid_602444, JString, required = false,
                                 default = nil)
  if valid_602444 != nil:
    section.add "X-Amz-Algorithm", valid_602444
  var valid_602445 = header.getOrDefault("X-Amz-Signature")
  valid_602445 = validateParameter(valid_602445, JString, required = false,
                                 default = nil)
  if valid_602445 != nil:
    section.add "X-Amz-Signature", valid_602445
  var valid_602446 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602446 = validateParameter(valid_602446, JString, required = false,
                                 default = nil)
  if valid_602446 != nil:
    section.add "X-Amz-SignedHeaders", valid_602446
  var valid_602447 = header.getOrDefault("X-Amz-Credential")
  valid_602447 = validateParameter(valid_602447, JString, required = false,
                                 default = nil)
  if valid_602447 != nil:
    section.add "X-Amz-Credential", valid_602447
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602448: Call_GetGetReservedNodeExchangeOfferings_602433;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_602448.validator(path, query, header, formData, body)
  let scheme = call_602448.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602448.url(scheme.get, call_602448.host, call_602448.base,
                         call_602448.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602448, url, valid)

proc call*(call_602449: Call_GetGetReservedNodeExchangeOfferings_602433;
          ReservedNodeId: string; MaxRecords: int = 0;
          Action: string = "GetReservedNodeExchangeOfferings"; Marker: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Action: string (required)
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Version: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  var query_602450 = newJObject()
  add(query_602450, "MaxRecords", newJInt(MaxRecords))
  add(query_602450, "Action", newJString(Action))
  add(query_602450, "Marker", newJString(Marker))
  add(query_602450, "Version", newJString(Version))
  add(query_602450, "ReservedNodeId", newJString(ReservedNodeId))
  result = call_602449.call(nil, query_602450, nil, nil, nil)

var getGetReservedNodeExchangeOfferings* = Call_GetGetReservedNodeExchangeOfferings_602433(
    name: "getGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_GetGetReservedNodeExchangeOfferings_602434, base: "/",
    url: url_GetGetReservedNodeExchangeOfferings_602435,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyCluster_602507 = ref object of OpenApiRestCall_599352
proc url_PostModifyCluster_602509(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyCluster_602508(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602510 = query.getOrDefault("Action")
  valid_602510 = validateParameter(valid_602510, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_602510 != nil:
    section.add "Action", valid_602510
  var valid_602511 = query.getOrDefault("Version")
  valid_602511 = validateParameter(valid_602511, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602511 != nil:
    section.add "Version", valid_602511
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602512 = header.getOrDefault("X-Amz-Date")
  valid_602512 = validateParameter(valid_602512, JString, required = false,
                                 default = nil)
  if valid_602512 != nil:
    section.add "X-Amz-Date", valid_602512
  var valid_602513 = header.getOrDefault("X-Amz-Security-Token")
  valid_602513 = validateParameter(valid_602513, JString, required = false,
                                 default = nil)
  if valid_602513 != nil:
    section.add "X-Amz-Security-Token", valid_602513
  var valid_602514 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602514 = validateParameter(valid_602514, JString, required = false,
                                 default = nil)
  if valid_602514 != nil:
    section.add "X-Amz-Content-Sha256", valid_602514
  var valid_602515 = header.getOrDefault("X-Amz-Algorithm")
  valid_602515 = validateParameter(valid_602515, JString, required = false,
                                 default = nil)
  if valid_602515 != nil:
    section.add "X-Amz-Algorithm", valid_602515
  var valid_602516 = header.getOrDefault("X-Amz-Signature")
  valid_602516 = validateParameter(valid_602516, JString, required = false,
                                 default = nil)
  if valid_602516 != nil:
    section.add "X-Amz-Signature", valid_602516
  var valid_602517 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602517 = validateParameter(valid_602517, JString, required = false,
                                 default = nil)
  if valid_602517 != nil:
    section.add "X-Amz-SignedHeaders", valid_602517
  var valid_602518 = header.getOrDefault("X-Amz-Credential")
  valid_602518 = validateParameter(valid_602518, JString, required = false,
                                 default = nil)
  if valid_602518 != nil:
    section.add "X-Amz-Credential", valid_602518
  result.add "header", section
  ## parameters in `formData` object:
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  section = newJObject()
  var valid_602519 = formData.getOrDefault("EnhancedVpcRouting")
  valid_602519 = validateParameter(valid_602519, JBool, required = false, default = nil)
  if valid_602519 != nil:
    section.add "EnhancedVpcRouting", valid_602519
  var valid_602520 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_602520 = validateParameter(valid_602520, JArray, required = false,
                                 default = nil)
  if valid_602520 != nil:
    section.add "VpcSecurityGroupIds", valid_602520
  var valid_602521 = formData.getOrDefault("ClusterVersion")
  valid_602521 = validateParameter(valid_602521, JString, required = false,
                                 default = nil)
  if valid_602521 != nil:
    section.add "ClusterVersion", valid_602521
  var valid_602522 = formData.getOrDefault("ClusterType")
  valid_602522 = validateParameter(valid_602522, JString, required = false,
                                 default = nil)
  if valid_602522 != nil:
    section.add "ClusterType", valid_602522
  var valid_602523 = formData.getOrDefault("MasterUserPassword")
  valid_602523 = validateParameter(valid_602523, JString, required = false,
                                 default = nil)
  if valid_602523 != nil:
    section.add "MasterUserPassword", valid_602523
  var valid_602524 = formData.getOrDefault("ClusterSecurityGroups")
  valid_602524 = validateParameter(valid_602524, JArray, required = false,
                                 default = nil)
  if valid_602524 != nil:
    section.add "ClusterSecurityGroups", valid_602524
  var valid_602525 = formData.getOrDefault("Encrypted")
  valid_602525 = validateParameter(valid_602525, JBool, required = false, default = nil)
  if valid_602525 != nil:
    section.add "Encrypted", valid_602525
  var valid_602526 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_602526 = validateParameter(valid_602526, JString, required = false,
                                 default = nil)
  if valid_602526 != nil:
    section.add "HsmConfigurationIdentifier", valid_602526
  var valid_602527 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_602527 = validateParameter(valid_602527, JString, required = false,
                                 default = nil)
  if valid_602527 != nil:
    section.add "HsmClientCertificateIdentifier", valid_602527
  var valid_602528 = formData.getOrDefault("PubliclyAccessible")
  valid_602528 = validateParameter(valid_602528, JBool, required = false, default = nil)
  if valid_602528 != nil:
    section.add "PubliclyAccessible", valid_602528
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_602529 = formData.getOrDefault("ClusterIdentifier")
  valid_602529 = validateParameter(valid_602529, JString, required = true,
                                 default = nil)
  if valid_602529 != nil:
    section.add "ClusterIdentifier", valid_602529
  var valid_602530 = formData.getOrDefault("NumberOfNodes")
  valid_602530 = validateParameter(valid_602530, JInt, required = false, default = nil)
  if valid_602530 != nil:
    section.add "NumberOfNodes", valid_602530
  var valid_602531 = formData.getOrDefault("ClusterParameterGroupName")
  valid_602531 = validateParameter(valid_602531, JString, required = false,
                                 default = nil)
  if valid_602531 != nil:
    section.add "ClusterParameterGroupName", valid_602531
  var valid_602532 = formData.getOrDefault("KmsKeyId")
  valid_602532 = validateParameter(valid_602532, JString, required = false,
                                 default = nil)
  if valid_602532 != nil:
    section.add "KmsKeyId", valid_602532
  var valid_602533 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602533 = validateParameter(valid_602533, JInt, required = false, default = nil)
  if valid_602533 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602533
  var valid_602534 = formData.getOrDefault("ElasticIp")
  valid_602534 = validateParameter(valid_602534, JString, required = false,
                                 default = nil)
  if valid_602534 != nil:
    section.add "ElasticIp", valid_602534
  var valid_602535 = formData.getOrDefault("NewClusterIdentifier")
  valid_602535 = validateParameter(valid_602535, JString, required = false,
                                 default = nil)
  if valid_602535 != nil:
    section.add "NewClusterIdentifier", valid_602535
  var valid_602536 = formData.getOrDefault("AllowVersionUpgrade")
  valid_602536 = validateParameter(valid_602536, JBool, required = false, default = nil)
  if valid_602536 != nil:
    section.add "AllowVersionUpgrade", valid_602536
  var valid_602537 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_602537 = validateParameter(valid_602537, JInt, required = false, default = nil)
  if valid_602537 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_602537
  var valid_602538 = formData.getOrDefault("NodeType")
  valid_602538 = validateParameter(valid_602538, JString, required = false,
                                 default = nil)
  if valid_602538 != nil:
    section.add "NodeType", valid_602538
  var valid_602539 = formData.getOrDefault("MaintenanceTrackName")
  valid_602539 = validateParameter(valid_602539, JString, required = false,
                                 default = nil)
  if valid_602539 != nil:
    section.add "MaintenanceTrackName", valid_602539
  var valid_602540 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_602540 = validateParameter(valid_602540, JString, required = false,
                                 default = nil)
  if valid_602540 != nil:
    section.add "PreferredMaintenanceWindow", valid_602540
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602541: Call_PostModifyCluster_602507; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_602541.validator(path, query, header, formData, body)
  let scheme = call_602541.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602541.url(scheme.get, call_602541.host, call_602541.base,
                         call_602541.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602541, url, valid)

proc call*(call_602542: Call_PostModifyCluster_602507; ClusterIdentifier: string;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterVersion: string = ""; ClusterType: string = "";
          MasterUserPassword: string = ""; ClusterSecurityGroups: JsonNode = nil;
          Encrypted: bool = false; HsmConfigurationIdentifier: string = "";
          Action: string = "ModifyCluster";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          ClusterParameterGroupName: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          NewClusterIdentifier: string = ""; AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          NodeType: string = ""; MaintenanceTrackName: string = "";
          PreferredMaintenanceWindow: string = ""): Recallable =
  ## postModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  var query_602543 = newJObject()
  var formData_602544 = newJObject()
  add(formData_602544, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    formData_602544.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_602544, "ClusterVersion", newJString(ClusterVersion))
  add(formData_602544, "ClusterType", newJString(ClusterType))
  add(formData_602544, "MasterUserPassword", newJString(MasterUserPassword))
  if ClusterSecurityGroups != nil:
    formData_602544.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_602544, "Encrypted", newJBool(Encrypted))
  add(formData_602544, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_602543, "Action", newJString(Action))
  add(formData_602544, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_602544, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_602544, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_602544, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_602544, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_602544, "KmsKeyId", newJString(KmsKeyId))
  add(formData_602544, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_602544, "ElasticIp", newJString(ElasticIp))
  add(formData_602544, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(formData_602544, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_602544, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_602543, "Version", newJString(Version))
  add(formData_602544, "NodeType", newJString(NodeType))
  add(formData_602544, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_602544, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  result = call_602542.call(nil, query_602543, nil, formData_602544, nil)

var postModifyCluster* = Call_PostModifyCluster_602507(name: "postModifyCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_PostModifyCluster_602508,
    base: "/", url: url_PostModifyCluster_602509,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyCluster_602470 = ref object of OpenApiRestCall_599352
proc url_GetModifyCluster_602472(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyCluster_602471(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_602473 = query.getOrDefault("ClusterSecurityGroups")
  valid_602473 = validateParameter(valid_602473, JArray, required = false,
                                 default = nil)
  if valid_602473 != nil:
    section.add "ClusterSecurityGroups", valid_602473
  var valid_602474 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_602474 = validateParameter(valid_602474, JString, required = false,
                                 default = nil)
  if valid_602474 != nil:
    section.add "HsmClientCertificateIdentifier", valid_602474
  var valid_602475 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_602475 = validateParameter(valid_602475, JString, required = false,
                                 default = nil)
  if valid_602475 != nil:
    section.add "PreferredMaintenanceWindow", valid_602475
  var valid_602476 = query.getOrDefault("Encrypted")
  valid_602476 = validateParameter(valid_602476, JBool, required = false, default = nil)
  if valid_602476 != nil:
    section.add "Encrypted", valid_602476
  var valid_602477 = query.getOrDefault("MaintenanceTrackName")
  valid_602477 = validateParameter(valid_602477, JString, required = false,
                                 default = nil)
  if valid_602477 != nil:
    section.add "MaintenanceTrackName", valid_602477
  var valid_602478 = query.getOrDefault("MasterUserPassword")
  valid_602478 = validateParameter(valid_602478, JString, required = false,
                                 default = nil)
  if valid_602478 != nil:
    section.add "MasterUserPassword", valid_602478
  var valid_602479 = query.getOrDefault("AllowVersionUpgrade")
  valid_602479 = validateParameter(valid_602479, JBool, required = false, default = nil)
  if valid_602479 != nil:
    section.add "AllowVersionUpgrade", valid_602479
  var valid_602480 = query.getOrDefault("EnhancedVpcRouting")
  valid_602480 = validateParameter(valid_602480, JBool, required = false, default = nil)
  if valid_602480 != nil:
    section.add "EnhancedVpcRouting", valid_602480
  var valid_602481 = query.getOrDefault("VpcSecurityGroupIds")
  valid_602481 = validateParameter(valid_602481, JArray, required = false,
                                 default = nil)
  if valid_602481 != nil:
    section.add "VpcSecurityGroupIds", valid_602481
  var valid_602482 = query.getOrDefault("ClusterParameterGroupName")
  valid_602482 = validateParameter(valid_602482, JString, required = false,
                                 default = nil)
  if valid_602482 != nil:
    section.add "ClusterParameterGroupName", valid_602482
  var valid_602483 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_602483 = validateParameter(valid_602483, JString, required = false,
                                 default = nil)
  if valid_602483 != nil:
    section.add "HsmConfigurationIdentifier", valid_602483
  var valid_602484 = query.getOrDefault("NewClusterIdentifier")
  valid_602484 = validateParameter(valid_602484, JString, required = false,
                                 default = nil)
  if valid_602484 != nil:
    section.add "NewClusterIdentifier", valid_602484
  var valid_602485 = query.getOrDefault("ElasticIp")
  valid_602485 = validateParameter(valid_602485, JString, required = false,
                                 default = nil)
  if valid_602485 != nil:
    section.add "ElasticIp", valid_602485
  assert query != nil,
        "query argument is necessary due to required `ClusterIdentifier` field"
  var valid_602486 = query.getOrDefault("ClusterIdentifier")
  valid_602486 = validateParameter(valid_602486, JString, required = true,
                                 default = nil)
  if valid_602486 != nil:
    section.add "ClusterIdentifier", valid_602486
  var valid_602487 = query.getOrDefault("Action")
  valid_602487 = validateParameter(valid_602487, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_602487 != nil:
    section.add "Action", valid_602487
  var valid_602488 = query.getOrDefault("KmsKeyId")
  valid_602488 = validateParameter(valid_602488, JString, required = false,
                                 default = nil)
  if valid_602488 != nil:
    section.add "KmsKeyId", valid_602488
  var valid_602489 = query.getOrDefault("PubliclyAccessible")
  valid_602489 = validateParameter(valid_602489, JBool, required = false, default = nil)
  if valid_602489 != nil:
    section.add "PubliclyAccessible", valid_602489
  var valid_602490 = query.getOrDefault("NumberOfNodes")
  valid_602490 = validateParameter(valid_602490, JInt, required = false, default = nil)
  if valid_602490 != nil:
    section.add "NumberOfNodes", valid_602490
  var valid_602491 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_602491 = validateParameter(valid_602491, JInt, required = false, default = nil)
  if valid_602491 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_602491
  var valid_602492 = query.getOrDefault("NodeType")
  valid_602492 = validateParameter(valid_602492, JString, required = false,
                                 default = nil)
  if valid_602492 != nil:
    section.add "NodeType", valid_602492
  var valid_602493 = query.getOrDefault("ClusterVersion")
  valid_602493 = validateParameter(valid_602493, JString, required = false,
                                 default = nil)
  if valid_602493 != nil:
    section.add "ClusterVersion", valid_602493
  var valid_602494 = query.getOrDefault("Version")
  valid_602494 = validateParameter(valid_602494, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602494 != nil:
    section.add "Version", valid_602494
  var valid_602495 = query.getOrDefault("ClusterType")
  valid_602495 = validateParameter(valid_602495, JString, required = false,
                                 default = nil)
  if valid_602495 != nil:
    section.add "ClusterType", valid_602495
  var valid_602496 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602496 = validateParameter(valid_602496, JInt, required = false, default = nil)
  if valid_602496 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602496
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602497 = header.getOrDefault("X-Amz-Date")
  valid_602497 = validateParameter(valid_602497, JString, required = false,
                                 default = nil)
  if valid_602497 != nil:
    section.add "X-Amz-Date", valid_602497
  var valid_602498 = header.getOrDefault("X-Amz-Security-Token")
  valid_602498 = validateParameter(valid_602498, JString, required = false,
                                 default = nil)
  if valid_602498 != nil:
    section.add "X-Amz-Security-Token", valid_602498
  var valid_602499 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602499 = validateParameter(valid_602499, JString, required = false,
                                 default = nil)
  if valid_602499 != nil:
    section.add "X-Amz-Content-Sha256", valid_602499
  var valid_602500 = header.getOrDefault("X-Amz-Algorithm")
  valid_602500 = validateParameter(valid_602500, JString, required = false,
                                 default = nil)
  if valid_602500 != nil:
    section.add "X-Amz-Algorithm", valid_602500
  var valid_602501 = header.getOrDefault("X-Amz-Signature")
  valid_602501 = validateParameter(valid_602501, JString, required = false,
                                 default = nil)
  if valid_602501 != nil:
    section.add "X-Amz-Signature", valid_602501
  var valid_602502 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602502 = validateParameter(valid_602502, JString, required = false,
                                 default = nil)
  if valid_602502 != nil:
    section.add "X-Amz-SignedHeaders", valid_602502
  var valid_602503 = header.getOrDefault("X-Amz-Credential")
  valid_602503 = validateParameter(valid_602503, JString, required = false,
                                 default = nil)
  if valid_602503 != nil:
    section.add "X-Amz-Credential", valid_602503
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602504: Call_GetModifyCluster_602470; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_602504.validator(path, query, header, formData, body)
  let scheme = call_602504.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602504.url(scheme.get, call_602504.host, call_602504.base,
                         call_602504.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602504, url, valid)

proc call*(call_602505: Call_GetModifyCluster_602470; ClusterIdentifier: string;
          ClusterSecurityGroups: JsonNode = nil;
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = ""; Encrypted: bool = false;
          MaintenanceTrackName: string = ""; MasterUserPassword: string = "";
          AllowVersionUpgrade: bool = false; EnhancedVpcRouting: bool = false;
          VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = "";
          NewClusterIdentifier: string = ""; ElasticIp: string = "";
          Action: string = "ModifyCluster"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; NodeType: string = "";
          ClusterVersion: string = ""; Version: string = "2012-12-01";
          ClusterType: string = ""; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_602506 = newJObject()
  if ClusterSecurityGroups != nil:
    query_602506.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_602506, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_602506, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_602506, "Encrypted", newJBool(Encrypted))
  add(query_602506, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_602506, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_602506, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_602506, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_602506.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_602506, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_602506, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_602506, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(query_602506, "ElasticIp", newJString(ElasticIp))
  add(query_602506, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602506, "Action", newJString(Action))
  add(query_602506, "KmsKeyId", newJString(KmsKeyId))
  add(query_602506, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_602506, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_602506, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_602506, "NodeType", newJString(NodeType))
  add(query_602506, "ClusterVersion", newJString(ClusterVersion))
  add(query_602506, "Version", newJString(Version))
  add(query_602506, "ClusterType", newJString(ClusterType))
  add(query_602506, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_602505.call(nil, query_602506, nil, nil, nil)

var getModifyCluster* = Call_GetModifyCluster_602470(name: "getModifyCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_GetModifyCluster_602471,
    base: "/", url: url_GetModifyCluster_602472,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterDbRevision_602562 = ref object of OpenApiRestCall_599352
proc url_PostModifyClusterDbRevision_602564(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterDbRevision_602563(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602565 = query.getOrDefault("Action")
  valid_602565 = validateParameter(valid_602565, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_602565 != nil:
    section.add "Action", valid_602565
  var valid_602566 = query.getOrDefault("Version")
  valid_602566 = validateParameter(valid_602566, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602566 != nil:
    section.add "Version", valid_602566
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602567 = header.getOrDefault("X-Amz-Date")
  valid_602567 = validateParameter(valid_602567, JString, required = false,
                                 default = nil)
  if valid_602567 != nil:
    section.add "X-Amz-Date", valid_602567
  var valid_602568 = header.getOrDefault("X-Amz-Security-Token")
  valid_602568 = validateParameter(valid_602568, JString, required = false,
                                 default = nil)
  if valid_602568 != nil:
    section.add "X-Amz-Security-Token", valid_602568
  var valid_602569 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602569 = validateParameter(valid_602569, JString, required = false,
                                 default = nil)
  if valid_602569 != nil:
    section.add "X-Amz-Content-Sha256", valid_602569
  var valid_602570 = header.getOrDefault("X-Amz-Algorithm")
  valid_602570 = validateParameter(valid_602570, JString, required = false,
                                 default = nil)
  if valid_602570 != nil:
    section.add "X-Amz-Algorithm", valid_602570
  var valid_602571 = header.getOrDefault("X-Amz-Signature")
  valid_602571 = validateParameter(valid_602571, JString, required = false,
                                 default = nil)
  if valid_602571 != nil:
    section.add "X-Amz-Signature", valid_602571
  var valid_602572 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602572 = validateParameter(valid_602572, JString, required = false,
                                 default = nil)
  if valid_602572 != nil:
    section.add "X-Amz-SignedHeaders", valid_602572
  var valid_602573 = header.getOrDefault("X-Amz-Credential")
  valid_602573 = validateParameter(valid_602573, JString, required = false,
                                 default = nil)
  if valid_602573 != nil:
    section.add "X-Amz-Credential", valid_602573
  result.add "header", section
  ## parameters in `formData` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `RevisionTarget` field"
  var valid_602574 = formData.getOrDefault("RevisionTarget")
  valid_602574 = validateParameter(valid_602574, JString, required = true,
                                 default = nil)
  if valid_602574 != nil:
    section.add "RevisionTarget", valid_602574
  var valid_602575 = formData.getOrDefault("ClusterIdentifier")
  valid_602575 = validateParameter(valid_602575, JString, required = true,
                                 default = nil)
  if valid_602575 != nil:
    section.add "ClusterIdentifier", valid_602575
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602576: Call_PostModifyClusterDbRevision_602562; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_602576.validator(path, query, header, formData, body)
  let scheme = call_602576.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602576.url(scheme.get, call_602576.host, call_602576.base,
                         call_602576.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602576, url, valid)

proc call*(call_602577: Call_PostModifyClusterDbRevision_602562;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_602578 = newJObject()
  var formData_602579 = newJObject()
  add(formData_602579, "RevisionTarget", newJString(RevisionTarget))
  add(query_602578, "Action", newJString(Action))
  add(formData_602579, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602578, "Version", newJString(Version))
  result = call_602577.call(nil, query_602578, nil, formData_602579, nil)

var postModifyClusterDbRevision* = Call_PostModifyClusterDbRevision_602562(
    name: "postModifyClusterDbRevision", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_PostModifyClusterDbRevision_602563, base: "/",
    url: url_PostModifyClusterDbRevision_602564,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterDbRevision_602545 = ref object of OpenApiRestCall_599352
proc url_GetModifyClusterDbRevision_602547(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterDbRevision_602546(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `RevisionTarget` field"
  var valid_602548 = query.getOrDefault("RevisionTarget")
  valid_602548 = validateParameter(valid_602548, JString, required = true,
                                 default = nil)
  if valid_602548 != nil:
    section.add "RevisionTarget", valid_602548
  var valid_602549 = query.getOrDefault("Action")
  valid_602549 = validateParameter(valid_602549, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_602549 != nil:
    section.add "Action", valid_602549
  var valid_602550 = query.getOrDefault("ClusterIdentifier")
  valid_602550 = validateParameter(valid_602550, JString, required = true,
                                 default = nil)
  if valid_602550 != nil:
    section.add "ClusterIdentifier", valid_602550
  var valid_602551 = query.getOrDefault("Version")
  valid_602551 = validateParameter(valid_602551, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602551 != nil:
    section.add "Version", valid_602551
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602552 = header.getOrDefault("X-Amz-Date")
  valid_602552 = validateParameter(valid_602552, JString, required = false,
                                 default = nil)
  if valid_602552 != nil:
    section.add "X-Amz-Date", valid_602552
  var valid_602553 = header.getOrDefault("X-Amz-Security-Token")
  valid_602553 = validateParameter(valid_602553, JString, required = false,
                                 default = nil)
  if valid_602553 != nil:
    section.add "X-Amz-Security-Token", valid_602553
  var valid_602554 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602554 = validateParameter(valid_602554, JString, required = false,
                                 default = nil)
  if valid_602554 != nil:
    section.add "X-Amz-Content-Sha256", valid_602554
  var valid_602555 = header.getOrDefault("X-Amz-Algorithm")
  valid_602555 = validateParameter(valid_602555, JString, required = false,
                                 default = nil)
  if valid_602555 != nil:
    section.add "X-Amz-Algorithm", valid_602555
  var valid_602556 = header.getOrDefault("X-Amz-Signature")
  valid_602556 = validateParameter(valid_602556, JString, required = false,
                                 default = nil)
  if valid_602556 != nil:
    section.add "X-Amz-Signature", valid_602556
  var valid_602557 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602557 = validateParameter(valid_602557, JString, required = false,
                                 default = nil)
  if valid_602557 != nil:
    section.add "X-Amz-SignedHeaders", valid_602557
  var valid_602558 = header.getOrDefault("X-Amz-Credential")
  valid_602558 = validateParameter(valid_602558, JString, required = false,
                                 default = nil)
  if valid_602558 != nil:
    section.add "X-Amz-Credential", valid_602558
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602559: Call_GetModifyClusterDbRevision_602545; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_602559.validator(path, query, header, formData, body)
  let scheme = call_602559.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602559.url(scheme.get, call_602559.host, call_602559.base,
                         call_602559.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602559, url, valid)

proc call*(call_602560: Call_GetModifyClusterDbRevision_602545;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_602561 = newJObject()
  add(query_602561, "RevisionTarget", newJString(RevisionTarget))
  add(query_602561, "Action", newJString(Action))
  add(query_602561, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602561, "Version", newJString(Version))
  result = call_602560.call(nil, query_602561, nil, nil, nil)

var getModifyClusterDbRevision* = Call_GetModifyClusterDbRevision_602545(
    name: "getModifyClusterDbRevision", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_GetModifyClusterDbRevision_602546, base: "/",
    url: url_GetModifyClusterDbRevision_602547,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterIamRoles_602598 = ref object of OpenApiRestCall_599352
proc url_PostModifyClusterIamRoles_602600(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterIamRoles_602599(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602601 = query.getOrDefault("Action")
  valid_602601 = validateParameter(valid_602601, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_602601 != nil:
    section.add "Action", valid_602601
  var valid_602602 = query.getOrDefault("Version")
  valid_602602 = validateParameter(valid_602602, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602602 != nil:
    section.add "Version", valid_602602
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602603 = header.getOrDefault("X-Amz-Date")
  valid_602603 = validateParameter(valid_602603, JString, required = false,
                                 default = nil)
  if valid_602603 != nil:
    section.add "X-Amz-Date", valid_602603
  var valid_602604 = header.getOrDefault("X-Amz-Security-Token")
  valid_602604 = validateParameter(valid_602604, JString, required = false,
                                 default = nil)
  if valid_602604 != nil:
    section.add "X-Amz-Security-Token", valid_602604
  var valid_602605 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602605 = validateParameter(valid_602605, JString, required = false,
                                 default = nil)
  if valid_602605 != nil:
    section.add "X-Amz-Content-Sha256", valid_602605
  var valid_602606 = header.getOrDefault("X-Amz-Algorithm")
  valid_602606 = validateParameter(valid_602606, JString, required = false,
                                 default = nil)
  if valid_602606 != nil:
    section.add "X-Amz-Algorithm", valid_602606
  var valid_602607 = header.getOrDefault("X-Amz-Signature")
  valid_602607 = validateParameter(valid_602607, JString, required = false,
                                 default = nil)
  if valid_602607 != nil:
    section.add "X-Amz-Signature", valid_602607
  var valid_602608 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602608 = validateParameter(valid_602608, JString, required = false,
                                 default = nil)
  if valid_602608 != nil:
    section.add "X-Amz-SignedHeaders", valid_602608
  var valid_602609 = header.getOrDefault("X-Amz-Credential")
  valid_602609 = validateParameter(valid_602609, JString, required = false,
                                 default = nil)
  if valid_602609 != nil:
    section.add "X-Amz-Credential", valid_602609
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_602610 = formData.getOrDefault("ClusterIdentifier")
  valid_602610 = validateParameter(valid_602610, JString, required = true,
                                 default = nil)
  if valid_602610 != nil:
    section.add "ClusterIdentifier", valid_602610
  var valid_602611 = formData.getOrDefault("AddIamRoles")
  valid_602611 = validateParameter(valid_602611, JArray, required = false,
                                 default = nil)
  if valid_602611 != nil:
    section.add "AddIamRoles", valid_602611
  var valid_602612 = formData.getOrDefault("RemoveIamRoles")
  valid_602612 = validateParameter(valid_602612, JArray, required = false,
                                 default = nil)
  if valid_602612 != nil:
    section.add "RemoveIamRoles", valid_602612
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602613: Call_PostModifyClusterIamRoles_602598; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_602613.validator(path, query, header, formData, body)
  let scheme = call_602613.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602613.url(scheme.get, call_602613.host, call_602613.base,
                         call_602613.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602613, url, valid)

proc call*(call_602614: Call_PostModifyClusterIamRoles_602598;
          ClusterIdentifier: string; Action: string = "ModifyClusterIamRoles";
          AddIamRoles: JsonNode = nil; RemoveIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: string (required)
  var query_602615 = newJObject()
  var formData_602616 = newJObject()
  add(query_602615, "Action", newJString(Action))
  add(formData_602616, "ClusterIdentifier", newJString(ClusterIdentifier))
  if AddIamRoles != nil:
    formData_602616.add "AddIamRoles", AddIamRoles
  if RemoveIamRoles != nil:
    formData_602616.add "RemoveIamRoles", RemoveIamRoles
  add(query_602615, "Version", newJString(Version))
  result = call_602614.call(nil, query_602615, nil, formData_602616, nil)

var postModifyClusterIamRoles* = Call_PostModifyClusterIamRoles_602598(
    name: "postModifyClusterIamRoles", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_PostModifyClusterIamRoles_602599, base: "/",
    url: url_PostModifyClusterIamRoles_602600,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterIamRoles_602580 = ref object of OpenApiRestCall_599352
proc url_GetModifyClusterIamRoles_602582(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterIamRoles_602581(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   Version: JString (required)
  section = newJObject()
  var valid_602583 = query.getOrDefault("AddIamRoles")
  valid_602583 = validateParameter(valid_602583, JArray, required = false,
                                 default = nil)
  if valid_602583 != nil:
    section.add "AddIamRoles", valid_602583
  var valid_602584 = query.getOrDefault("RemoveIamRoles")
  valid_602584 = validateParameter(valid_602584, JArray, required = false,
                                 default = nil)
  if valid_602584 != nil:
    section.add "RemoveIamRoles", valid_602584
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602585 = query.getOrDefault("Action")
  valid_602585 = validateParameter(valid_602585, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_602585 != nil:
    section.add "Action", valid_602585
  var valid_602586 = query.getOrDefault("ClusterIdentifier")
  valid_602586 = validateParameter(valid_602586, JString, required = true,
                                 default = nil)
  if valid_602586 != nil:
    section.add "ClusterIdentifier", valid_602586
  var valid_602587 = query.getOrDefault("Version")
  valid_602587 = validateParameter(valid_602587, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602587 != nil:
    section.add "Version", valid_602587
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602588 = header.getOrDefault("X-Amz-Date")
  valid_602588 = validateParameter(valid_602588, JString, required = false,
                                 default = nil)
  if valid_602588 != nil:
    section.add "X-Amz-Date", valid_602588
  var valid_602589 = header.getOrDefault("X-Amz-Security-Token")
  valid_602589 = validateParameter(valid_602589, JString, required = false,
                                 default = nil)
  if valid_602589 != nil:
    section.add "X-Amz-Security-Token", valid_602589
  var valid_602590 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602590 = validateParameter(valid_602590, JString, required = false,
                                 default = nil)
  if valid_602590 != nil:
    section.add "X-Amz-Content-Sha256", valid_602590
  var valid_602591 = header.getOrDefault("X-Amz-Algorithm")
  valid_602591 = validateParameter(valid_602591, JString, required = false,
                                 default = nil)
  if valid_602591 != nil:
    section.add "X-Amz-Algorithm", valid_602591
  var valid_602592 = header.getOrDefault("X-Amz-Signature")
  valid_602592 = validateParameter(valid_602592, JString, required = false,
                                 default = nil)
  if valid_602592 != nil:
    section.add "X-Amz-Signature", valid_602592
  var valid_602593 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602593 = validateParameter(valid_602593, JString, required = false,
                                 default = nil)
  if valid_602593 != nil:
    section.add "X-Amz-SignedHeaders", valid_602593
  var valid_602594 = header.getOrDefault("X-Amz-Credential")
  valid_602594 = validateParameter(valid_602594, JString, required = false,
                                 default = nil)
  if valid_602594 != nil:
    section.add "X-Amz-Credential", valid_602594
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602595: Call_GetModifyClusterIamRoles_602580; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_602595.validator(path, query, header, formData, body)
  let scheme = call_602595.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602595.url(scheme.get, call_602595.host, call_602595.base,
                         call_602595.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602595, url, valid)

proc call*(call_602596: Call_GetModifyClusterIamRoles_602580;
          ClusterIdentifier: string; AddIamRoles: JsonNode = nil;
          RemoveIamRoles: JsonNode = nil; Action: string = "ModifyClusterIamRoles";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   Version: string (required)
  var query_602597 = newJObject()
  if AddIamRoles != nil:
    query_602597.add "AddIamRoles", AddIamRoles
  if RemoveIamRoles != nil:
    query_602597.add "RemoveIamRoles", RemoveIamRoles
  add(query_602597, "Action", newJString(Action))
  add(query_602597, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602597, "Version", newJString(Version))
  result = call_602596.call(nil, query_602597, nil, nil, nil)

var getModifyClusterIamRoles* = Call_GetModifyClusterIamRoles_602580(
    name: "getModifyClusterIamRoles", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_GetModifyClusterIamRoles_602581, base: "/",
    url: url_GetModifyClusterIamRoles_602582, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterMaintenance_602638 = ref object of OpenApiRestCall_599352
proc url_PostModifyClusterMaintenance_602640(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterMaintenance_602639(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602641 = query.getOrDefault("Action")
  valid_602641 = validateParameter(valid_602641, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_602641 != nil:
    section.add "Action", valid_602641
  var valid_602642 = query.getOrDefault("Version")
  valid_602642 = validateParameter(valid_602642, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602642 != nil:
    section.add "Version", valid_602642
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602643 = header.getOrDefault("X-Amz-Date")
  valid_602643 = validateParameter(valid_602643, JString, required = false,
                                 default = nil)
  if valid_602643 != nil:
    section.add "X-Amz-Date", valid_602643
  var valid_602644 = header.getOrDefault("X-Amz-Security-Token")
  valid_602644 = validateParameter(valid_602644, JString, required = false,
                                 default = nil)
  if valid_602644 != nil:
    section.add "X-Amz-Security-Token", valid_602644
  var valid_602645 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602645 = validateParameter(valid_602645, JString, required = false,
                                 default = nil)
  if valid_602645 != nil:
    section.add "X-Amz-Content-Sha256", valid_602645
  var valid_602646 = header.getOrDefault("X-Amz-Algorithm")
  valid_602646 = validateParameter(valid_602646, JString, required = false,
                                 default = nil)
  if valid_602646 != nil:
    section.add "X-Amz-Algorithm", valid_602646
  var valid_602647 = header.getOrDefault("X-Amz-Signature")
  valid_602647 = validateParameter(valid_602647, JString, required = false,
                                 default = nil)
  if valid_602647 != nil:
    section.add "X-Amz-Signature", valid_602647
  var valid_602648 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602648 = validateParameter(valid_602648, JString, required = false,
                                 default = nil)
  if valid_602648 != nil:
    section.add "X-Amz-SignedHeaders", valid_602648
  var valid_602649 = header.getOrDefault("X-Amz-Credential")
  valid_602649 = validateParameter(valid_602649, JString, required = false,
                                 default = nil)
  if valid_602649 != nil:
    section.add "X-Amz-Credential", valid_602649
  result.add "header", section
  ## parameters in `formData` object:
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  section = newJObject()
  var valid_602650 = formData.getOrDefault("DeferMaintenanceDuration")
  valid_602650 = validateParameter(valid_602650, JInt, required = false, default = nil)
  if valid_602650 != nil:
    section.add "DeferMaintenanceDuration", valid_602650
  var valid_602651 = formData.getOrDefault("DeferMaintenanceIdentifier")
  valid_602651 = validateParameter(valid_602651, JString, required = false,
                                 default = nil)
  if valid_602651 != nil:
    section.add "DeferMaintenanceIdentifier", valid_602651
  var valid_602652 = formData.getOrDefault("DeferMaintenanceStartTime")
  valid_602652 = validateParameter(valid_602652, JString, required = false,
                                 default = nil)
  if valid_602652 != nil:
    section.add "DeferMaintenanceStartTime", valid_602652
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_602653 = formData.getOrDefault("ClusterIdentifier")
  valid_602653 = validateParameter(valid_602653, JString, required = true,
                                 default = nil)
  if valid_602653 != nil:
    section.add "ClusterIdentifier", valid_602653
  var valid_602654 = formData.getOrDefault("DeferMaintenanceEndTime")
  valid_602654 = validateParameter(valid_602654, JString, required = false,
                                 default = nil)
  if valid_602654 != nil:
    section.add "DeferMaintenanceEndTime", valid_602654
  var valid_602655 = formData.getOrDefault("DeferMaintenance")
  valid_602655 = validateParameter(valid_602655, JBool, required = false, default = nil)
  if valid_602655 != nil:
    section.add "DeferMaintenance", valid_602655
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602656: Call_PostModifyClusterMaintenance_602638; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_602656.validator(path, query, header, formData, body)
  let scheme = call_602656.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602656.url(scheme.get, call_602656.host, call_602656.base,
                         call_602656.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602656, url, valid)

proc call*(call_602657: Call_PostModifyClusterMaintenance_602638;
          ClusterIdentifier: string; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceIdentifier: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenanceStartTime: string = "";
          DeferMaintenanceEndTime: string = ""; DeferMaintenance: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   Action: string (required)
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Version: string (required)
  var query_602658 = newJObject()
  var formData_602659 = newJObject()
  add(formData_602659, "DeferMaintenanceDuration",
      newJInt(DeferMaintenanceDuration))
  add(formData_602659, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_602658, "Action", newJString(Action))
  add(formData_602659, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(formData_602659, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_602659, "DeferMaintenanceEndTime",
      newJString(DeferMaintenanceEndTime))
  add(formData_602659, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_602658, "Version", newJString(Version))
  result = call_602657.call(nil, query_602658, nil, formData_602659, nil)

var postModifyClusterMaintenance* = Call_PostModifyClusterMaintenance_602638(
    name: "postModifyClusterMaintenance", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_PostModifyClusterMaintenance_602639, base: "/",
    url: url_PostModifyClusterMaintenance_602640,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterMaintenance_602617 = ref object of OpenApiRestCall_599352
proc url_GetModifyClusterMaintenance_602619(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterMaintenance_602618(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: JString (required)
  section = newJObject()
  var valid_602620 = query.getOrDefault("DeferMaintenanceStartTime")
  valid_602620 = validateParameter(valid_602620, JString, required = false,
                                 default = nil)
  if valid_602620 != nil:
    section.add "DeferMaintenanceStartTime", valid_602620
  var valid_602621 = query.getOrDefault("DeferMaintenanceDuration")
  valid_602621 = validateParameter(valid_602621, JInt, required = false, default = nil)
  if valid_602621 != nil:
    section.add "DeferMaintenanceDuration", valid_602621
  var valid_602622 = query.getOrDefault("DeferMaintenanceEndTime")
  valid_602622 = validateParameter(valid_602622, JString, required = false,
                                 default = nil)
  if valid_602622 != nil:
    section.add "DeferMaintenanceEndTime", valid_602622
  var valid_602623 = query.getOrDefault("DeferMaintenanceIdentifier")
  valid_602623 = validateParameter(valid_602623, JString, required = false,
                                 default = nil)
  if valid_602623 != nil:
    section.add "DeferMaintenanceIdentifier", valid_602623
  var valid_602624 = query.getOrDefault("DeferMaintenance")
  valid_602624 = validateParameter(valid_602624, JBool, required = false, default = nil)
  if valid_602624 != nil:
    section.add "DeferMaintenance", valid_602624
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602625 = query.getOrDefault("Action")
  valid_602625 = validateParameter(valid_602625, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_602625 != nil:
    section.add "Action", valid_602625
  var valid_602626 = query.getOrDefault("ClusterIdentifier")
  valid_602626 = validateParameter(valid_602626, JString, required = true,
                                 default = nil)
  if valid_602626 != nil:
    section.add "ClusterIdentifier", valid_602626
  var valid_602627 = query.getOrDefault("Version")
  valid_602627 = validateParameter(valid_602627, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602627 != nil:
    section.add "Version", valid_602627
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602628 = header.getOrDefault("X-Amz-Date")
  valid_602628 = validateParameter(valid_602628, JString, required = false,
                                 default = nil)
  if valid_602628 != nil:
    section.add "X-Amz-Date", valid_602628
  var valid_602629 = header.getOrDefault("X-Amz-Security-Token")
  valid_602629 = validateParameter(valid_602629, JString, required = false,
                                 default = nil)
  if valid_602629 != nil:
    section.add "X-Amz-Security-Token", valid_602629
  var valid_602630 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602630 = validateParameter(valid_602630, JString, required = false,
                                 default = nil)
  if valid_602630 != nil:
    section.add "X-Amz-Content-Sha256", valid_602630
  var valid_602631 = header.getOrDefault("X-Amz-Algorithm")
  valid_602631 = validateParameter(valid_602631, JString, required = false,
                                 default = nil)
  if valid_602631 != nil:
    section.add "X-Amz-Algorithm", valid_602631
  var valid_602632 = header.getOrDefault("X-Amz-Signature")
  valid_602632 = validateParameter(valid_602632, JString, required = false,
                                 default = nil)
  if valid_602632 != nil:
    section.add "X-Amz-Signature", valid_602632
  var valid_602633 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602633 = validateParameter(valid_602633, JString, required = false,
                                 default = nil)
  if valid_602633 != nil:
    section.add "X-Amz-SignedHeaders", valid_602633
  var valid_602634 = header.getOrDefault("X-Amz-Credential")
  valid_602634 = validateParameter(valid_602634, JString, required = false,
                                 default = nil)
  if valid_602634 != nil:
    section.add "X-Amz-Credential", valid_602634
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602635: Call_GetModifyClusterMaintenance_602617; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_602635.validator(path, query, header, formData, body)
  let scheme = call_602635.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602635.url(scheme.get, call_602635.host, call_602635.base,
                         call_602635.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602635, url, valid)

proc call*(call_602636: Call_GetModifyClusterMaintenance_602617;
          ClusterIdentifier: string; DeferMaintenanceStartTime: string = "";
          DeferMaintenanceDuration: int = 0; DeferMaintenanceEndTime: string = "";
          DeferMaintenanceIdentifier: string = ""; DeferMaintenance: bool = false;
          Action: string = "ModifyClusterMaintenance";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: string (required)
  var query_602637 = newJObject()
  add(query_602637, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(query_602637, "DeferMaintenanceDuration", newJInt(DeferMaintenanceDuration))
  add(query_602637, "DeferMaintenanceEndTime", newJString(DeferMaintenanceEndTime))
  add(query_602637, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_602637, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_602637, "Action", newJString(Action))
  add(query_602637, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602637, "Version", newJString(Version))
  result = call_602636.call(nil, query_602637, nil, nil, nil)

var getModifyClusterMaintenance* = Call_GetModifyClusterMaintenance_602617(
    name: "getModifyClusterMaintenance", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_GetModifyClusterMaintenance_602618, base: "/",
    url: url_GetModifyClusterMaintenance_602619,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterParameterGroup_602677 = ref object of OpenApiRestCall_599352
proc url_PostModifyClusterParameterGroup_602679(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterParameterGroup_602678(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602680 = query.getOrDefault("Action")
  valid_602680 = validateParameter(valid_602680, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_602680 != nil:
    section.add "Action", valid_602680
  var valid_602681 = query.getOrDefault("Version")
  valid_602681 = validateParameter(valid_602681, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602681 != nil:
    section.add "Version", valid_602681
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602682 = header.getOrDefault("X-Amz-Date")
  valid_602682 = validateParameter(valid_602682, JString, required = false,
                                 default = nil)
  if valid_602682 != nil:
    section.add "X-Amz-Date", valid_602682
  var valid_602683 = header.getOrDefault("X-Amz-Security-Token")
  valid_602683 = validateParameter(valid_602683, JString, required = false,
                                 default = nil)
  if valid_602683 != nil:
    section.add "X-Amz-Security-Token", valid_602683
  var valid_602684 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602684 = validateParameter(valid_602684, JString, required = false,
                                 default = nil)
  if valid_602684 != nil:
    section.add "X-Amz-Content-Sha256", valid_602684
  var valid_602685 = header.getOrDefault("X-Amz-Algorithm")
  valid_602685 = validateParameter(valid_602685, JString, required = false,
                                 default = nil)
  if valid_602685 != nil:
    section.add "X-Amz-Algorithm", valid_602685
  var valid_602686 = header.getOrDefault("X-Amz-Signature")
  valid_602686 = validateParameter(valid_602686, JString, required = false,
                                 default = nil)
  if valid_602686 != nil:
    section.add "X-Amz-Signature", valid_602686
  var valid_602687 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602687 = validateParameter(valid_602687, JString, required = false,
                                 default = nil)
  if valid_602687 != nil:
    section.add "X-Amz-SignedHeaders", valid_602687
  var valid_602688 = header.getOrDefault("X-Amz-Credential")
  valid_602688 = validateParameter(valid_602688, JString, required = false,
                                 default = nil)
  if valid_602688 != nil:
    section.add "X-Amz-Credential", valid_602688
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_602689 = formData.getOrDefault("ParameterGroupName")
  valid_602689 = validateParameter(valid_602689, JString, required = true,
                                 default = nil)
  if valid_602689 != nil:
    section.add "ParameterGroupName", valid_602689
  var valid_602690 = formData.getOrDefault("Parameters")
  valid_602690 = validateParameter(valid_602690, JArray, required = true, default = nil)
  if valid_602690 != nil:
    section.add "Parameters", valid_602690
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602691: Call_PostModifyClusterParameterGroup_602677;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602691.validator(path, query, header, formData, body)
  let scheme = call_602691.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602691.url(scheme.get, call_602691.host, call_602691.base,
                         call_602691.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602691, url, valid)

proc call*(call_602692: Call_PostModifyClusterParameterGroup_602677;
          ParameterGroupName: string; Parameters: JsonNode;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602693 = newJObject()
  var formData_602694 = newJObject()
  add(formData_602694, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    formData_602694.add "Parameters", Parameters
  add(query_602693, "Action", newJString(Action))
  add(query_602693, "Version", newJString(Version))
  result = call_602692.call(nil, query_602693, nil, formData_602694, nil)

var postModifyClusterParameterGroup* = Call_PostModifyClusterParameterGroup_602677(
    name: "postModifyClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_PostModifyClusterParameterGroup_602678, base: "/",
    url: url_PostModifyClusterParameterGroup_602679,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterParameterGroup_602660 = ref object of OpenApiRestCall_599352
proc url_GetModifyClusterParameterGroup_602662(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterParameterGroup_602661(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_602663 = query.getOrDefault("ParameterGroupName")
  valid_602663 = validateParameter(valid_602663, JString, required = true,
                                 default = nil)
  if valid_602663 != nil:
    section.add "ParameterGroupName", valid_602663
  var valid_602664 = query.getOrDefault("Parameters")
  valid_602664 = validateParameter(valid_602664, JArray, required = true, default = nil)
  if valid_602664 != nil:
    section.add "Parameters", valid_602664
  var valid_602665 = query.getOrDefault("Action")
  valid_602665 = validateParameter(valid_602665, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_602665 != nil:
    section.add "Action", valid_602665
  var valid_602666 = query.getOrDefault("Version")
  valid_602666 = validateParameter(valid_602666, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602666 != nil:
    section.add "Version", valid_602666
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602667 = header.getOrDefault("X-Amz-Date")
  valid_602667 = validateParameter(valid_602667, JString, required = false,
                                 default = nil)
  if valid_602667 != nil:
    section.add "X-Amz-Date", valid_602667
  var valid_602668 = header.getOrDefault("X-Amz-Security-Token")
  valid_602668 = validateParameter(valid_602668, JString, required = false,
                                 default = nil)
  if valid_602668 != nil:
    section.add "X-Amz-Security-Token", valid_602668
  var valid_602669 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602669 = validateParameter(valid_602669, JString, required = false,
                                 default = nil)
  if valid_602669 != nil:
    section.add "X-Amz-Content-Sha256", valid_602669
  var valid_602670 = header.getOrDefault("X-Amz-Algorithm")
  valid_602670 = validateParameter(valid_602670, JString, required = false,
                                 default = nil)
  if valid_602670 != nil:
    section.add "X-Amz-Algorithm", valid_602670
  var valid_602671 = header.getOrDefault("X-Amz-Signature")
  valid_602671 = validateParameter(valid_602671, JString, required = false,
                                 default = nil)
  if valid_602671 != nil:
    section.add "X-Amz-Signature", valid_602671
  var valid_602672 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602672 = validateParameter(valid_602672, JString, required = false,
                                 default = nil)
  if valid_602672 != nil:
    section.add "X-Amz-SignedHeaders", valid_602672
  var valid_602673 = header.getOrDefault("X-Amz-Credential")
  valid_602673 = validateParameter(valid_602673, JString, required = false,
                                 default = nil)
  if valid_602673 != nil:
    section.add "X-Amz-Credential", valid_602673
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602674: Call_GetModifyClusterParameterGroup_602660; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602674.validator(path, query, header, formData, body)
  let scheme = call_602674.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602674.url(scheme.get, call_602674.host, call_602674.base,
                         call_602674.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602674, url, valid)

proc call*(call_602675: Call_GetModifyClusterParameterGroup_602660;
          ParameterGroupName: string; Parameters: JsonNode;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_602676 = newJObject()
  add(query_602676, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    query_602676.add "Parameters", Parameters
  add(query_602676, "Action", newJString(Action))
  add(query_602676, "Version", newJString(Version))
  result = call_602675.call(nil, query_602676, nil, nil, nil)

var getModifyClusterParameterGroup* = Call_GetModifyClusterParameterGroup_602660(
    name: "getModifyClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_GetModifyClusterParameterGroup_602661, base: "/",
    url: url_GetModifyClusterParameterGroup_602662,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshot_602713 = ref object of OpenApiRestCall_599352
proc url_PostModifyClusterSnapshot_602715(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshot_602714(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602716 = query.getOrDefault("Action")
  valid_602716 = validateParameter(valid_602716, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_602716 != nil:
    section.add "Action", valid_602716
  var valid_602717 = query.getOrDefault("Version")
  valid_602717 = validateParameter(valid_602717, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602717 != nil:
    section.add "Version", valid_602717
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602718 = header.getOrDefault("X-Amz-Date")
  valid_602718 = validateParameter(valid_602718, JString, required = false,
                                 default = nil)
  if valid_602718 != nil:
    section.add "X-Amz-Date", valid_602718
  var valid_602719 = header.getOrDefault("X-Amz-Security-Token")
  valid_602719 = validateParameter(valid_602719, JString, required = false,
                                 default = nil)
  if valid_602719 != nil:
    section.add "X-Amz-Security-Token", valid_602719
  var valid_602720 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602720 = validateParameter(valid_602720, JString, required = false,
                                 default = nil)
  if valid_602720 != nil:
    section.add "X-Amz-Content-Sha256", valid_602720
  var valid_602721 = header.getOrDefault("X-Amz-Algorithm")
  valid_602721 = validateParameter(valid_602721, JString, required = false,
                                 default = nil)
  if valid_602721 != nil:
    section.add "X-Amz-Algorithm", valid_602721
  var valid_602722 = header.getOrDefault("X-Amz-Signature")
  valid_602722 = validateParameter(valid_602722, JString, required = false,
                                 default = nil)
  if valid_602722 != nil:
    section.add "X-Amz-Signature", valid_602722
  var valid_602723 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602723 = validateParameter(valid_602723, JString, required = false,
                                 default = nil)
  if valid_602723 != nil:
    section.add "X-Amz-SignedHeaders", valid_602723
  var valid_602724 = header.getOrDefault("X-Amz-Credential")
  valid_602724 = validateParameter(valid_602724, JString, required = false,
                                 default = nil)
  if valid_602724 != nil:
    section.add "X-Amz-Credential", valid_602724
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_602725 = formData.getOrDefault("Force")
  valid_602725 = validateParameter(valid_602725, JBool, required = false, default = nil)
  if valid_602725 != nil:
    section.add "Force", valid_602725
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_602726 = formData.getOrDefault("SnapshotIdentifier")
  valid_602726 = validateParameter(valid_602726, JString, required = true,
                                 default = nil)
  if valid_602726 != nil:
    section.add "SnapshotIdentifier", valid_602726
  var valid_602727 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602727 = validateParameter(valid_602727, JInt, required = false, default = nil)
  if valid_602727 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602727
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602728: Call_PostModifyClusterSnapshot_602713; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_602728.validator(path, query, header, formData, body)
  let scheme = call_602728.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602728.url(scheme.get, call_602728.host, call_602728.base,
                         call_602728.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602728, url, valid)

proc call*(call_602729: Call_PostModifyClusterSnapshot_602713;
          SnapshotIdentifier: string; Force: bool = false;
          Action: string = "ModifyClusterSnapshot";
          ManualSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Version: string (required)
  var query_602730 = newJObject()
  var formData_602731 = newJObject()
  add(formData_602731, "Force", newJBool(Force))
  add(query_602730, "Action", newJString(Action))
  add(formData_602731, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_602731, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_602730, "Version", newJString(Version))
  result = call_602729.call(nil, query_602730, nil, formData_602731, nil)

var postModifyClusterSnapshot* = Call_PostModifyClusterSnapshot_602713(
    name: "postModifyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_PostModifyClusterSnapshot_602714, base: "/",
    url: url_PostModifyClusterSnapshot_602715,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshot_602695 = ref object of OpenApiRestCall_599352
proc url_GetModifyClusterSnapshot_602697(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshot_602696(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Version: JString (required)
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602698 = query.getOrDefault("Action")
  valid_602698 = validateParameter(valid_602698, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_602698 != nil:
    section.add "Action", valid_602698
  var valid_602699 = query.getOrDefault("SnapshotIdentifier")
  valid_602699 = validateParameter(valid_602699, JString, required = true,
                                 default = nil)
  if valid_602699 != nil:
    section.add "SnapshotIdentifier", valid_602699
  var valid_602700 = query.getOrDefault("Version")
  valid_602700 = validateParameter(valid_602700, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602700 != nil:
    section.add "Version", valid_602700
  var valid_602701 = query.getOrDefault("Force")
  valid_602701 = validateParameter(valid_602701, JBool, required = false, default = nil)
  if valid_602701 != nil:
    section.add "Force", valid_602701
  var valid_602702 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_602702 = validateParameter(valid_602702, JInt, required = false, default = nil)
  if valid_602702 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_602702
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602703 = header.getOrDefault("X-Amz-Date")
  valid_602703 = validateParameter(valid_602703, JString, required = false,
                                 default = nil)
  if valid_602703 != nil:
    section.add "X-Amz-Date", valid_602703
  var valid_602704 = header.getOrDefault("X-Amz-Security-Token")
  valid_602704 = validateParameter(valid_602704, JString, required = false,
                                 default = nil)
  if valid_602704 != nil:
    section.add "X-Amz-Security-Token", valid_602704
  var valid_602705 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602705 = validateParameter(valid_602705, JString, required = false,
                                 default = nil)
  if valid_602705 != nil:
    section.add "X-Amz-Content-Sha256", valid_602705
  var valid_602706 = header.getOrDefault("X-Amz-Algorithm")
  valid_602706 = validateParameter(valid_602706, JString, required = false,
                                 default = nil)
  if valid_602706 != nil:
    section.add "X-Amz-Algorithm", valid_602706
  var valid_602707 = header.getOrDefault("X-Amz-Signature")
  valid_602707 = validateParameter(valid_602707, JString, required = false,
                                 default = nil)
  if valid_602707 != nil:
    section.add "X-Amz-Signature", valid_602707
  var valid_602708 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602708 = validateParameter(valid_602708, JString, required = false,
                                 default = nil)
  if valid_602708 != nil:
    section.add "X-Amz-SignedHeaders", valid_602708
  var valid_602709 = header.getOrDefault("X-Amz-Credential")
  valid_602709 = validateParameter(valid_602709, JString, required = false,
                                 default = nil)
  if valid_602709 != nil:
    section.add "X-Amz-Credential", valid_602709
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602710: Call_GetModifyClusterSnapshot_602695; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_602710.validator(path, query, header, formData, body)
  let scheme = call_602710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602710.url(scheme.get, call_602710.host, call_602710.base,
                         call_602710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602710, url, valid)

proc call*(call_602711: Call_GetModifyClusterSnapshot_602695;
          SnapshotIdentifier: string; Action: string = "ModifyClusterSnapshot";
          Version: string = "2012-12-01"; Force: bool = false;
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Version: string (required)
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_602712 = newJObject()
  add(query_602712, "Action", newJString(Action))
  add(query_602712, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_602712, "Version", newJString(Version))
  add(query_602712, "Force", newJBool(Force))
  add(query_602712, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_602711.call(nil, query_602712, nil, nil, nil)

var getModifyClusterSnapshot* = Call_GetModifyClusterSnapshot_602695(
    name: "getModifyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_GetModifyClusterSnapshot_602696, base: "/",
    url: url_GetModifyClusterSnapshot_602697, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshotSchedule_602750 = ref object of OpenApiRestCall_599352
proc url_PostModifyClusterSnapshotSchedule_602752(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSnapshotSchedule_602751(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602753 = query.getOrDefault("Action")
  valid_602753 = validateParameter(valid_602753, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_602753 != nil:
    section.add "Action", valid_602753
  var valid_602754 = query.getOrDefault("Version")
  valid_602754 = validateParameter(valid_602754, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602754 != nil:
    section.add "Version", valid_602754
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602755 = header.getOrDefault("X-Amz-Date")
  valid_602755 = validateParameter(valid_602755, JString, required = false,
                                 default = nil)
  if valid_602755 != nil:
    section.add "X-Amz-Date", valid_602755
  var valid_602756 = header.getOrDefault("X-Amz-Security-Token")
  valid_602756 = validateParameter(valid_602756, JString, required = false,
                                 default = nil)
  if valid_602756 != nil:
    section.add "X-Amz-Security-Token", valid_602756
  var valid_602757 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602757 = validateParameter(valid_602757, JString, required = false,
                                 default = nil)
  if valid_602757 != nil:
    section.add "X-Amz-Content-Sha256", valid_602757
  var valid_602758 = header.getOrDefault("X-Amz-Algorithm")
  valid_602758 = validateParameter(valid_602758, JString, required = false,
                                 default = nil)
  if valid_602758 != nil:
    section.add "X-Amz-Algorithm", valid_602758
  var valid_602759 = header.getOrDefault("X-Amz-Signature")
  valid_602759 = validateParameter(valid_602759, JString, required = false,
                                 default = nil)
  if valid_602759 != nil:
    section.add "X-Amz-Signature", valid_602759
  var valid_602760 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602760 = validateParameter(valid_602760, JString, required = false,
                                 default = nil)
  if valid_602760 != nil:
    section.add "X-Amz-SignedHeaders", valid_602760
  var valid_602761 = header.getOrDefault("X-Amz-Credential")
  valid_602761 = validateParameter(valid_602761, JString, required = false,
                                 default = nil)
  if valid_602761 != nil:
    section.add "X-Amz-Credential", valid_602761
  result.add "header", section
  ## parameters in `formData` object:
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  section = newJObject()
  var valid_602762 = formData.getOrDefault("DisassociateSchedule")
  valid_602762 = validateParameter(valid_602762, JBool, required = false, default = nil)
  if valid_602762 != nil:
    section.add "DisassociateSchedule", valid_602762
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_602763 = formData.getOrDefault("ClusterIdentifier")
  valid_602763 = validateParameter(valid_602763, JString, required = true,
                                 default = nil)
  if valid_602763 != nil:
    section.add "ClusterIdentifier", valid_602763
  var valid_602764 = formData.getOrDefault("ScheduleIdentifier")
  valid_602764 = validateParameter(valid_602764, JString, required = false,
                                 default = nil)
  if valid_602764 != nil:
    section.add "ScheduleIdentifier", valid_602764
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602765: Call_PostModifyClusterSnapshotSchedule_602750;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_602765.validator(path, query, header, formData, body)
  let scheme = call_602765.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602765.url(scheme.get, call_602765.host, call_602765.base,
                         call_602765.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602765, url, valid)

proc call*(call_602766: Call_PostModifyClusterSnapshotSchedule_602750;
          ClusterIdentifier: string; DisassociateSchedule: bool = false;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Version: string (required)
  var query_602767 = newJObject()
  var formData_602768 = newJObject()
  add(formData_602768, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_602767, "Action", newJString(Action))
  add(formData_602768, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_602768, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_602767, "Version", newJString(Version))
  result = call_602766.call(nil, query_602767, nil, formData_602768, nil)

var postModifyClusterSnapshotSchedule* = Call_PostModifyClusterSnapshotSchedule_602750(
    name: "postModifyClusterSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_PostModifyClusterSnapshotSchedule_602751, base: "/",
    url: url_PostModifyClusterSnapshotSchedule_602752,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshotSchedule_602732 = ref object of OpenApiRestCall_599352
proc url_GetModifyClusterSnapshotSchedule_602734(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSnapshotSchedule_602733(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602735 = query.getOrDefault("Action")
  valid_602735 = validateParameter(valid_602735, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_602735 != nil:
    section.add "Action", valid_602735
  var valid_602736 = query.getOrDefault("ClusterIdentifier")
  valid_602736 = validateParameter(valid_602736, JString, required = true,
                                 default = nil)
  if valid_602736 != nil:
    section.add "ClusterIdentifier", valid_602736
  var valid_602737 = query.getOrDefault("ScheduleIdentifier")
  valid_602737 = validateParameter(valid_602737, JString, required = false,
                                 default = nil)
  if valid_602737 != nil:
    section.add "ScheduleIdentifier", valid_602737
  var valid_602738 = query.getOrDefault("DisassociateSchedule")
  valid_602738 = validateParameter(valid_602738, JBool, required = false, default = nil)
  if valid_602738 != nil:
    section.add "DisassociateSchedule", valid_602738
  var valid_602739 = query.getOrDefault("Version")
  valid_602739 = validateParameter(valid_602739, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602739 != nil:
    section.add "Version", valid_602739
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602740 = header.getOrDefault("X-Amz-Date")
  valid_602740 = validateParameter(valid_602740, JString, required = false,
                                 default = nil)
  if valid_602740 != nil:
    section.add "X-Amz-Date", valid_602740
  var valid_602741 = header.getOrDefault("X-Amz-Security-Token")
  valid_602741 = validateParameter(valid_602741, JString, required = false,
                                 default = nil)
  if valid_602741 != nil:
    section.add "X-Amz-Security-Token", valid_602741
  var valid_602742 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602742 = validateParameter(valid_602742, JString, required = false,
                                 default = nil)
  if valid_602742 != nil:
    section.add "X-Amz-Content-Sha256", valid_602742
  var valid_602743 = header.getOrDefault("X-Amz-Algorithm")
  valid_602743 = validateParameter(valid_602743, JString, required = false,
                                 default = nil)
  if valid_602743 != nil:
    section.add "X-Amz-Algorithm", valid_602743
  var valid_602744 = header.getOrDefault("X-Amz-Signature")
  valid_602744 = validateParameter(valid_602744, JString, required = false,
                                 default = nil)
  if valid_602744 != nil:
    section.add "X-Amz-Signature", valid_602744
  var valid_602745 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602745 = validateParameter(valid_602745, JString, required = false,
                                 default = nil)
  if valid_602745 != nil:
    section.add "X-Amz-SignedHeaders", valid_602745
  var valid_602746 = header.getOrDefault("X-Amz-Credential")
  valid_602746 = validateParameter(valid_602746, JString, required = false,
                                 default = nil)
  if valid_602746 != nil:
    section.add "X-Amz-Credential", valid_602746
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602747: Call_GetModifyClusterSnapshotSchedule_602732;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_602747.validator(path, query, header, formData, body)
  let scheme = call_602747.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602747.url(scheme.get, call_602747.host, call_602747.base,
                         call_602747.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602747, url, valid)

proc call*(call_602748: Call_GetModifyClusterSnapshotSchedule_602732;
          ClusterIdentifier: string;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; DisassociateSchedule: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: string (required)
  var query_602749 = newJObject()
  add(query_602749, "Action", newJString(Action))
  add(query_602749, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602749, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_602749, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_602749, "Version", newJString(Version))
  result = call_602748.call(nil, query_602749, nil, nil, nil)

var getModifyClusterSnapshotSchedule* = Call_GetModifyClusterSnapshotSchedule_602732(
    name: "getModifyClusterSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_GetModifyClusterSnapshotSchedule_602733, base: "/",
    url: url_GetModifyClusterSnapshotSchedule_602734,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSubnetGroup_602787 = ref object of OpenApiRestCall_599352
proc url_PostModifyClusterSubnetGroup_602789(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyClusterSubnetGroup_602788(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602790 = query.getOrDefault("Action")
  valid_602790 = validateParameter(valid_602790, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_602790 != nil:
    section.add "Action", valid_602790
  var valid_602791 = query.getOrDefault("Version")
  valid_602791 = validateParameter(valid_602791, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602791 != nil:
    section.add "Version", valid_602791
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602792 = header.getOrDefault("X-Amz-Date")
  valid_602792 = validateParameter(valid_602792, JString, required = false,
                                 default = nil)
  if valid_602792 != nil:
    section.add "X-Amz-Date", valid_602792
  var valid_602793 = header.getOrDefault("X-Amz-Security-Token")
  valid_602793 = validateParameter(valid_602793, JString, required = false,
                                 default = nil)
  if valid_602793 != nil:
    section.add "X-Amz-Security-Token", valid_602793
  var valid_602794 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602794 = validateParameter(valid_602794, JString, required = false,
                                 default = nil)
  if valid_602794 != nil:
    section.add "X-Amz-Content-Sha256", valid_602794
  var valid_602795 = header.getOrDefault("X-Amz-Algorithm")
  valid_602795 = validateParameter(valid_602795, JString, required = false,
                                 default = nil)
  if valid_602795 != nil:
    section.add "X-Amz-Algorithm", valid_602795
  var valid_602796 = header.getOrDefault("X-Amz-Signature")
  valid_602796 = validateParameter(valid_602796, JString, required = false,
                                 default = nil)
  if valid_602796 != nil:
    section.add "X-Amz-Signature", valid_602796
  var valid_602797 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602797 = validateParameter(valid_602797, JString, required = false,
                                 default = nil)
  if valid_602797 != nil:
    section.add "X-Amz-SignedHeaders", valid_602797
  var valid_602798 = header.getOrDefault("X-Amz-Credential")
  valid_602798 = validateParameter(valid_602798, JString, required = false,
                                 default = nil)
  if valid_602798 != nil:
    section.add "X-Amz-Credential", valid_602798
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `SubnetIds` field"
  var valid_602799 = formData.getOrDefault("SubnetIds")
  valid_602799 = validateParameter(valid_602799, JArray, required = true, default = nil)
  if valid_602799 != nil:
    section.add "SubnetIds", valid_602799
  var valid_602800 = formData.getOrDefault("Description")
  valid_602800 = validateParameter(valid_602800, JString, required = false,
                                 default = nil)
  if valid_602800 != nil:
    section.add "Description", valid_602800
  var valid_602801 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_602801 = validateParameter(valid_602801, JString, required = true,
                                 default = nil)
  if valid_602801 != nil:
    section.add "ClusterSubnetGroupName", valid_602801
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602802: Call_PostModifyClusterSubnetGroup_602787; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_602802.validator(path, query, header, formData, body)
  let scheme = call_602802.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602802.url(scheme.get, call_602802.host, call_602802.base,
                         call_602802.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602802, url, valid)

proc call*(call_602803: Call_PostModifyClusterSubnetGroup_602787;
          SubnetIds: JsonNode; ClusterSubnetGroupName: string;
          Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"; Description: string = ""): Recallable =
  ## postModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  var query_602804 = newJObject()
  var formData_602805 = newJObject()
  if SubnetIds != nil:
    formData_602805.add "SubnetIds", SubnetIds
  add(query_602804, "Action", newJString(Action))
  add(query_602804, "Version", newJString(Version))
  add(formData_602805, "Description", newJString(Description))
  add(formData_602805, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_602803.call(nil, query_602804, nil, formData_602805, nil)

var postModifyClusterSubnetGroup* = Call_PostModifyClusterSubnetGroup_602787(
    name: "postModifyClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_PostModifyClusterSubnetGroup_602788, base: "/",
    url: url_PostModifyClusterSubnetGroup_602789,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSubnetGroup_602769 = ref object of OpenApiRestCall_599352
proc url_GetModifyClusterSubnetGroup_602771(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyClusterSubnetGroup_602770(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   Action: JString (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_602772 = query.getOrDefault("ClusterSubnetGroupName")
  valid_602772 = validateParameter(valid_602772, JString, required = true,
                                 default = nil)
  if valid_602772 != nil:
    section.add "ClusterSubnetGroupName", valid_602772
  var valid_602773 = query.getOrDefault("Description")
  valid_602773 = validateParameter(valid_602773, JString, required = false,
                                 default = nil)
  if valid_602773 != nil:
    section.add "Description", valid_602773
  var valid_602774 = query.getOrDefault("Action")
  valid_602774 = validateParameter(valid_602774, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_602774 != nil:
    section.add "Action", valid_602774
  var valid_602775 = query.getOrDefault("SubnetIds")
  valid_602775 = validateParameter(valid_602775, JArray, required = true, default = nil)
  if valid_602775 != nil:
    section.add "SubnetIds", valid_602775
  var valid_602776 = query.getOrDefault("Version")
  valid_602776 = validateParameter(valid_602776, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602776 != nil:
    section.add "Version", valid_602776
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602777 = header.getOrDefault("X-Amz-Date")
  valid_602777 = validateParameter(valid_602777, JString, required = false,
                                 default = nil)
  if valid_602777 != nil:
    section.add "X-Amz-Date", valid_602777
  var valid_602778 = header.getOrDefault("X-Amz-Security-Token")
  valid_602778 = validateParameter(valid_602778, JString, required = false,
                                 default = nil)
  if valid_602778 != nil:
    section.add "X-Amz-Security-Token", valid_602778
  var valid_602779 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602779 = validateParameter(valid_602779, JString, required = false,
                                 default = nil)
  if valid_602779 != nil:
    section.add "X-Amz-Content-Sha256", valid_602779
  var valid_602780 = header.getOrDefault("X-Amz-Algorithm")
  valid_602780 = validateParameter(valid_602780, JString, required = false,
                                 default = nil)
  if valid_602780 != nil:
    section.add "X-Amz-Algorithm", valid_602780
  var valid_602781 = header.getOrDefault("X-Amz-Signature")
  valid_602781 = validateParameter(valid_602781, JString, required = false,
                                 default = nil)
  if valid_602781 != nil:
    section.add "X-Amz-Signature", valid_602781
  var valid_602782 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602782 = validateParameter(valid_602782, JString, required = false,
                                 default = nil)
  if valid_602782 != nil:
    section.add "X-Amz-SignedHeaders", valid_602782
  var valid_602783 = header.getOrDefault("X-Amz-Credential")
  valid_602783 = validateParameter(valid_602783, JString, required = false,
                                 default = nil)
  if valid_602783 != nil:
    section.add "X-Amz-Credential", valid_602783
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602784: Call_GetModifyClusterSubnetGroup_602769; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_602784.validator(path, query, header, formData, body)
  let scheme = call_602784.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602784.url(scheme.get, call_602784.host, call_602784.base,
                         call_602784.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602784, url, valid)

proc call*(call_602785: Call_GetModifyClusterSubnetGroup_602769;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Description: string = ""; Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   Action: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Version: string (required)
  var query_602786 = newJObject()
  add(query_602786, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_602786, "Description", newJString(Description))
  add(query_602786, "Action", newJString(Action))
  if SubnetIds != nil:
    query_602786.add "SubnetIds", SubnetIds
  add(query_602786, "Version", newJString(Version))
  result = call_602785.call(nil, query_602786, nil, nil, nil)

var getModifyClusterSubnetGroup* = Call_GetModifyClusterSubnetGroup_602769(
    name: "getModifyClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_GetModifyClusterSubnetGroup_602770, base: "/",
    url: url_GetModifyClusterSubnetGroup_602771,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyEventSubscription_602828 = ref object of OpenApiRestCall_599352
proc url_PostModifyEventSubscription_602830(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyEventSubscription_602829(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602831 = query.getOrDefault("Action")
  valid_602831 = validateParameter(valid_602831, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_602831 != nil:
    section.add "Action", valid_602831
  var valid_602832 = query.getOrDefault("Version")
  valid_602832 = validateParameter(valid_602832, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602832 != nil:
    section.add "Version", valid_602832
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602833 = header.getOrDefault("X-Amz-Date")
  valid_602833 = validateParameter(valid_602833, JString, required = false,
                                 default = nil)
  if valid_602833 != nil:
    section.add "X-Amz-Date", valid_602833
  var valid_602834 = header.getOrDefault("X-Amz-Security-Token")
  valid_602834 = validateParameter(valid_602834, JString, required = false,
                                 default = nil)
  if valid_602834 != nil:
    section.add "X-Amz-Security-Token", valid_602834
  var valid_602835 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602835 = validateParameter(valid_602835, JString, required = false,
                                 default = nil)
  if valid_602835 != nil:
    section.add "X-Amz-Content-Sha256", valid_602835
  var valid_602836 = header.getOrDefault("X-Amz-Algorithm")
  valid_602836 = validateParameter(valid_602836, JString, required = false,
                                 default = nil)
  if valid_602836 != nil:
    section.add "X-Amz-Algorithm", valid_602836
  var valid_602837 = header.getOrDefault("X-Amz-Signature")
  valid_602837 = validateParameter(valid_602837, JString, required = false,
                                 default = nil)
  if valid_602837 != nil:
    section.add "X-Amz-Signature", valid_602837
  var valid_602838 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602838 = validateParameter(valid_602838, JString, required = false,
                                 default = nil)
  if valid_602838 != nil:
    section.add "X-Amz-SignedHeaders", valid_602838
  var valid_602839 = header.getOrDefault("X-Amz-Credential")
  valid_602839 = validateParameter(valid_602839, JString, required = false,
                                 default = nil)
  if valid_602839 != nil:
    section.add "X-Amz-Credential", valid_602839
  result.add "header", section
  ## parameters in `formData` object:
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  section = newJObject()
  var valid_602840 = formData.getOrDefault("Enabled")
  valid_602840 = validateParameter(valid_602840, JBool, required = false, default = nil)
  if valid_602840 != nil:
    section.add "Enabled", valid_602840
  var valid_602841 = formData.getOrDefault("EventCategories")
  valid_602841 = validateParameter(valid_602841, JArray, required = false,
                                 default = nil)
  if valid_602841 != nil:
    section.add "EventCategories", valid_602841
  var valid_602842 = formData.getOrDefault("SnsTopicArn")
  valid_602842 = validateParameter(valid_602842, JString, required = false,
                                 default = nil)
  if valid_602842 != nil:
    section.add "SnsTopicArn", valid_602842
  var valid_602843 = formData.getOrDefault("Severity")
  valid_602843 = validateParameter(valid_602843, JString, required = false,
                                 default = nil)
  if valid_602843 != nil:
    section.add "Severity", valid_602843
  var valid_602844 = formData.getOrDefault("SourceIds")
  valid_602844 = validateParameter(valid_602844, JArray, required = false,
                                 default = nil)
  if valid_602844 != nil:
    section.add "SourceIds", valid_602844
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_602845 = formData.getOrDefault("SubscriptionName")
  valid_602845 = validateParameter(valid_602845, JString, required = true,
                                 default = nil)
  if valid_602845 != nil:
    section.add "SubscriptionName", valid_602845
  var valid_602846 = formData.getOrDefault("SourceType")
  valid_602846 = validateParameter(valid_602846, JString, required = false,
                                 default = nil)
  if valid_602846 != nil:
    section.add "SourceType", valid_602846
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602847: Call_PostModifyEventSubscription_602828; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_602847.validator(path, query, header, formData, body)
  let scheme = call_602847.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602847.url(scheme.get, call_602847.host, call_602847.base,
                         call_602847.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602847, url, valid)

proc call*(call_602848: Call_PostModifyEventSubscription_602828;
          SubscriptionName: string; Enabled: bool = false;
          EventCategories: JsonNode = nil; SnsTopicArn: string = "";
          Severity: string = ""; SourceIds: JsonNode = nil;
          Action: string = "ModifyEventSubscription";
          Version: string = "2012-12-01"; SourceType: string = ""): Recallable =
  ## postModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  var query_602849 = newJObject()
  var formData_602850 = newJObject()
  add(formData_602850, "Enabled", newJBool(Enabled))
  if EventCategories != nil:
    formData_602850.add "EventCategories", EventCategories
  add(formData_602850, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_602850, "Severity", newJString(Severity))
  if SourceIds != nil:
    formData_602850.add "SourceIds", SourceIds
  add(formData_602850, "SubscriptionName", newJString(SubscriptionName))
  add(query_602849, "Action", newJString(Action))
  add(query_602849, "Version", newJString(Version))
  add(formData_602850, "SourceType", newJString(SourceType))
  result = call_602848.call(nil, query_602849, nil, formData_602850, nil)

var postModifyEventSubscription* = Call_PostModifyEventSubscription_602828(
    name: "postModifyEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_PostModifyEventSubscription_602829, base: "/",
    url: url_PostModifyEventSubscription_602830,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyEventSubscription_602806 = ref object of OpenApiRestCall_599352
proc url_GetModifyEventSubscription_602808(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyEventSubscription_602807(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Action: JString (required)
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_602809 = query.getOrDefault("SourceType")
  valid_602809 = validateParameter(valid_602809, JString, required = false,
                                 default = nil)
  if valid_602809 != nil:
    section.add "SourceType", valid_602809
  var valid_602810 = query.getOrDefault("SourceIds")
  valid_602810 = validateParameter(valid_602810, JArray, required = false,
                                 default = nil)
  if valid_602810 != nil:
    section.add "SourceIds", valid_602810
  var valid_602811 = query.getOrDefault("Enabled")
  valid_602811 = validateParameter(valid_602811, JBool, required = false, default = nil)
  if valid_602811 != nil:
    section.add "Enabled", valid_602811
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602812 = query.getOrDefault("Action")
  valid_602812 = validateParameter(valid_602812, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_602812 != nil:
    section.add "Action", valid_602812
  var valid_602813 = query.getOrDefault("SnsTopicArn")
  valid_602813 = validateParameter(valid_602813, JString, required = false,
                                 default = nil)
  if valid_602813 != nil:
    section.add "SnsTopicArn", valid_602813
  var valid_602814 = query.getOrDefault("EventCategories")
  valid_602814 = validateParameter(valid_602814, JArray, required = false,
                                 default = nil)
  if valid_602814 != nil:
    section.add "EventCategories", valid_602814
  var valid_602815 = query.getOrDefault("SubscriptionName")
  valid_602815 = validateParameter(valid_602815, JString, required = true,
                                 default = nil)
  if valid_602815 != nil:
    section.add "SubscriptionName", valid_602815
  var valid_602816 = query.getOrDefault("Severity")
  valid_602816 = validateParameter(valid_602816, JString, required = false,
                                 default = nil)
  if valid_602816 != nil:
    section.add "Severity", valid_602816
  var valid_602817 = query.getOrDefault("Version")
  valid_602817 = validateParameter(valid_602817, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602817 != nil:
    section.add "Version", valid_602817
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602818 = header.getOrDefault("X-Amz-Date")
  valid_602818 = validateParameter(valid_602818, JString, required = false,
                                 default = nil)
  if valid_602818 != nil:
    section.add "X-Amz-Date", valid_602818
  var valid_602819 = header.getOrDefault("X-Amz-Security-Token")
  valid_602819 = validateParameter(valid_602819, JString, required = false,
                                 default = nil)
  if valid_602819 != nil:
    section.add "X-Amz-Security-Token", valid_602819
  var valid_602820 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602820 = validateParameter(valid_602820, JString, required = false,
                                 default = nil)
  if valid_602820 != nil:
    section.add "X-Amz-Content-Sha256", valid_602820
  var valid_602821 = header.getOrDefault("X-Amz-Algorithm")
  valid_602821 = validateParameter(valid_602821, JString, required = false,
                                 default = nil)
  if valid_602821 != nil:
    section.add "X-Amz-Algorithm", valid_602821
  var valid_602822 = header.getOrDefault("X-Amz-Signature")
  valid_602822 = validateParameter(valid_602822, JString, required = false,
                                 default = nil)
  if valid_602822 != nil:
    section.add "X-Amz-Signature", valid_602822
  var valid_602823 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602823 = validateParameter(valid_602823, JString, required = false,
                                 default = nil)
  if valid_602823 != nil:
    section.add "X-Amz-SignedHeaders", valid_602823
  var valid_602824 = header.getOrDefault("X-Amz-Credential")
  valid_602824 = validateParameter(valid_602824, JString, required = false,
                                 default = nil)
  if valid_602824 != nil:
    section.add "X-Amz-Credential", valid_602824
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602825: Call_GetModifyEventSubscription_602806; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_602825.validator(path, query, header, formData, body)
  let scheme = call_602825.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602825.url(scheme.get, call_602825.host, call_602825.base,
                         call_602825.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602825, url, valid)

proc call*(call_602826: Call_GetModifyEventSubscription_602806;
          SubscriptionName: string; SourceType: string = "";
          SourceIds: JsonNode = nil; Enabled: bool = false;
          Action: string = "ModifyEventSubscription"; SnsTopicArn: string = "";
          EventCategories: JsonNode = nil; Severity: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Action: string (required)
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   Version: string (required)
  var query_602827 = newJObject()
  add(query_602827, "SourceType", newJString(SourceType))
  if SourceIds != nil:
    query_602827.add "SourceIds", SourceIds
  add(query_602827, "Enabled", newJBool(Enabled))
  add(query_602827, "Action", newJString(Action))
  add(query_602827, "SnsTopicArn", newJString(SnsTopicArn))
  if EventCategories != nil:
    query_602827.add "EventCategories", EventCategories
  add(query_602827, "SubscriptionName", newJString(SubscriptionName))
  add(query_602827, "Severity", newJString(Severity))
  add(query_602827, "Version", newJString(Version))
  result = call_602826.call(nil, query_602827, nil, nil, nil)

var getModifyEventSubscription* = Call_GetModifyEventSubscription_602806(
    name: "getModifyEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_GetModifyEventSubscription_602807, base: "/",
    url: url_GetModifyEventSubscription_602808,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyScheduledAction_602874 = ref object of OpenApiRestCall_599352
proc url_PostModifyScheduledAction_602876(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifyScheduledAction_602875(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modify a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602877 = query.getOrDefault("Action")
  valid_602877 = validateParameter(valid_602877, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_602877 != nil:
    section.add "Action", valid_602877
  var valid_602878 = query.getOrDefault("Version")
  valid_602878 = validateParameter(valid_602878, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602878 != nil:
    section.add "Version", valid_602878
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602879 = header.getOrDefault("X-Amz-Date")
  valid_602879 = validateParameter(valid_602879, JString, required = false,
                                 default = nil)
  if valid_602879 != nil:
    section.add "X-Amz-Date", valid_602879
  var valid_602880 = header.getOrDefault("X-Amz-Security-Token")
  valid_602880 = validateParameter(valid_602880, JString, required = false,
                                 default = nil)
  if valid_602880 != nil:
    section.add "X-Amz-Security-Token", valid_602880
  var valid_602881 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602881 = validateParameter(valid_602881, JString, required = false,
                                 default = nil)
  if valid_602881 != nil:
    section.add "X-Amz-Content-Sha256", valid_602881
  var valid_602882 = header.getOrDefault("X-Amz-Algorithm")
  valid_602882 = validateParameter(valid_602882, JString, required = false,
                                 default = nil)
  if valid_602882 != nil:
    section.add "X-Amz-Algorithm", valid_602882
  var valid_602883 = header.getOrDefault("X-Amz-Signature")
  valid_602883 = validateParameter(valid_602883, JString, required = false,
                                 default = nil)
  if valid_602883 != nil:
    section.add "X-Amz-Signature", valid_602883
  var valid_602884 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602884 = validateParameter(valid_602884, JString, required = false,
                                 default = nil)
  if valid_602884 != nil:
    section.add "X-Amz-SignedHeaders", valid_602884
  var valid_602885 = header.getOrDefault("X-Amz-Credential")
  valid_602885 = validateParameter(valid_602885, JString, required = false,
                                 default = nil)
  if valid_602885 != nil:
    section.add "X-Amz-Credential", valid_602885
  result.add "header", section
  ## parameters in `formData` object:
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  section = newJObject()
  var valid_602886 = formData.getOrDefault("Schedule")
  valid_602886 = validateParameter(valid_602886, JString, required = false,
                                 default = nil)
  if valid_602886 != nil:
    section.add "Schedule", valid_602886
  var valid_602887 = formData.getOrDefault("ScheduledActionDescription")
  valid_602887 = validateParameter(valid_602887, JString, required = false,
                                 default = nil)
  if valid_602887 != nil:
    section.add "ScheduledActionDescription", valid_602887
  var valid_602888 = formData.getOrDefault("TargetAction.ResizeCluster")
  valid_602888 = validateParameter(valid_602888, JString, required = false,
                                 default = nil)
  if valid_602888 != nil:
    section.add "TargetAction.ResizeCluster", valid_602888
  var valid_602889 = formData.getOrDefault("StartTime")
  valid_602889 = validateParameter(valid_602889, JString, required = false,
                                 default = nil)
  if valid_602889 != nil:
    section.add "StartTime", valid_602889
  assert formData != nil, "formData argument is necessary due to required `ScheduledActionName` field"
  var valid_602890 = formData.getOrDefault("ScheduledActionName")
  valid_602890 = validateParameter(valid_602890, JString, required = true,
                                 default = nil)
  if valid_602890 != nil:
    section.add "ScheduledActionName", valid_602890
  var valid_602891 = formData.getOrDefault("Enable")
  valid_602891 = validateParameter(valid_602891, JBool, required = false, default = nil)
  if valid_602891 != nil:
    section.add "Enable", valid_602891
  var valid_602892 = formData.getOrDefault("IamRole")
  valid_602892 = validateParameter(valid_602892, JString, required = false,
                                 default = nil)
  if valid_602892 != nil:
    section.add "IamRole", valid_602892
  var valid_602893 = formData.getOrDefault("EndTime")
  valid_602893 = validateParameter(valid_602893, JString, required = false,
                                 default = nil)
  if valid_602893 != nil:
    section.add "EndTime", valid_602893
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602894: Call_PostModifyScheduledAction_602874; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modify a scheduled action. 
  ## 
  let valid = call_602894.validator(path, query, header, formData, body)
  let scheme = call_602894.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602894.url(scheme.get, call_602894.host, call_602894.base,
                         call_602894.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602894, url, valid)

proc call*(call_602895: Call_PostModifyScheduledAction_602874;
          ScheduledActionName: string; Schedule: string = "";
          ScheduledActionDescription: string = "";
          TargetActionResizeCluster: string = ""; StartTime: string = "";
          Action: string = "ModifyScheduledAction"; Enable: bool = false;
          IamRole: string = ""; EndTime: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyScheduledAction
  ## Modify a scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Action: string (required)
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  var query_602896 = newJObject()
  var formData_602897 = newJObject()
  add(formData_602897, "Schedule", newJString(Schedule))
  add(formData_602897, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(formData_602897, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  add(formData_602897, "StartTime", newJString(StartTime))
  add(query_602896, "Action", newJString(Action))
  add(formData_602897, "ScheduledActionName", newJString(ScheduledActionName))
  add(formData_602897, "Enable", newJBool(Enable))
  add(formData_602897, "IamRole", newJString(IamRole))
  add(formData_602897, "EndTime", newJString(EndTime))
  add(query_602896, "Version", newJString(Version))
  result = call_602895.call(nil, query_602896, nil, formData_602897, nil)

var postModifyScheduledAction* = Call_PostModifyScheduledAction_602874(
    name: "postModifyScheduledAction", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_PostModifyScheduledAction_602875, base: "/",
    url: url_PostModifyScheduledAction_602876,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyScheduledAction_602851 = ref object of OpenApiRestCall_599352
proc url_GetModifyScheduledAction_602853(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifyScheduledAction_602852(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modify a scheduled action. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Schedule: JString
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionName: JString (required)
  ##                      : The name of the scheduled action to modify. 
  ##   StartTime: JString
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: JString
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: JBool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   Action: JString (required)
  ##   EndTime: JString
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: JString (required)
  ##   ScheduledActionDescription: JString
  ##                             : A modified description of the scheduled action. 
  ##   TargetAction.ResizeCluster: JString
  ##                             : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  section = newJObject()
  var valid_602854 = query.getOrDefault("Schedule")
  valid_602854 = validateParameter(valid_602854, JString, required = false,
                                 default = nil)
  if valid_602854 != nil:
    section.add "Schedule", valid_602854
  assert query != nil, "query argument is necessary due to required `ScheduledActionName` field"
  var valid_602855 = query.getOrDefault("ScheduledActionName")
  valid_602855 = validateParameter(valid_602855, JString, required = true,
                                 default = nil)
  if valid_602855 != nil:
    section.add "ScheduledActionName", valid_602855
  var valid_602856 = query.getOrDefault("StartTime")
  valid_602856 = validateParameter(valid_602856, JString, required = false,
                                 default = nil)
  if valid_602856 != nil:
    section.add "StartTime", valid_602856
  var valid_602857 = query.getOrDefault("IamRole")
  valid_602857 = validateParameter(valid_602857, JString, required = false,
                                 default = nil)
  if valid_602857 != nil:
    section.add "IamRole", valid_602857
  var valid_602858 = query.getOrDefault("Enable")
  valid_602858 = validateParameter(valid_602858, JBool, required = false, default = nil)
  if valid_602858 != nil:
    section.add "Enable", valid_602858
  var valid_602859 = query.getOrDefault("Action")
  valid_602859 = validateParameter(valid_602859, JString, required = true,
                                 default = newJString("ModifyScheduledAction"))
  if valid_602859 != nil:
    section.add "Action", valid_602859
  var valid_602860 = query.getOrDefault("EndTime")
  valid_602860 = validateParameter(valid_602860, JString, required = false,
                                 default = nil)
  if valid_602860 != nil:
    section.add "EndTime", valid_602860
  var valid_602861 = query.getOrDefault("Version")
  valid_602861 = validateParameter(valid_602861, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602861 != nil:
    section.add "Version", valid_602861
  var valid_602862 = query.getOrDefault("ScheduledActionDescription")
  valid_602862 = validateParameter(valid_602862, JString, required = false,
                                 default = nil)
  if valid_602862 != nil:
    section.add "ScheduledActionDescription", valid_602862
  var valid_602863 = query.getOrDefault("TargetAction.ResizeCluster")
  valid_602863 = validateParameter(valid_602863, JString, required = false,
                                 default = nil)
  if valid_602863 != nil:
    section.add "TargetAction.ResizeCluster", valid_602863
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602864 = header.getOrDefault("X-Amz-Date")
  valid_602864 = validateParameter(valid_602864, JString, required = false,
                                 default = nil)
  if valid_602864 != nil:
    section.add "X-Amz-Date", valid_602864
  var valid_602865 = header.getOrDefault("X-Amz-Security-Token")
  valid_602865 = validateParameter(valid_602865, JString, required = false,
                                 default = nil)
  if valid_602865 != nil:
    section.add "X-Amz-Security-Token", valid_602865
  var valid_602866 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602866 = validateParameter(valid_602866, JString, required = false,
                                 default = nil)
  if valid_602866 != nil:
    section.add "X-Amz-Content-Sha256", valid_602866
  var valid_602867 = header.getOrDefault("X-Amz-Algorithm")
  valid_602867 = validateParameter(valid_602867, JString, required = false,
                                 default = nil)
  if valid_602867 != nil:
    section.add "X-Amz-Algorithm", valid_602867
  var valid_602868 = header.getOrDefault("X-Amz-Signature")
  valid_602868 = validateParameter(valid_602868, JString, required = false,
                                 default = nil)
  if valid_602868 != nil:
    section.add "X-Amz-Signature", valid_602868
  var valid_602869 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602869 = validateParameter(valid_602869, JString, required = false,
                                 default = nil)
  if valid_602869 != nil:
    section.add "X-Amz-SignedHeaders", valid_602869
  var valid_602870 = header.getOrDefault("X-Amz-Credential")
  valid_602870 = validateParameter(valid_602870, JString, required = false,
                                 default = nil)
  if valid_602870 != nil:
    section.add "X-Amz-Credential", valid_602870
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602871: Call_GetModifyScheduledAction_602851; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modify a scheduled action. 
  ## 
  let valid = call_602871.validator(path, query, header, formData, body)
  let scheme = call_602871.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602871.url(scheme.get, call_602871.host, call_602871.base,
                         call_602871.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602871, url, valid)

proc call*(call_602872: Call_GetModifyScheduledAction_602851;
          ScheduledActionName: string; Schedule: string = ""; StartTime: string = "";
          IamRole: string = ""; Enable: bool = false;
          Action: string = "ModifyScheduledAction"; EndTime: string = "";
          Version: string = "2012-12-01"; ScheduledActionDescription: string = "";
          TargetActionResizeCluster: string = ""): Recallable =
  ## getModifyScheduledAction
  ## Modify a scheduled action. 
  ##   Schedule: string
  ##           : A modified schedule in either <code>at( )</code> or <code>cron( )</code> format. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   ScheduledActionName: string (required)
  ##                      : The name of the scheduled action to modify. 
  ##   StartTime: string
  ##            : A modified start time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   IamRole: string
  ##          : A different IAM role to assume to run the target action. For more information about this parameter, see <a>ScheduledAction</a>.
  ##   Enable: bool
  ##         : A modified enable flag of the scheduled action. If true, the scheduled action is active. If false, the scheduled action is disabled. 
  ##   Action: string (required)
  ##   EndTime: string
  ##          : A modified end time of the scheduled action. For more information about this parameter, see <a>ScheduledAction</a>. 
  ##   Version: string (required)
  ##   ScheduledActionDescription: string
  ##                             : A modified description of the scheduled action. 
  ##   TargetActionResizeCluster: string
  ##                            : The action type that specifies an Amazon Redshift API operation that is supported by the Amazon Redshift scheduler. 
  ## An action that runs a <code>ResizeCluster</code> API operation. 
  var query_602873 = newJObject()
  add(query_602873, "Schedule", newJString(Schedule))
  add(query_602873, "ScheduledActionName", newJString(ScheduledActionName))
  add(query_602873, "StartTime", newJString(StartTime))
  add(query_602873, "IamRole", newJString(IamRole))
  add(query_602873, "Enable", newJBool(Enable))
  add(query_602873, "Action", newJString(Action))
  add(query_602873, "EndTime", newJString(EndTime))
  add(query_602873, "Version", newJString(Version))
  add(query_602873, "ScheduledActionDescription",
      newJString(ScheduledActionDescription))
  add(query_602873, "TargetAction.ResizeCluster",
      newJString(TargetActionResizeCluster))
  result = call_602872.call(nil, query_602873, nil, nil, nil)

var getModifyScheduledAction* = Call_GetModifyScheduledAction_602851(
    name: "getModifyScheduledAction", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyScheduledAction",
    validator: validate_GetModifyScheduledAction_602852, base: "/",
    url: url_GetModifyScheduledAction_602853, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotCopyRetentionPeriod_602916 = ref object of OpenApiRestCall_599352
proc url_PostModifySnapshotCopyRetentionPeriod_602918(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotCopyRetentionPeriod_602917(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602919 = query.getOrDefault("Action")
  valid_602919 = validateParameter(valid_602919, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_602919 != nil:
    section.add "Action", valid_602919
  var valid_602920 = query.getOrDefault("Version")
  valid_602920 = validateParameter(valid_602920, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602920 != nil:
    section.add "Version", valid_602920
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602921 = header.getOrDefault("X-Amz-Date")
  valid_602921 = validateParameter(valid_602921, JString, required = false,
                                 default = nil)
  if valid_602921 != nil:
    section.add "X-Amz-Date", valid_602921
  var valid_602922 = header.getOrDefault("X-Amz-Security-Token")
  valid_602922 = validateParameter(valid_602922, JString, required = false,
                                 default = nil)
  if valid_602922 != nil:
    section.add "X-Amz-Security-Token", valid_602922
  var valid_602923 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602923 = validateParameter(valid_602923, JString, required = false,
                                 default = nil)
  if valid_602923 != nil:
    section.add "X-Amz-Content-Sha256", valid_602923
  var valid_602924 = header.getOrDefault("X-Amz-Algorithm")
  valid_602924 = validateParameter(valid_602924, JString, required = false,
                                 default = nil)
  if valid_602924 != nil:
    section.add "X-Amz-Algorithm", valid_602924
  var valid_602925 = header.getOrDefault("X-Amz-Signature")
  valid_602925 = validateParameter(valid_602925, JString, required = false,
                                 default = nil)
  if valid_602925 != nil:
    section.add "X-Amz-Signature", valid_602925
  var valid_602926 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602926 = validateParameter(valid_602926, JString, required = false,
                                 default = nil)
  if valid_602926 != nil:
    section.add "X-Amz-SignedHeaders", valid_602926
  var valid_602927 = header.getOrDefault("X-Amz-Credential")
  valid_602927 = validateParameter(valid_602927, JString, required = false,
                                 default = nil)
  if valid_602927 != nil:
    section.add "X-Amz-Credential", valid_602927
  result.add "header", section
  ## parameters in `formData` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  var valid_602928 = formData.getOrDefault("Manual")
  valid_602928 = validateParameter(valid_602928, JBool, required = false, default = nil)
  if valid_602928 != nil:
    section.add "Manual", valid_602928
  assert formData != nil, "formData argument is necessary due to required `RetentionPeriod` field"
  var valid_602929 = formData.getOrDefault("RetentionPeriod")
  valid_602929 = validateParameter(valid_602929, JInt, required = true, default = nil)
  if valid_602929 != nil:
    section.add "RetentionPeriod", valid_602929
  var valid_602930 = formData.getOrDefault("ClusterIdentifier")
  valid_602930 = validateParameter(valid_602930, JString, required = true,
                                 default = nil)
  if valid_602930 != nil:
    section.add "ClusterIdentifier", valid_602930
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602931: Call_PostModifySnapshotCopyRetentionPeriod_602916;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_602931.validator(path, query, header, formData, body)
  let scheme = call_602931.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602931.url(scheme.get, call_602931.host, call_602931.base,
                         call_602931.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602931, url, valid)

proc call*(call_602932: Call_PostModifySnapshotCopyRetentionPeriod_602916;
          RetentionPeriod: int; ClusterIdentifier: string; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_602933 = newJObject()
  var formData_602934 = newJObject()
  add(formData_602934, "Manual", newJBool(Manual))
  add(formData_602934, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_602933, "Action", newJString(Action))
  add(formData_602934, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602933, "Version", newJString(Version))
  result = call_602932.call(nil, query_602933, nil, formData_602934, nil)

var postModifySnapshotCopyRetentionPeriod* = Call_PostModifySnapshotCopyRetentionPeriod_602916(
    name: "postModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_PostModifySnapshotCopyRetentionPeriod_602917, base: "/",
    url: url_PostModifySnapshotCopyRetentionPeriod_602918,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotCopyRetentionPeriod_602898 = ref object of OpenApiRestCall_599352
proc url_GetModifySnapshotCopyRetentionPeriod_602900(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotCopyRetentionPeriod_602899(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Version: JString (required)
  section = newJObject()
  var valid_602901 = query.getOrDefault("Manual")
  valid_602901 = validateParameter(valid_602901, JBool, required = false, default = nil)
  if valid_602901 != nil:
    section.add "Manual", valid_602901
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602902 = query.getOrDefault("Action")
  valid_602902 = validateParameter(valid_602902, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_602902 != nil:
    section.add "Action", valid_602902
  var valid_602903 = query.getOrDefault("ClusterIdentifier")
  valid_602903 = validateParameter(valid_602903, JString, required = true,
                                 default = nil)
  if valid_602903 != nil:
    section.add "ClusterIdentifier", valid_602903
  var valid_602904 = query.getOrDefault("RetentionPeriod")
  valid_602904 = validateParameter(valid_602904, JInt, required = true, default = nil)
  if valid_602904 != nil:
    section.add "RetentionPeriod", valid_602904
  var valid_602905 = query.getOrDefault("Version")
  valid_602905 = validateParameter(valid_602905, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602905 != nil:
    section.add "Version", valid_602905
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602906 = header.getOrDefault("X-Amz-Date")
  valid_602906 = validateParameter(valid_602906, JString, required = false,
                                 default = nil)
  if valid_602906 != nil:
    section.add "X-Amz-Date", valid_602906
  var valid_602907 = header.getOrDefault("X-Amz-Security-Token")
  valid_602907 = validateParameter(valid_602907, JString, required = false,
                                 default = nil)
  if valid_602907 != nil:
    section.add "X-Amz-Security-Token", valid_602907
  var valid_602908 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602908 = validateParameter(valid_602908, JString, required = false,
                                 default = nil)
  if valid_602908 != nil:
    section.add "X-Amz-Content-Sha256", valid_602908
  var valid_602909 = header.getOrDefault("X-Amz-Algorithm")
  valid_602909 = validateParameter(valid_602909, JString, required = false,
                                 default = nil)
  if valid_602909 != nil:
    section.add "X-Amz-Algorithm", valid_602909
  var valid_602910 = header.getOrDefault("X-Amz-Signature")
  valid_602910 = validateParameter(valid_602910, JString, required = false,
                                 default = nil)
  if valid_602910 != nil:
    section.add "X-Amz-Signature", valid_602910
  var valid_602911 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602911 = validateParameter(valid_602911, JString, required = false,
                                 default = nil)
  if valid_602911 != nil:
    section.add "X-Amz-SignedHeaders", valid_602911
  var valid_602912 = header.getOrDefault("X-Amz-Credential")
  valid_602912 = validateParameter(valid_602912, JString, required = false,
                                 default = nil)
  if valid_602912 != nil:
    section.add "X-Amz-Credential", valid_602912
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602913: Call_GetModifySnapshotCopyRetentionPeriod_602898;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_602913.validator(path, query, header, formData, body)
  let scheme = call_602913.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602913.url(scheme.get, call_602913.host, call_602913.base,
                         call_602913.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602913, url, valid)

proc call*(call_602914: Call_GetModifySnapshotCopyRetentionPeriod_602898;
          ClusterIdentifier: string; RetentionPeriod: int; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Version: string (required)
  var query_602915 = newJObject()
  add(query_602915, "Manual", newJBool(Manual))
  add(query_602915, "Action", newJString(Action))
  add(query_602915, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_602915, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_602915, "Version", newJString(Version))
  result = call_602914.call(nil, query_602915, nil, nil, nil)

var getModifySnapshotCopyRetentionPeriod* = Call_GetModifySnapshotCopyRetentionPeriod_602898(
    name: "getModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_GetModifySnapshotCopyRetentionPeriod_602899, base: "/",
    url: url_GetModifySnapshotCopyRetentionPeriod_602900,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotSchedule_602952 = ref object of OpenApiRestCall_599352
proc url_PostModifySnapshotSchedule_602954(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostModifySnapshotSchedule_602953(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602955 = query.getOrDefault("Action")
  valid_602955 = validateParameter(valid_602955, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_602955 != nil:
    section.add "Action", valid_602955
  var valid_602956 = query.getOrDefault("Version")
  valid_602956 = validateParameter(valid_602956, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602956 != nil:
    section.add "Version", valid_602956
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602957 = header.getOrDefault("X-Amz-Date")
  valid_602957 = validateParameter(valid_602957, JString, required = false,
                                 default = nil)
  if valid_602957 != nil:
    section.add "X-Amz-Date", valid_602957
  var valid_602958 = header.getOrDefault("X-Amz-Security-Token")
  valid_602958 = validateParameter(valid_602958, JString, required = false,
                                 default = nil)
  if valid_602958 != nil:
    section.add "X-Amz-Security-Token", valid_602958
  var valid_602959 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602959 = validateParameter(valid_602959, JString, required = false,
                                 default = nil)
  if valid_602959 != nil:
    section.add "X-Amz-Content-Sha256", valid_602959
  var valid_602960 = header.getOrDefault("X-Amz-Algorithm")
  valid_602960 = validateParameter(valid_602960, JString, required = false,
                                 default = nil)
  if valid_602960 != nil:
    section.add "X-Amz-Algorithm", valid_602960
  var valid_602961 = header.getOrDefault("X-Amz-Signature")
  valid_602961 = validateParameter(valid_602961, JString, required = false,
                                 default = nil)
  if valid_602961 != nil:
    section.add "X-Amz-Signature", valid_602961
  var valid_602962 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602962 = validateParameter(valid_602962, JString, required = false,
                                 default = nil)
  if valid_602962 != nil:
    section.add "X-Amz-SignedHeaders", valid_602962
  var valid_602963 = header.getOrDefault("X-Amz-Credential")
  valid_602963 = validateParameter(valid_602963, JString, required = false,
                                 default = nil)
  if valid_602963 != nil:
    section.add "X-Amz-Credential", valid_602963
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleDefinitions` field"
  var valid_602964 = formData.getOrDefault("ScheduleDefinitions")
  valid_602964 = validateParameter(valid_602964, JArray, required = true, default = nil)
  if valid_602964 != nil:
    section.add "ScheduleDefinitions", valid_602964
  var valid_602965 = formData.getOrDefault("ScheduleIdentifier")
  valid_602965 = validateParameter(valid_602965, JString, required = true,
                                 default = nil)
  if valid_602965 != nil:
    section.add "ScheduleIdentifier", valid_602965
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602966: Call_PostModifySnapshotSchedule_602952; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_602966.validator(path, query, header, formData, body)
  let scheme = call_602966.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602966.url(scheme.get, call_602966.host, call_602966.base,
                         call_602966.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602966, url, valid)

proc call*(call_602967: Call_PostModifySnapshotSchedule_602952;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_602968 = newJObject()
  var formData_602969 = newJObject()
  if ScheduleDefinitions != nil:
    formData_602969.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_602968, "Action", newJString(Action))
  add(formData_602969, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_602968, "Version", newJString(Version))
  result = call_602967.call(nil, query_602968, nil, formData_602969, nil)

var postModifySnapshotSchedule* = Call_PostModifySnapshotSchedule_602952(
    name: "postModifySnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_PostModifySnapshotSchedule_602953, base: "/",
    url: url_PostModifySnapshotSchedule_602954,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotSchedule_602935 = ref object of OpenApiRestCall_599352
proc url_GetModifySnapshotSchedule_602937(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetModifySnapshotSchedule_602936(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: JString (required)
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleDefinitions` field"
  var valid_602938 = query.getOrDefault("ScheduleDefinitions")
  valid_602938 = validateParameter(valid_602938, JArray, required = true, default = nil)
  if valid_602938 != nil:
    section.add "ScheduleDefinitions", valid_602938
  var valid_602939 = query.getOrDefault("Action")
  valid_602939 = validateParameter(valid_602939, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_602939 != nil:
    section.add "Action", valid_602939
  var valid_602940 = query.getOrDefault("ScheduleIdentifier")
  valid_602940 = validateParameter(valid_602940, JString, required = true,
                                 default = nil)
  if valid_602940 != nil:
    section.add "ScheduleIdentifier", valid_602940
  var valid_602941 = query.getOrDefault("Version")
  valid_602941 = validateParameter(valid_602941, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602941 != nil:
    section.add "Version", valid_602941
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602942 = header.getOrDefault("X-Amz-Date")
  valid_602942 = validateParameter(valid_602942, JString, required = false,
                                 default = nil)
  if valid_602942 != nil:
    section.add "X-Amz-Date", valid_602942
  var valid_602943 = header.getOrDefault("X-Amz-Security-Token")
  valid_602943 = validateParameter(valid_602943, JString, required = false,
                                 default = nil)
  if valid_602943 != nil:
    section.add "X-Amz-Security-Token", valid_602943
  var valid_602944 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602944 = validateParameter(valid_602944, JString, required = false,
                                 default = nil)
  if valid_602944 != nil:
    section.add "X-Amz-Content-Sha256", valid_602944
  var valid_602945 = header.getOrDefault("X-Amz-Algorithm")
  valid_602945 = validateParameter(valid_602945, JString, required = false,
                                 default = nil)
  if valid_602945 != nil:
    section.add "X-Amz-Algorithm", valid_602945
  var valid_602946 = header.getOrDefault("X-Amz-Signature")
  valid_602946 = validateParameter(valid_602946, JString, required = false,
                                 default = nil)
  if valid_602946 != nil:
    section.add "X-Amz-Signature", valid_602946
  var valid_602947 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602947 = validateParameter(valid_602947, JString, required = false,
                                 default = nil)
  if valid_602947 != nil:
    section.add "X-Amz-SignedHeaders", valid_602947
  var valid_602948 = header.getOrDefault("X-Amz-Credential")
  valid_602948 = validateParameter(valid_602948, JString, required = false,
                                 default = nil)
  if valid_602948 != nil:
    section.add "X-Amz-Credential", valid_602948
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602949: Call_GetModifySnapshotSchedule_602935; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_602949.validator(path, query, header, formData, body)
  let scheme = call_602949.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602949.url(scheme.get, call_602949.host, call_602949.base,
                         call_602949.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602949, url, valid)

proc call*(call_602950: Call_GetModifySnapshotSchedule_602935;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_602951 = newJObject()
  if ScheduleDefinitions != nil:
    query_602951.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_602951, "Action", newJString(Action))
  add(query_602951, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_602951, "Version", newJString(Version))
  result = call_602950.call(nil, query_602951, nil, nil, nil)

var getModifySnapshotSchedule* = Call_GetModifySnapshotSchedule_602935(
    name: "getModifySnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_GetModifySnapshotSchedule_602936, base: "/",
    url: url_GetModifySnapshotSchedule_602937,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostPurchaseReservedNodeOffering_602987 = ref object of OpenApiRestCall_599352
proc url_PostPurchaseReservedNodeOffering_602989(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostPurchaseReservedNodeOffering_602988(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_602990 = query.getOrDefault("Action")
  valid_602990 = validateParameter(valid_602990, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_602990 != nil:
    section.add "Action", valid_602990
  var valid_602991 = query.getOrDefault("Version")
  valid_602991 = validateParameter(valid_602991, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602991 != nil:
    section.add "Version", valid_602991
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602992 = header.getOrDefault("X-Amz-Date")
  valid_602992 = validateParameter(valid_602992, JString, required = false,
                                 default = nil)
  if valid_602992 != nil:
    section.add "X-Amz-Date", valid_602992
  var valid_602993 = header.getOrDefault("X-Amz-Security-Token")
  valid_602993 = validateParameter(valid_602993, JString, required = false,
                                 default = nil)
  if valid_602993 != nil:
    section.add "X-Amz-Security-Token", valid_602993
  var valid_602994 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602994 = validateParameter(valid_602994, JString, required = false,
                                 default = nil)
  if valid_602994 != nil:
    section.add "X-Amz-Content-Sha256", valid_602994
  var valid_602995 = header.getOrDefault("X-Amz-Algorithm")
  valid_602995 = validateParameter(valid_602995, JString, required = false,
                                 default = nil)
  if valid_602995 != nil:
    section.add "X-Amz-Algorithm", valid_602995
  var valid_602996 = header.getOrDefault("X-Amz-Signature")
  valid_602996 = validateParameter(valid_602996, JString, required = false,
                                 default = nil)
  if valid_602996 != nil:
    section.add "X-Amz-Signature", valid_602996
  var valid_602997 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602997 = validateParameter(valid_602997, JString, required = false,
                                 default = nil)
  if valid_602997 != nil:
    section.add "X-Amz-SignedHeaders", valid_602997
  var valid_602998 = header.getOrDefault("X-Amz-Credential")
  valid_602998 = validateParameter(valid_602998, JString, required = false,
                                 default = nil)
  if valid_602998 != nil:
    section.add "X-Amz-Credential", valid_602998
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_602999 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_602999 = validateParameter(valid_602999, JString, required = true,
                                 default = nil)
  if valid_602999 != nil:
    section.add "ReservedNodeOfferingId", valid_602999
  var valid_603000 = formData.getOrDefault("NodeCount")
  valid_603000 = validateParameter(valid_603000, JInt, required = false, default = nil)
  if valid_603000 != nil:
    section.add "NodeCount", valid_603000
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603001: Call_PostPurchaseReservedNodeOffering_602987;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603001.validator(path, query, header, formData, body)
  let scheme = call_603001.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603001.url(scheme.get, call_603001.host, call_603001.base,
                         call_603001.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603001, url, valid)

proc call*(call_603002: Call_PostPurchaseReservedNodeOffering_602987;
          ReservedNodeOfferingId: string; NodeCount: int = 0;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"): Recallable =
  ## postPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_603003 = newJObject()
  var formData_603004 = newJObject()
  add(formData_603004, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_603004, "NodeCount", newJInt(NodeCount))
  add(query_603003, "Action", newJString(Action))
  add(query_603003, "Version", newJString(Version))
  result = call_603002.call(nil, query_603003, nil, formData_603004, nil)

var postPurchaseReservedNodeOffering* = Call_PostPurchaseReservedNodeOffering_602987(
    name: "postPurchaseReservedNodeOffering", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_PostPurchaseReservedNodeOffering_602988, base: "/",
    url: url_PostPurchaseReservedNodeOffering_602989,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPurchaseReservedNodeOffering_602970 = ref object of OpenApiRestCall_599352
proc url_GetPurchaseReservedNodeOffering_602972(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetPurchaseReservedNodeOffering_602971(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: JString (required)
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_602973 = query.getOrDefault("ReservedNodeOfferingId")
  valid_602973 = validateParameter(valid_602973, JString, required = true,
                                 default = nil)
  if valid_602973 != nil:
    section.add "ReservedNodeOfferingId", valid_602973
  var valid_602974 = query.getOrDefault("Action")
  valid_602974 = validateParameter(valid_602974, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_602974 != nil:
    section.add "Action", valid_602974
  var valid_602975 = query.getOrDefault("NodeCount")
  valid_602975 = validateParameter(valid_602975, JInt, required = false, default = nil)
  if valid_602975 != nil:
    section.add "NodeCount", valid_602975
  var valid_602976 = query.getOrDefault("Version")
  valid_602976 = validateParameter(valid_602976, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_602976 != nil:
    section.add "Version", valid_602976
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_602977 = header.getOrDefault("X-Amz-Date")
  valid_602977 = validateParameter(valid_602977, JString, required = false,
                                 default = nil)
  if valid_602977 != nil:
    section.add "X-Amz-Date", valid_602977
  var valid_602978 = header.getOrDefault("X-Amz-Security-Token")
  valid_602978 = validateParameter(valid_602978, JString, required = false,
                                 default = nil)
  if valid_602978 != nil:
    section.add "X-Amz-Security-Token", valid_602978
  var valid_602979 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_602979 = validateParameter(valid_602979, JString, required = false,
                                 default = nil)
  if valid_602979 != nil:
    section.add "X-Amz-Content-Sha256", valid_602979
  var valid_602980 = header.getOrDefault("X-Amz-Algorithm")
  valid_602980 = validateParameter(valid_602980, JString, required = false,
                                 default = nil)
  if valid_602980 != nil:
    section.add "X-Amz-Algorithm", valid_602980
  var valid_602981 = header.getOrDefault("X-Amz-Signature")
  valid_602981 = validateParameter(valid_602981, JString, required = false,
                                 default = nil)
  if valid_602981 != nil:
    section.add "X-Amz-Signature", valid_602981
  var valid_602982 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_602982 = validateParameter(valid_602982, JString, required = false,
                                 default = nil)
  if valid_602982 != nil:
    section.add "X-Amz-SignedHeaders", valid_602982
  var valid_602983 = header.getOrDefault("X-Amz-Credential")
  valid_602983 = validateParameter(valid_602983, JString, required = false,
                                 default = nil)
  if valid_602983 != nil:
    section.add "X-Amz-Credential", valid_602983
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_602984: Call_GetPurchaseReservedNodeOffering_602970;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_602984.validator(path, query, header, formData, body)
  let scheme = call_602984.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_602984.url(scheme.get, call_602984.host, call_602984.base,
                         call_602984.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_602984, url, valid)

proc call*(call_602985: Call_GetPurchaseReservedNodeOffering_602970;
          ReservedNodeOfferingId: string;
          Action: string = "PurchaseReservedNodeOffering"; NodeCount: int = 0;
          Version: string = "2012-12-01"): Recallable =
  ## getPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   Version: string (required)
  var query_602986 = newJObject()
  add(query_602986, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_602986, "Action", newJString(Action))
  add(query_602986, "NodeCount", newJInt(NodeCount))
  add(query_602986, "Version", newJString(Version))
  result = call_602985.call(nil, query_602986, nil, nil, nil)

var getPurchaseReservedNodeOffering* = Call_GetPurchaseReservedNodeOffering_602970(
    name: "getPurchaseReservedNodeOffering", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_GetPurchaseReservedNodeOffering_602971, base: "/",
    url: url_GetPurchaseReservedNodeOffering_602972,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRebootCluster_603021 = ref object of OpenApiRestCall_599352
proc url_PostRebootCluster_603023(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRebootCluster_603022(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603024 = query.getOrDefault("Action")
  valid_603024 = validateParameter(valid_603024, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_603024 != nil:
    section.add "Action", valid_603024
  var valid_603025 = query.getOrDefault("Version")
  valid_603025 = validateParameter(valid_603025, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603025 != nil:
    section.add "Version", valid_603025
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603026 = header.getOrDefault("X-Amz-Date")
  valid_603026 = validateParameter(valid_603026, JString, required = false,
                                 default = nil)
  if valid_603026 != nil:
    section.add "X-Amz-Date", valid_603026
  var valid_603027 = header.getOrDefault("X-Amz-Security-Token")
  valid_603027 = validateParameter(valid_603027, JString, required = false,
                                 default = nil)
  if valid_603027 != nil:
    section.add "X-Amz-Security-Token", valid_603027
  var valid_603028 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603028 = validateParameter(valid_603028, JString, required = false,
                                 default = nil)
  if valid_603028 != nil:
    section.add "X-Amz-Content-Sha256", valid_603028
  var valid_603029 = header.getOrDefault("X-Amz-Algorithm")
  valid_603029 = validateParameter(valid_603029, JString, required = false,
                                 default = nil)
  if valid_603029 != nil:
    section.add "X-Amz-Algorithm", valid_603029
  var valid_603030 = header.getOrDefault("X-Amz-Signature")
  valid_603030 = validateParameter(valid_603030, JString, required = false,
                                 default = nil)
  if valid_603030 != nil:
    section.add "X-Amz-Signature", valid_603030
  var valid_603031 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603031 = validateParameter(valid_603031, JString, required = false,
                                 default = nil)
  if valid_603031 != nil:
    section.add "X-Amz-SignedHeaders", valid_603031
  var valid_603032 = header.getOrDefault("X-Amz-Credential")
  valid_603032 = validateParameter(valid_603032, JString, required = false,
                                 default = nil)
  if valid_603032 != nil:
    section.add "X-Amz-Credential", valid_603032
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_603033 = formData.getOrDefault("ClusterIdentifier")
  valid_603033 = validateParameter(valid_603033, JString, required = true,
                                 default = nil)
  if valid_603033 != nil:
    section.add "ClusterIdentifier", valid_603033
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603034: Call_PostRebootCluster_603021; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_603034.validator(path, query, header, formData, body)
  let scheme = call_603034.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603034.url(scheme.get, call_603034.host, call_603034.base,
                         call_603034.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603034, url, valid)

proc call*(call_603035: Call_PostRebootCluster_603021; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## postRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_603036 = newJObject()
  var formData_603037 = newJObject()
  add(query_603036, "Action", newJString(Action))
  add(formData_603037, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603036, "Version", newJString(Version))
  result = call_603035.call(nil, query_603036, nil, formData_603037, nil)

var postRebootCluster* = Call_PostRebootCluster_603021(name: "postRebootCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_PostRebootCluster_603022,
    base: "/", url: url_PostRebootCluster_603023,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRebootCluster_603005 = ref object of OpenApiRestCall_599352
proc url_GetRebootCluster_603007(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRebootCluster_603006(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603008 = query.getOrDefault("Action")
  valid_603008 = validateParameter(valid_603008, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_603008 != nil:
    section.add "Action", valid_603008
  var valid_603009 = query.getOrDefault("ClusterIdentifier")
  valid_603009 = validateParameter(valid_603009, JString, required = true,
                                 default = nil)
  if valid_603009 != nil:
    section.add "ClusterIdentifier", valid_603009
  var valid_603010 = query.getOrDefault("Version")
  valid_603010 = validateParameter(valid_603010, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603010 != nil:
    section.add "Version", valid_603010
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603011 = header.getOrDefault("X-Amz-Date")
  valid_603011 = validateParameter(valid_603011, JString, required = false,
                                 default = nil)
  if valid_603011 != nil:
    section.add "X-Amz-Date", valid_603011
  var valid_603012 = header.getOrDefault("X-Amz-Security-Token")
  valid_603012 = validateParameter(valid_603012, JString, required = false,
                                 default = nil)
  if valid_603012 != nil:
    section.add "X-Amz-Security-Token", valid_603012
  var valid_603013 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603013 = validateParameter(valid_603013, JString, required = false,
                                 default = nil)
  if valid_603013 != nil:
    section.add "X-Amz-Content-Sha256", valid_603013
  var valid_603014 = header.getOrDefault("X-Amz-Algorithm")
  valid_603014 = validateParameter(valid_603014, JString, required = false,
                                 default = nil)
  if valid_603014 != nil:
    section.add "X-Amz-Algorithm", valid_603014
  var valid_603015 = header.getOrDefault("X-Amz-Signature")
  valid_603015 = validateParameter(valid_603015, JString, required = false,
                                 default = nil)
  if valid_603015 != nil:
    section.add "X-Amz-Signature", valid_603015
  var valid_603016 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603016 = validateParameter(valid_603016, JString, required = false,
                                 default = nil)
  if valid_603016 != nil:
    section.add "X-Amz-SignedHeaders", valid_603016
  var valid_603017 = header.getOrDefault("X-Amz-Credential")
  valid_603017 = validateParameter(valid_603017, JString, required = false,
                                 default = nil)
  if valid_603017 != nil:
    section.add "X-Amz-Credential", valid_603017
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603018: Call_GetRebootCluster_603005; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_603018.validator(path, query, header, formData, body)
  let scheme = call_603018.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603018.url(scheme.get, call_603018.host, call_603018.base,
                         call_603018.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603018, url, valid)

proc call*(call_603019: Call_GetRebootCluster_603005; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## getRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_603020 = newJObject()
  add(query_603020, "Action", newJString(Action))
  add(query_603020, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603020, "Version", newJString(Version))
  result = call_603019.call(nil, query_603020, nil, nil, nil)

var getRebootCluster* = Call_GetRebootCluster_603005(name: "getRebootCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_GetRebootCluster_603006,
    base: "/", url: url_GetRebootCluster_603007,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResetClusterParameterGroup_603056 = ref object of OpenApiRestCall_599352
proc url_PostResetClusterParameterGroup_603058(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResetClusterParameterGroup_603057(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603059 = query.getOrDefault("Action")
  valid_603059 = validateParameter(valid_603059, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_603059 != nil:
    section.add "Action", valid_603059
  var valid_603060 = query.getOrDefault("Version")
  valid_603060 = validateParameter(valid_603060, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603060 != nil:
    section.add "Version", valid_603060
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603061 = header.getOrDefault("X-Amz-Date")
  valid_603061 = validateParameter(valid_603061, JString, required = false,
                                 default = nil)
  if valid_603061 != nil:
    section.add "X-Amz-Date", valid_603061
  var valid_603062 = header.getOrDefault("X-Amz-Security-Token")
  valid_603062 = validateParameter(valid_603062, JString, required = false,
                                 default = nil)
  if valid_603062 != nil:
    section.add "X-Amz-Security-Token", valid_603062
  var valid_603063 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603063 = validateParameter(valid_603063, JString, required = false,
                                 default = nil)
  if valid_603063 != nil:
    section.add "X-Amz-Content-Sha256", valid_603063
  var valid_603064 = header.getOrDefault("X-Amz-Algorithm")
  valid_603064 = validateParameter(valid_603064, JString, required = false,
                                 default = nil)
  if valid_603064 != nil:
    section.add "X-Amz-Algorithm", valid_603064
  var valid_603065 = header.getOrDefault("X-Amz-Signature")
  valid_603065 = validateParameter(valid_603065, JString, required = false,
                                 default = nil)
  if valid_603065 != nil:
    section.add "X-Amz-Signature", valid_603065
  var valid_603066 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603066 = validateParameter(valid_603066, JString, required = false,
                                 default = nil)
  if valid_603066 != nil:
    section.add "X-Amz-SignedHeaders", valid_603066
  var valid_603067 = header.getOrDefault("X-Amz-Credential")
  valid_603067 = validateParameter(valid_603067, JString, required = false,
                                 default = nil)
  if valid_603067 != nil:
    section.add "X-Amz-Credential", valid_603067
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_603068 = formData.getOrDefault("ParameterGroupName")
  valid_603068 = validateParameter(valid_603068, JString, required = true,
                                 default = nil)
  if valid_603068 != nil:
    section.add "ParameterGroupName", valid_603068
  var valid_603069 = formData.getOrDefault("Parameters")
  valid_603069 = validateParameter(valid_603069, JArray, required = false,
                                 default = nil)
  if valid_603069 != nil:
    section.add "Parameters", valid_603069
  var valid_603070 = formData.getOrDefault("ResetAllParameters")
  valid_603070 = validateParameter(valid_603070, JBool, required = false, default = nil)
  if valid_603070 != nil:
    section.add "ResetAllParameters", valid_603070
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603071: Call_PostResetClusterParameterGroup_603056; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_603071.validator(path, query, header, formData, body)
  let scheme = call_603071.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603071.url(scheme.get, call_603071.host, call_603071.base,
                         call_603071.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603071, url, valid)

proc call*(call_603072: Call_PostResetClusterParameterGroup_603056;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          Action: string = "ResetClusterParameterGroup";
          ResetAllParameters: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: string (required)
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: string (required)
  var query_603073 = newJObject()
  var formData_603074 = newJObject()
  add(formData_603074, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    formData_603074.add "Parameters", Parameters
  add(query_603073, "Action", newJString(Action))
  add(formData_603074, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_603073, "Version", newJString(Version))
  result = call_603072.call(nil, query_603073, nil, formData_603074, nil)

var postResetClusterParameterGroup* = Call_PostResetClusterParameterGroup_603056(
    name: "postResetClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_PostResetClusterParameterGroup_603057, base: "/",
    url: url_PostResetClusterParameterGroup_603058,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResetClusterParameterGroup_603038 = ref object of OpenApiRestCall_599352
proc url_GetResetClusterParameterGroup_603040(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResetClusterParameterGroup_603039(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: JString (required)
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ParameterGroupName` field"
  var valid_603041 = query.getOrDefault("ParameterGroupName")
  valid_603041 = validateParameter(valid_603041, JString, required = true,
                                 default = nil)
  if valid_603041 != nil:
    section.add "ParameterGroupName", valid_603041
  var valid_603042 = query.getOrDefault("Parameters")
  valid_603042 = validateParameter(valid_603042, JArray, required = false,
                                 default = nil)
  if valid_603042 != nil:
    section.add "Parameters", valid_603042
  var valid_603043 = query.getOrDefault("Action")
  valid_603043 = validateParameter(valid_603043, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_603043 != nil:
    section.add "Action", valid_603043
  var valid_603044 = query.getOrDefault("ResetAllParameters")
  valid_603044 = validateParameter(valid_603044, JBool, required = false, default = nil)
  if valid_603044 != nil:
    section.add "ResetAllParameters", valid_603044
  var valid_603045 = query.getOrDefault("Version")
  valid_603045 = validateParameter(valid_603045, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603045 != nil:
    section.add "Version", valid_603045
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603046 = header.getOrDefault("X-Amz-Date")
  valid_603046 = validateParameter(valid_603046, JString, required = false,
                                 default = nil)
  if valid_603046 != nil:
    section.add "X-Amz-Date", valid_603046
  var valid_603047 = header.getOrDefault("X-Amz-Security-Token")
  valid_603047 = validateParameter(valid_603047, JString, required = false,
                                 default = nil)
  if valid_603047 != nil:
    section.add "X-Amz-Security-Token", valid_603047
  var valid_603048 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603048 = validateParameter(valid_603048, JString, required = false,
                                 default = nil)
  if valid_603048 != nil:
    section.add "X-Amz-Content-Sha256", valid_603048
  var valid_603049 = header.getOrDefault("X-Amz-Algorithm")
  valid_603049 = validateParameter(valid_603049, JString, required = false,
                                 default = nil)
  if valid_603049 != nil:
    section.add "X-Amz-Algorithm", valid_603049
  var valid_603050 = header.getOrDefault("X-Amz-Signature")
  valid_603050 = validateParameter(valid_603050, JString, required = false,
                                 default = nil)
  if valid_603050 != nil:
    section.add "X-Amz-Signature", valid_603050
  var valid_603051 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603051 = validateParameter(valid_603051, JString, required = false,
                                 default = nil)
  if valid_603051 != nil:
    section.add "X-Amz-SignedHeaders", valid_603051
  var valid_603052 = header.getOrDefault("X-Amz-Credential")
  valid_603052 = validateParameter(valid_603052, JString, required = false,
                                 default = nil)
  if valid_603052 != nil:
    section.add "X-Amz-Credential", valid_603052
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603053: Call_GetResetClusterParameterGroup_603038; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_603053.validator(path, query, header, formData, body)
  let scheme = call_603053.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603053.url(scheme.get, call_603053.host, call_603053.base,
                         call_603053.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603053, url, valid)

proc call*(call_603054: Call_GetResetClusterParameterGroup_603038;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          Action: string = "ResetClusterParameterGroup";
          ResetAllParameters: bool = false; Version: string = "2012-12-01"): Recallable =
  ## getResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   Action: string (required)
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Version: string (required)
  var query_603055 = newJObject()
  add(query_603055, "ParameterGroupName", newJString(ParameterGroupName))
  if Parameters != nil:
    query_603055.add "Parameters", Parameters
  add(query_603055, "Action", newJString(Action))
  add(query_603055, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_603055, "Version", newJString(Version))
  result = call_603054.call(nil, query_603055, nil, nil, nil)

var getResetClusterParameterGroup* = Call_GetResetClusterParameterGroup_603038(
    name: "getResetClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_GetResetClusterParameterGroup_603039, base: "/",
    url: url_GetResetClusterParameterGroup_603040,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResizeCluster_603095 = ref object of OpenApiRestCall_599352
proc url_PostResizeCluster_603097(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostResizeCluster_603096(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603098 = query.getOrDefault("Action")
  valid_603098 = validateParameter(valid_603098, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_603098 != nil:
    section.add "Action", valid_603098
  var valid_603099 = query.getOrDefault("Version")
  valid_603099 = validateParameter(valid_603099, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603099 != nil:
    section.add "Version", valid_603099
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603100 = header.getOrDefault("X-Amz-Date")
  valid_603100 = validateParameter(valid_603100, JString, required = false,
                                 default = nil)
  if valid_603100 != nil:
    section.add "X-Amz-Date", valid_603100
  var valid_603101 = header.getOrDefault("X-Amz-Security-Token")
  valid_603101 = validateParameter(valid_603101, JString, required = false,
                                 default = nil)
  if valid_603101 != nil:
    section.add "X-Amz-Security-Token", valid_603101
  var valid_603102 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603102 = validateParameter(valid_603102, JString, required = false,
                                 default = nil)
  if valid_603102 != nil:
    section.add "X-Amz-Content-Sha256", valid_603102
  var valid_603103 = header.getOrDefault("X-Amz-Algorithm")
  valid_603103 = validateParameter(valid_603103, JString, required = false,
                                 default = nil)
  if valid_603103 != nil:
    section.add "X-Amz-Algorithm", valid_603103
  var valid_603104 = header.getOrDefault("X-Amz-Signature")
  valid_603104 = validateParameter(valid_603104, JString, required = false,
                                 default = nil)
  if valid_603104 != nil:
    section.add "X-Amz-Signature", valid_603104
  var valid_603105 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603105 = validateParameter(valid_603105, JString, required = false,
                                 default = nil)
  if valid_603105 != nil:
    section.add "X-Amz-SignedHeaders", valid_603105
  var valid_603106 = header.getOrDefault("X-Amz-Credential")
  valid_603106 = validateParameter(valid_603106, JString, required = false,
                                 default = nil)
  if valid_603106 != nil:
    section.add "X-Amz-Credential", valid_603106
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  section = newJObject()
  var valid_603107 = formData.getOrDefault("ClusterType")
  valid_603107 = validateParameter(valid_603107, JString, required = false,
                                 default = nil)
  if valid_603107 != nil:
    section.add "ClusterType", valid_603107
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_603108 = formData.getOrDefault("ClusterIdentifier")
  valid_603108 = validateParameter(valid_603108, JString, required = true,
                                 default = nil)
  if valid_603108 != nil:
    section.add "ClusterIdentifier", valid_603108
  var valid_603109 = formData.getOrDefault("NumberOfNodes")
  valid_603109 = validateParameter(valid_603109, JInt, required = true, default = nil)
  if valid_603109 != nil:
    section.add "NumberOfNodes", valid_603109
  var valid_603110 = formData.getOrDefault("Classic")
  valid_603110 = validateParameter(valid_603110, JBool, required = false, default = nil)
  if valid_603110 != nil:
    section.add "Classic", valid_603110
  var valid_603111 = formData.getOrDefault("NodeType")
  valid_603111 = validateParameter(valid_603111, JString, required = false,
                                 default = nil)
  if valid_603111 != nil:
    section.add "NodeType", valid_603111
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603112: Call_PostResizeCluster_603095; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_603112.validator(path, query, header, formData, body)
  let scheme = call_603112.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603112.url(scheme.get, call_603112.host, call_603112.base,
                         call_603112.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603112, url, valid)

proc call*(call_603113: Call_PostResizeCluster_603095; ClusterIdentifier: string;
          NumberOfNodes: int; ClusterType: string = "";
          Action: string = "ResizeCluster"; Classic: bool = false;
          Version: string = "2012-12-01"; NodeType: string = ""): Recallable =
  ## postResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Version: string (required)
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  var query_603114 = newJObject()
  var formData_603115 = newJObject()
  add(formData_603115, "ClusterType", newJString(ClusterType))
  add(query_603114, "Action", newJString(Action))
  add(formData_603115, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_603115, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_603115, "Classic", newJBool(Classic))
  add(query_603114, "Version", newJString(Version))
  add(formData_603115, "NodeType", newJString(NodeType))
  result = call_603113.call(nil, query_603114, nil, formData_603115, nil)

var postResizeCluster* = Call_PostResizeCluster_603095(name: "postResizeCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_PostResizeCluster_603096,
    base: "/", url: url_PostResizeCluster_603097,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResizeCluster_603075 = ref object of OpenApiRestCall_599352
proc url_GetResizeCluster_603077(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetResizeCluster_603076(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   Version: JString (required)
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603078 = query.getOrDefault("Action")
  valid_603078 = validateParameter(valid_603078, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_603078 != nil:
    section.add "Action", valid_603078
  var valid_603079 = query.getOrDefault("ClusterIdentifier")
  valid_603079 = validateParameter(valid_603079, JString, required = true,
                                 default = nil)
  if valid_603079 != nil:
    section.add "ClusterIdentifier", valid_603079
  var valid_603080 = query.getOrDefault("Classic")
  valid_603080 = validateParameter(valid_603080, JBool, required = false, default = nil)
  if valid_603080 != nil:
    section.add "Classic", valid_603080
  var valid_603081 = query.getOrDefault("NumberOfNodes")
  valid_603081 = validateParameter(valid_603081, JInt, required = true, default = nil)
  if valid_603081 != nil:
    section.add "NumberOfNodes", valid_603081
  var valid_603082 = query.getOrDefault("NodeType")
  valid_603082 = validateParameter(valid_603082, JString, required = false,
                                 default = nil)
  if valid_603082 != nil:
    section.add "NodeType", valid_603082
  var valid_603083 = query.getOrDefault("Version")
  valid_603083 = validateParameter(valid_603083, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603083 != nil:
    section.add "Version", valid_603083
  var valid_603084 = query.getOrDefault("ClusterType")
  valid_603084 = validateParameter(valid_603084, JString, required = false,
                                 default = nil)
  if valid_603084 != nil:
    section.add "ClusterType", valid_603084
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603085 = header.getOrDefault("X-Amz-Date")
  valid_603085 = validateParameter(valid_603085, JString, required = false,
                                 default = nil)
  if valid_603085 != nil:
    section.add "X-Amz-Date", valid_603085
  var valid_603086 = header.getOrDefault("X-Amz-Security-Token")
  valid_603086 = validateParameter(valid_603086, JString, required = false,
                                 default = nil)
  if valid_603086 != nil:
    section.add "X-Amz-Security-Token", valid_603086
  var valid_603087 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603087 = validateParameter(valid_603087, JString, required = false,
                                 default = nil)
  if valid_603087 != nil:
    section.add "X-Amz-Content-Sha256", valid_603087
  var valid_603088 = header.getOrDefault("X-Amz-Algorithm")
  valid_603088 = validateParameter(valid_603088, JString, required = false,
                                 default = nil)
  if valid_603088 != nil:
    section.add "X-Amz-Algorithm", valid_603088
  var valid_603089 = header.getOrDefault("X-Amz-Signature")
  valid_603089 = validateParameter(valid_603089, JString, required = false,
                                 default = nil)
  if valid_603089 != nil:
    section.add "X-Amz-Signature", valid_603089
  var valid_603090 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603090 = validateParameter(valid_603090, JString, required = false,
                                 default = nil)
  if valid_603090 != nil:
    section.add "X-Amz-SignedHeaders", valid_603090
  var valid_603091 = header.getOrDefault("X-Amz-Credential")
  valid_603091 = validateParameter(valid_603091, JString, required = false,
                                 default = nil)
  if valid_603091 != nil:
    section.add "X-Amz-Credential", valid_603091
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603092: Call_GetResizeCluster_603075; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_603092.validator(path, query, header, formData, body)
  let scheme = call_603092.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603092.url(scheme.get, call_603092.host, call_603092.base,
                         call_603092.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603092, url, valid)

proc call*(call_603093: Call_GetResizeCluster_603075; ClusterIdentifier: string;
          NumberOfNodes: int; Action: string = "ResizeCluster"; Classic: bool = false;
          NodeType: string = ""; Version: string = "2012-12-01";
          ClusterType: string = ""): Recallable =
  ## getResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   Version: string (required)
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  var query_603094 = newJObject()
  add(query_603094, "Action", newJString(Action))
  add(query_603094, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603094, "Classic", newJBool(Classic))
  add(query_603094, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_603094, "NodeType", newJString(NodeType))
  add(query_603094, "Version", newJString(Version))
  add(query_603094, "ClusterType", newJString(ClusterType))
  result = call_603093.call(nil, query_603094, nil, nil, nil)

var getResizeCluster* = Call_GetResizeCluster_603075(name: "getResizeCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_GetResizeCluster_603076,
    base: "/", url: url_GetResizeCluster_603077,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreFromClusterSnapshot_603157 = ref object of OpenApiRestCall_599352
proc url_PostRestoreFromClusterSnapshot_603159(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreFromClusterSnapshot_603158(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603160 = query.getOrDefault("Action")
  valid_603160 = validateParameter(valid_603160, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_603160 != nil:
    section.add "Action", valid_603160
  var valid_603161 = query.getOrDefault("Version")
  valid_603161 = validateParameter(valid_603161, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603161 != nil:
    section.add "Version", valid_603161
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603162 = header.getOrDefault("X-Amz-Date")
  valid_603162 = validateParameter(valid_603162, JString, required = false,
                                 default = nil)
  if valid_603162 != nil:
    section.add "X-Amz-Date", valid_603162
  var valid_603163 = header.getOrDefault("X-Amz-Security-Token")
  valid_603163 = validateParameter(valid_603163, JString, required = false,
                                 default = nil)
  if valid_603163 != nil:
    section.add "X-Amz-Security-Token", valid_603163
  var valid_603164 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603164 = validateParameter(valid_603164, JString, required = false,
                                 default = nil)
  if valid_603164 != nil:
    section.add "X-Amz-Content-Sha256", valid_603164
  var valid_603165 = header.getOrDefault("X-Amz-Algorithm")
  valid_603165 = validateParameter(valid_603165, JString, required = false,
                                 default = nil)
  if valid_603165 != nil:
    section.add "X-Amz-Algorithm", valid_603165
  var valid_603166 = header.getOrDefault("X-Amz-Signature")
  valid_603166 = validateParameter(valid_603166, JString, required = false,
                                 default = nil)
  if valid_603166 != nil:
    section.add "X-Amz-Signature", valid_603166
  var valid_603167 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603167 = validateParameter(valid_603167, JString, required = false,
                                 default = nil)
  if valid_603167 != nil:
    section.add "X-Amz-SignedHeaders", valid_603167
  var valid_603168 = header.getOrDefault("X-Amz-Credential")
  valid_603168 = validateParameter(valid_603168, JString, required = false,
                                 default = nil)
  if valid_603168 != nil:
    section.add "X-Amz-Credential", valid_603168
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  section = newJObject()
  var valid_603169 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_603169 = validateParameter(valid_603169, JString, required = false,
                                 default = nil)
  if valid_603169 != nil:
    section.add "PreferredMaintenanceWindow", valid_603169
  var valid_603170 = formData.getOrDefault("EnhancedVpcRouting")
  valid_603170 = validateParameter(valid_603170, JBool, required = false, default = nil)
  if valid_603170 != nil:
    section.add "EnhancedVpcRouting", valid_603170
  var valid_603171 = formData.getOrDefault("Port")
  valid_603171 = validateParameter(valid_603171, JInt, required = false, default = nil)
  if valid_603171 != nil:
    section.add "Port", valid_603171
  var valid_603172 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_603172 = validateParameter(valid_603172, JArray, required = false,
                                 default = nil)
  if valid_603172 != nil:
    section.add "VpcSecurityGroupIds", valid_603172
  var valid_603173 = formData.getOrDefault("AdditionalInfo")
  valid_603173 = validateParameter(valid_603173, JString, required = false,
                                 default = nil)
  if valid_603173 != nil:
    section.add "AdditionalInfo", valid_603173
  var valid_603174 = formData.getOrDefault("AvailabilityZone")
  valid_603174 = validateParameter(valid_603174, JString, required = false,
                                 default = nil)
  if valid_603174 != nil:
    section.add "AvailabilityZone", valid_603174
  var valid_603175 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_603175 = validateParameter(valid_603175, JString, required = false,
                                 default = nil)
  if valid_603175 != nil:
    section.add "SnapshotClusterIdentifier", valid_603175
  var valid_603176 = formData.getOrDefault("ClusterSecurityGroups")
  valid_603176 = validateParameter(valid_603176, JArray, required = false,
                                 default = nil)
  if valid_603176 != nil:
    section.add "ClusterSecurityGroups", valid_603176
  var valid_603177 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_603177 = validateParameter(valid_603177, JString, required = false,
                                 default = nil)
  if valid_603177 != nil:
    section.add "HsmConfigurationIdentifier", valid_603177
  var valid_603178 = formData.getOrDefault("OwnerAccount")
  valid_603178 = validateParameter(valid_603178, JString, required = false,
                                 default = nil)
  if valid_603178 != nil:
    section.add "OwnerAccount", valid_603178
  var valid_603179 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_603179 = validateParameter(valid_603179, JString, required = false,
                                 default = nil)
  if valid_603179 != nil:
    section.add "HsmClientCertificateIdentifier", valid_603179
  var valid_603180 = formData.getOrDefault("PubliclyAccessible")
  valid_603180 = validateParameter(valid_603180, JBool, required = false, default = nil)
  if valid_603180 != nil:
    section.add "PubliclyAccessible", valid_603180
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_603181 = formData.getOrDefault("ClusterIdentifier")
  valid_603181 = validateParameter(valid_603181, JString, required = true,
                                 default = nil)
  if valid_603181 != nil:
    section.add "ClusterIdentifier", valid_603181
  var valid_603182 = formData.getOrDefault("IamRoles")
  valid_603182 = validateParameter(valid_603182, JArray, required = false,
                                 default = nil)
  if valid_603182 != nil:
    section.add "IamRoles", valid_603182
  var valid_603183 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_603183 = validateParameter(valid_603183, JString, required = false,
                                 default = nil)
  if valid_603183 != nil:
    section.add "SnapshotScheduleIdentifier", valid_603183
  var valid_603184 = formData.getOrDefault("NumberOfNodes")
  valid_603184 = validateParameter(valid_603184, JInt, required = false, default = nil)
  if valid_603184 != nil:
    section.add "NumberOfNodes", valid_603184
  var valid_603185 = formData.getOrDefault("ClusterParameterGroupName")
  valid_603185 = validateParameter(valid_603185, JString, required = false,
                                 default = nil)
  if valid_603185 != nil:
    section.add "ClusterParameterGroupName", valid_603185
  var valid_603186 = formData.getOrDefault("KmsKeyId")
  valid_603186 = validateParameter(valid_603186, JString, required = false,
                                 default = nil)
  if valid_603186 != nil:
    section.add "KmsKeyId", valid_603186
  var valid_603187 = formData.getOrDefault("SnapshotIdentifier")
  valid_603187 = validateParameter(valid_603187, JString, required = true,
                                 default = nil)
  if valid_603187 != nil:
    section.add "SnapshotIdentifier", valid_603187
  var valid_603188 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_603188 = validateParameter(valid_603188, JInt, required = false, default = nil)
  if valid_603188 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_603188
  var valid_603189 = formData.getOrDefault("ElasticIp")
  valid_603189 = validateParameter(valid_603189, JString, required = false,
                                 default = nil)
  if valid_603189 != nil:
    section.add "ElasticIp", valid_603189
  var valid_603190 = formData.getOrDefault("AllowVersionUpgrade")
  valid_603190 = validateParameter(valid_603190, JBool, required = false, default = nil)
  if valid_603190 != nil:
    section.add "AllowVersionUpgrade", valid_603190
  var valid_603191 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_603191 = validateParameter(valid_603191, JInt, required = false, default = nil)
  if valid_603191 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_603191
  var valid_603192 = formData.getOrDefault("NodeType")
  valid_603192 = validateParameter(valid_603192, JString, required = false,
                                 default = nil)
  if valid_603192 != nil:
    section.add "NodeType", valid_603192
  var valid_603193 = formData.getOrDefault("MaintenanceTrackName")
  valid_603193 = validateParameter(valid_603193, JString, required = false,
                                 default = nil)
  if valid_603193 != nil:
    section.add "MaintenanceTrackName", valid_603193
  var valid_603194 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_603194 = validateParameter(valid_603194, JString, required = false,
                                 default = nil)
  if valid_603194 != nil:
    section.add "ClusterSubnetGroupName", valid_603194
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603195: Call_PostRestoreFromClusterSnapshot_603157; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603195.validator(path, query, header, formData, body)
  let scheme = call_603195.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603195.url(scheme.get, call_603195.host, call_603195.base,
                         call_603195.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603195, url, valid)

proc call*(call_603196: Call_PostRestoreFromClusterSnapshot_603157;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          PreferredMaintenanceWindow: string = ""; EnhancedVpcRouting: bool = false;
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil;
          AdditionalInfo: string = ""; AvailabilityZone: string = "";
          SnapshotClusterIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil;
          HsmConfigurationIdentifier: string = "";
          Action: string = "RestoreFromClusterSnapshot"; OwnerAccount: string = "";
          HsmClientCertificateIdentifier: string = "";
          PubliclyAccessible: bool = false; IamRoles: JsonNode = nil;
          SnapshotScheduleIdentifier: string = ""; NumberOfNodes: int = 0;
          ClusterParameterGroupName: string = ""; KmsKeyId: string = "";
          ManualSnapshotRetentionPeriod: int = 0; ElasticIp: string = "";
          AllowVersionUpgrade: bool = false;
          AutomatedSnapshotRetentionPeriod: int = 0; Version: string = "2012-12-01";
          NodeType: string = ""; MaintenanceTrackName: string = "";
          ClusterSubnetGroupName: string = ""): Recallable =
  ## postRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   Version: string (required)
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  var query_603197 = newJObject()
  var formData_603198 = newJObject()
  add(formData_603198, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_603198, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_603198, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    formData_603198.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_603198, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_603198, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_603198, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  if ClusterSecurityGroups != nil:
    formData_603198.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_603198, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_603197, "Action", newJString(Action))
  add(formData_603198, "OwnerAccount", newJString(OwnerAccount))
  add(formData_603198, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_603198, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(formData_603198, "ClusterIdentifier", newJString(ClusterIdentifier))
  if IamRoles != nil:
    formData_603198.add "IamRoles", IamRoles
  add(formData_603198, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(formData_603198, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_603198, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_603198, "KmsKeyId", newJString(KmsKeyId))
  add(formData_603198, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_603198, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_603198, "ElasticIp", newJString(ElasticIp))
  add(formData_603198, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_603198, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_603197, "Version", newJString(Version))
  add(formData_603198, "NodeType", newJString(NodeType))
  add(formData_603198, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_603198, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  result = call_603196.call(nil, query_603197, nil, formData_603198, nil)

var postRestoreFromClusterSnapshot* = Call_PostRestoreFromClusterSnapshot_603157(
    name: "postRestoreFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_PostRestoreFromClusterSnapshot_603158, base: "/",
    url: url_PostRestoreFromClusterSnapshot_603159,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreFromClusterSnapshot_603116 = ref object of OpenApiRestCall_599352
proc url_GetRestoreFromClusterSnapshot_603118(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreFromClusterSnapshot_603117(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Action: JString (required)
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Version: JString (required)
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_603119 = query.getOrDefault("ClusterSecurityGroups")
  valid_603119 = validateParameter(valid_603119, JArray, required = false,
                                 default = nil)
  if valid_603119 != nil:
    section.add "ClusterSecurityGroups", valid_603119
  var valid_603120 = query.getOrDefault("ClusterSubnetGroupName")
  valid_603120 = validateParameter(valid_603120, JString, required = false,
                                 default = nil)
  if valid_603120 != nil:
    section.add "ClusterSubnetGroupName", valid_603120
  var valid_603121 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_603121 = validateParameter(valid_603121, JString, required = false,
                                 default = nil)
  if valid_603121 != nil:
    section.add "HsmClientCertificateIdentifier", valid_603121
  var valid_603122 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_603122 = validateParameter(valid_603122, JString, required = false,
                                 default = nil)
  if valid_603122 != nil:
    section.add "PreferredMaintenanceWindow", valid_603122
  var valid_603123 = query.getOrDefault("MaintenanceTrackName")
  valid_603123 = validateParameter(valid_603123, JString, required = false,
                                 default = nil)
  if valid_603123 != nil:
    section.add "MaintenanceTrackName", valid_603123
  var valid_603124 = query.getOrDefault("IamRoles")
  valid_603124 = validateParameter(valid_603124, JArray, required = false,
                                 default = nil)
  if valid_603124 != nil:
    section.add "IamRoles", valid_603124
  var valid_603125 = query.getOrDefault("AvailabilityZone")
  valid_603125 = validateParameter(valid_603125, JString, required = false,
                                 default = nil)
  if valid_603125 != nil:
    section.add "AvailabilityZone", valid_603125
  var valid_603126 = query.getOrDefault("AllowVersionUpgrade")
  valid_603126 = validateParameter(valid_603126, JBool, required = false, default = nil)
  if valid_603126 != nil:
    section.add "AllowVersionUpgrade", valid_603126
  var valid_603127 = query.getOrDefault("EnhancedVpcRouting")
  valid_603127 = validateParameter(valid_603127, JBool, required = false, default = nil)
  if valid_603127 != nil:
    section.add "EnhancedVpcRouting", valid_603127
  var valid_603128 = query.getOrDefault("VpcSecurityGroupIds")
  valid_603128 = validateParameter(valid_603128, JArray, required = false,
                                 default = nil)
  if valid_603128 != nil:
    section.add "VpcSecurityGroupIds", valid_603128
  var valid_603129 = query.getOrDefault("ClusterParameterGroupName")
  valid_603129 = validateParameter(valid_603129, JString, required = false,
                                 default = nil)
  if valid_603129 != nil:
    section.add "ClusterParameterGroupName", valid_603129
  var valid_603130 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_603130 = validateParameter(valid_603130, JString, required = false,
                                 default = nil)
  if valid_603130 != nil:
    section.add "HsmConfigurationIdentifier", valid_603130
  var valid_603131 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_603131 = validateParameter(valid_603131, JString, required = false,
                                 default = nil)
  if valid_603131 != nil:
    section.add "SnapshotScheduleIdentifier", valid_603131
  var valid_603132 = query.getOrDefault("AdditionalInfo")
  valid_603132 = validateParameter(valid_603132, JString, required = false,
                                 default = nil)
  if valid_603132 != nil:
    section.add "AdditionalInfo", valid_603132
  var valid_603133 = query.getOrDefault("ElasticIp")
  valid_603133 = validateParameter(valid_603133, JString, required = false,
                                 default = nil)
  if valid_603133 != nil:
    section.add "ElasticIp", valid_603133
  assert query != nil,
        "query argument is necessary due to required `ClusterIdentifier` field"
  var valid_603134 = query.getOrDefault("ClusterIdentifier")
  valid_603134 = validateParameter(valid_603134, JString, required = true,
                                 default = nil)
  if valid_603134 != nil:
    section.add "ClusterIdentifier", valid_603134
  var valid_603135 = query.getOrDefault("OwnerAccount")
  valid_603135 = validateParameter(valid_603135, JString, required = false,
                                 default = nil)
  if valid_603135 != nil:
    section.add "OwnerAccount", valid_603135
  var valid_603136 = query.getOrDefault("Action")
  valid_603136 = validateParameter(valid_603136, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_603136 != nil:
    section.add "Action", valid_603136
  var valid_603137 = query.getOrDefault("KmsKeyId")
  valid_603137 = validateParameter(valid_603137, JString, required = false,
                                 default = nil)
  if valid_603137 != nil:
    section.add "KmsKeyId", valid_603137
  var valid_603138 = query.getOrDefault("PubliclyAccessible")
  valid_603138 = validateParameter(valid_603138, JBool, required = false, default = nil)
  if valid_603138 != nil:
    section.add "PubliclyAccessible", valid_603138
  var valid_603139 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_603139 = validateParameter(valid_603139, JString, required = false,
                                 default = nil)
  if valid_603139 != nil:
    section.add "SnapshotClusterIdentifier", valid_603139
  var valid_603140 = query.getOrDefault("Port")
  valid_603140 = validateParameter(valid_603140, JInt, required = false, default = nil)
  if valid_603140 != nil:
    section.add "Port", valid_603140
  var valid_603141 = query.getOrDefault("NumberOfNodes")
  valid_603141 = validateParameter(valid_603141, JInt, required = false, default = nil)
  if valid_603141 != nil:
    section.add "NumberOfNodes", valid_603141
  var valid_603142 = query.getOrDefault("SnapshotIdentifier")
  valid_603142 = validateParameter(valid_603142, JString, required = true,
                                 default = nil)
  if valid_603142 != nil:
    section.add "SnapshotIdentifier", valid_603142
  var valid_603143 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_603143 = validateParameter(valid_603143, JInt, required = false, default = nil)
  if valid_603143 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_603143
  var valid_603144 = query.getOrDefault("NodeType")
  valid_603144 = validateParameter(valid_603144, JString, required = false,
                                 default = nil)
  if valid_603144 != nil:
    section.add "NodeType", valid_603144
  var valid_603145 = query.getOrDefault("Version")
  valid_603145 = validateParameter(valid_603145, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603145 != nil:
    section.add "Version", valid_603145
  var valid_603146 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_603146 = validateParameter(valid_603146, JInt, required = false, default = nil)
  if valid_603146 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_603146
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603147 = header.getOrDefault("X-Amz-Date")
  valid_603147 = validateParameter(valid_603147, JString, required = false,
                                 default = nil)
  if valid_603147 != nil:
    section.add "X-Amz-Date", valid_603147
  var valid_603148 = header.getOrDefault("X-Amz-Security-Token")
  valid_603148 = validateParameter(valid_603148, JString, required = false,
                                 default = nil)
  if valid_603148 != nil:
    section.add "X-Amz-Security-Token", valid_603148
  var valid_603149 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603149 = validateParameter(valid_603149, JString, required = false,
                                 default = nil)
  if valid_603149 != nil:
    section.add "X-Amz-Content-Sha256", valid_603149
  var valid_603150 = header.getOrDefault("X-Amz-Algorithm")
  valid_603150 = validateParameter(valid_603150, JString, required = false,
                                 default = nil)
  if valid_603150 != nil:
    section.add "X-Amz-Algorithm", valid_603150
  var valid_603151 = header.getOrDefault("X-Amz-Signature")
  valid_603151 = validateParameter(valid_603151, JString, required = false,
                                 default = nil)
  if valid_603151 != nil:
    section.add "X-Amz-Signature", valid_603151
  var valid_603152 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603152 = validateParameter(valid_603152, JString, required = false,
                                 default = nil)
  if valid_603152 != nil:
    section.add "X-Amz-SignedHeaders", valid_603152
  var valid_603153 = header.getOrDefault("X-Amz-Credential")
  valid_603153 = validateParameter(valid_603153, JString, required = false,
                                 default = nil)
  if valid_603153 != nil:
    section.add "X-Amz-Credential", valid_603153
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603154: Call_GetRestoreFromClusterSnapshot_603116; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603154.validator(path, query, header, formData, body)
  let scheme = call_603154.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603154.url(scheme.get, call_603154.host, call_603154.base,
                         call_603154.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603154, url, valid)

proc call*(call_603155: Call_GetRestoreFromClusterSnapshot_603116;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          ClusterSecurityGroups: JsonNode = nil;
          ClusterSubnetGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          PreferredMaintenanceWindow: string = "";
          MaintenanceTrackName: string = ""; IamRoles: JsonNode = nil;
          AvailabilityZone: string = ""; AllowVersionUpgrade: bool = false;
          EnhancedVpcRouting: bool = false; VpcSecurityGroupIds: JsonNode = nil;
          ClusterParameterGroupName: string = "";
          HsmConfigurationIdentifier: string = "";
          SnapshotScheduleIdentifier: string = ""; AdditionalInfo: string = "";
          ElasticIp: string = ""; OwnerAccount: string = "";
          Action: string = "RestoreFromClusterSnapshot"; KmsKeyId: string = "";
          PubliclyAccessible: bool = false; SnapshotClusterIdentifier: string = "";
          Port: int = 0; NumberOfNodes: int = 0;
          AutomatedSnapshotRetentionPeriod: int = 0; NodeType: string = "";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## getRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Action: string (required)
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_603156 = newJObject()
  if ClusterSecurityGroups != nil:
    query_603156.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_603156, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_603156, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_603156, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_603156, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if IamRoles != nil:
    query_603156.add "IamRoles", IamRoles
  add(query_603156, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_603156, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_603156, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  if VpcSecurityGroupIds != nil:
    query_603156.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_603156, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_603156, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_603156, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_603156, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_603156, "ElasticIp", newJString(ElasticIp))
  add(query_603156, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603156, "OwnerAccount", newJString(OwnerAccount))
  add(query_603156, "Action", newJString(Action))
  add(query_603156, "KmsKeyId", newJString(KmsKeyId))
  add(query_603156, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_603156, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_603156, "Port", newJInt(Port))
  add(query_603156, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_603156, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603156, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_603156, "NodeType", newJString(NodeType))
  add(query_603156, "Version", newJString(Version))
  add(query_603156, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_603155.call(nil, query_603156, nil, nil, nil)

var getRestoreFromClusterSnapshot* = Call_GetRestoreFromClusterSnapshot_603116(
    name: "getRestoreFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_GetRestoreFromClusterSnapshot_603117, base: "/",
    url: url_GetRestoreFromClusterSnapshot_603118,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreTableFromClusterSnapshot_603222 = ref object of OpenApiRestCall_599352
proc url_PostRestoreTableFromClusterSnapshot_603224(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRestoreTableFromClusterSnapshot_603223(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603225 = query.getOrDefault("Action")
  valid_603225 = validateParameter(valid_603225, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_603225 != nil:
    section.add "Action", valid_603225
  var valid_603226 = query.getOrDefault("Version")
  valid_603226 = validateParameter(valid_603226, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603226 != nil:
    section.add "Version", valid_603226
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603227 = header.getOrDefault("X-Amz-Date")
  valid_603227 = validateParameter(valid_603227, JString, required = false,
                                 default = nil)
  if valid_603227 != nil:
    section.add "X-Amz-Date", valid_603227
  var valid_603228 = header.getOrDefault("X-Amz-Security-Token")
  valid_603228 = validateParameter(valid_603228, JString, required = false,
                                 default = nil)
  if valid_603228 != nil:
    section.add "X-Amz-Security-Token", valid_603228
  var valid_603229 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603229 = validateParameter(valid_603229, JString, required = false,
                                 default = nil)
  if valid_603229 != nil:
    section.add "X-Amz-Content-Sha256", valid_603229
  var valid_603230 = header.getOrDefault("X-Amz-Algorithm")
  valid_603230 = validateParameter(valid_603230, JString, required = false,
                                 default = nil)
  if valid_603230 != nil:
    section.add "X-Amz-Algorithm", valid_603230
  var valid_603231 = header.getOrDefault("X-Amz-Signature")
  valid_603231 = validateParameter(valid_603231, JString, required = false,
                                 default = nil)
  if valid_603231 != nil:
    section.add "X-Amz-Signature", valid_603231
  var valid_603232 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603232 = validateParameter(valid_603232, JString, required = false,
                                 default = nil)
  if valid_603232 != nil:
    section.add "X-Amz-SignedHeaders", valid_603232
  var valid_603233 = header.getOrDefault("X-Amz-Credential")
  valid_603233 = validateParameter(valid_603233, JString, required = false,
                                 default = nil)
  if valid_603233 != nil:
    section.add "X-Amz-Credential", valid_603233
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  section = newJObject()
  var valid_603234 = formData.getOrDefault("SourceSchemaName")
  valid_603234 = validateParameter(valid_603234, JString, required = false,
                                 default = nil)
  if valid_603234 != nil:
    section.add "SourceSchemaName", valid_603234
  assert formData != nil, "formData argument is necessary due to required `SourceDatabaseName` field"
  var valid_603235 = formData.getOrDefault("SourceDatabaseName")
  valid_603235 = validateParameter(valid_603235, JString, required = true,
                                 default = nil)
  if valid_603235 != nil:
    section.add "SourceDatabaseName", valid_603235
  var valid_603236 = formData.getOrDefault("SourceTableName")
  valid_603236 = validateParameter(valid_603236, JString, required = true,
                                 default = nil)
  if valid_603236 != nil:
    section.add "SourceTableName", valid_603236
  var valid_603237 = formData.getOrDefault("ClusterIdentifier")
  valid_603237 = validateParameter(valid_603237, JString, required = true,
                                 default = nil)
  if valid_603237 != nil:
    section.add "ClusterIdentifier", valid_603237
  var valid_603238 = formData.getOrDefault("TargetDatabaseName")
  valid_603238 = validateParameter(valid_603238, JString, required = false,
                                 default = nil)
  if valid_603238 != nil:
    section.add "TargetDatabaseName", valid_603238
  var valid_603239 = formData.getOrDefault("SnapshotIdentifier")
  valid_603239 = validateParameter(valid_603239, JString, required = true,
                                 default = nil)
  if valid_603239 != nil:
    section.add "SnapshotIdentifier", valid_603239
  var valid_603240 = formData.getOrDefault("TargetSchemaName")
  valid_603240 = validateParameter(valid_603240, JString, required = false,
                                 default = nil)
  if valid_603240 != nil:
    section.add "TargetSchemaName", valid_603240
  var valid_603241 = formData.getOrDefault("NewTableName")
  valid_603241 = validateParameter(valid_603241, JString, required = true,
                                 default = nil)
  if valid_603241 != nil:
    section.add "NewTableName", valid_603241
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603242: Call_PostRestoreTableFromClusterSnapshot_603222;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_603242.validator(path, query, header, formData, body)
  let scheme = call_603242.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603242.url(scheme.get, call_603242.host, call_603242.base,
                         call_603242.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603242, url, valid)

proc call*(call_603243: Call_PostRestoreTableFromClusterSnapshot_603222;
          SourceDatabaseName: string; SourceTableName: string;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          NewTableName: string; SourceSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          TargetDatabaseName: string = ""; TargetSchemaName: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   Version: string (required)
  var query_603244 = newJObject()
  var formData_603245 = newJObject()
  add(formData_603245, "SourceSchemaName", newJString(SourceSchemaName))
  add(formData_603245, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(formData_603245, "SourceTableName", newJString(SourceTableName))
  add(query_603244, "Action", newJString(Action))
  add(formData_603245, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_603245, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(formData_603245, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_603245, "TargetSchemaName", newJString(TargetSchemaName))
  add(formData_603245, "NewTableName", newJString(NewTableName))
  add(query_603244, "Version", newJString(Version))
  result = call_603243.call(nil, query_603244, nil, formData_603245, nil)

var postRestoreTableFromClusterSnapshot* = Call_PostRestoreTableFromClusterSnapshot_603222(
    name: "postRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_PostRestoreTableFromClusterSnapshot_603223, base: "/",
    url: url_PostRestoreTableFromClusterSnapshot_603224,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreTableFromClusterSnapshot_603199 = ref object of OpenApiRestCall_599352
proc url_GetRestoreTableFromClusterSnapshot_603201(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRestoreTableFromClusterSnapshot_603200(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   Action: JString (required)
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   Version: JString (required)
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SourceDatabaseName` field"
  var valid_603202 = query.getOrDefault("SourceDatabaseName")
  valid_603202 = validateParameter(valid_603202, JString, required = true,
                                 default = nil)
  if valid_603202 != nil:
    section.add "SourceDatabaseName", valid_603202
  var valid_603203 = query.getOrDefault("SourceTableName")
  valid_603203 = validateParameter(valid_603203, JString, required = true,
                                 default = nil)
  if valid_603203 != nil:
    section.add "SourceTableName", valid_603203
  var valid_603204 = query.getOrDefault("SourceSchemaName")
  valid_603204 = validateParameter(valid_603204, JString, required = false,
                                 default = nil)
  if valid_603204 != nil:
    section.add "SourceSchemaName", valid_603204
  var valid_603205 = query.getOrDefault("ClusterIdentifier")
  valid_603205 = validateParameter(valid_603205, JString, required = true,
                                 default = nil)
  if valid_603205 != nil:
    section.add "ClusterIdentifier", valid_603205
  var valid_603206 = query.getOrDefault("Action")
  valid_603206 = validateParameter(valid_603206, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_603206 != nil:
    section.add "Action", valid_603206
  var valid_603207 = query.getOrDefault("TargetDatabaseName")
  valid_603207 = validateParameter(valid_603207, JString, required = false,
                                 default = nil)
  if valid_603207 != nil:
    section.add "TargetDatabaseName", valid_603207
  var valid_603208 = query.getOrDefault("NewTableName")
  valid_603208 = validateParameter(valid_603208, JString, required = true,
                                 default = nil)
  if valid_603208 != nil:
    section.add "NewTableName", valid_603208
  var valid_603209 = query.getOrDefault("SnapshotIdentifier")
  valid_603209 = validateParameter(valid_603209, JString, required = true,
                                 default = nil)
  if valid_603209 != nil:
    section.add "SnapshotIdentifier", valid_603209
  var valid_603210 = query.getOrDefault("Version")
  valid_603210 = validateParameter(valid_603210, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603210 != nil:
    section.add "Version", valid_603210
  var valid_603211 = query.getOrDefault("TargetSchemaName")
  valid_603211 = validateParameter(valid_603211, JString, required = false,
                                 default = nil)
  if valid_603211 != nil:
    section.add "TargetSchemaName", valid_603211
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603212 = header.getOrDefault("X-Amz-Date")
  valid_603212 = validateParameter(valid_603212, JString, required = false,
                                 default = nil)
  if valid_603212 != nil:
    section.add "X-Amz-Date", valid_603212
  var valid_603213 = header.getOrDefault("X-Amz-Security-Token")
  valid_603213 = validateParameter(valid_603213, JString, required = false,
                                 default = nil)
  if valid_603213 != nil:
    section.add "X-Amz-Security-Token", valid_603213
  var valid_603214 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603214 = validateParameter(valid_603214, JString, required = false,
                                 default = nil)
  if valid_603214 != nil:
    section.add "X-Amz-Content-Sha256", valid_603214
  var valid_603215 = header.getOrDefault("X-Amz-Algorithm")
  valid_603215 = validateParameter(valid_603215, JString, required = false,
                                 default = nil)
  if valid_603215 != nil:
    section.add "X-Amz-Algorithm", valid_603215
  var valid_603216 = header.getOrDefault("X-Amz-Signature")
  valid_603216 = validateParameter(valid_603216, JString, required = false,
                                 default = nil)
  if valid_603216 != nil:
    section.add "X-Amz-Signature", valid_603216
  var valid_603217 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603217 = validateParameter(valid_603217, JString, required = false,
                                 default = nil)
  if valid_603217 != nil:
    section.add "X-Amz-SignedHeaders", valid_603217
  var valid_603218 = header.getOrDefault("X-Amz-Credential")
  valid_603218 = validateParameter(valid_603218, JString, required = false,
                                 default = nil)
  if valid_603218 != nil:
    section.add "X-Amz-Credential", valid_603218
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603219: Call_GetRestoreTableFromClusterSnapshot_603199;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_603219.validator(path, query, header, formData, body)
  let scheme = call_603219.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603219.url(scheme.get, call_603219.host, call_603219.base,
                         call_603219.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603219, url, valid)

proc call*(call_603220: Call_GetRestoreTableFromClusterSnapshot_603199;
          SourceDatabaseName: string; SourceTableName: string;
          ClusterIdentifier: string; NewTableName: string;
          SnapshotIdentifier: string; SourceSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          TargetDatabaseName: string = ""; Version: string = "2012-12-01";
          TargetSchemaName: string = ""): Recallable =
  ## getRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   Action: string (required)
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   Version: string (required)
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  var query_603221 = newJObject()
  add(query_603221, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_603221, "SourceTableName", newJString(SourceTableName))
  add(query_603221, "SourceSchemaName", newJString(SourceSchemaName))
  add(query_603221, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603221, "Action", newJString(Action))
  add(query_603221, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(query_603221, "NewTableName", newJString(NewTableName))
  add(query_603221, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603221, "Version", newJString(Version))
  add(query_603221, "TargetSchemaName", newJString(TargetSchemaName))
  result = call_603220.call(nil, query_603221, nil, nil, nil)

var getRestoreTableFromClusterSnapshot* = Call_GetRestoreTableFromClusterSnapshot_603199(
    name: "getRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_GetRestoreTableFromClusterSnapshot_603200, base: "/",
    url: url_GetRestoreTableFromClusterSnapshot_603201,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeClusterSecurityGroupIngress_603265 = ref object of OpenApiRestCall_599352
proc url_PostRevokeClusterSecurityGroupIngress_603267(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeClusterSecurityGroupIngress_603266(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603268 = query.getOrDefault("Action")
  valid_603268 = validateParameter(valid_603268, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_603268 != nil:
    section.add "Action", valid_603268
  var valid_603269 = query.getOrDefault("Version")
  valid_603269 = validateParameter(valid_603269, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603269 != nil:
    section.add "Version", valid_603269
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603270 = header.getOrDefault("X-Amz-Date")
  valid_603270 = validateParameter(valid_603270, JString, required = false,
                                 default = nil)
  if valid_603270 != nil:
    section.add "X-Amz-Date", valid_603270
  var valid_603271 = header.getOrDefault("X-Amz-Security-Token")
  valid_603271 = validateParameter(valid_603271, JString, required = false,
                                 default = nil)
  if valid_603271 != nil:
    section.add "X-Amz-Security-Token", valid_603271
  var valid_603272 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603272 = validateParameter(valid_603272, JString, required = false,
                                 default = nil)
  if valid_603272 != nil:
    section.add "X-Amz-Content-Sha256", valid_603272
  var valid_603273 = header.getOrDefault("X-Amz-Algorithm")
  valid_603273 = validateParameter(valid_603273, JString, required = false,
                                 default = nil)
  if valid_603273 != nil:
    section.add "X-Amz-Algorithm", valid_603273
  var valid_603274 = header.getOrDefault("X-Amz-Signature")
  valid_603274 = validateParameter(valid_603274, JString, required = false,
                                 default = nil)
  if valid_603274 != nil:
    section.add "X-Amz-Signature", valid_603274
  var valid_603275 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603275 = validateParameter(valid_603275, JString, required = false,
                                 default = nil)
  if valid_603275 != nil:
    section.add "X-Amz-SignedHeaders", valid_603275
  var valid_603276 = header.getOrDefault("X-Amz-Credential")
  valid_603276 = validateParameter(valid_603276, JString, required = false,
                                 default = nil)
  if valid_603276 != nil:
    section.add "X-Amz-Credential", valid_603276
  result.add "header", section
  ## parameters in `formData` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  section = newJObject()
  var valid_603277 = formData.getOrDefault("EC2SecurityGroupName")
  valid_603277 = validateParameter(valid_603277, JString, required = false,
                                 default = nil)
  if valid_603277 != nil:
    section.add "EC2SecurityGroupName", valid_603277
  var valid_603278 = formData.getOrDefault("CIDRIP")
  valid_603278 = validateParameter(valid_603278, JString, required = false,
                                 default = nil)
  if valid_603278 != nil:
    section.add "CIDRIP", valid_603278
  var valid_603279 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_603279 = validateParameter(valid_603279, JString, required = false,
                                 default = nil)
  if valid_603279 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_603279
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_603280 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_603280 = validateParameter(valid_603280, JString, required = true,
                                 default = nil)
  if valid_603280 != nil:
    section.add "ClusterSecurityGroupName", valid_603280
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603281: Call_PostRevokeClusterSecurityGroupIngress_603265;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_603281.validator(path, query, header, formData, body)
  let scheme = call_603281.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603281.url(scheme.get, call_603281.host, call_603281.base,
                         call_603281.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603281, url, valid)

proc call*(call_603282: Call_PostRevokeClusterSecurityGroupIngress_603265;
          ClusterSecurityGroupName: string;
          Action: string = "RevokeClusterSecurityGroupIngress";
          EC2SecurityGroupName: string = ""; CIDRIP: string = "";
          Version: string = "2012-12-01"; EC2SecurityGroupOwnerId: string = ""): Recallable =
  ## postRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   Version: string (required)
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  var query_603283 = newJObject()
  var formData_603284 = newJObject()
  add(query_603283, "Action", newJString(Action))
  add(formData_603284, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_603284, "CIDRIP", newJString(CIDRIP))
  add(query_603283, "Version", newJString(Version))
  add(formData_603284, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_603284, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  result = call_603282.call(nil, query_603283, nil, formData_603284, nil)

var postRevokeClusterSecurityGroupIngress* = Call_PostRevokeClusterSecurityGroupIngress_603265(
    name: "postRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_PostRevokeClusterSecurityGroupIngress_603266, base: "/",
    url: url_PostRevokeClusterSecurityGroupIngress_603267,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeClusterSecurityGroupIngress_603246 = ref object of OpenApiRestCall_599352
proc url_GetRevokeClusterSecurityGroupIngress_603248(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeClusterSecurityGroupIngress_603247(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_603249 = query.getOrDefault("ClusterSecurityGroupName")
  valid_603249 = validateParameter(valid_603249, JString, required = true,
                                 default = nil)
  if valid_603249 != nil:
    section.add "ClusterSecurityGroupName", valid_603249
  var valid_603250 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_603250 = validateParameter(valid_603250, JString, required = false,
                                 default = nil)
  if valid_603250 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_603250
  var valid_603251 = query.getOrDefault("Action")
  valid_603251 = validateParameter(valid_603251, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_603251 != nil:
    section.add "Action", valid_603251
  var valid_603252 = query.getOrDefault("CIDRIP")
  valid_603252 = validateParameter(valid_603252, JString, required = false,
                                 default = nil)
  if valid_603252 != nil:
    section.add "CIDRIP", valid_603252
  var valid_603253 = query.getOrDefault("EC2SecurityGroupName")
  valid_603253 = validateParameter(valid_603253, JString, required = false,
                                 default = nil)
  if valid_603253 != nil:
    section.add "EC2SecurityGroupName", valid_603253
  var valid_603254 = query.getOrDefault("Version")
  valid_603254 = validateParameter(valid_603254, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603254 != nil:
    section.add "Version", valid_603254
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603255 = header.getOrDefault("X-Amz-Date")
  valid_603255 = validateParameter(valid_603255, JString, required = false,
                                 default = nil)
  if valid_603255 != nil:
    section.add "X-Amz-Date", valid_603255
  var valid_603256 = header.getOrDefault("X-Amz-Security-Token")
  valid_603256 = validateParameter(valid_603256, JString, required = false,
                                 default = nil)
  if valid_603256 != nil:
    section.add "X-Amz-Security-Token", valid_603256
  var valid_603257 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603257 = validateParameter(valid_603257, JString, required = false,
                                 default = nil)
  if valid_603257 != nil:
    section.add "X-Amz-Content-Sha256", valid_603257
  var valid_603258 = header.getOrDefault("X-Amz-Algorithm")
  valid_603258 = validateParameter(valid_603258, JString, required = false,
                                 default = nil)
  if valid_603258 != nil:
    section.add "X-Amz-Algorithm", valid_603258
  var valid_603259 = header.getOrDefault("X-Amz-Signature")
  valid_603259 = validateParameter(valid_603259, JString, required = false,
                                 default = nil)
  if valid_603259 != nil:
    section.add "X-Amz-Signature", valid_603259
  var valid_603260 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603260 = validateParameter(valid_603260, JString, required = false,
                                 default = nil)
  if valid_603260 != nil:
    section.add "X-Amz-SignedHeaders", valid_603260
  var valid_603261 = header.getOrDefault("X-Amz-Credential")
  valid_603261 = validateParameter(valid_603261, JString, required = false,
                                 default = nil)
  if valid_603261 != nil:
    section.add "X-Amz-Credential", valid_603261
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603262: Call_GetRevokeClusterSecurityGroupIngress_603246;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_603262.validator(path, query, header, formData, body)
  let scheme = call_603262.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603262.url(scheme.get, call_603262.host, call_603262.base,
                         call_603262.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603262, url, valid)

proc call*(call_603263: Call_GetRevokeClusterSecurityGroupIngress_603246;
          ClusterSecurityGroupName: string; EC2SecurityGroupOwnerId: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress"; CIDRIP: string = "";
          EC2SecurityGroupName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   Action: string (required)
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   Version: string (required)
  var query_603264 = newJObject()
  add(query_603264, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_603264, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_603264, "Action", newJString(Action))
  add(query_603264, "CIDRIP", newJString(CIDRIP))
  add(query_603264, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_603264, "Version", newJString(Version))
  result = call_603263.call(nil, query_603264, nil, nil, nil)

var getRevokeClusterSecurityGroupIngress* = Call_GetRevokeClusterSecurityGroupIngress_603246(
    name: "getRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_GetRevokeClusterSecurityGroupIngress_603247, base: "/",
    url: url_GetRevokeClusterSecurityGroupIngress_603248,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeSnapshotAccess_603303 = ref object of OpenApiRestCall_599352
proc url_PostRevokeSnapshotAccess_603305(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRevokeSnapshotAccess_603304(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603306 = query.getOrDefault("Action")
  valid_603306 = validateParameter(valid_603306, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_603306 != nil:
    section.add "Action", valid_603306
  var valid_603307 = query.getOrDefault("Version")
  valid_603307 = validateParameter(valid_603307, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603307 != nil:
    section.add "Version", valid_603307
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603308 = header.getOrDefault("X-Amz-Date")
  valid_603308 = validateParameter(valid_603308, JString, required = false,
                                 default = nil)
  if valid_603308 != nil:
    section.add "X-Amz-Date", valid_603308
  var valid_603309 = header.getOrDefault("X-Amz-Security-Token")
  valid_603309 = validateParameter(valid_603309, JString, required = false,
                                 default = nil)
  if valid_603309 != nil:
    section.add "X-Amz-Security-Token", valid_603309
  var valid_603310 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603310 = validateParameter(valid_603310, JString, required = false,
                                 default = nil)
  if valid_603310 != nil:
    section.add "X-Amz-Content-Sha256", valid_603310
  var valid_603311 = header.getOrDefault("X-Amz-Algorithm")
  valid_603311 = validateParameter(valid_603311, JString, required = false,
                                 default = nil)
  if valid_603311 != nil:
    section.add "X-Amz-Algorithm", valid_603311
  var valid_603312 = header.getOrDefault("X-Amz-Signature")
  valid_603312 = validateParameter(valid_603312, JString, required = false,
                                 default = nil)
  if valid_603312 != nil:
    section.add "X-Amz-Signature", valid_603312
  var valid_603313 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603313 = validateParameter(valid_603313, JString, required = false,
                                 default = nil)
  if valid_603313 != nil:
    section.add "X-Amz-SignedHeaders", valid_603313
  var valid_603314 = header.getOrDefault("X-Amz-Credential")
  valid_603314 = validateParameter(valid_603314, JString, required = false,
                                 default = nil)
  if valid_603314 != nil:
    section.add "X-Amz-Credential", valid_603314
  result.add "header", section
  ## parameters in `formData` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_603315 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_603315 = validateParameter(valid_603315, JString, required = true,
                                 default = nil)
  if valid_603315 != nil:
    section.add "AccountWithRestoreAccess", valid_603315
  var valid_603316 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_603316 = validateParameter(valid_603316, JString, required = false,
                                 default = nil)
  if valid_603316 != nil:
    section.add "SnapshotClusterIdentifier", valid_603316
  var valid_603317 = formData.getOrDefault("SnapshotIdentifier")
  valid_603317 = validateParameter(valid_603317, JString, required = true,
                                 default = nil)
  if valid_603317 != nil:
    section.add "SnapshotIdentifier", valid_603317
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603318: Call_PostRevokeSnapshotAccess_603303; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603318.validator(path, query, header, formData, body)
  let scheme = call_603318.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603318.url(scheme.get, call_603318.host, call_603318.base,
                         call_603318.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603318, url, valid)

proc call*(call_603319: Call_PostRevokeSnapshotAccess_603303;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "RevokeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## postRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: string (required)
  var query_603320 = newJObject()
  var formData_603321 = newJObject()
  add(formData_603321, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_603321, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_603320, "Action", newJString(Action))
  add(formData_603321, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603320, "Version", newJString(Version))
  result = call_603319.call(nil, query_603320, nil, formData_603321, nil)

var postRevokeSnapshotAccess* = Call_PostRevokeSnapshotAccess_603303(
    name: "postRevokeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_PostRevokeSnapshotAccess_603304, base: "/",
    url: url_PostRevokeSnapshotAccess_603305, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeSnapshotAccess_603285 = ref object of OpenApiRestCall_599352
proc url_GetRevokeSnapshotAccess_603287(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRevokeSnapshotAccess_603286(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   Action: JString (required)
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `AccountWithRestoreAccess` field"
  var valid_603288 = query.getOrDefault("AccountWithRestoreAccess")
  valid_603288 = validateParameter(valid_603288, JString, required = true,
                                 default = nil)
  if valid_603288 != nil:
    section.add "AccountWithRestoreAccess", valid_603288
  var valid_603289 = query.getOrDefault("Action")
  valid_603289 = validateParameter(valid_603289, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_603289 != nil:
    section.add "Action", valid_603289
  var valid_603290 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_603290 = validateParameter(valid_603290, JString, required = false,
                                 default = nil)
  if valid_603290 != nil:
    section.add "SnapshotClusterIdentifier", valid_603290
  var valid_603291 = query.getOrDefault("SnapshotIdentifier")
  valid_603291 = validateParameter(valid_603291, JString, required = true,
                                 default = nil)
  if valid_603291 != nil:
    section.add "SnapshotIdentifier", valid_603291
  var valid_603292 = query.getOrDefault("Version")
  valid_603292 = validateParameter(valid_603292, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603292 != nil:
    section.add "Version", valid_603292
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603293 = header.getOrDefault("X-Amz-Date")
  valid_603293 = validateParameter(valid_603293, JString, required = false,
                                 default = nil)
  if valid_603293 != nil:
    section.add "X-Amz-Date", valid_603293
  var valid_603294 = header.getOrDefault("X-Amz-Security-Token")
  valid_603294 = validateParameter(valid_603294, JString, required = false,
                                 default = nil)
  if valid_603294 != nil:
    section.add "X-Amz-Security-Token", valid_603294
  var valid_603295 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603295 = validateParameter(valid_603295, JString, required = false,
                                 default = nil)
  if valid_603295 != nil:
    section.add "X-Amz-Content-Sha256", valid_603295
  var valid_603296 = header.getOrDefault("X-Amz-Algorithm")
  valid_603296 = validateParameter(valid_603296, JString, required = false,
                                 default = nil)
  if valid_603296 != nil:
    section.add "X-Amz-Algorithm", valid_603296
  var valid_603297 = header.getOrDefault("X-Amz-Signature")
  valid_603297 = validateParameter(valid_603297, JString, required = false,
                                 default = nil)
  if valid_603297 != nil:
    section.add "X-Amz-Signature", valid_603297
  var valid_603298 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603298 = validateParameter(valid_603298, JString, required = false,
                                 default = nil)
  if valid_603298 != nil:
    section.add "X-Amz-SignedHeaders", valid_603298
  var valid_603299 = header.getOrDefault("X-Amz-Credential")
  valid_603299 = validateParameter(valid_603299, JString, required = false,
                                 default = nil)
  if valid_603299 != nil:
    section.add "X-Amz-Credential", valid_603299
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603300: Call_GetRevokeSnapshotAccess_603285; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_603300.validator(path, query, header, formData, body)
  let scheme = call_603300.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603300.url(scheme.get, call_603300.host, call_603300.base,
                         call_603300.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603300, url, valid)

proc call*(call_603301: Call_GetRevokeSnapshotAccess_603285;
          AccountWithRestoreAccess: string; SnapshotIdentifier: string;
          Action: string = "RevokeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Version: string (required)
  var query_603302 = newJObject()
  add(query_603302, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(query_603302, "Action", newJString(Action))
  add(query_603302, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_603302, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_603302, "Version", newJString(Version))
  result = call_603301.call(nil, query_603302, nil, nil, nil)

var getRevokeSnapshotAccess* = Call_GetRevokeSnapshotAccess_603285(
    name: "getRevokeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_GetRevokeSnapshotAccess_603286, base: "/",
    url: url_GetRevokeSnapshotAccess_603287, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRotateEncryptionKey_603338 = ref object of OpenApiRestCall_599352
proc url_PostRotateEncryptionKey_603340(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_PostRotateEncryptionKey_603339(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603341 = query.getOrDefault("Action")
  valid_603341 = validateParameter(valid_603341, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_603341 != nil:
    section.add "Action", valid_603341
  var valid_603342 = query.getOrDefault("Version")
  valid_603342 = validateParameter(valid_603342, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603342 != nil:
    section.add "Version", valid_603342
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603343 = header.getOrDefault("X-Amz-Date")
  valid_603343 = validateParameter(valid_603343, JString, required = false,
                                 default = nil)
  if valid_603343 != nil:
    section.add "X-Amz-Date", valid_603343
  var valid_603344 = header.getOrDefault("X-Amz-Security-Token")
  valid_603344 = validateParameter(valid_603344, JString, required = false,
                                 default = nil)
  if valid_603344 != nil:
    section.add "X-Amz-Security-Token", valid_603344
  var valid_603345 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603345 = validateParameter(valid_603345, JString, required = false,
                                 default = nil)
  if valid_603345 != nil:
    section.add "X-Amz-Content-Sha256", valid_603345
  var valid_603346 = header.getOrDefault("X-Amz-Algorithm")
  valid_603346 = validateParameter(valid_603346, JString, required = false,
                                 default = nil)
  if valid_603346 != nil:
    section.add "X-Amz-Algorithm", valid_603346
  var valid_603347 = header.getOrDefault("X-Amz-Signature")
  valid_603347 = validateParameter(valid_603347, JString, required = false,
                                 default = nil)
  if valid_603347 != nil:
    section.add "X-Amz-Signature", valid_603347
  var valid_603348 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603348 = validateParameter(valid_603348, JString, required = false,
                                 default = nil)
  if valid_603348 != nil:
    section.add "X-Amz-SignedHeaders", valid_603348
  var valid_603349 = header.getOrDefault("X-Amz-Credential")
  valid_603349 = validateParameter(valid_603349, JString, required = false,
                                 default = nil)
  if valid_603349 != nil:
    section.add "X-Amz-Credential", valid_603349
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_603350 = formData.getOrDefault("ClusterIdentifier")
  valid_603350 = validateParameter(valid_603350, JString, required = true,
                                 default = nil)
  if valid_603350 != nil:
    section.add "ClusterIdentifier", valid_603350
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603351: Call_PostRotateEncryptionKey_603338; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_603351.validator(path, query, header, formData, body)
  let scheme = call_603351.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603351.url(scheme.get, call_603351.host, call_603351.base,
                         call_603351.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603351, url, valid)

proc call*(call_603352: Call_PostRotateEncryptionKey_603338;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## postRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_603353 = newJObject()
  var formData_603354 = newJObject()
  add(query_603353, "Action", newJString(Action))
  add(formData_603354, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603353, "Version", newJString(Version))
  result = call_603352.call(nil, query_603353, nil, formData_603354, nil)

var postRotateEncryptionKey* = Call_PostRotateEncryptionKey_603338(
    name: "postRotateEncryptionKey", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_PostRotateEncryptionKey_603339, base: "/",
    url: url_PostRotateEncryptionKey_603340, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRotateEncryptionKey_603322 = ref object of OpenApiRestCall_599352
proc url_GetRotateEncryptionKey_603324(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  if base ==
      "/" and route.startsWith "/":
    result.path = route
  else:
    result.path = base & route

proc validate_GetRotateEncryptionKey_603323(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_603325 = query.getOrDefault("Action")
  valid_603325 = validateParameter(valid_603325, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_603325 != nil:
    section.add "Action", valid_603325
  var valid_603326 = query.getOrDefault("ClusterIdentifier")
  valid_603326 = validateParameter(valid_603326, JString, required = true,
                                 default = nil)
  if valid_603326 != nil:
    section.add "ClusterIdentifier", valid_603326
  var valid_603327 = query.getOrDefault("Version")
  valid_603327 = validateParameter(valid_603327, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_603327 != nil:
    section.add "Version", valid_603327
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Date: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-Signature: JString
  ##   X-Amz-SignedHeaders: JString
  ##   X-Amz-Credential: JString
  section = newJObject()
  var valid_603328 = header.getOrDefault("X-Amz-Date")
  valid_603328 = validateParameter(valid_603328, JString, required = false,
                                 default = nil)
  if valid_603328 != nil:
    section.add "X-Amz-Date", valid_603328
  var valid_603329 = header.getOrDefault("X-Amz-Security-Token")
  valid_603329 = validateParameter(valid_603329, JString, required = false,
                                 default = nil)
  if valid_603329 != nil:
    section.add "X-Amz-Security-Token", valid_603329
  var valid_603330 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_603330 = validateParameter(valid_603330, JString, required = false,
                                 default = nil)
  if valid_603330 != nil:
    section.add "X-Amz-Content-Sha256", valid_603330
  var valid_603331 = header.getOrDefault("X-Amz-Algorithm")
  valid_603331 = validateParameter(valid_603331, JString, required = false,
                                 default = nil)
  if valid_603331 != nil:
    section.add "X-Amz-Algorithm", valid_603331
  var valid_603332 = header.getOrDefault("X-Amz-Signature")
  valid_603332 = validateParameter(valid_603332, JString, required = false,
                                 default = nil)
  if valid_603332 != nil:
    section.add "X-Amz-Signature", valid_603332
  var valid_603333 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_603333 = validateParameter(valid_603333, JString, required = false,
                                 default = nil)
  if valid_603333 != nil:
    section.add "X-Amz-SignedHeaders", valid_603333
  var valid_603334 = header.getOrDefault("X-Amz-Credential")
  valid_603334 = validateParameter(valid_603334, JString, required = false,
                                 default = nil)
  if valid_603334 != nil:
    section.add "X-Amz-Credential", valid_603334
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_603335: Call_GetRotateEncryptionKey_603322; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_603335.validator(path, query, header, formData, body)
  let scheme = call_603335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_603335.url(scheme.get, call_603335.host, call_603335.base,
                         call_603335.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = atozHook(call_603335, url, valid)

proc call*(call_603336: Call_GetRotateEncryptionKey_603322;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## getRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_603337 = newJObject()
  add(query_603337, "Action", newJString(Action))
  add(query_603337, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_603337, "Version", newJString(Version))
  result = call_603336.call(nil, query_603337, nil, nil, nil)

var getRotateEncryptionKey* = Call_GetRotateEncryptionKey_603322(
    name: "getRotateEncryptionKey", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_GetRotateEncryptionKey_603323, base: "/",
    url: url_GetRotateEncryptionKey_603324, schemes: {Scheme.Https, Scheme.Http})
export
  rest

proc atozSign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", "")
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", "")
    region = os.getEnv("AWS_REGION", "")
  assert secret != "", "need secret key in env"
  assert access != "", "need access key in env"
  assert region != "", "need region in env"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method atozHook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
  result.atozSign(input.getOrDefault("query"), SHA256)
