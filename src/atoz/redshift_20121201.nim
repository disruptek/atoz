
import
  json, options, hashes, uri, tables, rest, os, uri, strutils, httpcore, sigv4

## auto-generated via openapi macro
## title: Amazon Redshift
## version: 2012-12-01
## termsOfService: https://aws.amazon.com/service-terms/
## license:
##     name: Apache 2.0 License
##     url: http://www.apache.org/licenses/
## 
## <fullname>Amazon Redshift</fullname> <p> <b>Overview</b> </p> <p>This is an interface reference for Amazon Redshift. It contains documentation for one of the programming or command line interfaces you can use to manage Amazon Redshift clusters. Note that Amazon Redshift is asynchronous, which means that some interfaces may require techniques, such as polling or asynchronous callback handlers, to determine when a command has been applied. In this reference, the parameter descriptions indicate whether a change is applied immediately, on the next instance reboot, or during the next maintenance window. For a summary of the Amazon Redshift cluster management interfaces, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/using-aws-sdk.html">Using the Amazon Redshift Management Interfaces</a>.</p> <p>Amazon Redshift manages all the work of setting up, operating, and scaling a data warehouse: provisioning capacity, monitoring and backing up the cluster, and applying patches and upgrades to the Amazon Redshift engine. You can focus on using your data to acquire new insights for your business and customers.</p> <p>If you are a first-time user of Amazon Redshift, we recommend that you begin by reading the <a href="https://docs.aws.amazon.com/redshift/latest/gsg/getting-started.html">Amazon Redshift Getting Started Guide</a>.</p> <p>If you are a database developer, the <a href="https://docs.aws.amazon.com/redshift/latest/dg/welcome.html">Amazon Redshift Database Developer Guide</a> explains how to design, build, query, and maintain the databases that make up your data warehouse. </p>
## 
## Amazon Web Services documentation
## https://docs.aws.amazon.com/redshift/
type
  Scheme {.pure.} = enum
    Https = "https", Http = "http", Wss = "wss", Ws = "ws"
  ValidatorSignature = proc (query: JsonNode = nil; body: JsonNode = nil;
                          header: JsonNode = nil; path: JsonNode = nil;
                          formData: JsonNode = nil): JsonNode
  OpenApiRestCall = ref object of RestCall
    validator*: ValidatorSignature
    route*: string
    base*: string
    host*: string
    schemes*: set[Scheme]
    url*: proc (protocol: Scheme; host: string; base: string; route: string;
              path: JsonNode; query: JsonNode): Uri

  OpenApiRestCall_592348 = ref object of OpenApiRestCall
proc hash(scheme: Scheme): Hash {.used.} =
  result = hash(ord(scheme))

proc clone[T: OpenApiRestCall_592348](t: T): T {.used.} =
  result = T(name: t.name, meth: t.meth, host: t.host, base: t.base, route: t.route,
           schemes: t.schemes, validator: t.validator, url: t.url)

proc pickScheme(t: OpenApiRestCall_592348): Option[Scheme] {.used.} =
  ## select a supported scheme from a set of candidates
  for scheme in Scheme.low ..
      Scheme.high:
    if scheme notin t.schemes:
      continue
    if scheme in [Scheme.Https, Scheme.Wss]:
      when defined(ssl):
        return some(scheme)
      else:
        continue
    return some(scheme)

proc validateParameter(js: JsonNode; kind: JsonNodeKind; required: bool;
                      default: JsonNode = nil): JsonNode =
  ## ensure an input is of the correct json type and yield
  ## a suitable default value when appropriate
  if js ==
      nil:
    if default != nil:
      return validateParameter(default, kind, required = required)
  result = js
  if result ==
      nil:
    assert not required, $kind & " expected; received nil"
    if required:
      result = newJNull()
  else:
    assert js.kind ==
        kind, $kind & " expected; received " &
        $js.kind

type
  KeyVal {.used.} = tuple[key: string, val: string]
  PathTokenKind = enum
    ConstantSegment, VariableSegment
  PathToken = tuple[kind: PathTokenKind, value: string]
proc queryString(query: JsonNode): string {.used.} =
  var qs: seq[KeyVal]
  if query == nil:
    return ""
  for k, v in query.pairs:
    qs.add (key: k, val: v.getStr)
  result = encodeQuery(qs)

proc hydratePath(input: JsonNode; segments: seq[PathToken]): Option[string] {.used.} =
  ## reconstitute a path with constants and variable values taken from json
  var head: string
  if segments.len == 0:
    return some("")
  head = segments[0].value
  case segments[0].kind
  of ConstantSegment:
    discard
  of VariableSegment:
    if head notin input:
      return
    let js = input[head]
    case js.kind
    of JInt, JFloat, JNull, JBool:
      head = $js
    of JString:
      head = js.getStr
    else:
      return
  var remainder = input.hydratePath(segments[1 ..^ 1])
  if remainder.isNone:
    return
  result = some(head & remainder.get)

const
  awsServers = {Scheme.Http: {"ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com", "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
                           "us-west-2": "redshift.us-west-2.amazonaws.com",
                           "eu-west-2": "redshift.eu-west-2.amazonaws.com", "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com", "eu-central-1": "redshift.eu-central-1.amazonaws.com",
                           "us-east-2": "redshift.us-east-2.amazonaws.com",
                           "us-east-1": "redshift.us-east-1.amazonaws.com", "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
                           "ap-south-1": "redshift.ap-south-1.amazonaws.com",
                           "eu-north-1": "redshift.eu-north-1.amazonaws.com", "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
                           "us-west-1": "redshift.us-west-1.amazonaws.com", "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
                           "eu-west-3": "redshift.eu-west-3.amazonaws.com", "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
                           "sa-east-1": "redshift.sa-east-1.amazonaws.com",
                           "eu-west-1": "redshift.eu-west-1.amazonaws.com", "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com", "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com", "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable, Scheme.Https: {
      "ap-northeast-1": "redshift.ap-northeast-1.amazonaws.com",
      "ap-southeast-1": "redshift.ap-southeast-1.amazonaws.com",
      "us-west-2": "redshift.us-west-2.amazonaws.com",
      "eu-west-2": "redshift.eu-west-2.amazonaws.com",
      "ap-northeast-3": "redshift.ap-northeast-3.amazonaws.com",
      "eu-central-1": "redshift.eu-central-1.amazonaws.com",
      "us-east-2": "redshift.us-east-2.amazonaws.com",
      "us-east-1": "redshift.us-east-1.amazonaws.com",
      "cn-northwest-1": "redshift.cn-northwest-1.amazonaws.com.cn",
      "ap-south-1": "redshift.ap-south-1.amazonaws.com",
      "eu-north-1": "redshift.eu-north-1.amazonaws.com",
      "ap-northeast-2": "redshift.ap-northeast-2.amazonaws.com",
      "us-west-1": "redshift.us-west-1.amazonaws.com",
      "us-gov-east-1": "redshift.us-gov-east-1.amazonaws.com",
      "eu-west-3": "redshift.eu-west-3.amazonaws.com",
      "cn-north-1": "redshift.cn-north-1.amazonaws.com.cn",
      "sa-east-1": "redshift.sa-east-1.amazonaws.com",
      "eu-west-1": "redshift.eu-west-1.amazonaws.com",
      "us-gov-west-1": "redshift.us-gov-west-1.amazonaws.com",
      "ap-southeast-2": "redshift.ap-southeast-2.amazonaws.com",
      "ca-central-1": "redshift.ca-central-1.amazonaws.com"}.toTable}.toTable
const
  awsServiceName = "redshift"
method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.}
type
  Call_PostAcceptReservedNodeExchange_592959 = ref object of OpenApiRestCall_592348
proc url_PostAcceptReservedNodeExchange_592961(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostAcceptReservedNodeExchange_592960(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_592962 = query.getOrDefault("Action")
  valid_592962 = validateParameter(valid_592962, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_592962 != nil:
    section.add "Action", valid_592962
  var valid_592963 = query.getOrDefault("Version")
  valid_592963 = validateParameter(valid_592963, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_592963 != nil:
    section.add "Version", valid_592963
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_592964 = header.getOrDefault("X-Amz-Signature")
  valid_592964 = validateParameter(valid_592964, JString, required = false,
                                 default = nil)
  if valid_592964 != nil:
    section.add "X-Amz-Signature", valid_592964
  var valid_592965 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_592965 = validateParameter(valid_592965, JString, required = false,
                                 default = nil)
  if valid_592965 != nil:
    section.add "X-Amz-Content-Sha256", valid_592965
  var valid_592966 = header.getOrDefault("X-Amz-Date")
  valid_592966 = validateParameter(valid_592966, JString, required = false,
                                 default = nil)
  if valid_592966 != nil:
    section.add "X-Amz-Date", valid_592966
  var valid_592967 = header.getOrDefault("X-Amz-Credential")
  valid_592967 = validateParameter(valid_592967, JString, required = false,
                                 default = nil)
  if valid_592967 != nil:
    section.add "X-Amz-Credential", valid_592967
  var valid_592968 = header.getOrDefault("X-Amz-Security-Token")
  valid_592968 = validateParameter(valid_592968, JString, required = false,
                                 default = nil)
  if valid_592968 != nil:
    section.add "X-Amz-Security-Token", valid_592968
  var valid_592969 = header.getOrDefault("X-Amz-Algorithm")
  valid_592969 = validateParameter(valid_592969, JString, required = false,
                                 default = nil)
  if valid_592969 != nil:
    section.add "X-Amz-Algorithm", valid_592969
  var valid_592970 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_592970 = validateParameter(valid_592970, JString, required = false,
                                 default = nil)
  if valid_592970 != nil:
    section.add "X-Amz-SignedHeaders", valid_592970
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_592971 = formData.getOrDefault("ReservedNodeId")
  valid_592971 = validateParameter(valid_592971, JString, required = true,
                                 default = nil)
  if valid_592971 != nil:
    section.add "ReservedNodeId", valid_592971
  var valid_592972 = formData.getOrDefault("TargetReservedNodeOfferingId")
  valid_592972 = validateParameter(valid_592972, JString, required = true,
                                 default = nil)
  if valid_592972 != nil:
    section.add "TargetReservedNodeOfferingId", valid_592972
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592973: Call_PostAcceptReservedNodeExchange_592959; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_592973.validator(path, query, header, formData, body)
  let scheme = call_592973.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592973.url(scheme.get, call_592973.host, call_592973.base,
                         call_592973.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592973, url, valid)

proc call*(call_592974: Call_PostAcceptReservedNodeExchange_592959;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## postAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_592975 = newJObject()
  var formData_592976 = newJObject()
  add(formData_592976, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_592976, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  add(query_592975, "Action", newJString(Action))
  add(query_592975, "Version", newJString(Version))
  result = call_592974.call(nil, query_592975, nil, formData_592976, nil)

var postAcceptReservedNodeExchange* = Call_PostAcceptReservedNodeExchange_592959(
    name: "postAcceptReservedNodeExchange", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_PostAcceptReservedNodeExchange_592960, base: "/",
    url: url_PostAcceptReservedNodeExchange_592961,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAcceptReservedNodeExchange_592687 = ref object of OpenApiRestCall_592348
proc url_GetAcceptReservedNodeExchange_592689(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAcceptReservedNodeExchange_592688(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   Version: JString (required)
  ##   TargetReservedNodeOfferingId: JString (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_592814 = query.getOrDefault("Action")
  valid_592814 = validateParameter(valid_592814, JString, required = true, default = newJString(
      "AcceptReservedNodeExchange"))
  if valid_592814 != nil:
    section.add "Action", valid_592814
  var valid_592815 = query.getOrDefault("ReservedNodeId")
  valid_592815 = validateParameter(valid_592815, JString, required = true,
                                 default = nil)
  if valid_592815 != nil:
    section.add "ReservedNodeId", valid_592815
  var valid_592816 = query.getOrDefault("Version")
  valid_592816 = validateParameter(valid_592816, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_592816 != nil:
    section.add "Version", valid_592816
  var valid_592817 = query.getOrDefault("TargetReservedNodeOfferingId")
  valid_592817 = validateParameter(valid_592817, JString, required = true,
                                 default = nil)
  if valid_592817 != nil:
    section.add "TargetReservedNodeOfferingId", valid_592817
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_592818 = header.getOrDefault("X-Amz-Signature")
  valid_592818 = validateParameter(valid_592818, JString, required = false,
                                 default = nil)
  if valid_592818 != nil:
    section.add "X-Amz-Signature", valid_592818
  var valid_592819 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_592819 = validateParameter(valid_592819, JString, required = false,
                                 default = nil)
  if valid_592819 != nil:
    section.add "X-Amz-Content-Sha256", valid_592819
  var valid_592820 = header.getOrDefault("X-Amz-Date")
  valid_592820 = validateParameter(valid_592820, JString, required = false,
                                 default = nil)
  if valid_592820 != nil:
    section.add "X-Amz-Date", valid_592820
  var valid_592821 = header.getOrDefault("X-Amz-Credential")
  valid_592821 = validateParameter(valid_592821, JString, required = false,
                                 default = nil)
  if valid_592821 != nil:
    section.add "X-Amz-Credential", valid_592821
  var valid_592822 = header.getOrDefault("X-Amz-Security-Token")
  valid_592822 = validateParameter(valid_592822, JString, required = false,
                                 default = nil)
  if valid_592822 != nil:
    section.add "X-Amz-Security-Token", valid_592822
  var valid_592823 = header.getOrDefault("X-Amz-Algorithm")
  valid_592823 = validateParameter(valid_592823, JString, required = false,
                                 default = nil)
  if valid_592823 != nil:
    section.add "X-Amz-Algorithm", valid_592823
  var valid_592824 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_592824 = validateParameter(valid_592824, JString, required = false,
                                 default = nil)
  if valid_592824 != nil:
    section.add "X-Amz-SignedHeaders", valid_592824
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592847: Call_GetAcceptReservedNodeExchange_592687; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ## 
  let valid = call_592847.validator(path, query, header, formData, body)
  let scheme = call_592847.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592847.url(scheme.get, call_592847.host, call_592847.base,
                         call_592847.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592847, url, valid)

proc call*(call_592918: Call_GetAcceptReservedNodeExchange_592687;
          ReservedNodeId: string; TargetReservedNodeOfferingId: string;
          Action: string = "AcceptReservedNodeExchange";
          Version: string = "2012-12-01"): Recallable =
  ## getAcceptReservedNodeExchange
  ## Exchanges a DC1 Reserved Node for a DC2 Reserved Node with no changes to the configuration (term, payment type, or number of nodes) and no additional costs. 
  ##   Action: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier of the DC1 Reserved Node to be exchanged.
  ##   Version: string (required)
  ##   TargetReservedNodeOfferingId: string (required)
  ##                               : The unique identifier of the DC2 Reserved Node offering to be used for the exchange. You can obtain the value for the parameter by calling <a>GetReservedNodeExchangeOfferings</a> 
  var query_592919 = newJObject()
  add(query_592919, "Action", newJString(Action))
  add(query_592919, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_592919, "Version", newJString(Version))
  add(query_592919, "TargetReservedNodeOfferingId",
      newJString(TargetReservedNodeOfferingId))
  result = call_592918.call(nil, query_592919, nil, nil, nil)

var getAcceptReservedNodeExchange* = Call_GetAcceptReservedNodeExchange_592687(
    name: "getAcceptReservedNodeExchange", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AcceptReservedNodeExchange",
    validator: validate_GetAcceptReservedNodeExchange_592688, base: "/",
    url: url_GetAcceptReservedNodeExchange_592689,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeClusterSecurityGroupIngress_592996 = ref object of OpenApiRestCall_592348
proc url_PostAuthorizeClusterSecurityGroupIngress_592998(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostAuthorizeClusterSecurityGroupIngress_592997(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_592999 = query.getOrDefault("Action")
  valid_592999 = validateParameter(valid_592999, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_592999 != nil:
    section.add "Action", valid_592999
  var valid_593000 = query.getOrDefault("Version")
  valid_593000 = validateParameter(valid_593000, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593000 != nil:
    section.add "Version", valid_593000
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593001 = header.getOrDefault("X-Amz-Signature")
  valid_593001 = validateParameter(valid_593001, JString, required = false,
                                 default = nil)
  if valid_593001 != nil:
    section.add "X-Amz-Signature", valid_593001
  var valid_593002 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593002 = validateParameter(valid_593002, JString, required = false,
                                 default = nil)
  if valid_593002 != nil:
    section.add "X-Amz-Content-Sha256", valid_593002
  var valid_593003 = header.getOrDefault("X-Amz-Date")
  valid_593003 = validateParameter(valid_593003, JString, required = false,
                                 default = nil)
  if valid_593003 != nil:
    section.add "X-Amz-Date", valid_593003
  var valid_593004 = header.getOrDefault("X-Amz-Credential")
  valid_593004 = validateParameter(valid_593004, JString, required = false,
                                 default = nil)
  if valid_593004 != nil:
    section.add "X-Amz-Credential", valid_593004
  var valid_593005 = header.getOrDefault("X-Amz-Security-Token")
  valid_593005 = validateParameter(valid_593005, JString, required = false,
                                 default = nil)
  if valid_593005 != nil:
    section.add "X-Amz-Security-Token", valid_593005
  var valid_593006 = header.getOrDefault("X-Amz-Algorithm")
  valid_593006 = validateParameter(valid_593006, JString, required = false,
                                 default = nil)
  if valid_593006 != nil:
    section.add "X-Amz-Algorithm", valid_593006
  var valid_593007 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593007 = validateParameter(valid_593007, JString, required = false,
                                 default = nil)
  if valid_593007 != nil:
    section.add "X-Amz-SignedHeaders", valid_593007
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_593008 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_593008 = validateParameter(valid_593008, JString, required = true,
                                 default = nil)
  if valid_593008 != nil:
    section.add "ClusterSecurityGroupName", valid_593008
  var valid_593009 = formData.getOrDefault("EC2SecurityGroupName")
  valid_593009 = validateParameter(valid_593009, JString, required = false,
                                 default = nil)
  if valid_593009 != nil:
    section.add "EC2SecurityGroupName", valid_593009
  var valid_593010 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_593010 = validateParameter(valid_593010, JString, required = false,
                                 default = nil)
  if valid_593010 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_593010
  var valid_593011 = formData.getOrDefault("CIDRIP")
  valid_593011 = validateParameter(valid_593011, JString, required = false,
                                 default = nil)
  if valid_593011 != nil:
    section.add "CIDRIP", valid_593011
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593012: Call_PostAuthorizeClusterSecurityGroupIngress_592996;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593012.validator(path, query, header, formData, body)
  let scheme = call_593012.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593012.url(scheme.get, call_593012.host, call_593012.base,
                         call_593012.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593012, url, valid)

proc call*(call_593013: Call_PostAuthorizeClusterSecurityGroupIngress_592996;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = ""; CIDRIP: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593014 = newJObject()
  var formData_593015 = newJObject()
  add(formData_593015, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_593015, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_593015, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_593015, "CIDRIP", newJString(CIDRIP))
  add(query_593014, "Action", newJString(Action))
  add(query_593014, "Version", newJString(Version))
  result = call_593013.call(nil, query_593014, nil, formData_593015, nil)

var postAuthorizeClusterSecurityGroupIngress* = Call_PostAuthorizeClusterSecurityGroupIngress_592996(
    name: "postAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_PostAuthorizeClusterSecurityGroupIngress_592997,
    base: "/", url: url_PostAuthorizeClusterSecurityGroupIngress_592998,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeClusterSecurityGroupIngress_592977 = ref object of OpenApiRestCall_592348
proc url_GetAuthorizeClusterSecurityGroupIngress_592979(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAuthorizeClusterSecurityGroupIngress_592978(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range to be added the Amazon Redshift security group.
  section = newJObject()
  var valid_592980 = query.getOrDefault("EC2SecurityGroupName")
  valid_592980 = validateParameter(valid_592980, JString, required = false,
                                 default = nil)
  if valid_592980 != nil:
    section.add "EC2SecurityGroupName", valid_592980
  var valid_592981 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_592981 = validateParameter(valid_592981, JString, required = false,
                                 default = nil)
  if valid_592981 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_592981
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_592982 = query.getOrDefault("ClusterSecurityGroupName")
  valid_592982 = validateParameter(valid_592982, JString, required = true,
                                 default = nil)
  if valid_592982 != nil:
    section.add "ClusterSecurityGroupName", valid_592982
  var valid_592983 = query.getOrDefault("Action")
  valid_592983 = validateParameter(valid_592983, JString, required = true, default = newJString(
      "AuthorizeClusterSecurityGroupIngress"))
  if valid_592983 != nil:
    section.add "Action", valid_592983
  var valid_592984 = query.getOrDefault("Version")
  valid_592984 = validateParameter(valid_592984, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_592984 != nil:
    section.add "Version", valid_592984
  var valid_592985 = query.getOrDefault("CIDRIP")
  valid_592985 = validateParameter(valid_592985, JString, required = false,
                                 default = nil)
  if valid_592985 != nil:
    section.add "CIDRIP", valid_592985
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_592986 = header.getOrDefault("X-Amz-Signature")
  valid_592986 = validateParameter(valid_592986, JString, required = false,
                                 default = nil)
  if valid_592986 != nil:
    section.add "X-Amz-Signature", valid_592986
  var valid_592987 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_592987 = validateParameter(valid_592987, JString, required = false,
                                 default = nil)
  if valid_592987 != nil:
    section.add "X-Amz-Content-Sha256", valid_592987
  var valid_592988 = header.getOrDefault("X-Amz-Date")
  valid_592988 = validateParameter(valid_592988, JString, required = false,
                                 default = nil)
  if valid_592988 != nil:
    section.add "X-Amz-Date", valid_592988
  var valid_592989 = header.getOrDefault("X-Amz-Credential")
  valid_592989 = validateParameter(valid_592989, JString, required = false,
                                 default = nil)
  if valid_592989 != nil:
    section.add "X-Amz-Credential", valid_592989
  var valid_592990 = header.getOrDefault("X-Amz-Security-Token")
  valid_592990 = validateParameter(valid_592990, JString, required = false,
                                 default = nil)
  if valid_592990 != nil:
    section.add "X-Amz-Security-Token", valid_592990
  var valid_592991 = header.getOrDefault("X-Amz-Algorithm")
  valid_592991 = validateParameter(valid_592991, JString, required = false,
                                 default = nil)
  if valid_592991 != nil:
    section.add "X-Amz-Algorithm", valid_592991
  var valid_592992 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_592992 = validateParameter(valid_592992, JString, required = false,
                                 default = nil)
  if valid_592992 != nil:
    section.add "X-Amz-SignedHeaders", valid_592992
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_592993: Call_GetAuthorizeClusterSecurityGroupIngress_592977;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_592993.validator(path, query, header, formData, body)
  let scheme = call_592993.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_592993.url(scheme.get, call_592993.host, call_592993.base,
                         call_592993.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_592993, url, valid)

proc call*(call_592994: Call_GetAuthorizeClusterSecurityGroupIngress_592977;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = "";
          Action: string = "AuthorizeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"; CIDRIP: string = ""): Recallable =
  ## getAuthorizeClusterSecurityGroupIngress
  ## <p>Adds an inbound (ingress) rule to an Amazon Redshift security group. Depending on whether the application accessing your cluster is running on the Internet or an Amazon EC2 instance, you can authorize inbound access to either a Classless Interdomain Routing (CIDR)/Internet Protocol (IP) range or to an Amazon EC2 security group. You can add as many as 20 ingress rules to an Amazon Redshift security group.</p> <p>If you authorize access to an Amazon EC2 security group, specify <i>EC2SecurityGroupName</i> and <i>EC2SecurityGroupOwnerId</i>. The Amazon EC2 security group and Amazon Redshift cluster must be in the same AWS Region. </p> <p>If you authorize access to a CIDR/IP address range, specify <i>CIDRIP</i>. For an overview of CIDR blocks, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>. </p> <p>You must also associate the security group with a cluster so that clients running on these IP addresses or the EC2 instance are authorized to connect to the cluster. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Working with Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   EC2SecurityGroupName: string
  ##                       : The EC2 security group to be added the Amazon Redshift security group.
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified by the <i>EC2SecurityGroupName</i> parameter. The AWS Access Key ID is not an acceptable value. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security group to which the ingress rule is added.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   CIDRIP: string
  ##         : The IP range to be added the Amazon Redshift security group.
  var query_592995 = newJObject()
  add(query_592995, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_592995, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_592995, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_592995, "Action", newJString(Action))
  add(query_592995, "Version", newJString(Version))
  add(query_592995, "CIDRIP", newJString(CIDRIP))
  result = call_592994.call(nil, query_592995, nil, nil, nil)

var getAuthorizeClusterSecurityGroupIngress* = Call_GetAuthorizeClusterSecurityGroupIngress_592977(
    name: "getAuthorizeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=AuthorizeClusterSecurityGroupIngress",
    validator: validate_GetAuthorizeClusterSecurityGroupIngress_592978, base: "/",
    url: url_GetAuthorizeClusterSecurityGroupIngress_592979,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostAuthorizeSnapshotAccess_593034 = ref object of OpenApiRestCall_592348
proc url_PostAuthorizeSnapshotAccess_593036(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostAuthorizeSnapshotAccess_593035(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593037 = query.getOrDefault("Action")
  valid_593037 = validateParameter(valid_593037, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_593037 != nil:
    section.add "Action", valid_593037
  var valid_593038 = query.getOrDefault("Version")
  valid_593038 = validateParameter(valid_593038, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593038 != nil:
    section.add "Version", valid_593038
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593039 = header.getOrDefault("X-Amz-Signature")
  valid_593039 = validateParameter(valid_593039, JString, required = false,
                                 default = nil)
  if valid_593039 != nil:
    section.add "X-Amz-Signature", valid_593039
  var valid_593040 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593040 = validateParameter(valid_593040, JString, required = false,
                                 default = nil)
  if valid_593040 != nil:
    section.add "X-Amz-Content-Sha256", valid_593040
  var valid_593041 = header.getOrDefault("X-Amz-Date")
  valid_593041 = validateParameter(valid_593041, JString, required = false,
                                 default = nil)
  if valid_593041 != nil:
    section.add "X-Amz-Date", valid_593041
  var valid_593042 = header.getOrDefault("X-Amz-Credential")
  valid_593042 = validateParameter(valid_593042, JString, required = false,
                                 default = nil)
  if valid_593042 != nil:
    section.add "X-Amz-Credential", valid_593042
  var valid_593043 = header.getOrDefault("X-Amz-Security-Token")
  valid_593043 = validateParameter(valid_593043, JString, required = false,
                                 default = nil)
  if valid_593043 != nil:
    section.add "X-Amz-Security-Token", valid_593043
  var valid_593044 = header.getOrDefault("X-Amz-Algorithm")
  valid_593044 = validateParameter(valid_593044, JString, required = false,
                                 default = nil)
  if valid_593044 != nil:
    section.add "X-Amz-Algorithm", valid_593044
  var valid_593045 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593045 = validateParameter(valid_593045, JString, required = false,
                                 default = nil)
  if valid_593045 != nil:
    section.add "X-Amz-SignedHeaders", valid_593045
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_593046 = formData.getOrDefault("SnapshotIdentifier")
  valid_593046 = validateParameter(valid_593046, JString, required = true,
                                 default = nil)
  if valid_593046 != nil:
    section.add "SnapshotIdentifier", valid_593046
  var valid_593047 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_593047 = validateParameter(valid_593047, JString, required = true,
                                 default = nil)
  if valid_593047 != nil:
    section.add "AccountWithRestoreAccess", valid_593047
  var valid_593048 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_593048 = validateParameter(valid_593048, JString, required = false,
                                 default = nil)
  if valid_593048 != nil:
    section.add "SnapshotClusterIdentifier", valid_593048
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593049: Call_PostAuthorizeSnapshotAccess_593034; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593049.validator(path, query, header, formData, body)
  let scheme = call_593049.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593049.url(scheme.get, call_593049.host, call_593049.base,
                         call_593049.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593049, url, valid)

proc call*(call_593050: Call_PostAuthorizeSnapshotAccess_593034;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          Action: string = "AuthorizeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   Action: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Version: string (required)
  var query_593051 = newJObject()
  var formData_593052 = newJObject()
  add(formData_593052, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_593051, "Action", newJString(Action))
  add(formData_593052, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_593052, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_593051, "Version", newJString(Version))
  result = call_593050.call(nil, query_593051, nil, formData_593052, nil)

var postAuthorizeSnapshotAccess* = Call_PostAuthorizeSnapshotAccess_593034(
    name: "postAuthorizeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_PostAuthorizeSnapshotAccess_593035, base: "/",
    url: url_PostAuthorizeSnapshotAccess_593036,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetAuthorizeSnapshotAccess_593016 = ref object of OpenApiRestCall_592348
proc url_GetAuthorizeSnapshotAccess_593018(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetAuthorizeSnapshotAccess_593017(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_593019 = query.getOrDefault("SnapshotIdentifier")
  valid_593019 = validateParameter(valid_593019, JString, required = true,
                                 default = nil)
  if valid_593019 != nil:
    section.add "SnapshotIdentifier", valid_593019
  var valid_593020 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_593020 = validateParameter(valid_593020, JString, required = false,
                                 default = nil)
  if valid_593020 != nil:
    section.add "SnapshotClusterIdentifier", valid_593020
  var valid_593021 = query.getOrDefault("Action")
  valid_593021 = validateParameter(valid_593021, JString, required = true, default = newJString(
      "AuthorizeSnapshotAccess"))
  if valid_593021 != nil:
    section.add "Action", valid_593021
  var valid_593022 = query.getOrDefault("Version")
  valid_593022 = validateParameter(valid_593022, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593022 != nil:
    section.add "Version", valid_593022
  var valid_593023 = query.getOrDefault("AccountWithRestoreAccess")
  valid_593023 = validateParameter(valid_593023, JString, required = true,
                                 default = nil)
  if valid_593023 != nil:
    section.add "AccountWithRestoreAccess", valid_593023
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593024 = header.getOrDefault("X-Amz-Signature")
  valid_593024 = validateParameter(valid_593024, JString, required = false,
                                 default = nil)
  if valid_593024 != nil:
    section.add "X-Amz-Signature", valid_593024
  var valid_593025 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593025 = validateParameter(valid_593025, JString, required = false,
                                 default = nil)
  if valid_593025 != nil:
    section.add "X-Amz-Content-Sha256", valid_593025
  var valid_593026 = header.getOrDefault("X-Amz-Date")
  valid_593026 = validateParameter(valid_593026, JString, required = false,
                                 default = nil)
  if valid_593026 != nil:
    section.add "X-Amz-Date", valid_593026
  var valid_593027 = header.getOrDefault("X-Amz-Credential")
  valid_593027 = validateParameter(valid_593027, JString, required = false,
                                 default = nil)
  if valid_593027 != nil:
    section.add "X-Amz-Credential", valid_593027
  var valid_593028 = header.getOrDefault("X-Amz-Security-Token")
  valid_593028 = validateParameter(valid_593028, JString, required = false,
                                 default = nil)
  if valid_593028 != nil:
    section.add "X-Amz-Security-Token", valid_593028
  var valid_593029 = header.getOrDefault("X-Amz-Algorithm")
  valid_593029 = validateParameter(valid_593029, JString, required = false,
                                 default = nil)
  if valid_593029 != nil:
    section.add "X-Amz-Algorithm", valid_593029
  var valid_593030 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593030 = validateParameter(valid_593030, JString, required = false,
                                 default = nil)
  if valid_593030 != nil:
    section.add "X-Amz-SignedHeaders", valid_593030
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593031: Call_GetAuthorizeSnapshotAccess_593016; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593031.validator(path, query, header, formData, body)
  let scheme = call_593031.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593031.url(scheme.get, call_593031.host, call_593031.base,
                         call_593031.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593031, url, valid)

proc call*(call_593032: Call_GetAuthorizeSnapshotAccess_593016;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "AuthorizeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## getAuthorizeSnapshotAccess
  ## <p>Authorizes the specified AWS customer account to restore the specified snapshot.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot the account is authorized to restore.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : <p>The identifier of the AWS customer account authorized to restore the specified snapshot.</p> <p>To share a snapshot with AWS support, specify amazon-redshift-support.</p>
  var query_593033 = newJObject()
  add(query_593033, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_593033, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_593033, "Action", newJString(Action))
  add(query_593033, "Version", newJString(Version))
  add(query_593033, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  result = call_593032.call(nil, query_593033, nil, nil, nil)

var getAuthorizeSnapshotAccess* = Call_GetAuthorizeSnapshotAccess_593016(
    name: "getAuthorizeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=AuthorizeSnapshotAccess",
    validator: validate_GetAuthorizeSnapshotAccess_593017, base: "/",
    url: url_GetAuthorizeSnapshotAccess_593018,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchDeleteClusterSnapshots_593069 = ref object of OpenApiRestCall_592348
proc url_PostBatchDeleteClusterSnapshots_593071(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostBatchDeleteClusterSnapshots_593070(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593072 = query.getOrDefault("Action")
  valid_593072 = validateParameter(valid_593072, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_593072 != nil:
    section.add "Action", valid_593072
  var valid_593073 = query.getOrDefault("Version")
  valid_593073 = validateParameter(valid_593073, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593073 != nil:
    section.add "Version", valid_593073
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593074 = header.getOrDefault("X-Amz-Signature")
  valid_593074 = validateParameter(valid_593074, JString, required = false,
                                 default = nil)
  if valid_593074 != nil:
    section.add "X-Amz-Signature", valid_593074
  var valid_593075 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593075 = validateParameter(valid_593075, JString, required = false,
                                 default = nil)
  if valid_593075 != nil:
    section.add "X-Amz-Content-Sha256", valid_593075
  var valid_593076 = header.getOrDefault("X-Amz-Date")
  valid_593076 = validateParameter(valid_593076, JString, required = false,
                                 default = nil)
  if valid_593076 != nil:
    section.add "X-Amz-Date", valid_593076
  var valid_593077 = header.getOrDefault("X-Amz-Credential")
  valid_593077 = validateParameter(valid_593077, JString, required = false,
                                 default = nil)
  if valid_593077 != nil:
    section.add "X-Amz-Credential", valid_593077
  var valid_593078 = header.getOrDefault("X-Amz-Security-Token")
  valid_593078 = validateParameter(valid_593078, JString, required = false,
                                 default = nil)
  if valid_593078 != nil:
    section.add "X-Amz-Security-Token", valid_593078
  var valid_593079 = header.getOrDefault("X-Amz-Algorithm")
  valid_593079 = validateParameter(valid_593079, JString, required = false,
                                 default = nil)
  if valid_593079 != nil:
    section.add "X-Amz-Algorithm", valid_593079
  var valid_593080 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593080 = validateParameter(valid_593080, JString, required = false,
                                 default = nil)
  if valid_593080 != nil:
    section.add "X-Amz-SignedHeaders", valid_593080
  result.add "header", section
  ## parameters in `formData` object:
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Identifiers` field"
  var valid_593081 = formData.getOrDefault("Identifiers")
  valid_593081 = validateParameter(valid_593081, JArray, required = true, default = nil)
  if valid_593081 != nil:
    section.add "Identifiers", valid_593081
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593082: Call_PostBatchDeleteClusterSnapshots_593069;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_593082.validator(path, query, header, formData, body)
  let scheme = call_593082.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593082.url(scheme.get, call_593082.host, call_593082.base,
                         call_593082.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593082, url, valid)

proc call*(call_593083: Call_PostBatchDeleteClusterSnapshots_593069;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## postBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593084 = newJObject()
  var formData_593085 = newJObject()
  if Identifiers != nil:
    formData_593085.add "Identifiers", Identifiers
  add(query_593084, "Action", newJString(Action))
  add(query_593084, "Version", newJString(Version))
  result = call_593083.call(nil, query_593084, nil, formData_593085, nil)

var postBatchDeleteClusterSnapshots* = Call_PostBatchDeleteClusterSnapshots_593069(
    name: "postBatchDeleteClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_PostBatchDeleteClusterSnapshots_593070, base: "/",
    url: url_PostBatchDeleteClusterSnapshots_593071,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchDeleteClusterSnapshots_593053 = ref object of OpenApiRestCall_592348
proc url_GetBatchDeleteClusterSnapshots_593055(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetBatchDeleteClusterSnapshots_593054(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a set of cluster snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593056 = query.getOrDefault("Action")
  valid_593056 = validateParameter(valid_593056, JString, required = true, default = newJString(
      "BatchDeleteClusterSnapshots"))
  if valid_593056 != nil:
    section.add "Action", valid_593056
  var valid_593057 = query.getOrDefault("Identifiers")
  valid_593057 = validateParameter(valid_593057, JArray, required = true, default = nil)
  if valid_593057 != nil:
    section.add "Identifiers", valid_593057
  var valid_593058 = query.getOrDefault("Version")
  valid_593058 = validateParameter(valid_593058, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593058 != nil:
    section.add "Version", valid_593058
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593059 = header.getOrDefault("X-Amz-Signature")
  valid_593059 = validateParameter(valid_593059, JString, required = false,
                                 default = nil)
  if valid_593059 != nil:
    section.add "X-Amz-Signature", valid_593059
  var valid_593060 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593060 = validateParameter(valid_593060, JString, required = false,
                                 default = nil)
  if valid_593060 != nil:
    section.add "X-Amz-Content-Sha256", valid_593060
  var valid_593061 = header.getOrDefault("X-Amz-Date")
  valid_593061 = validateParameter(valid_593061, JString, required = false,
                                 default = nil)
  if valid_593061 != nil:
    section.add "X-Amz-Date", valid_593061
  var valid_593062 = header.getOrDefault("X-Amz-Credential")
  valid_593062 = validateParameter(valid_593062, JString, required = false,
                                 default = nil)
  if valid_593062 != nil:
    section.add "X-Amz-Credential", valid_593062
  var valid_593063 = header.getOrDefault("X-Amz-Security-Token")
  valid_593063 = validateParameter(valid_593063, JString, required = false,
                                 default = nil)
  if valid_593063 != nil:
    section.add "X-Amz-Security-Token", valid_593063
  var valid_593064 = header.getOrDefault("X-Amz-Algorithm")
  valid_593064 = validateParameter(valid_593064, JString, required = false,
                                 default = nil)
  if valid_593064 != nil:
    section.add "X-Amz-Algorithm", valid_593064
  var valid_593065 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593065 = validateParameter(valid_593065, JString, required = false,
                                 default = nil)
  if valid_593065 != nil:
    section.add "X-Amz-SignedHeaders", valid_593065
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593066: Call_GetBatchDeleteClusterSnapshots_593053; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a set of cluster snapshots.
  ## 
  let valid = call_593066.validator(path, query, header, formData, body)
  let scheme = call_593066.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593066.url(scheme.get, call_593066.host, call_593066.base,
                         call_593066.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593066, url, valid)

proc call*(call_593067: Call_GetBatchDeleteClusterSnapshots_593053;
          Identifiers: JsonNode; Action: string = "BatchDeleteClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchDeleteClusterSnapshots
  ## Deletes a set of cluster snapshots.
  ##   Action: string (required)
  ##   Identifiers: JArray (required)
  ##              : A list of identifiers for the snapshots that you want to delete.
  ##   Version: string (required)
  var query_593068 = newJObject()
  add(query_593068, "Action", newJString(Action))
  if Identifiers != nil:
    query_593068.add "Identifiers", Identifiers
  add(query_593068, "Version", newJString(Version))
  result = call_593067.call(nil, query_593068, nil, nil, nil)

var getBatchDeleteClusterSnapshots* = Call_GetBatchDeleteClusterSnapshots_593053(
    name: "getBatchDeleteClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchDeleteClusterSnapshots",
    validator: validate_GetBatchDeleteClusterSnapshots_593054, base: "/",
    url: url_GetBatchDeleteClusterSnapshots_593055,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostBatchModifyClusterSnapshots_593104 = ref object of OpenApiRestCall_592348
proc url_PostBatchModifyClusterSnapshots_593106(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostBatchModifyClusterSnapshots_593105(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593107 = query.getOrDefault("Action")
  valid_593107 = validateParameter(valid_593107, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_593107 != nil:
    section.add "Action", valid_593107
  var valid_593108 = query.getOrDefault("Version")
  valid_593108 = validateParameter(valid_593108, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593108 != nil:
    section.add "Version", valid_593108
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593109 = header.getOrDefault("X-Amz-Signature")
  valid_593109 = validateParameter(valid_593109, JString, required = false,
                                 default = nil)
  if valid_593109 != nil:
    section.add "X-Amz-Signature", valid_593109
  var valid_593110 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593110 = validateParameter(valid_593110, JString, required = false,
                                 default = nil)
  if valid_593110 != nil:
    section.add "X-Amz-Content-Sha256", valid_593110
  var valid_593111 = header.getOrDefault("X-Amz-Date")
  valid_593111 = validateParameter(valid_593111, JString, required = false,
                                 default = nil)
  if valid_593111 != nil:
    section.add "X-Amz-Date", valid_593111
  var valid_593112 = header.getOrDefault("X-Amz-Credential")
  valid_593112 = validateParameter(valid_593112, JString, required = false,
                                 default = nil)
  if valid_593112 != nil:
    section.add "X-Amz-Credential", valid_593112
  var valid_593113 = header.getOrDefault("X-Amz-Security-Token")
  valid_593113 = validateParameter(valid_593113, JString, required = false,
                                 default = nil)
  if valid_593113 != nil:
    section.add "X-Amz-Security-Token", valid_593113
  var valid_593114 = header.getOrDefault("X-Amz-Algorithm")
  valid_593114 = validateParameter(valid_593114, JString, required = false,
                                 default = nil)
  if valid_593114 != nil:
    section.add "X-Amz-Algorithm", valid_593114
  var valid_593115 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593115 = validateParameter(valid_593115, JString, required = false,
                                 default = nil)
  if valid_593115 != nil:
    section.add "X-Amz-SignedHeaders", valid_593115
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  section = newJObject()
  var valid_593116 = formData.getOrDefault("Force")
  valid_593116 = validateParameter(valid_593116, JBool, required = false, default = nil)
  if valid_593116 != nil:
    section.add "Force", valid_593116
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifierList` field"
  var valid_593117 = formData.getOrDefault("SnapshotIdentifierList")
  valid_593117 = validateParameter(valid_593117, JArray, required = true, default = nil)
  if valid_593117 != nil:
    section.add "SnapshotIdentifierList", valid_593117
  var valid_593118 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_593118 = validateParameter(valid_593118, JInt, required = false, default = nil)
  if valid_593118 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_593118
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593119: Call_PostBatchModifyClusterSnapshots_593104;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_593119.validator(path, query, header, formData, body)
  let scheme = call_593119.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593119.url(scheme.get, call_593119.host, call_593119.base,
                         call_593119.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593119, url, valid)

proc call*(call_593120: Call_PostBatchModifyClusterSnapshots_593104;
          SnapshotIdentifierList: JsonNode; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  var query_593121 = newJObject()
  var formData_593122 = newJObject()
  add(formData_593122, "Force", newJBool(Force))
  if SnapshotIdentifierList != nil:
    formData_593122.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_593121, "Action", newJString(Action))
  add(query_593121, "Version", newJString(Version))
  add(formData_593122, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_593120.call(nil, query_593121, nil, formData_593122, nil)

var postBatchModifyClusterSnapshots* = Call_PostBatchModifyClusterSnapshots_593104(
    name: "postBatchModifyClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_PostBatchModifyClusterSnapshots_593105, base: "/",
    url: url_PostBatchModifyClusterSnapshots_593106,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetBatchModifyClusterSnapshots_593086 = ref object of OpenApiRestCall_592348
proc url_GetBatchModifyClusterSnapshots_593088(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetBatchModifyClusterSnapshots_593087(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a list of snapshots.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: JBool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   Action: JString (required)
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Version: JString (required)
  section = newJObject()
  var valid_593089 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_593089 = validateParameter(valid_593089, JInt, required = false, default = nil)
  if valid_593089 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_593089
  var valid_593090 = query.getOrDefault("Force")
  valid_593090 = validateParameter(valid_593090, JBool, required = false, default = nil)
  if valid_593090 != nil:
    section.add "Force", valid_593090
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593091 = query.getOrDefault("Action")
  valid_593091 = validateParameter(valid_593091, JString, required = true, default = newJString(
      "BatchModifyClusterSnapshots"))
  if valid_593091 != nil:
    section.add "Action", valid_593091
  var valid_593092 = query.getOrDefault("SnapshotIdentifierList")
  valid_593092 = validateParameter(valid_593092, JArray, required = true, default = nil)
  if valid_593092 != nil:
    section.add "SnapshotIdentifierList", valid_593092
  var valid_593093 = query.getOrDefault("Version")
  valid_593093 = validateParameter(valid_593093, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593093 != nil:
    section.add "Version", valid_593093
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593094 = header.getOrDefault("X-Amz-Signature")
  valid_593094 = validateParameter(valid_593094, JString, required = false,
                                 default = nil)
  if valid_593094 != nil:
    section.add "X-Amz-Signature", valid_593094
  var valid_593095 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593095 = validateParameter(valid_593095, JString, required = false,
                                 default = nil)
  if valid_593095 != nil:
    section.add "X-Amz-Content-Sha256", valid_593095
  var valid_593096 = header.getOrDefault("X-Amz-Date")
  valid_593096 = validateParameter(valid_593096, JString, required = false,
                                 default = nil)
  if valid_593096 != nil:
    section.add "X-Amz-Date", valid_593096
  var valid_593097 = header.getOrDefault("X-Amz-Credential")
  valid_593097 = validateParameter(valid_593097, JString, required = false,
                                 default = nil)
  if valid_593097 != nil:
    section.add "X-Amz-Credential", valid_593097
  var valid_593098 = header.getOrDefault("X-Amz-Security-Token")
  valid_593098 = validateParameter(valid_593098, JString, required = false,
                                 default = nil)
  if valid_593098 != nil:
    section.add "X-Amz-Security-Token", valid_593098
  var valid_593099 = header.getOrDefault("X-Amz-Algorithm")
  valid_593099 = validateParameter(valid_593099, JString, required = false,
                                 default = nil)
  if valid_593099 != nil:
    section.add "X-Amz-Algorithm", valid_593099
  var valid_593100 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593100 = validateParameter(valid_593100, JString, required = false,
                                 default = nil)
  if valid_593100 != nil:
    section.add "X-Amz-SignedHeaders", valid_593100
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593101: Call_GetBatchModifyClusterSnapshots_593086; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a list of snapshots.
  ## 
  let valid = call_593101.validator(path, query, header, formData, body)
  let scheme = call_593101.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593101.url(scheme.get, call_593101.host, call_593101.base,
                         call_593101.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593101, url, valid)

proc call*(call_593102: Call_GetBatchModifyClusterSnapshots_593086;
          SnapshotIdentifierList: JsonNode;
          ManualSnapshotRetentionPeriod: int = 0; Force: bool = false;
          Action: string = "BatchModifyClusterSnapshots";
          Version: string = "2012-12-01"): Recallable =
  ## getBatchModifyClusterSnapshots
  ## Modifies the settings for a list of snapshots.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If you specify the value -1, the manual snapshot is retained indefinitely.</p> <p>The number must be either -1 or an integer between 1 and 3,653.</p> <p>If you decrease the manual snapshot retention period from its current value, existing manual snapshots that fall outside of the new retention period will return an error. If you want to suppress the errors and delete the snapshots, use the force option. </p>
  ##   Force: bool
  ##        : A boolean value indicating whether to override an exception if the retention period has passed. 
  ##   Action: string (required)
  ##   SnapshotIdentifierList: JArray (required)
  ##                         : A list of snapshot identifiers you want to modify.
  ##   Version: string (required)
  var query_593103 = newJObject()
  add(query_593103, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_593103, "Force", newJBool(Force))
  add(query_593103, "Action", newJString(Action))
  if SnapshotIdentifierList != nil:
    query_593103.add "SnapshotIdentifierList", SnapshotIdentifierList
  add(query_593103, "Version", newJString(Version))
  result = call_593102.call(nil, query_593103, nil, nil, nil)

var getBatchModifyClusterSnapshots* = Call_GetBatchModifyClusterSnapshots_593086(
    name: "getBatchModifyClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=BatchModifyClusterSnapshots",
    validator: validate_GetBatchModifyClusterSnapshots_593087, base: "/",
    url: url_GetBatchModifyClusterSnapshots_593088,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCancelResize_593139 = ref object of OpenApiRestCall_592348
proc url_PostCancelResize_593141(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCancelResize_593140(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593142 = query.getOrDefault("Action")
  valid_593142 = validateParameter(valid_593142, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_593142 != nil:
    section.add "Action", valid_593142
  var valid_593143 = query.getOrDefault("Version")
  valid_593143 = validateParameter(valid_593143, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593143 != nil:
    section.add "Version", valid_593143
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593144 = header.getOrDefault("X-Amz-Signature")
  valid_593144 = validateParameter(valid_593144, JString, required = false,
                                 default = nil)
  if valid_593144 != nil:
    section.add "X-Amz-Signature", valid_593144
  var valid_593145 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593145 = validateParameter(valid_593145, JString, required = false,
                                 default = nil)
  if valid_593145 != nil:
    section.add "X-Amz-Content-Sha256", valid_593145
  var valid_593146 = header.getOrDefault("X-Amz-Date")
  valid_593146 = validateParameter(valid_593146, JString, required = false,
                                 default = nil)
  if valid_593146 != nil:
    section.add "X-Amz-Date", valid_593146
  var valid_593147 = header.getOrDefault("X-Amz-Credential")
  valid_593147 = validateParameter(valid_593147, JString, required = false,
                                 default = nil)
  if valid_593147 != nil:
    section.add "X-Amz-Credential", valid_593147
  var valid_593148 = header.getOrDefault("X-Amz-Security-Token")
  valid_593148 = validateParameter(valid_593148, JString, required = false,
                                 default = nil)
  if valid_593148 != nil:
    section.add "X-Amz-Security-Token", valid_593148
  var valid_593149 = header.getOrDefault("X-Amz-Algorithm")
  valid_593149 = validateParameter(valid_593149, JString, required = false,
                                 default = nil)
  if valid_593149 != nil:
    section.add "X-Amz-Algorithm", valid_593149
  var valid_593150 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593150 = validateParameter(valid_593150, JString, required = false,
                                 default = nil)
  if valid_593150 != nil:
    section.add "X-Amz-SignedHeaders", valid_593150
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_593151 = formData.getOrDefault("ClusterIdentifier")
  valid_593151 = validateParameter(valid_593151, JString, required = true,
                                 default = nil)
  if valid_593151 != nil:
    section.add "ClusterIdentifier", valid_593151
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593152: Call_PostCancelResize_593139; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_593152.validator(path, query, header, formData, body)
  let scheme = call_593152.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593152.url(scheme.get, call_593152.host, call_593152.base,
                         call_593152.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593152, url, valid)

proc call*(call_593153: Call_PostCancelResize_593139; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## postCancelResize
  ## Cancels a resize operation.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593154 = newJObject()
  var formData_593155 = newJObject()
  add(formData_593155, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_593154, "Action", newJString(Action))
  add(query_593154, "Version", newJString(Version))
  result = call_593153.call(nil, query_593154, nil, formData_593155, nil)

var postCancelResize* = Call_PostCancelResize_593139(name: "postCancelResize",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_PostCancelResize_593140,
    base: "/", url: url_PostCancelResize_593141,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCancelResize_593123 = ref object of OpenApiRestCall_592348
proc url_GetCancelResize_593125(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCancelResize_593124(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## Cancels a resize operation.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593126 = query.getOrDefault("Action")
  valid_593126 = validateParameter(valid_593126, JString, required = true,
                                 default = newJString("CancelResize"))
  if valid_593126 != nil:
    section.add "Action", valid_593126
  var valid_593127 = query.getOrDefault("ClusterIdentifier")
  valid_593127 = validateParameter(valid_593127, JString, required = true,
                                 default = nil)
  if valid_593127 != nil:
    section.add "ClusterIdentifier", valid_593127
  var valid_593128 = query.getOrDefault("Version")
  valid_593128 = validateParameter(valid_593128, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593128 != nil:
    section.add "Version", valid_593128
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593129 = header.getOrDefault("X-Amz-Signature")
  valid_593129 = validateParameter(valid_593129, JString, required = false,
                                 default = nil)
  if valid_593129 != nil:
    section.add "X-Amz-Signature", valid_593129
  var valid_593130 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593130 = validateParameter(valid_593130, JString, required = false,
                                 default = nil)
  if valid_593130 != nil:
    section.add "X-Amz-Content-Sha256", valid_593130
  var valid_593131 = header.getOrDefault("X-Amz-Date")
  valid_593131 = validateParameter(valid_593131, JString, required = false,
                                 default = nil)
  if valid_593131 != nil:
    section.add "X-Amz-Date", valid_593131
  var valid_593132 = header.getOrDefault("X-Amz-Credential")
  valid_593132 = validateParameter(valid_593132, JString, required = false,
                                 default = nil)
  if valid_593132 != nil:
    section.add "X-Amz-Credential", valid_593132
  var valid_593133 = header.getOrDefault("X-Amz-Security-Token")
  valid_593133 = validateParameter(valid_593133, JString, required = false,
                                 default = nil)
  if valid_593133 != nil:
    section.add "X-Amz-Security-Token", valid_593133
  var valid_593134 = header.getOrDefault("X-Amz-Algorithm")
  valid_593134 = validateParameter(valid_593134, JString, required = false,
                                 default = nil)
  if valid_593134 != nil:
    section.add "X-Amz-Algorithm", valid_593134
  var valid_593135 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593135 = validateParameter(valid_593135, JString, required = false,
                                 default = nil)
  if valid_593135 != nil:
    section.add "X-Amz-SignedHeaders", valid_593135
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593136: Call_GetCancelResize_593123; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Cancels a resize operation.
  ## 
  let valid = call_593136.validator(path, query, header, formData, body)
  let scheme = call_593136.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593136.url(scheme.get, call_593136.host, call_593136.base,
                         call_593136.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593136, url, valid)

proc call*(call_593137: Call_GetCancelResize_593123; ClusterIdentifier: string;
          Action: string = "CancelResize"; Version: string = "2012-12-01"): Recallable =
  ## getCancelResize
  ## Cancels a resize operation.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster that you want to cancel a resize operation for.
  ##   Version: string (required)
  var query_593138 = newJObject()
  add(query_593138, "Action", newJString(Action))
  add(query_593138, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_593138, "Version", newJString(Version))
  result = call_593137.call(nil, query_593138, nil, nil, nil)

var getCancelResize* = Call_GetCancelResize_593123(name: "getCancelResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CancelResize", validator: validate_GetCancelResize_593124,
    base: "/", url: url_GetCancelResize_593125, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCopyClusterSnapshot_593175 = ref object of OpenApiRestCall_592348
proc url_PostCopyClusterSnapshot_593177(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCopyClusterSnapshot_593176(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593178 = query.getOrDefault("Action")
  valid_593178 = validateParameter(valid_593178, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_593178 != nil:
    section.add "Action", valid_593178
  var valid_593179 = query.getOrDefault("Version")
  valid_593179 = validateParameter(valid_593179, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593179 != nil:
    section.add "Version", valid_593179
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593180 = header.getOrDefault("X-Amz-Signature")
  valid_593180 = validateParameter(valid_593180, JString, required = false,
                                 default = nil)
  if valid_593180 != nil:
    section.add "X-Amz-Signature", valid_593180
  var valid_593181 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593181 = validateParameter(valid_593181, JString, required = false,
                                 default = nil)
  if valid_593181 != nil:
    section.add "X-Amz-Content-Sha256", valid_593181
  var valid_593182 = header.getOrDefault("X-Amz-Date")
  valid_593182 = validateParameter(valid_593182, JString, required = false,
                                 default = nil)
  if valid_593182 != nil:
    section.add "X-Amz-Date", valid_593182
  var valid_593183 = header.getOrDefault("X-Amz-Credential")
  valid_593183 = validateParameter(valid_593183, JString, required = false,
                                 default = nil)
  if valid_593183 != nil:
    section.add "X-Amz-Credential", valid_593183
  var valid_593184 = header.getOrDefault("X-Amz-Security-Token")
  valid_593184 = validateParameter(valid_593184, JString, required = false,
                                 default = nil)
  if valid_593184 != nil:
    section.add "X-Amz-Security-Token", valid_593184
  var valid_593185 = header.getOrDefault("X-Amz-Algorithm")
  valid_593185 = validateParameter(valid_593185, JString, required = false,
                                 default = nil)
  if valid_593185 != nil:
    section.add "X-Amz-Algorithm", valid_593185
  var valid_593186 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593186 = validateParameter(valid_593186, JString, required = false,
                                 default = nil)
  if valid_593186 != nil:
    section.add "X-Amz-SignedHeaders", valid_593186
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_593187 = formData.getOrDefault("SourceSnapshotIdentifier")
  valid_593187 = validateParameter(valid_593187, JString, required = true,
                                 default = nil)
  if valid_593187 != nil:
    section.add "SourceSnapshotIdentifier", valid_593187
  var valid_593188 = formData.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_593188 = validateParameter(valid_593188, JString, required = false,
                                 default = nil)
  if valid_593188 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_593188
  var valid_593189 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_593189 = validateParameter(valid_593189, JInt, required = false, default = nil)
  if valid_593189 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_593189
  var valid_593190 = formData.getOrDefault("TargetSnapshotIdentifier")
  valid_593190 = validateParameter(valid_593190, JString, required = true,
                                 default = nil)
  if valid_593190 != nil:
    section.add "TargetSnapshotIdentifier", valid_593190
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593191: Call_PostCopyClusterSnapshot_593175; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593191.validator(path, query, header, formData, body)
  let scheme = call_593191.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593191.url(scheme.get, call_593191.host, call_593191.base,
                         call_593191.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593191, url, valid)

proc call*(call_593192: Call_PostCopyClusterSnapshot_593175;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          SourceSnapshotClusterIdentifier: string = "";
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  var query_593193 = newJObject()
  var formData_593194 = newJObject()
  add(formData_593194, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(formData_593194, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  add(query_593193, "Action", newJString(Action))
  add(query_593193, "Version", newJString(Version))
  add(formData_593194, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(formData_593194, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  result = call_593192.call(nil, query_593193, nil, formData_593194, nil)

var postCopyClusterSnapshot* = Call_PostCopyClusterSnapshot_593175(
    name: "postCopyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_PostCopyClusterSnapshot_593176, base: "/",
    url: url_PostCopyClusterSnapshot_593177, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCopyClusterSnapshot_593156 = ref object of OpenApiRestCall_592348
proc url_GetCopyClusterSnapshot_593158(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCopyClusterSnapshot_593157(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SourceSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: JString (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SourceSnapshotClusterIdentifier: JString
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  section = newJObject()
  var valid_593159 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_593159 = validateParameter(valid_593159, JInt, required = false, default = nil)
  if valid_593159 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_593159
  assert query != nil, "query argument is necessary due to required `SourceSnapshotIdentifier` field"
  var valid_593160 = query.getOrDefault("SourceSnapshotIdentifier")
  valid_593160 = validateParameter(valid_593160, JString, required = true,
                                 default = nil)
  if valid_593160 != nil:
    section.add "SourceSnapshotIdentifier", valid_593160
  var valid_593161 = query.getOrDefault("TargetSnapshotIdentifier")
  valid_593161 = validateParameter(valid_593161, JString, required = true,
                                 default = nil)
  if valid_593161 != nil:
    section.add "TargetSnapshotIdentifier", valid_593161
  var valid_593162 = query.getOrDefault("Action")
  valid_593162 = validateParameter(valid_593162, JString, required = true,
                                 default = newJString("CopyClusterSnapshot"))
  if valid_593162 != nil:
    section.add "Action", valid_593162
  var valid_593163 = query.getOrDefault("Version")
  valid_593163 = validateParameter(valid_593163, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593163 != nil:
    section.add "Version", valid_593163
  var valid_593164 = query.getOrDefault("SourceSnapshotClusterIdentifier")
  valid_593164 = validateParameter(valid_593164, JString, required = false,
                                 default = nil)
  if valid_593164 != nil:
    section.add "SourceSnapshotClusterIdentifier", valid_593164
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593165 = header.getOrDefault("X-Amz-Signature")
  valid_593165 = validateParameter(valid_593165, JString, required = false,
                                 default = nil)
  if valid_593165 != nil:
    section.add "X-Amz-Signature", valid_593165
  var valid_593166 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593166 = validateParameter(valid_593166, JString, required = false,
                                 default = nil)
  if valid_593166 != nil:
    section.add "X-Amz-Content-Sha256", valid_593166
  var valid_593167 = header.getOrDefault("X-Amz-Date")
  valid_593167 = validateParameter(valid_593167, JString, required = false,
                                 default = nil)
  if valid_593167 != nil:
    section.add "X-Amz-Date", valid_593167
  var valid_593168 = header.getOrDefault("X-Amz-Credential")
  valid_593168 = validateParameter(valid_593168, JString, required = false,
                                 default = nil)
  if valid_593168 != nil:
    section.add "X-Amz-Credential", valid_593168
  var valid_593169 = header.getOrDefault("X-Amz-Security-Token")
  valid_593169 = validateParameter(valid_593169, JString, required = false,
                                 default = nil)
  if valid_593169 != nil:
    section.add "X-Amz-Security-Token", valid_593169
  var valid_593170 = header.getOrDefault("X-Amz-Algorithm")
  valid_593170 = validateParameter(valid_593170, JString, required = false,
                                 default = nil)
  if valid_593170 != nil:
    section.add "X-Amz-Algorithm", valid_593170
  var valid_593171 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593171 = validateParameter(valid_593171, JString, required = false,
                                 default = nil)
  if valid_593171 != nil:
    section.add "X-Amz-SignedHeaders", valid_593171
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593172: Call_GetCopyClusterSnapshot_593156; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593172.validator(path, query, header, formData, body)
  let scheme = call_593172.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593172.url(scheme.get, call_593172.host, call_593172.base,
                         call_593172.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593172, url, valid)

proc call*(call_593173: Call_GetCopyClusterSnapshot_593156;
          SourceSnapshotIdentifier: string; TargetSnapshotIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0;
          Action: string = "CopyClusterSnapshot"; Version: string = "2012-12-01";
          SourceSnapshotClusterIdentifier: string = ""): Recallable =
  ## getCopyClusterSnapshot
  ## <p>Copies the specified automated cluster snapshot to a new manual cluster snapshot. The source must be an automated snapshot and it must be in the available state.</p> <p>When you delete a cluster, Amazon Redshift deletes any automated snapshots of the cluster. Also, when the retention period of the snapshot expires, Amazon Redshift automatically deletes it. If you want to keep an automated snapshot for a longer period, you can make a manual copy of the snapshot. Manual snapshots are retained until you delete them.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SourceSnapshotIdentifier: string (required)
  ##                           : <p>The identifier for the source snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid automated snapshot whose state is <code>available</code>.</p> </li> </ul>
  ##   TargetSnapshotIdentifier: string (required)
  ##                           : <p>The identifier given to the new manual snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for the AWS account that is making the request.</p> </li> </ul>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceSnapshotClusterIdentifier: string
  ##                                  : <p>The identifier of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints:</p> <ul> <li> <p>Must be the identifier for a valid cluster.</p> </li> </ul>
  var query_593174 = newJObject()
  add(query_593174, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_593174, "SourceSnapshotIdentifier",
      newJString(SourceSnapshotIdentifier))
  add(query_593174, "TargetSnapshotIdentifier",
      newJString(TargetSnapshotIdentifier))
  add(query_593174, "Action", newJString(Action))
  add(query_593174, "Version", newJString(Version))
  add(query_593174, "SourceSnapshotClusterIdentifier",
      newJString(SourceSnapshotClusterIdentifier))
  result = call_593173.call(nil, query_593174, nil, nil, nil)

var getCopyClusterSnapshot* = Call_GetCopyClusterSnapshot_593156(
    name: "getCopyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CopyClusterSnapshot",
    validator: validate_GetCopyClusterSnapshot_593157, base: "/",
    url: url_GetCopyClusterSnapshot_593158, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateCluster_593240 = ref object of OpenApiRestCall_592348
proc url_PostCreateCluster_593242(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateCluster_593241(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593243 = query.getOrDefault("Action")
  valid_593243 = validateParameter(valid_593243, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_593243 != nil:
    section.add "Action", valid_593243
  var valid_593244 = query.getOrDefault("Version")
  valid_593244 = validateParameter(valid_593244, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593244 != nil:
    section.add "Version", valid_593244
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593245 = header.getOrDefault("X-Amz-Signature")
  valid_593245 = validateParameter(valid_593245, JString, required = false,
                                 default = nil)
  if valid_593245 != nil:
    section.add "X-Amz-Signature", valid_593245
  var valid_593246 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593246 = validateParameter(valid_593246, JString, required = false,
                                 default = nil)
  if valid_593246 != nil:
    section.add "X-Amz-Content-Sha256", valid_593246
  var valid_593247 = header.getOrDefault("X-Amz-Date")
  valid_593247 = validateParameter(valid_593247, JString, required = false,
                                 default = nil)
  if valid_593247 != nil:
    section.add "X-Amz-Date", valid_593247
  var valid_593248 = header.getOrDefault("X-Amz-Credential")
  valid_593248 = validateParameter(valid_593248, JString, required = false,
                                 default = nil)
  if valid_593248 != nil:
    section.add "X-Amz-Credential", valid_593248
  var valid_593249 = header.getOrDefault("X-Amz-Security-Token")
  valid_593249 = validateParameter(valid_593249, JString, required = false,
                                 default = nil)
  if valid_593249 != nil:
    section.add "X-Amz-Security-Token", valid_593249
  var valid_593250 = header.getOrDefault("X-Amz-Algorithm")
  valid_593250 = validateParameter(valid_593250, JString, required = false,
                                 default = nil)
  if valid_593250 != nil:
    section.add "X-Amz-Algorithm", valid_593250
  var valid_593251 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593251 = validateParameter(valid_593251, JString, required = false,
                                 default = nil)
  if valid_593251 != nil:
    section.add "X-Amz-SignedHeaders", valid_593251
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_593252 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_593252 = validateParameter(valid_593252, JString, required = false,
                                 default = nil)
  if valid_593252 != nil:
    section.add "PreferredMaintenanceWindow", valid_593252
  var valid_593253 = formData.getOrDefault("Port")
  valid_593253 = validateParameter(valid_593253, JInt, required = false, default = nil)
  if valid_593253 != nil:
    section.add "Port", valid_593253
  assert formData != nil,
        "formData argument is necessary due to required `NodeType` field"
  var valid_593254 = formData.getOrDefault("NodeType")
  valid_593254 = validateParameter(valid_593254, JString, required = true,
                                 default = nil)
  if valid_593254 != nil:
    section.add "NodeType", valid_593254
  var valid_593255 = formData.getOrDefault("ClusterIdentifier")
  valid_593255 = validateParameter(valid_593255, JString, required = true,
                                 default = nil)
  if valid_593255 != nil:
    section.add "ClusterIdentifier", valid_593255
  var valid_593256 = formData.getOrDefault("MasterUserPassword")
  valid_593256 = validateParameter(valid_593256, JString, required = true,
                                 default = nil)
  if valid_593256 != nil:
    section.add "MasterUserPassword", valid_593256
  var valid_593257 = formData.getOrDefault("MaintenanceTrackName")
  valid_593257 = validateParameter(valid_593257, JString, required = false,
                                 default = nil)
  if valid_593257 != nil:
    section.add "MaintenanceTrackName", valid_593257
  var valid_593258 = formData.getOrDefault("MasterUsername")
  valid_593258 = validateParameter(valid_593258, JString, required = true,
                                 default = nil)
  if valid_593258 != nil:
    section.add "MasterUsername", valid_593258
  var valid_593259 = formData.getOrDefault("ClusterSecurityGroups")
  valid_593259 = validateParameter(valid_593259, JArray, required = false,
                                 default = nil)
  if valid_593259 != nil:
    section.add "ClusterSecurityGroups", valid_593259
  var valid_593260 = formData.getOrDefault("IamRoles")
  valid_593260 = validateParameter(valid_593260, JArray, required = false,
                                 default = nil)
  if valid_593260 != nil:
    section.add "IamRoles", valid_593260
  var valid_593261 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_593261 = validateParameter(valid_593261, JArray, required = false,
                                 default = nil)
  if valid_593261 != nil:
    section.add "VpcSecurityGroupIds", valid_593261
  var valid_593262 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_593262 = validateParameter(valid_593262, JInt, required = false, default = nil)
  if valid_593262 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_593262
  var valid_593263 = formData.getOrDefault("AvailabilityZone")
  valid_593263 = validateParameter(valid_593263, JString, required = false,
                                 default = nil)
  if valid_593263 != nil:
    section.add "AvailabilityZone", valid_593263
  var valid_593264 = formData.getOrDefault("NumberOfNodes")
  valid_593264 = validateParameter(valid_593264, JInt, required = false, default = nil)
  if valid_593264 != nil:
    section.add "NumberOfNodes", valid_593264
  var valid_593265 = formData.getOrDefault("KmsKeyId")
  valid_593265 = validateParameter(valid_593265, JString, required = false,
                                 default = nil)
  if valid_593265 != nil:
    section.add "KmsKeyId", valid_593265
  var valid_593266 = formData.getOrDefault("EnhancedVpcRouting")
  valid_593266 = validateParameter(valid_593266, JBool, required = false, default = nil)
  if valid_593266 != nil:
    section.add "EnhancedVpcRouting", valid_593266
  var valid_593267 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_593267 = validateParameter(valid_593267, JString, required = false,
                                 default = nil)
  if valid_593267 != nil:
    section.add "ClusterSubnetGroupName", valid_593267
  var valid_593268 = formData.getOrDefault("AllowVersionUpgrade")
  valid_593268 = validateParameter(valid_593268, JBool, required = false, default = nil)
  if valid_593268 != nil:
    section.add "AllowVersionUpgrade", valid_593268
  var valid_593269 = formData.getOrDefault("DBName")
  valid_593269 = validateParameter(valid_593269, JString, required = false,
                                 default = nil)
  if valid_593269 != nil:
    section.add "DBName", valid_593269
  var valid_593270 = formData.getOrDefault("PubliclyAccessible")
  valid_593270 = validateParameter(valid_593270, JBool, required = false, default = nil)
  if valid_593270 != nil:
    section.add "PubliclyAccessible", valid_593270
  var valid_593271 = formData.getOrDefault("ClusterParameterGroupName")
  valid_593271 = validateParameter(valid_593271, JString, required = false,
                                 default = nil)
  if valid_593271 != nil:
    section.add "ClusterParameterGroupName", valid_593271
  var valid_593272 = formData.getOrDefault("ClusterVersion")
  valid_593272 = validateParameter(valid_593272, JString, required = false,
                                 default = nil)
  if valid_593272 != nil:
    section.add "ClusterVersion", valid_593272
  var valid_593273 = formData.getOrDefault("ClusterType")
  valid_593273 = validateParameter(valid_593273, JString, required = false,
                                 default = nil)
  if valid_593273 != nil:
    section.add "ClusterType", valid_593273
  var valid_593274 = formData.getOrDefault("Encrypted")
  valid_593274 = validateParameter(valid_593274, JBool, required = false, default = nil)
  if valid_593274 != nil:
    section.add "Encrypted", valid_593274
  var valid_593275 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_593275 = validateParameter(valid_593275, JString, required = false,
                                 default = nil)
  if valid_593275 != nil:
    section.add "HsmClientCertificateIdentifier", valid_593275
  var valid_593276 = formData.getOrDefault("Tags")
  valid_593276 = validateParameter(valid_593276, JArray, required = false,
                                 default = nil)
  if valid_593276 != nil:
    section.add "Tags", valid_593276
  var valid_593277 = formData.getOrDefault("AdditionalInfo")
  valid_593277 = validateParameter(valid_593277, JString, required = false,
                                 default = nil)
  if valid_593277 != nil:
    section.add "AdditionalInfo", valid_593277
  var valid_593278 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_593278 = validateParameter(valid_593278, JString, required = false,
                                 default = nil)
  if valid_593278 != nil:
    section.add "SnapshotScheduleIdentifier", valid_593278
  var valid_593279 = formData.getOrDefault("ElasticIp")
  valid_593279 = validateParameter(valid_593279, JString, required = false,
                                 default = nil)
  if valid_593279 != nil:
    section.add "ElasticIp", valid_593279
  var valid_593280 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_593280 = validateParameter(valid_593280, JString, required = false,
                                 default = nil)
  if valid_593280 != nil:
    section.add "HsmConfigurationIdentifier", valid_593280
  var valid_593281 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_593281 = validateParameter(valid_593281, JInt, required = false, default = nil)
  if valid_593281 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_593281
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593282: Call_PostCreateCluster_593240; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593282.validator(path, query, header, formData, body)
  let scheme = call_593282.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593282.url(scheme.get, call_593282.host, call_593282.base,
                         call_593282.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593282, url, valid)

proc call*(call_593283: Call_PostCreateCluster_593240; NodeType: string;
          ClusterIdentifier: string; MasterUserPassword: string;
          MasterUsername: string; PreferredMaintenanceWindow: string = "";
          Port: int = 0; MaintenanceTrackName: string = "";
          ClusterSecurityGroups: JsonNode = nil; IamRoles: JsonNode = nil;
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0; AvailabilityZone: string = "";
          NumberOfNodes: int = 0; KmsKeyId: string = "";
          EnhancedVpcRouting: bool = false; ClusterSubnetGroupName: string = "";
          AllowVersionUpgrade: bool = false; DBName: string = "";
          PubliclyAccessible: bool = false; Action: string = "CreateCluster";
          ClusterParameterGroupName: string = ""; ClusterVersion: string = "";
          ClusterType: string = ""; Encrypted: bool = false;
          HsmClientCertificateIdentifier: string = ""; Tags: JsonNode = nil;
          AdditionalInfo: string = ""; SnapshotScheduleIdentifier: string = "";
          Version: string = "2012-12-01"; ElasticIp: string = "";
          HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_593284 = newJObject()
  var formData_593285 = newJObject()
  add(formData_593285, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_593285, "Port", newJInt(Port))
  add(formData_593285, "NodeType", newJString(NodeType))
  add(formData_593285, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_593285, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_593285, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_593285, "MasterUsername", newJString(MasterUsername))
  if ClusterSecurityGroups != nil:
    formData_593285.add "ClusterSecurityGroups", ClusterSecurityGroups
  if IamRoles != nil:
    formData_593285.add "IamRoles", IamRoles
  if VpcSecurityGroupIds != nil:
    formData_593285.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_593285, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_593285, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_593285, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_593285, "KmsKeyId", newJString(KmsKeyId))
  add(formData_593285, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_593285, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_593285, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_593285, "DBName", newJString(DBName))
  add(formData_593285, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_593284, "Action", newJString(Action))
  add(formData_593285, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_593285, "ClusterVersion", newJString(ClusterVersion))
  add(formData_593285, "ClusterType", newJString(ClusterType))
  add(formData_593285, "Encrypted", newJBool(Encrypted))
  add(formData_593285, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    formData_593285.add "Tags", Tags
  add(formData_593285, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_593285, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_593284, "Version", newJString(Version))
  add(formData_593285, "ElasticIp", newJString(ElasticIp))
  add(formData_593285, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_593285, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_593283.call(nil, query_593284, nil, formData_593285, nil)

var postCreateCluster* = Call_PostCreateCluster_593240(name: "postCreateCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_PostCreateCluster_593241,
    base: "/", url: url_PostCreateCluster_593242,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateCluster_593195 = ref object of OpenApiRestCall_592348
proc url_GetCreateCluster_593197(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateCluster_593196(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   MaintenanceTrackName: JString
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   DBName: JString
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Encrypted: JBool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: JString (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterType: JString
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   MasterUsername: JString (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   MasterUserPassword: JString (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AvailabilityZone: JString
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  section = newJObject()
  var valid_593198 = query.getOrDefault("ClusterSubnetGroupName")
  valid_593198 = validateParameter(valid_593198, JString, required = false,
                                 default = nil)
  if valid_593198 != nil:
    section.add "ClusterSubnetGroupName", valid_593198
  var valid_593199 = query.getOrDefault("MaintenanceTrackName")
  valid_593199 = validateParameter(valid_593199, JString, required = false,
                                 default = nil)
  if valid_593199 != nil:
    section.add "MaintenanceTrackName", valid_593199
  var valid_593200 = query.getOrDefault("DBName")
  valid_593200 = validateParameter(valid_593200, JString, required = false,
                                 default = nil)
  if valid_593200 != nil:
    section.add "DBName", valid_593200
  var valid_593201 = query.getOrDefault("Encrypted")
  valid_593201 = validateParameter(valid_593201, JBool, required = false, default = nil)
  if valid_593201 != nil:
    section.add "Encrypted", valid_593201
  var valid_593202 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_593202 = validateParameter(valid_593202, JInt, required = false, default = nil)
  if valid_593202 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_593202
  var valid_593203 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_593203 = validateParameter(valid_593203, JString, required = false,
                                 default = nil)
  if valid_593203 != nil:
    section.add "HsmClientCertificateIdentifier", valid_593203
  var valid_593204 = query.getOrDefault("ClusterSecurityGroups")
  valid_593204 = validateParameter(valid_593204, JArray, required = false,
                                 default = nil)
  if valid_593204 != nil:
    section.add "ClusterSecurityGroups", valid_593204
  var valid_593205 = query.getOrDefault("Tags")
  valid_593205 = validateParameter(valid_593205, JArray, required = false,
                                 default = nil)
  if valid_593205 != nil:
    section.add "Tags", valid_593205
  var valid_593206 = query.getOrDefault("KmsKeyId")
  valid_593206 = validateParameter(valid_593206, JString, required = false,
                                 default = nil)
  if valid_593206 != nil:
    section.add "KmsKeyId", valid_593206
  var valid_593207 = query.getOrDefault("ClusterParameterGroupName")
  valid_593207 = validateParameter(valid_593207, JString, required = false,
                                 default = nil)
  if valid_593207 != nil:
    section.add "ClusterParameterGroupName", valid_593207
  assert query != nil,
        "query argument is necessary due to required `NodeType` field"
  var valid_593208 = query.getOrDefault("NodeType")
  valid_593208 = validateParameter(valid_593208, JString, required = true,
                                 default = nil)
  if valid_593208 != nil:
    section.add "NodeType", valid_593208
  var valid_593209 = query.getOrDefault("ClusterVersion")
  valid_593209 = validateParameter(valid_593209, JString, required = false,
                                 default = nil)
  if valid_593209 != nil:
    section.add "ClusterVersion", valid_593209
  var valid_593210 = query.getOrDefault("IamRoles")
  valid_593210 = validateParameter(valid_593210, JArray, required = false,
                                 default = nil)
  if valid_593210 != nil:
    section.add "IamRoles", valid_593210
  var valid_593211 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_593211 = validateParameter(valid_593211, JString, required = false,
                                 default = nil)
  if valid_593211 != nil:
    section.add "SnapshotScheduleIdentifier", valid_593211
  var valid_593212 = query.getOrDefault("ClusterType")
  valid_593212 = validateParameter(valid_593212, JString, required = false,
                                 default = nil)
  if valid_593212 != nil:
    section.add "ClusterType", valid_593212
  var valid_593213 = query.getOrDefault("NumberOfNodes")
  valid_593213 = validateParameter(valid_593213, JInt, required = false, default = nil)
  if valid_593213 != nil:
    section.add "NumberOfNodes", valid_593213
  var valid_593214 = query.getOrDefault("MasterUsername")
  valid_593214 = validateParameter(valid_593214, JString, required = true,
                                 default = nil)
  if valid_593214 != nil:
    section.add "MasterUsername", valid_593214
  var valid_593215 = query.getOrDefault("AdditionalInfo")
  valid_593215 = validateParameter(valid_593215, JString, required = false,
                                 default = nil)
  if valid_593215 != nil:
    section.add "AdditionalInfo", valid_593215
  var valid_593216 = query.getOrDefault("AllowVersionUpgrade")
  valid_593216 = validateParameter(valid_593216, JBool, required = false, default = nil)
  if valid_593216 != nil:
    section.add "AllowVersionUpgrade", valid_593216
  var valid_593217 = query.getOrDefault("ElasticIp")
  valid_593217 = validateParameter(valid_593217, JString, required = false,
                                 default = nil)
  if valid_593217 != nil:
    section.add "ElasticIp", valid_593217
  var valid_593218 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_593218 = validateParameter(valid_593218, JInt, required = false, default = nil)
  if valid_593218 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_593218
  var valid_593219 = query.getOrDefault("EnhancedVpcRouting")
  valid_593219 = validateParameter(valid_593219, JBool, required = false, default = nil)
  if valid_593219 != nil:
    section.add "EnhancedVpcRouting", valid_593219
  var valid_593220 = query.getOrDefault("Action")
  valid_593220 = validateParameter(valid_593220, JString, required = true,
                                 default = newJString("CreateCluster"))
  if valid_593220 != nil:
    section.add "Action", valid_593220
  var valid_593221 = query.getOrDefault("ClusterIdentifier")
  valid_593221 = validateParameter(valid_593221, JString, required = true,
                                 default = nil)
  if valid_593221 != nil:
    section.add "ClusterIdentifier", valid_593221
  var valid_593222 = query.getOrDefault("Port")
  valid_593222 = validateParameter(valid_593222, JInt, required = false, default = nil)
  if valid_593222 != nil:
    section.add "Port", valid_593222
  var valid_593223 = query.getOrDefault("VpcSecurityGroupIds")
  valid_593223 = validateParameter(valid_593223, JArray, required = false,
                                 default = nil)
  if valid_593223 != nil:
    section.add "VpcSecurityGroupIds", valid_593223
  var valid_593224 = query.getOrDefault("MasterUserPassword")
  valid_593224 = validateParameter(valid_593224, JString, required = true,
                                 default = nil)
  if valid_593224 != nil:
    section.add "MasterUserPassword", valid_593224
  var valid_593225 = query.getOrDefault("AvailabilityZone")
  valid_593225 = validateParameter(valid_593225, JString, required = false,
                                 default = nil)
  if valid_593225 != nil:
    section.add "AvailabilityZone", valid_593225
  var valid_593226 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_593226 = validateParameter(valid_593226, JString, required = false,
                                 default = nil)
  if valid_593226 != nil:
    section.add "HsmConfigurationIdentifier", valid_593226
  var valid_593227 = query.getOrDefault("Version")
  valid_593227 = validateParameter(valid_593227, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593227 != nil:
    section.add "Version", valid_593227
  var valid_593228 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_593228 = validateParameter(valid_593228, JString, required = false,
                                 default = nil)
  if valid_593228 != nil:
    section.add "PreferredMaintenanceWindow", valid_593228
  var valid_593229 = query.getOrDefault("PubliclyAccessible")
  valid_593229 = validateParameter(valid_593229, JBool, required = false, default = nil)
  if valid_593229 != nil:
    section.add "PubliclyAccessible", valid_593229
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593230 = header.getOrDefault("X-Amz-Signature")
  valid_593230 = validateParameter(valid_593230, JString, required = false,
                                 default = nil)
  if valid_593230 != nil:
    section.add "X-Amz-Signature", valid_593230
  var valid_593231 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593231 = validateParameter(valid_593231, JString, required = false,
                                 default = nil)
  if valid_593231 != nil:
    section.add "X-Amz-Content-Sha256", valid_593231
  var valid_593232 = header.getOrDefault("X-Amz-Date")
  valid_593232 = validateParameter(valid_593232, JString, required = false,
                                 default = nil)
  if valid_593232 != nil:
    section.add "X-Amz-Date", valid_593232
  var valid_593233 = header.getOrDefault("X-Amz-Credential")
  valid_593233 = validateParameter(valid_593233, JString, required = false,
                                 default = nil)
  if valid_593233 != nil:
    section.add "X-Amz-Credential", valid_593233
  var valid_593234 = header.getOrDefault("X-Amz-Security-Token")
  valid_593234 = validateParameter(valid_593234, JString, required = false,
                                 default = nil)
  if valid_593234 != nil:
    section.add "X-Amz-Security-Token", valid_593234
  var valid_593235 = header.getOrDefault("X-Amz-Algorithm")
  valid_593235 = validateParameter(valid_593235, JString, required = false,
                                 default = nil)
  if valid_593235 != nil:
    section.add "X-Amz-Algorithm", valid_593235
  var valid_593236 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593236 = validateParameter(valid_593236, JString, required = false,
                                 default = nil)
  if valid_593236 != nil:
    section.add "X-Amz-SignedHeaders", valid_593236
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593237: Call_GetCreateCluster_593195; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593237.validator(path, query, header, formData, body)
  let scheme = call_593237.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593237.url(scheme.get, call_593237.host, call_593237.base,
                         call_593237.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593237, url, valid)

proc call*(call_593238: Call_GetCreateCluster_593195; NodeType: string;
          MasterUsername: string; ClusterIdentifier: string;
          MasterUserPassword: string; ClusterSubnetGroupName: string = "";
          MaintenanceTrackName: string = ""; DBName: string = "";
          Encrypted: bool = false; ManualSnapshotRetentionPeriod: int = 0;
          HsmClientCertificateIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil; Tags: JsonNode = nil;
          KmsKeyId: string = ""; ClusterParameterGroupName: string = "";
          ClusterVersion: string = ""; IamRoles: JsonNode = nil;
          SnapshotScheduleIdentifier: string = ""; ClusterType: string = "";
          NumberOfNodes: int = 0; AdditionalInfo: string = "";
          AllowVersionUpgrade: bool = false; ElasticIp: string = "";
          AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false; Action: string = "CreateCluster";
          Port: int = 0; VpcSecurityGroupIds: JsonNode = nil;
          AvailabilityZone: string = ""; HsmConfigurationIdentifier: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getCreateCluster
  ## <p>Creates a new cluster.</p> <p>To create a cluster in Virtual Private Cloud (VPC), you must provide a cluster subnet group name. The cluster subnet group identifies the subnets of your VPC that Amazon Redshift uses when creating the cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of a cluster subnet group to be associated with this cluster.</p> <p>If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).</p>
  ##   MaintenanceTrackName: string
  ##                       : An optional parameter for the name of the maintenance track for the cluster. If you don't provide a maintenance track name, the cluster is assigned to the <code>current</code> track.
  ##   DBName: string
  ##         : <p>The name of the first database to be created when the cluster is created.</p> <p>To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database. For more information, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/t_creating_database.html">Create a Database</a> in the Amazon Redshift Database Developer Guide. </p> <p>Default: <code>dev</code> </p> <p>Constraints:</p> <ul> <li> <p>Must contain 1 to 64 alphanumeric characters.</p> </li> <li> <p>Must contain only lowercase letters.</p> </li> <li> <p>Cannot be a word that is reserved by the service. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   Encrypted: bool
  ##            : <p>If <code>true</code>, the data in the cluster is encrypted at rest. </p> <p>Default: false</p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a> </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: string (required)
  ##           : <p>The node type to be provisioned for the cluster. For information about node types, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The version of the Amazon Redshift engine software that you want to deploy on the cluster.</p> <p>The version selected runs on all the nodes in the cluster.</p> <p>Constraints: Only version 1.0 is currently available.</p> <p>Example: <code>1.0</code> </p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated with it at any time.</p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   ClusterType: string
  ##              : <p>The type of the cluster. When cluster type is specified as</p> <ul> <li> <p> <code>single-node</code>, the <b>NumberOfNodes</b> parameter is not required.</p> </li> <li> <p> <code>multi-node</code>, the <b>NumberOfNodes</b> parameter is required.</p> </li> </ul> <p>Valid Values: <code>multi-node</code> | <code>single-node</code> </p> <p>Default: <code>multi-node</code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The number of compute nodes in the cluster. This parameter is required when the <b>ClusterType</b> parameter is specified as <code>multi-node</code>. </p> <p>For information about determining how many nodes you need, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#how-many-nodes"> Working with Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p> <p>If you don't specify this parameter, you get a single-node cluster. When requesting a multi-node cluster, you must specify the number of nodes that you want in the cluster.</p> <p>Default: <code>1</code> </p> <p>Constraints: Value must be at least 1 and no more than 100.</p>
  ##   MasterUsername: string (required)
  ##                 : <p>The user name associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 - 128 alphanumeric characters. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide. </p> </li> </ul>
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster.</p> <p>When a new major version of the Amazon Redshift engine is released, you can request that the service automatically apply upgrades during the maintenance window to the Amazon Redshift engine that is running on your cluster.</p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: <code>1</code> </p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. The identifier also appears in the Amazon Redshift console.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>myexamplecluster</code> </p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts incoming connections.</p> <p>The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections.</p> <p>Default: <code>5439</code> </p> <p>Valid Values: <code>1150-65535</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p>
  ##   MasterUserPassword: string (required)
  ##                     : <p>The password associated with the master user account for the cluster that is being created.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   AvailabilityZone: string
  ##                   : <p>The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.</p> <p>Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint.</p> <p>Example: <code>us-east-1d</code> </p> <p>Constraint: The specified Availability Zone must be in the same region as the current endpoint.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: A 30-minute window selected at random from an 8-hour block of time per region, occurring on a random day of the week. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  var query_593239 = newJObject()
  add(query_593239, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_593239, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_593239, "DBName", newJString(DBName))
  add(query_593239, "Encrypted", newJBool(Encrypted))
  add(query_593239, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_593239, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if ClusterSecurityGroups != nil:
    query_593239.add "ClusterSecurityGroups", ClusterSecurityGroups
  if Tags != nil:
    query_593239.add "Tags", Tags
  add(query_593239, "KmsKeyId", newJString(KmsKeyId))
  add(query_593239, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_593239, "NodeType", newJString(NodeType))
  add(query_593239, "ClusterVersion", newJString(ClusterVersion))
  if IamRoles != nil:
    query_593239.add "IamRoles", IamRoles
  add(query_593239, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_593239, "ClusterType", newJString(ClusterType))
  add(query_593239, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_593239, "MasterUsername", newJString(MasterUsername))
  add(query_593239, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_593239, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_593239, "ElasticIp", newJString(ElasticIp))
  add(query_593239, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_593239, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_593239, "Action", newJString(Action))
  add(query_593239, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_593239, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    query_593239.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_593239, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_593239, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_593239, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_593239, "Version", newJString(Version))
  add(query_593239, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_593239, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_593238.call(nil, query_593239, nil, nil, nil)

var getCreateCluster* = Call_GetCreateCluster_593195(name: "getCreateCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateCluster", validator: validate_GetCreateCluster_593196,
    base: "/", url: url_GetCreateCluster_593197,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterParameterGroup_593305 = ref object of OpenApiRestCall_592348
proc url_PostCreateClusterParameterGroup_593307(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterParameterGroup_593306(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593308 = query.getOrDefault("Action")
  valid_593308 = validateParameter(valid_593308, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_593308 != nil:
    section.add "Action", valid_593308
  var valid_593309 = query.getOrDefault("Version")
  valid_593309 = validateParameter(valid_593309, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593309 != nil:
    section.add "Version", valid_593309
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593310 = header.getOrDefault("X-Amz-Signature")
  valid_593310 = validateParameter(valid_593310, JString, required = false,
                                 default = nil)
  if valid_593310 != nil:
    section.add "X-Amz-Signature", valid_593310
  var valid_593311 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593311 = validateParameter(valid_593311, JString, required = false,
                                 default = nil)
  if valid_593311 != nil:
    section.add "X-Amz-Content-Sha256", valid_593311
  var valid_593312 = header.getOrDefault("X-Amz-Date")
  valid_593312 = validateParameter(valid_593312, JString, required = false,
                                 default = nil)
  if valid_593312 != nil:
    section.add "X-Amz-Date", valid_593312
  var valid_593313 = header.getOrDefault("X-Amz-Credential")
  valid_593313 = validateParameter(valid_593313, JString, required = false,
                                 default = nil)
  if valid_593313 != nil:
    section.add "X-Amz-Credential", valid_593313
  var valid_593314 = header.getOrDefault("X-Amz-Security-Token")
  valid_593314 = validateParameter(valid_593314, JString, required = false,
                                 default = nil)
  if valid_593314 != nil:
    section.add "X-Amz-Security-Token", valid_593314
  var valid_593315 = header.getOrDefault("X-Amz-Algorithm")
  valid_593315 = validateParameter(valid_593315, JString, required = false,
                                 default = nil)
  if valid_593315 != nil:
    section.add "X-Amz-Algorithm", valid_593315
  var valid_593316 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593316 = validateParameter(valid_593316, JString, required = false,
                                 default = nil)
  if valid_593316 != nil:
    section.add "X-Amz-SignedHeaders", valid_593316
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_593317 = formData.getOrDefault("Description")
  valid_593317 = validateParameter(valid_593317, JString, required = true,
                                 default = nil)
  if valid_593317 != nil:
    section.add "Description", valid_593317
  var valid_593318 = formData.getOrDefault("ParameterGroupFamily")
  valid_593318 = validateParameter(valid_593318, JString, required = true,
                                 default = nil)
  if valid_593318 != nil:
    section.add "ParameterGroupFamily", valid_593318
  var valid_593319 = formData.getOrDefault("Tags")
  valid_593319 = validateParameter(valid_593319, JArray, required = false,
                                 default = nil)
  if valid_593319 != nil:
    section.add "Tags", valid_593319
  var valid_593320 = formData.getOrDefault("ParameterGroupName")
  valid_593320 = validateParameter(valid_593320, JString, required = true,
                                 default = nil)
  if valid_593320 != nil:
    section.add "ParameterGroupName", valid_593320
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593321: Call_PostCreateClusterParameterGroup_593305;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593321.validator(path, query, header, formData, body)
  let scheme = call_593321.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593321.url(scheme.get, call_593321.host, call_593321.base,
                         call_593321.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593321, url, valid)

proc call*(call_593322: Call_PostCreateClusterParameterGroup_593305;
          Description: string; ParameterGroupFamily: string;
          ParameterGroupName: string;
          Action: string = "CreateClusterParameterGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: string (required)
  var query_593323 = newJObject()
  var formData_593324 = newJObject()
  add(formData_593324, "Description", newJString(Description))
  add(formData_593324, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_593323, "Action", newJString(Action))
  if Tags != nil:
    formData_593324.add "Tags", Tags
  add(formData_593324, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_593323, "Version", newJString(Version))
  result = call_593322.call(nil, query_593323, nil, formData_593324, nil)

var postCreateClusterParameterGroup* = Call_PostCreateClusterParameterGroup_593305(
    name: "postCreateClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_PostCreateClusterParameterGroup_593306, base: "/",
    url: url_PostCreateClusterParameterGroup_593307,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterParameterGroup_593286 = ref object of OpenApiRestCall_592348
proc url_GetCreateClusterParameterGroup_593288(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterParameterGroup_593287(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: JString (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: JString (required)
  section = newJObject()
  var valid_593289 = query.getOrDefault("Tags")
  valid_593289 = validateParameter(valid_593289, JArray, required = false,
                                 default = nil)
  if valid_593289 != nil:
    section.add "Tags", valid_593289
  assert query != nil, "query argument is necessary due to required `ParameterGroupFamily` field"
  var valid_593290 = query.getOrDefault("ParameterGroupFamily")
  valid_593290 = validateParameter(valid_593290, JString, required = true,
                                 default = nil)
  if valid_593290 != nil:
    section.add "ParameterGroupFamily", valid_593290
  var valid_593291 = query.getOrDefault("Action")
  valid_593291 = validateParameter(valid_593291, JString, required = true, default = newJString(
      "CreateClusterParameterGroup"))
  if valid_593291 != nil:
    section.add "Action", valid_593291
  var valid_593292 = query.getOrDefault("Description")
  valid_593292 = validateParameter(valid_593292, JString, required = true,
                                 default = nil)
  if valid_593292 != nil:
    section.add "Description", valid_593292
  var valid_593293 = query.getOrDefault("ParameterGroupName")
  valid_593293 = validateParameter(valid_593293, JString, required = true,
                                 default = nil)
  if valid_593293 != nil:
    section.add "ParameterGroupName", valid_593293
  var valid_593294 = query.getOrDefault("Version")
  valid_593294 = validateParameter(valid_593294, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593294 != nil:
    section.add "Version", valid_593294
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593295 = header.getOrDefault("X-Amz-Signature")
  valid_593295 = validateParameter(valid_593295, JString, required = false,
                                 default = nil)
  if valid_593295 != nil:
    section.add "X-Amz-Signature", valid_593295
  var valid_593296 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593296 = validateParameter(valid_593296, JString, required = false,
                                 default = nil)
  if valid_593296 != nil:
    section.add "X-Amz-Content-Sha256", valid_593296
  var valid_593297 = header.getOrDefault("X-Amz-Date")
  valid_593297 = validateParameter(valid_593297, JString, required = false,
                                 default = nil)
  if valid_593297 != nil:
    section.add "X-Amz-Date", valid_593297
  var valid_593298 = header.getOrDefault("X-Amz-Credential")
  valid_593298 = validateParameter(valid_593298, JString, required = false,
                                 default = nil)
  if valid_593298 != nil:
    section.add "X-Amz-Credential", valid_593298
  var valid_593299 = header.getOrDefault("X-Amz-Security-Token")
  valid_593299 = validateParameter(valid_593299, JString, required = false,
                                 default = nil)
  if valid_593299 != nil:
    section.add "X-Amz-Security-Token", valid_593299
  var valid_593300 = header.getOrDefault("X-Amz-Algorithm")
  valid_593300 = validateParameter(valid_593300, JString, required = false,
                                 default = nil)
  if valid_593300 != nil:
    section.add "X-Amz-Algorithm", valid_593300
  var valid_593301 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593301 = validateParameter(valid_593301, JString, required = false,
                                 default = nil)
  if valid_593301 != nil:
    section.add "X-Amz-SignedHeaders", valid_593301
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593302: Call_GetCreateClusterParameterGroup_593286; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593302.validator(path, query, header, formData, body)
  let scheme = call_593302.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593302.url(scheme.get, call_593302.host, call_593302.base,
                         call_593302.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593302, url, valid)

proc call*(call_593303: Call_GetCreateClusterParameterGroup_593286;
          ParameterGroupFamily: string; Description: string;
          ParameterGroupName: string; Tags: JsonNode = nil;
          Action: string = "CreateClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterParameterGroup
  ## <p>Creates an Amazon Redshift parameter group.</p> <p>Creating parameter groups is independent of creating clusters. You can associate a cluster with a parameter group when you create the cluster. You can also associate an existing cluster with a parameter group after the cluster is created by using <a>ModifyCluster</a>. </p> <p>Parameters in the parameter group define specific behavior that applies to the databases you create on the cluster. For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ParameterGroupFamily: string (required)
  ##                       : <p>The Amazon Redshift engine version to which the cluster parameter group applies. The cluster engine version determines the set of parameters.</p> <p>To get a list of valid parameter group family names, you can call <a>DescribeClusterParameterGroups</a>. By default, Amazon Redshift returns a list of all the parameter groups that are owned by your AWS account, including the default parameter groups for each Amazon Redshift engine version. The parameter group family names associated with the default parameter groups provide you the valid values. For example, a valid family name is "redshift-1.0". </p>
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description of the parameter group.
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the cluster parameter group.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique withing your AWS account.</p> </li> </ul> <note> <p>This value is stored as a lower-case string.</p> </note>
  ##   Version: string (required)
  var query_593304 = newJObject()
  if Tags != nil:
    query_593304.add "Tags", Tags
  add(query_593304, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_593304, "Action", newJString(Action))
  add(query_593304, "Description", newJString(Description))
  add(query_593304, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_593304, "Version", newJString(Version))
  result = call_593303.call(nil, query_593304, nil, nil, nil)

var getCreateClusterParameterGroup* = Call_GetCreateClusterParameterGroup_593286(
    name: "getCreateClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterParameterGroup",
    validator: validate_GetCreateClusterParameterGroup_593287, base: "/",
    url: url_GetCreateClusterParameterGroup_593288,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSecurityGroup_593343 = ref object of OpenApiRestCall_592348
proc url_PostCreateClusterSecurityGroup_593345(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterSecurityGroup_593344(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593346 = query.getOrDefault("Action")
  valid_593346 = validateParameter(valid_593346, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_593346 != nil:
    section.add "Action", valid_593346
  var valid_593347 = query.getOrDefault("Version")
  valid_593347 = validateParameter(valid_593347, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593347 != nil:
    section.add "Version", valid_593347
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593348 = header.getOrDefault("X-Amz-Signature")
  valid_593348 = validateParameter(valid_593348, JString, required = false,
                                 default = nil)
  if valid_593348 != nil:
    section.add "X-Amz-Signature", valid_593348
  var valid_593349 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593349 = validateParameter(valid_593349, JString, required = false,
                                 default = nil)
  if valid_593349 != nil:
    section.add "X-Amz-Content-Sha256", valid_593349
  var valid_593350 = header.getOrDefault("X-Amz-Date")
  valid_593350 = validateParameter(valid_593350, JString, required = false,
                                 default = nil)
  if valid_593350 != nil:
    section.add "X-Amz-Date", valid_593350
  var valid_593351 = header.getOrDefault("X-Amz-Credential")
  valid_593351 = validateParameter(valid_593351, JString, required = false,
                                 default = nil)
  if valid_593351 != nil:
    section.add "X-Amz-Credential", valid_593351
  var valid_593352 = header.getOrDefault("X-Amz-Security-Token")
  valid_593352 = validateParameter(valid_593352, JString, required = false,
                                 default = nil)
  if valid_593352 != nil:
    section.add "X-Amz-Security-Token", valid_593352
  var valid_593353 = header.getOrDefault("X-Amz-Algorithm")
  valid_593353 = validateParameter(valid_593353, JString, required = false,
                                 default = nil)
  if valid_593353 != nil:
    section.add "X-Amz-Algorithm", valid_593353
  var valid_593354 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593354 = validateParameter(valid_593354, JString, required = false,
                                 default = nil)
  if valid_593354 != nil:
    section.add "X-Amz-SignedHeaders", valid_593354
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_593355 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_593355 = validateParameter(valid_593355, JString, required = true,
                                 default = nil)
  if valid_593355 != nil:
    section.add "ClusterSecurityGroupName", valid_593355
  var valid_593356 = formData.getOrDefault("Description")
  valid_593356 = validateParameter(valid_593356, JString, required = true,
                                 default = nil)
  if valid_593356 != nil:
    section.add "Description", valid_593356
  var valid_593357 = formData.getOrDefault("Tags")
  valid_593357 = validateParameter(valid_593357, JArray, required = false,
                                 default = nil)
  if valid_593357 != nil:
    section.add "Tags", valid_593357
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593358: Call_PostCreateClusterSecurityGroup_593343; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593358.validator(path, query, header, formData, body)
  let scheme = call_593358.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593358.url(scheme.get, call_593358.host, call_593358.base,
                         call_593358.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593358, url, valid)

proc call*(call_593359: Call_PostCreateClusterSecurityGroup_593343;
          ClusterSecurityGroupName: string; Description: string;
          Action: string = "CreateClusterSecurityGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_593360 = newJObject()
  var formData_593361 = newJObject()
  add(formData_593361, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_593361, "Description", newJString(Description))
  add(query_593360, "Action", newJString(Action))
  if Tags != nil:
    formData_593361.add "Tags", Tags
  add(query_593360, "Version", newJString(Version))
  result = call_593359.call(nil, query_593360, nil, formData_593361, nil)

var postCreateClusterSecurityGroup* = Call_PostCreateClusterSecurityGroup_593343(
    name: "postCreateClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_PostCreateClusterSecurityGroup_593344, base: "/",
    url: url_PostCreateClusterSecurityGroup_593345,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSecurityGroup_593325 = ref object of OpenApiRestCall_592348
proc url_GetCreateClusterSecurityGroup_593327(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterSecurityGroup_593326(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description for the security group.
  ##   Version: JString (required)
  section = newJObject()
  var valid_593328 = query.getOrDefault("Tags")
  valid_593328 = validateParameter(valid_593328, JArray, required = false,
                                 default = nil)
  if valid_593328 != nil:
    section.add "Tags", valid_593328
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_593329 = query.getOrDefault("ClusterSecurityGroupName")
  valid_593329 = validateParameter(valid_593329, JString, required = true,
                                 default = nil)
  if valid_593329 != nil:
    section.add "ClusterSecurityGroupName", valid_593329
  var valid_593330 = query.getOrDefault("Action")
  valid_593330 = validateParameter(valid_593330, JString, required = true, default = newJString(
      "CreateClusterSecurityGroup"))
  if valid_593330 != nil:
    section.add "Action", valid_593330
  var valid_593331 = query.getOrDefault("Description")
  valid_593331 = validateParameter(valid_593331, JString, required = true,
                                 default = nil)
  if valid_593331 != nil:
    section.add "Description", valid_593331
  var valid_593332 = query.getOrDefault("Version")
  valid_593332 = validateParameter(valid_593332, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593332 != nil:
    section.add "Version", valid_593332
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593333 = header.getOrDefault("X-Amz-Signature")
  valid_593333 = validateParameter(valid_593333, JString, required = false,
                                 default = nil)
  if valid_593333 != nil:
    section.add "X-Amz-Signature", valid_593333
  var valid_593334 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593334 = validateParameter(valid_593334, JString, required = false,
                                 default = nil)
  if valid_593334 != nil:
    section.add "X-Amz-Content-Sha256", valid_593334
  var valid_593335 = header.getOrDefault("X-Amz-Date")
  valid_593335 = validateParameter(valid_593335, JString, required = false,
                                 default = nil)
  if valid_593335 != nil:
    section.add "X-Amz-Date", valid_593335
  var valid_593336 = header.getOrDefault("X-Amz-Credential")
  valid_593336 = validateParameter(valid_593336, JString, required = false,
                                 default = nil)
  if valid_593336 != nil:
    section.add "X-Amz-Credential", valid_593336
  var valid_593337 = header.getOrDefault("X-Amz-Security-Token")
  valid_593337 = validateParameter(valid_593337, JString, required = false,
                                 default = nil)
  if valid_593337 != nil:
    section.add "X-Amz-Security-Token", valid_593337
  var valid_593338 = header.getOrDefault("X-Amz-Algorithm")
  valid_593338 = validateParameter(valid_593338, JString, required = false,
                                 default = nil)
  if valid_593338 != nil:
    section.add "X-Amz-Algorithm", valid_593338
  var valid_593339 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593339 = validateParameter(valid_593339, JString, required = false,
                                 default = nil)
  if valid_593339 != nil:
    section.add "X-Amz-SignedHeaders", valid_593339
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593340: Call_GetCreateClusterSecurityGroup_593325; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593340.validator(path, query, header, formData, body)
  let scheme = call_593340.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593340.url(scheme.get, call_593340.host, call_593340.base,
                         call_593340.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593340, url, valid)

proc call*(call_593341: Call_GetCreateClusterSecurityGroup_593325;
          ClusterSecurityGroupName: string; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSecurityGroup
  ## <p>Creates a new Amazon Redshift security group. You use security groups to control access to non-VPC clusters.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ClusterSecurityGroupName: string (required)
  ##                           : <p>The name for the security group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all security groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesecuritygroup</code> </p>
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description for the security group.
  ##   Version: string (required)
  var query_593342 = newJObject()
  if Tags != nil:
    query_593342.add "Tags", Tags
  add(query_593342, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_593342, "Action", newJString(Action))
  add(query_593342, "Description", newJString(Description))
  add(query_593342, "Version", newJString(Version))
  result = call_593341.call(nil, query_593342, nil, nil, nil)

var getCreateClusterSecurityGroup* = Call_GetCreateClusterSecurityGroup_593325(
    name: "getCreateClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSecurityGroup",
    validator: validate_GetCreateClusterSecurityGroup_593326, base: "/",
    url: url_GetCreateClusterSecurityGroup_593327,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSnapshot_593381 = ref object of OpenApiRestCall_592348
proc url_PostCreateClusterSnapshot_593383(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterSnapshot_593382(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593384 = query.getOrDefault("Action")
  valid_593384 = validateParameter(valid_593384, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_593384 != nil:
    section.add "Action", valid_593384
  var valid_593385 = query.getOrDefault("Version")
  valid_593385 = validateParameter(valid_593385, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593385 != nil:
    section.add "Version", valid_593385
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593386 = header.getOrDefault("X-Amz-Signature")
  valid_593386 = validateParameter(valid_593386, JString, required = false,
                                 default = nil)
  if valid_593386 != nil:
    section.add "X-Amz-Signature", valid_593386
  var valid_593387 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593387 = validateParameter(valid_593387, JString, required = false,
                                 default = nil)
  if valid_593387 != nil:
    section.add "X-Amz-Content-Sha256", valid_593387
  var valid_593388 = header.getOrDefault("X-Amz-Date")
  valid_593388 = validateParameter(valid_593388, JString, required = false,
                                 default = nil)
  if valid_593388 != nil:
    section.add "X-Amz-Date", valid_593388
  var valid_593389 = header.getOrDefault("X-Amz-Credential")
  valid_593389 = validateParameter(valid_593389, JString, required = false,
                                 default = nil)
  if valid_593389 != nil:
    section.add "X-Amz-Credential", valid_593389
  var valid_593390 = header.getOrDefault("X-Amz-Security-Token")
  valid_593390 = validateParameter(valid_593390, JString, required = false,
                                 default = nil)
  if valid_593390 != nil:
    section.add "X-Amz-Security-Token", valid_593390
  var valid_593391 = header.getOrDefault("X-Amz-Algorithm")
  valid_593391 = validateParameter(valid_593391, JString, required = false,
                                 default = nil)
  if valid_593391 != nil:
    section.add "X-Amz-Algorithm", valid_593391
  var valid_593392 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593392 = validateParameter(valid_593392, JString, required = false,
                                 default = nil)
  if valid_593392 != nil:
    section.add "X-Amz-SignedHeaders", valid_593392
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_593393 = formData.getOrDefault("ClusterIdentifier")
  valid_593393 = validateParameter(valid_593393, JString, required = true,
                                 default = nil)
  if valid_593393 != nil:
    section.add "ClusterIdentifier", valid_593393
  var valid_593394 = formData.getOrDefault("SnapshotIdentifier")
  valid_593394 = validateParameter(valid_593394, JString, required = true,
                                 default = nil)
  if valid_593394 != nil:
    section.add "SnapshotIdentifier", valid_593394
  var valid_593395 = formData.getOrDefault("Tags")
  valid_593395 = validateParameter(valid_593395, JArray, required = false,
                                 default = nil)
  if valid_593395 != nil:
    section.add "Tags", valid_593395
  var valid_593396 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_593396 = validateParameter(valid_593396, JInt, required = false, default = nil)
  if valid_593396 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_593396
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593397: Call_PostCreateClusterSnapshot_593381; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593397.validator(path, query, header, formData, body)
  let scheme = call_593397.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593397.url(scheme.get, call_593397.host, call_593397.base,
                         call_593397.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593397, url, valid)

proc call*(call_593398: Call_PostCreateClusterSnapshot_593381;
          ClusterIdentifier: string; SnapshotIdentifier: string;
          Action: string = "CreateClusterSnapshot"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"; ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_593399 = newJObject()
  var formData_593400 = newJObject()
  add(formData_593400, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_593400, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_593399, "Action", newJString(Action))
  if Tags != nil:
    formData_593400.add "Tags", Tags
  add(query_593399, "Version", newJString(Version))
  add(formData_593400, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_593398.call(nil, query_593399, nil, formData_593400, nil)

var postCreateClusterSnapshot* = Call_PostCreateClusterSnapshot_593381(
    name: "postCreateClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_PostCreateClusterSnapshot_593382, base: "/",
    url: url_PostCreateClusterSnapshot_593383,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSnapshot_593362 = ref object of OpenApiRestCall_592348
proc url_GetCreateClusterSnapshot_593364(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterSnapshot_593363(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_593365 = query.getOrDefault("SnapshotIdentifier")
  valid_593365 = validateParameter(valid_593365, JString, required = true,
                                 default = nil)
  if valid_593365 != nil:
    section.add "SnapshotIdentifier", valid_593365
  var valid_593366 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_593366 = validateParameter(valid_593366, JInt, required = false, default = nil)
  if valid_593366 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_593366
  var valid_593367 = query.getOrDefault("Tags")
  valid_593367 = validateParameter(valid_593367, JArray, required = false,
                                 default = nil)
  if valid_593367 != nil:
    section.add "Tags", valid_593367
  var valid_593368 = query.getOrDefault("Action")
  valid_593368 = validateParameter(valid_593368, JString, required = true,
                                 default = newJString("CreateClusterSnapshot"))
  if valid_593368 != nil:
    section.add "Action", valid_593368
  var valid_593369 = query.getOrDefault("ClusterIdentifier")
  valid_593369 = validateParameter(valid_593369, JString, required = true,
                                 default = nil)
  if valid_593369 != nil:
    section.add "ClusterIdentifier", valid_593369
  var valid_593370 = query.getOrDefault("Version")
  valid_593370 = validateParameter(valid_593370, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593370 != nil:
    section.add "Version", valid_593370
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593371 = header.getOrDefault("X-Amz-Signature")
  valid_593371 = validateParameter(valid_593371, JString, required = false,
                                 default = nil)
  if valid_593371 != nil:
    section.add "X-Amz-Signature", valid_593371
  var valid_593372 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593372 = validateParameter(valid_593372, JString, required = false,
                                 default = nil)
  if valid_593372 != nil:
    section.add "X-Amz-Content-Sha256", valid_593372
  var valid_593373 = header.getOrDefault("X-Amz-Date")
  valid_593373 = validateParameter(valid_593373, JString, required = false,
                                 default = nil)
  if valid_593373 != nil:
    section.add "X-Amz-Date", valid_593373
  var valid_593374 = header.getOrDefault("X-Amz-Credential")
  valid_593374 = validateParameter(valid_593374, JString, required = false,
                                 default = nil)
  if valid_593374 != nil:
    section.add "X-Amz-Credential", valid_593374
  var valid_593375 = header.getOrDefault("X-Amz-Security-Token")
  valid_593375 = validateParameter(valid_593375, JString, required = false,
                                 default = nil)
  if valid_593375 != nil:
    section.add "X-Amz-Security-Token", valid_593375
  var valid_593376 = header.getOrDefault("X-Amz-Algorithm")
  valid_593376 = validateParameter(valid_593376, JString, required = false,
                                 default = nil)
  if valid_593376 != nil:
    section.add "X-Amz-Algorithm", valid_593376
  var valid_593377 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593377 = validateParameter(valid_593377, JString, required = false,
                                 default = nil)
  if valid_593377 != nil:
    section.add "X-Amz-SignedHeaders", valid_593377
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593378: Call_GetCreateClusterSnapshot_593362; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593378.validator(path, query, header, formData, body)
  let scheme = call_593378.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593378.url(scheme.get, call_593378.host, call_593378.base,
                         call_593378.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593378, url, valid)

proc call*(call_593379: Call_GetCreateClusterSnapshot_593362;
          SnapshotIdentifier: string; ClusterIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0; Tags: JsonNode = nil;
          Action: string = "CreateClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSnapshot
  ## <p>Creates a manual snapshot of the specified cluster. The cluster must be in the <code>available</code> state. </p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>A unique identifier for the snapshot that you are requesting. This identifier must be unique for all snapshots within the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul> <p>Example: <code>my-snapshot-id</code> </p>
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier for which you want a snapshot.
  ##   Version: string (required)
  var query_593380 = newJObject()
  add(query_593380, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_593380, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  if Tags != nil:
    query_593380.add "Tags", Tags
  add(query_593380, "Action", newJString(Action))
  add(query_593380, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_593380, "Version", newJString(Version))
  result = call_593379.call(nil, query_593380, nil, nil, nil)

var getCreateClusterSnapshot* = Call_GetCreateClusterSnapshot_593362(
    name: "getCreateClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSnapshot",
    validator: validate_GetCreateClusterSnapshot_593363, base: "/",
    url: url_GetCreateClusterSnapshot_593364, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateClusterSubnetGroup_593420 = ref object of OpenApiRestCall_592348
proc url_PostCreateClusterSubnetGroup_593422(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateClusterSubnetGroup_593421(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593423 = query.getOrDefault("Action")
  valid_593423 = validateParameter(valid_593423, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_593423 != nil:
    section.add "Action", valid_593423
  var valid_593424 = query.getOrDefault("Version")
  valid_593424 = validateParameter(valid_593424, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593424 != nil:
    section.add "Version", valid_593424
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593425 = header.getOrDefault("X-Amz-Signature")
  valid_593425 = validateParameter(valid_593425, JString, required = false,
                                 default = nil)
  if valid_593425 != nil:
    section.add "X-Amz-Signature", valid_593425
  var valid_593426 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593426 = validateParameter(valid_593426, JString, required = false,
                                 default = nil)
  if valid_593426 != nil:
    section.add "X-Amz-Content-Sha256", valid_593426
  var valid_593427 = header.getOrDefault("X-Amz-Date")
  valid_593427 = validateParameter(valid_593427, JString, required = false,
                                 default = nil)
  if valid_593427 != nil:
    section.add "X-Amz-Date", valid_593427
  var valid_593428 = header.getOrDefault("X-Amz-Credential")
  valid_593428 = validateParameter(valid_593428, JString, required = false,
                                 default = nil)
  if valid_593428 != nil:
    section.add "X-Amz-Credential", valid_593428
  var valid_593429 = header.getOrDefault("X-Amz-Security-Token")
  valid_593429 = validateParameter(valid_593429, JString, required = false,
                                 default = nil)
  if valid_593429 != nil:
    section.add "X-Amz-Security-Token", valid_593429
  var valid_593430 = header.getOrDefault("X-Amz-Algorithm")
  valid_593430 = validateParameter(valid_593430, JString, required = false,
                                 default = nil)
  if valid_593430 != nil:
    section.add "X-Amz-Algorithm", valid_593430
  var valid_593431 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593431 = validateParameter(valid_593431, JString, required = false,
                                 default = nil)
  if valid_593431 != nil:
    section.add "X-Amz-SignedHeaders", valid_593431
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_593432 = formData.getOrDefault("Description")
  valid_593432 = validateParameter(valid_593432, JString, required = true,
                                 default = nil)
  if valid_593432 != nil:
    section.add "Description", valid_593432
  var valid_593433 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_593433 = validateParameter(valid_593433, JString, required = true,
                                 default = nil)
  if valid_593433 != nil:
    section.add "ClusterSubnetGroupName", valid_593433
  var valid_593434 = formData.getOrDefault("Tags")
  valid_593434 = validateParameter(valid_593434, JArray, required = false,
                                 default = nil)
  if valid_593434 != nil:
    section.add "Tags", valid_593434
  var valid_593435 = formData.getOrDefault("SubnetIds")
  valid_593435 = validateParameter(valid_593435, JArray, required = true, default = nil)
  if valid_593435 != nil:
    section.add "SubnetIds", valid_593435
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593436: Call_PostCreateClusterSubnetGroup_593420; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593436.validator(path, query, header, formData, body)
  let scheme = call_593436.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593436.url(scheme.get, call_593436.host, call_593436.base,
                         call_593436.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593436, url, valid)

proc call*(call_593437: Call_PostCreateClusterSubnetGroup_593420;
          Description: string; ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Action: string = "CreateClusterSubnetGroup"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  var query_593438 = newJObject()
  var formData_593439 = newJObject()
  add(formData_593439, "Description", newJString(Description))
  add(formData_593439, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_593438, "Action", newJString(Action))
  if Tags != nil:
    formData_593439.add "Tags", Tags
  add(query_593438, "Version", newJString(Version))
  if SubnetIds != nil:
    formData_593439.add "SubnetIds", SubnetIds
  result = call_593437.call(nil, query_593438, nil, formData_593439, nil)

var postCreateClusterSubnetGroup* = Call_PostCreateClusterSubnetGroup_593420(
    name: "postCreateClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_PostCreateClusterSubnetGroup_593421, base: "/",
    url: url_PostCreateClusterSubnetGroup_593422,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateClusterSubnetGroup_593401 = ref object of OpenApiRestCall_592348
proc url_GetCreateClusterSubnetGroup_593403(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateClusterSubnetGroup_593402(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A description for the subnet group.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_593404 = query.getOrDefault("ClusterSubnetGroupName")
  valid_593404 = validateParameter(valid_593404, JString, required = true,
                                 default = nil)
  if valid_593404 != nil:
    section.add "ClusterSubnetGroupName", valid_593404
  var valid_593405 = query.getOrDefault("Tags")
  valid_593405 = validateParameter(valid_593405, JArray, required = false,
                                 default = nil)
  if valid_593405 != nil:
    section.add "Tags", valid_593405
  var valid_593406 = query.getOrDefault("SubnetIds")
  valid_593406 = validateParameter(valid_593406, JArray, required = true, default = nil)
  if valid_593406 != nil:
    section.add "SubnetIds", valid_593406
  var valid_593407 = query.getOrDefault("Action")
  valid_593407 = validateParameter(valid_593407, JString, required = true, default = newJString(
      "CreateClusterSubnetGroup"))
  if valid_593407 != nil:
    section.add "Action", valid_593407
  var valid_593408 = query.getOrDefault("Description")
  valid_593408 = validateParameter(valid_593408, JString, required = true,
                                 default = nil)
  if valid_593408 != nil:
    section.add "Description", valid_593408
  var valid_593409 = query.getOrDefault("Version")
  valid_593409 = validateParameter(valid_593409, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593409 != nil:
    section.add "Version", valid_593409
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593410 = header.getOrDefault("X-Amz-Signature")
  valid_593410 = validateParameter(valid_593410, JString, required = false,
                                 default = nil)
  if valid_593410 != nil:
    section.add "X-Amz-Signature", valid_593410
  var valid_593411 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593411 = validateParameter(valid_593411, JString, required = false,
                                 default = nil)
  if valid_593411 != nil:
    section.add "X-Amz-Content-Sha256", valid_593411
  var valid_593412 = header.getOrDefault("X-Amz-Date")
  valid_593412 = validateParameter(valid_593412, JString, required = false,
                                 default = nil)
  if valid_593412 != nil:
    section.add "X-Amz-Date", valid_593412
  var valid_593413 = header.getOrDefault("X-Amz-Credential")
  valid_593413 = validateParameter(valid_593413, JString, required = false,
                                 default = nil)
  if valid_593413 != nil:
    section.add "X-Amz-Credential", valid_593413
  var valid_593414 = header.getOrDefault("X-Amz-Security-Token")
  valid_593414 = validateParameter(valid_593414, JString, required = false,
                                 default = nil)
  if valid_593414 != nil:
    section.add "X-Amz-Security-Token", valid_593414
  var valid_593415 = header.getOrDefault("X-Amz-Algorithm")
  valid_593415 = validateParameter(valid_593415, JString, required = false,
                                 default = nil)
  if valid_593415 != nil:
    section.add "X-Amz-Algorithm", valid_593415
  var valid_593416 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593416 = validateParameter(valid_593416, JString, required = false,
                                 default = nil)
  if valid_593416 != nil:
    section.add "X-Amz-SignedHeaders", valid_593416
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593417: Call_GetCreateClusterSubnetGroup_593401; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593417.validator(path, query, header, formData, body)
  let scheme = call_593417.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593417.url(scheme.get, call_593417.host, call_593417.base,
                         call_593417.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593417, url, valid)

proc call*(call_593418: Call_GetCreateClusterSubnetGroup_593401;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode; Description: string;
          Tags: JsonNode = nil; Action: string = "CreateClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateClusterSubnetGroup
  ## <p>Creates a new Amazon Redshift subnet group. You must provide a list of one or more subnets in your existing Amazon Virtual Private Cloud (Amazon VPC) when creating Amazon Redshift subnet group.</p> <p> For information about subnet groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-cluster-subnet-groups.html">Amazon Redshift Cluster Subnet Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string (required)
  ##                         : <p>The name for the subnet group. Amazon Redshift stores the value as a lowercase string.</p> <p>Constraints:</p> <ul> <li> <p>Must contain no more than 255 alphanumeric characters or hyphens.</p> </li> <li> <p>Must not be "Default".</p> </li> <li> <p>Must be unique for all subnet groups that are created by your AWS account.</p> </li> </ul> <p>Example: <code>examplesubnetgroup</code> </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A description for the subnet group.
  ##   Version: string (required)
  var query_593419 = newJObject()
  add(query_593419, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  if Tags != nil:
    query_593419.add "Tags", Tags
  if SubnetIds != nil:
    query_593419.add "SubnetIds", SubnetIds
  add(query_593419, "Action", newJString(Action))
  add(query_593419, "Description", newJString(Description))
  add(query_593419, "Version", newJString(Version))
  result = call_593418.call(nil, query_593419, nil, nil, nil)

var getCreateClusterSubnetGroup* = Call_GetCreateClusterSubnetGroup_593401(
    name: "getCreateClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateClusterSubnetGroup",
    validator: validate_GetCreateClusterSubnetGroup_593402, base: "/",
    url: url_GetCreateClusterSubnetGroup_593403,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateEventSubscription_593463 = ref object of OpenApiRestCall_592348
proc url_PostCreateEventSubscription_593465(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateEventSubscription_593464(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593466 = query.getOrDefault("Action")
  valid_593466 = validateParameter(valid_593466, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_593466 != nil:
    section.add "Action", valid_593466
  var valid_593467 = query.getOrDefault("Version")
  valid_593467 = validateParameter(valid_593467, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593467 != nil:
    section.add "Version", valid_593467
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593468 = header.getOrDefault("X-Amz-Signature")
  valid_593468 = validateParameter(valid_593468, JString, required = false,
                                 default = nil)
  if valid_593468 != nil:
    section.add "X-Amz-Signature", valid_593468
  var valid_593469 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593469 = validateParameter(valid_593469, JString, required = false,
                                 default = nil)
  if valid_593469 != nil:
    section.add "X-Amz-Content-Sha256", valid_593469
  var valid_593470 = header.getOrDefault("X-Amz-Date")
  valid_593470 = validateParameter(valid_593470, JString, required = false,
                                 default = nil)
  if valid_593470 != nil:
    section.add "X-Amz-Date", valid_593470
  var valid_593471 = header.getOrDefault("X-Amz-Credential")
  valid_593471 = validateParameter(valid_593471, JString, required = false,
                                 default = nil)
  if valid_593471 != nil:
    section.add "X-Amz-Credential", valid_593471
  var valid_593472 = header.getOrDefault("X-Amz-Security-Token")
  valid_593472 = validateParameter(valid_593472, JString, required = false,
                                 default = nil)
  if valid_593472 != nil:
    section.add "X-Amz-Security-Token", valid_593472
  var valid_593473 = header.getOrDefault("X-Amz-Algorithm")
  valid_593473 = validateParameter(valid_593473, JString, required = false,
                                 default = nil)
  if valid_593473 != nil:
    section.add "X-Amz-Algorithm", valid_593473
  var valid_593474 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593474 = validateParameter(valid_593474, JString, required = false,
                                 default = nil)
  if valid_593474 != nil:
    section.add "X-Amz-SignedHeaders", valid_593474
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  var valid_593475 = formData.getOrDefault("SourceIds")
  valid_593475 = validateParameter(valid_593475, JArray, required = false,
                                 default = nil)
  if valid_593475 != nil:
    section.add "SourceIds", valid_593475
  assert formData != nil,
        "formData argument is necessary due to required `SnsTopicArn` field"
  var valid_593476 = formData.getOrDefault("SnsTopicArn")
  valid_593476 = validateParameter(valid_593476, JString, required = true,
                                 default = nil)
  if valid_593476 != nil:
    section.add "SnsTopicArn", valid_593476
  var valid_593477 = formData.getOrDefault("Enabled")
  valid_593477 = validateParameter(valid_593477, JBool, required = false, default = nil)
  if valid_593477 != nil:
    section.add "Enabled", valid_593477
  var valid_593478 = formData.getOrDefault("SubscriptionName")
  valid_593478 = validateParameter(valid_593478, JString, required = true,
                                 default = nil)
  if valid_593478 != nil:
    section.add "SubscriptionName", valid_593478
  var valid_593479 = formData.getOrDefault("SourceType")
  valid_593479 = validateParameter(valid_593479, JString, required = false,
                                 default = nil)
  if valid_593479 != nil:
    section.add "SourceType", valid_593479
  var valid_593480 = formData.getOrDefault("Severity")
  valid_593480 = validateParameter(valid_593480, JString, required = false,
                                 default = nil)
  if valid_593480 != nil:
    section.add "Severity", valid_593480
  var valid_593481 = formData.getOrDefault("EventCategories")
  valid_593481 = validateParameter(valid_593481, JArray, required = false,
                                 default = nil)
  if valid_593481 != nil:
    section.add "EventCategories", valid_593481
  var valid_593482 = formData.getOrDefault("Tags")
  valid_593482 = validateParameter(valid_593482, JArray, required = false,
                                 default = nil)
  if valid_593482 != nil:
    section.add "Tags", valid_593482
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593483: Call_PostCreateEventSubscription_593463; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_593483.validator(path, query, header, formData, body)
  let scheme = call_593483.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593483.url(scheme.get, call_593483.host, call_593483.base,
                         call_593483.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593483, url, valid)

proc call*(call_593484: Call_PostCreateEventSubscription_593463;
          SnsTopicArn: string; SubscriptionName: string; SourceIds: JsonNode = nil;
          Enabled: bool = false; SourceType: string = ""; Severity: string = "";
          EventCategories: JsonNode = nil;
          Action: string = "CreateEventSubscription"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_593485 = newJObject()
  var formData_593486 = newJObject()
  if SourceIds != nil:
    formData_593486.add "SourceIds", SourceIds
  add(formData_593486, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_593486, "Enabled", newJBool(Enabled))
  add(formData_593486, "SubscriptionName", newJString(SubscriptionName))
  add(formData_593486, "SourceType", newJString(SourceType))
  add(formData_593486, "Severity", newJString(Severity))
  if EventCategories != nil:
    formData_593486.add "EventCategories", EventCategories
  add(query_593485, "Action", newJString(Action))
  if Tags != nil:
    formData_593486.add "Tags", Tags
  add(query_593485, "Version", newJString(Version))
  result = call_593484.call(nil, query_593485, nil, formData_593486, nil)

var postCreateEventSubscription* = Call_PostCreateEventSubscription_593463(
    name: "postCreateEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_PostCreateEventSubscription_593464, base: "/",
    url: url_PostCreateEventSubscription_593465,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateEventSubscription_593440 = ref object of OpenApiRestCall_592348
proc url_GetCreateEventSubscription_593442(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateEventSubscription_593441(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Enabled: JBool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: JString (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: JString (required)
  ##   SnsTopicArn: JString (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Version: JString (required)
  section = newJObject()
  var valid_593443 = query.getOrDefault("Tags")
  valid_593443 = validateParameter(valid_593443, JArray, required = false,
                                 default = nil)
  if valid_593443 != nil:
    section.add "Tags", valid_593443
  var valid_593444 = query.getOrDefault("SourceType")
  valid_593444 = validateParameter(valid_593444, JString, required = false,
                                 default = nil)
  if valid_593444 != nil:
    section.add "SourceType", valid_593444
  var valid_593445 = query.getOrDefault("Enabled")
  valid_593445 = validateParameter(valid_593445, JBool, required = false, default = nil)
  if valid_593445 != nil:
    section.add "Enabled", valid_593445
  var valid_593446 = query.getOrDefault("Severity")
  valid_593446 = validateParameter(valid_593446, JString, required = false,
                                 default = nil)
  if valid_593446 != nil:
    section.add "Severity", valid_593446
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_593447 = query.getOrDefault("SubscriptionName")
  valid_593447 = validateParameter(valid_593447, JString, required = true,
                                 default = nil)
  if valid_593447 != nil:
    section.add "SubscriptionName", valid_593447
  var valid_593448 = query.getOrDefault("EventCategories")
  valid_593448 = validateParameter(valid_593448, JArray, required = false,
                                 default = nil)
  if valid_593448 != nil:
    section.add "EventCategories", valid_593448
  var valid_593449 = query.getOrDefault("SourceIds")
  valid_593449 = validateParameter(valid_593449, JArray, required = false,
                                 default = nil)
  if valid_593449 != nil:
    section.add "SourceIds", valid_593449
  var valid_593450 = query.getOrDefault("Action")
  valid_593450 = validateParameter(valid_593450, JString, required = true, default = newJString(
      "CreateEventSubscription"))
  if valid_593450 != nil:
    section.add "Action", valid_593450
  var valid_593451 = query.getOrDefault("SnsTopicArn")
  valid_593451 = validateParameter(valid_593451, JString, required = true,
                                 default = nil)
  if valid_593451 != nil:
    section.add "SnsTopicArn", valid_593451
  var valid_593452 = query.getOrDefault("Version")
  valid_593452 = validateParameter(valid_593452, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593452 != nil:
    section.add "Version", valid_593452
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593453 = header.getOrDefault("X-Amz-Signature")
  valid_593453 = validateParameter(valid_593453, JString, required = false,
                                 default = nil)
  if valid_593453 != nil:
    section.add "X-Amz-Signature", valid_593453
  var valid_593454 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593454 = validateParameter(valid_593454, JString, required = false,
                                 default = nil)
  if valid_593454 != nil:
    section.add "X-Amz-Content-Sha256", valid_593454
  var valid_593455 = header.getOrDefault("X-Amz-Date")
  valid_593455 = validateParameter(valid_593455, JString, required = false,
                                 default = nil)
  if valid_593455 != nil:
    section.add "X-Amz-Date", valid_593455
  var valid_593456 = header.getOrDefault("X-Amz-Credential")
  valid_593456 = validateParameter(valid_593456, JString, required = false,
                                 default = nil)
  if valid_593456 != nil:
    section.add "X-Amz-Credential", valid_593456
  var valid_593457 = header.getOrDefault("X-Amz-Security-Token")
  valid_593457 = validateParameter(valid_593457, JString, required = false,
                                 default = nil)
  if valid_593457 != nil:
    section.add "X-Amz-Security-Token", valid_593457
  var valid_593458 = header.getOrDefault("X-Amz-Algorithm")
  valid_593458 = validateParameter(valid_593458, JString, required = false,
                                 default = nil)
  if valid_593458 != nil:
    section.add "X-Amz-Algorithm", valid_593458
  var valid_593459 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593459 = validateParameter(valid_593459, JString, required = false,
                                 default = nil)
  if valid_593459 != nil:
    section.add "X-Amz-SignedHeaders", valid_593459
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593460: Call_GetCreateEventSubscription_593440; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ## 
  let valid = call_593460.validator(path, query, header, formData, body)
  let scheme = call_593460.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593460.url(scheme.get, call_593460.host, call_593460.base,
                         call_593460.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593460, url, valid)

proc call*(call_593461: Call_GetCreateEventSubscription_593440;
          SubscriptionName: string; SnsTopicArn: string; Tags: JsonNode = nil;
          SourceType: string = ""; Enabled: bool = false; Severity: string = "";
          EventCategories: JsonNode = nil; SourceIds: JsonNode = nil;
          Action: string = "CreateEventSubscription"; Version: string = "2012-12-01"): Recallable =
  ## getCreateEventSubscription
  ## <p>Creates an Amazon Redshift event notification subscription. This action requires an ARN (Amazon Resource Name) of an Amazon SNS topic created by either the Amazon Redshift console, the Amazon SNS console, or the Amazon SNS API. To obtain an ARN with Amazon SNS, you must create a topic in Amazon SNS and subscribe to the topic. The ARN is displayed in the SNS console.</p> <p>You can specify the source type, and lists of Amazon Redshift source IDs, event categories, and event severities. Notifications will be sent for all events you want that match those criteria. For example, you can specify source type = cluster, source ID = my-cluster-1 and mycluster2, event categories = Availability, Backup, and severity = ERROR. The subscription will only send notifications for those ERROR events in the Availability and Backup categories for the specified clusters.</p> <p>If you specify both the source type and source IDs, such as source type = cluster and source identifier = my-cluster-1, notifications will be sent for all the cluster events for my-cluster-1. If you specify a source type but do not specify a source identifier, you will receive notice of the events for the objects of that type in your AWS account. If you do not specify either the SourceType nor the SourceIdentifier, you will be notified of events generated from all Amazon Redshift sources belonging to your AWS account. You must specify a source type if you specify a source ID.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Enabled: bool
  ##          : A boolean value; set to <code>true</code> to activate the subscription, and set to <code>false</code> to create the subscription but not activate it. 
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: string (required)
  ##                   : <p>The name of the event subscription to be created.</p> <p>Constraints:</p> <ul> <li> <p>Cannot be null, empty, or blank.</p> </li> <li> <p>Must contain from 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: string (required)
  ##   SnsTopicArn: string (required)
  ##              : The Amazon Resource Name (ARN) of the Amazon SNS topic used to transmit the event notifications. The ARN is created by Amazon SNS when you create a topic and subscribe to it.
  ##   Version: string (required)
  var query_593462 = newJObject()
  if Tags != nil:
    query_593462.add "Tags", Tags
  add(query_593462, "SourceType", newJString(SourceType))
  add(query_593462, "Enabled", newJBool(Enabled))
  add(query_593462, "Severity", newJString(Severity))
  add(query_593462, "SubscriptionName", newJString(SubscriptionName))
  if EventCategories != nil:
    query_593462.add "EventCategories", EventCategories
  if SourceIds != nil:
    query_593462.add "SourceIds", SourceIds
  add(query_593462, "Action", newJString(Action))
  add(query_593462, "SnsTopicArn", newJString(SnsTopicArn))
  add(query_593462, "Version", newJString(Version))
  result = call_593461.call(nil, query_593462, nil, nil, nil)

var getCreateEventSubscription* = Call_GetCreateEventSubscription_593440(
    name: "getCreateEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateEventSubscription",
    validator: validate_GetCreateEventSubscription_593441, base: "/",
    url: url_GetCreateEventSubscription_593442,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmClientCertificate_593504 = ref object of OpenApiRestCall_592348
proc url_PostCreateHsmClientCertificate_593506(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateHsmClientCertificate_593505(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593507 = query.getOrDefault("Action")
  valid_593507 = validateParameter(valid_593507, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_593507 != nil:
    section.add "Action", valid_593507
  var valid_593508 = query.getOrDefault("Version")
  valid_593508 = validateParameter(valid_593508, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593508 != nil:
    section.add "Version", valid_593508
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593509 = header.getOrDefault("X-Amz-Signature")
  valid_593509 = validateParameter(valid_593509, JString, required = false,
                                 default = nil)
  if valid_593509 != nil:
    section.add "X-Amz-Signature", valid_593509
  var valid_593510 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593510 = validateParameter(valid_593510, JString, required = false,
                                 default = nil)
  if valid_593510 != nil:
    section.add "X-Amz-Content-Sha256", valid_593510
  var valid_593511 = header.getOrDefault("X-Amz-Date")
  valid_593511 = validateParameter(valid_593511, JString, required = false,
                                 default = nil)
  if valid_593511 != nil:
    section.add "X-Amz-Date", valid_593511
  var valid_593512 = header.getOrDefault("X-Amz-Credential")
  valid_593512 = validateParameter(valid_593512, JString, required = false,
                                 default = nil)
  if valid_593512 != nil:
    section.add "X-Amz-Credential", valid_593512
  var valid_593513 = header.getOrDefault("X-Amz-Security-Token")
  valid_593513 = validateParameter(valid_593513, JString, required = false,
                                 default = nil)
  if valid_593513 != nil:
    section.add "X-Amz-Security-Token", valid_593513
  var valid_593514 = header.getOrDefault("X-Amz-Algorithm")
  valid_593514 = validateParameter(valid_593514, JString, required = false,
                                 default = nil)
  if valid_593514 != nil:
    section.add "X-Amz-Algorithm", valid_593514
  var valid_593515 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593515 = validateParameter(valid_593515, JString, required = false,
                                 default = nil)
  if valid_593515 != nil:
    section.add "X-Amz-SignedHeaders", valid_593515
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_593516 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_593516 = validateParameter(valid_593516, JString, required = true,
                                 default = nil)
  if valid_593516 != nil:
    section.add "HsmClientCertificateIdentifier", valid_593516
  var valid_593517 = formData.getOrDefault("Tags")
  valid_593517 = validateParameter(valid_593517, JArray, required = false,
                                 default = nil)
  if valid_593517 != nil:
    section.add "Tags", valid_593517
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593518: Call_PostCreateHsmClientCertificate_593504; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_593518.validator(path, query, header, formData, body)
  let scheme = call_593518.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593518.url(scheme.get, call_593518.host, call_593518.base,
                         call_593518.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593518, url, valid)

proc call*(call_593519: Call_PostCreateHsmClientCertificate_593504;
          HsmClientCertificateIdentifier: string;
          Action: string = "CreateHsmClientCertificate"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Version: string (required)
  var query_593520 = newJObject()
  var formData_593521 = newJObject()
  add(query_593520, "Action", newJString(Action))
  add(formData_593521, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    formData_593521.add "Tags", Tags
  add(query_593520, "Version", newJString(Version))
  result = call_593519.call(nil, query_593520, nil, formData_593521, nil)

var postCreateHsmClientCertificate* = Call_PostCreateHsmClientCertificate_593504(
    name: "postCreateHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_PostCreateHsmClientCertificate_593505, base: "/",
    url: url_PostCreateHsmClientCertificate_593506,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmClientCertificate_593487 = ref object of OpenApiRestCall_592348
proc url_GetCreateHsmClientCertificate_593489(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateHsmClientCertificate_593488(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_593490 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_593490 = validateParameter(valid_593490, JString, required = true,
                                 default = nil)
  if valid_593490 != nil:
    section.add "HsmClientCertificateIdentifier", valid_593490
  var valid_593491 = query.getOrDefault("Tags")
  valid_593491 = validateParameter(valid_593491, JArray, required = false,
                                 default = nil)
  if valid_593491 != nil:
    section.add "Tags", valid_593491
  var valid_593492 = query.getOrDefault("Action")
  valid_593492 = validateParameter(valid_593492, JString, required = true, default = newJString(
      "CreateHsmClientCertificate"))
  if valid_593492 != nil:
    section.add "Action", valid_593492
  var valid_593493 = query.getOrDefault("Version")
  valid_593493 = validateParameter(valid_593493, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593493 != nil:
    section.add "Version", valid_593493
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593494 = header.getOrDefault("X-Amz-Signature")
  valid_593494 = validateParameter(valid_593494, JString, required = false,
                                 default = nil)
  if valid_593494 != nil:
    section.add "X-Amz-Signature", valid_593494
  var valid_593495 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593495 = validateParameter(valid_593495, JString, required = false,
                                 default = nil)
  if valid_593495 != nil:
    section.add "X-Amz-Content-Sha256", valid_593495
  var valid_593496 = header.getOrDefault("X-Amz-Date")
  valid_593496 = validateParameter(valid_593496, JString, required = false,
                                 default = nil)
  if valid_593496 != nil:
    section.add "X-Amz-Date", valid_593496
  var valid_593497 = header.getOrDefault("X-Amz-Credential")
  valid_593497 = validateParameter(valid_593497, JString, required = false,
                                 default = nil)
  if valid_593497 != nil:
    section.add "X-Amz-Credential", valid_593497
  var valid_593498 = header.getOrDefault("X-Amz-Security-Token")
  valid_593498 = validateParameter(valid_593498, JString, required = false,
                                 default = nil)
  if valid_593498 != nil:
    section.add "X-Amz-Security-Token", valid_593498
  var valid_593499 = header.getOrDefault("X-Amz-Algorithm")
  valid_593499 = validateParameter(valid_593499, JString, required = false,
                                 default = nil)
  if valid_593499 != nil:
    section.add "X-Amz-Algorithm", valid_593499
  var valid_593500 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593500 = validateParameter(valid_593500, JString, required = false,
                                 default = nil)
  if valid_593500 != nil:
    section.add "X-Amz-SignedHeaders", valid_593500
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593501: Call_GetCreateHsmClientCertificate_593487; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_593501.validator(path, query, header, formData, body)
  let scheme = call_593501.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593501.url(scheme.get, call_593501.host, call_593501.base,
                         call_593501.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593501, url, valid)

proc call*(call_593502: Call_GetCreateHsmClientCertificate_593487;
          HsmClientCertificateIdentifier: string; Tags: JsonNode = nil;
          Action: string = "CreateHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmClientCertificate
  ## <p>Creates an HSM client certificate that an Amazon Redshift cluster will use to connect to the client's HSM in order to store and retrieve the keys used to encrypt the cluster databases.</p> <p>The command returns a public key, which you must store in the HSM. In addition to creating the HSM certificate, you must create an Amazon Redshift HSM configuration that provides a cluster the information needed to store and use encryption keys in the HSM. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier to be assigned to the new HSM client certificate that the cluster will use to connect to the HSM to use the database encryption keys.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593503 = newJObject()
  add(query_593503, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if Tags != nil:
    query_593503.add "Tags", Tags
  add(query_593503, "Action", newJString(Action))
  add(query_593503, "Version", newJString(Version))
  result = call_593502.call(nil, query_593503, nil, nil, nil)

var getCreateHsmClientCertificate* = Call_GetCreateHsmClientCertificate_593487(
    name: "getCreateHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmClientCertificate",
    validator: validate_GetCreateHsmClientCertificate_593488, base: "/",
    url: url_GetCreateHsmClientCertificate_593489,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateHsmConfiguration_593544 = ref object of OpenApiRestCall_592348
proc url_PostCreateHsmConfiguration_593546(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateHsmConfiguration_593545(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593547 = query.getOrDefault("Action")
  valid_593547 = validateParameter(valid_593547, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_593547 != nil:
    section.add "Action", valid_593547
  var valid_593548 = query.getOrDefault("Version")
  valid_593548 = validateParameter(valid_593548, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593548 != nil:
    section.add "Version", valid_593548
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593549 = header.getOrDefault("X-Amz-Signature")
  valid_593549 = validateParameter(valid_593549, JString, required = false,
                                 default = nil)
  if valid_593549 != nil:
    section.add "X-Amz-Signature", valid_593549
  var valid_593550 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593550 = validateParameter(valid_593550, JString, required = false,
                                 default = nil)
  if valid_593550 != nil:
    section.add "X-Amz-Content-Sha256", valid_593550
  var valid_593551 = header.getOrDefault("X-Amz-Date")
  valid_593551 = validateParameter(valid_593551, JString, required = false,
                                 default = nil)
  if valid_593551 != nil:
    section.add "X-Amz-Date", valid_593551
  var valid_593552 = header.getOrDefault("X-Amz-Credential")
  valid_593552 = validateParameter(valid_593552, JString, required = false,
                                 default = nil)
  if valid_593552 != nil:
    section.add "X-Amz-Credential", valid_593552
  var valid_593553 = header.getOrDefault("X-Amz-Security-Token")
  valid_593553 = validateParameter(valid_593553, JString, required = false,
                                 default = nil)
  if valid_593553 != nil:
    section.add "X-Amz-Security-Token", valid_593553
  var valid_593554 = header.getOrDefault("X-Amz-Algorithm")
  valid_593554 = validateParameter(valid_593554, JString, required = false,
                                 default = nil)
  if valid_593554 != nil:
    section.add "X-Amz-Algorithm", valid_593554
  var valid_593555 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593555 = validateParameter(valid_593555, JString, required = false,
                                 default = nil)
  if valid_593555 != nil:
    section.add "X-Amz-SignedHeaders", valid_593555
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Description` field"
  var valid_593556 = formData.getOrDefault("Description")
  valid_593556 = validateParameter(valid_593556, JString, required = true,
                                 default = nil)
  if valid_593556 != nil:
    section.add "Description", valid_593556
  var valid_593557 = formData.getOrDefault("Tags")
  valid_593557 = validateParameter(valid_593557, JArray, required = false,
                                 default = nil)
  if valid_593557 != nil:
    section.add "Tags", valid_593557
  var valid_593558 = formData.getOrDefault("HsmPartitionPassword")
  valid_593558 = validateParameter(valid_593558, JString, required = true,
                                 default = nil)
  if valid_593558 != nil:
    section.add "HsmPartitionPassword", valid_593558
  var valid_593559 = formData.getOrDefault("HsmPartitionName")
  valid_593559 = validateParameter(valid_593559, JString, required = true,
                                 default = nil)
  if valid_593559 != nil:
    section.add "HsmPartitionName", valid_593559
  var valid_593560 = formData.getOrDefault("HsmServerPublicCertificate")
  valid_593560 = validateParameter(valid_593560, JString, required = true,
                                 default = nil)
  if valid_593560 != nil:
    section.add "HsmServerPublicCertificate", valid_593560
  var valid_593561 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_593561 = validateParameter(valid_593561, JString, required = true,
                                 default = nil)
  if valid_593561 != nil:
    section.add "HsmConfigurationIdentifier", valid_593561
  var valid_593562 = formData.getOrDefault("HsmIpAddress")
  valid_593562 = validateParameter(valid_593562, JString, required = true,
                                 default = nil)
  if valid_593562 != nil:
    section.add "HsmIpAddress", valid_593562
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593563: Call_PostCreateHsmConfiguration_593544; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_593563.validator(path, query, header, formData, body)
  let scheme = call_593563.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593563.url(scheme.get, call_593563.host, call_593563.base,
                         call_593563.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593563, url, valid)

proc call*(call_593564: Call_PostCreateHsmConfiguration_593544;
          Description: string; HsmPartitionPassword: string;
          HsmPartitionName: string; HsmServerPublicCertificate: string;
          HsmConfigurationIdentifier: string; HsmIpAddress: string;
          Action: string = "CreateHsmConfiguration"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   Version: string (required)
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  var query_593565 = newJObject()
  var formData_593566 = newJObject()
  add(formData_593566, "Description", newJString(Description))
  add(query_593565, "Action", newJString(Action))
  if Tags != nil:
    formData_593566.add "Tags", Tags
  add(formData_593566, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_593565, "Version", newJString(Version))
  add(formData_593566, "HsmPartitionName", newJString(HsmPartitionName))
  add(formData_593566, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(formData_593566, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_593566, "HsmIpAddress", newJString(HsmIpAddress))
  result = call_593564.call(nil, query_593565, nil, formData_593566, nil)

var postCreateHsmConfiguration* = Call_PostCreateHsmConfiguration_593544(
    name: "postCreateHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_PostCreateHsmConfiguration_593545, base: "/",
    url: url_PostCreateHsmConfiguration_593546,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateHsmConfiguration_593522 = ref object of OpenApiRestCall_592348
proc url_GetCreateHsmConfiguration_593524(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateHsmConfiguration_593523(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmIpAddress: JString (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionPassword: JString (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmServerPublicCertificate: JString (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmPartitionName: JString (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Action: JString (required)
  ##   Description: JString (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Version: JString (required)
  section = newJObject()
  var valid_593525 = query.getOrDefault("Tags")
  valid_593525 = validateParameter(valid_593525, JArray, required = false,
                                 default = nil)
  if valid_593525 != nil:
    section.add "Tags", valid_593525
  assert query != nil,
        "query argument is necessary due to required `HsmIpAddress` field"
  var valid_593526 = query.getOrDefault("HsmIpAddress")
  valid_593526 = validateParameter(valid_593526, JString, required = true,
                                 default = nil)
  if valid_593526 != nil:
    section.add "HsmIpAddress", valid_593526
  var valid_593527 = query.getOrDefault("HsmPartitionPassword")
  valid_593527 = validateParameter(valid_593527, JString, required = true,
                                 default = nil)
  if valid_593527 != nil:
    section.add "HsmPartitionPassword", valid_593527
  var valid_593528 = query.getOrDefault("HsmServerPublicCertificate")
  valid_593528 = validateParameter(valid_593528, JString, required = true,
                                 default = nil)
  if valid_593528 != nil:
    section.add "HsmServerPublicCertificate", valid_593528
  var valid_593529 = query.getOrDefault("HsmPartitionName")
  valid_593529 = validateParameter(valid_593529, JString, required = true,
                                 default = nil)
  if valid_593529 != nil:
    section.add "HsmPartitionName", valid_593529
  var valid_593530 = query.getOrDefault("Action")
  valid_593530 = validateParameter(valid_593530, JString, required = true,
                                 default = newJString("CreateHsmConfiguration"))
  if valid_593530 != nil:
    section.add "Action", valid_593530
  var valid_593531 = query.getOrDefault("Description")
  valid_593531 = validateParameter(valid_593531, JString, required = true,
                                 default = nil)
  if valid_593531 != nil:
    section.add "Description", valid_593531
  var valid_593532 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_593532 = validateParameter(valid_593532, JString, required = true,
                                 default = nil)
  if valid_593532 != nil:
    section.add "HsmConfigurationIdentifier", valid_593532
  var valid_593533 = query.getOrDefault("Version")
  valid_593533 = validateParameter(valid_593533, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593533 != nil:
    section.add "Version", valid_593533
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593534 = header.getOrDefault("X-Amz-Signature")
  valid_593534 = validateParameter(valid_593534, JString, required = false,
                                 default = nil)
  if valid_593534 != nil:
    section.add "X-Amz-Signature", valid_593534
  var valid_593535 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593535 = validateParameter(valid_593535, JString, required = false,
                                 default = nil)
  if valid_593535 != nil:
    section.add "X-Amz-Content-Sha256", valid_593535
  var valid_593536 = header.getOrDefault("X-Amz-Date")
  valid_593536 = validateParameter(valid_593536, JString, required = false,
                                 default = nil)
  if valid_593536 != nil:
    section.add "X-Amz-Date", valid_593536
  var valid_593537 = header.getOrDefault("X-Amz-Credential")
  valid_593537 = validateParameter(valid_593537, JString, required = false,
                                 default = nil)
  if valid_593537 != nil:
    section.add "X-Amz-Credential", valid_593537
  var valid_593538 = header.getOrDefault("X-Amz-Security-Token")
  valid_593538 = validateParameter(valid_593538, JString, required = false,
                                 default = nil)
  if valid_593538 != nil:
    section.add "X-Amz-Security-Token", valid_593538
  var valid_593539 = header.getOrDefault("X-Amz-Algorithm")
  valid_593539 = validateParameter(valid_593539, JString, required = false,
                                 default = nil)
  if valid_593539 != nil:
    section.add "X-Amz-Algorithm", valid_593539
  var valid_593540 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593540 = validateParameter(valid_593540, JString, required = false,
                                 default = nil)
  if valid_593540 != nil:
    section.add "X-Amz-SignedHeaders", valid_593540
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593541: Call_GetCreateHsmConfiguration_593522; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ## 
  let valid = call_593541.validator(path, query, header, formData, body)
  let scheme = call_593541.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593541.url(scheme.get, call_593541.host, call_593541.base,
                         call_593541.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593541, url, valid)

proc call*(call_593542: Call_GetCreateHsmConfiguration_593522;
          HsmIpAddress: string; HsmPartitionPassword: string;
          HsmServerPublicCertificate: string; HsmPartitionName: string;
          Description: string; HsmConfigurationIdentifier: string;
          Tags: JsonNode = nil; Action: string = "CreateHsmConfiguration";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateHsmConfiguration
  ## <p>Creates an HSM configuration that contains the information required by an Amazon Redshift cluster to store and use database encryption keys in a Hardware Security Module (HSM). After creating the HSM configuration, you can specify it as a parameter when creating a cluster. The cluster will then store its encryption keys in the HSM.</p> <p>In addition to creating an HSM configuration, you must also create an HSM client certificate. For more information, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-HSM.html">Hardware Security Modules</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   HsmIpAddress: string (required)
  ##               : The IP address that the Amazon Redshift cluster must use to access the HSM.
  ##   HsmPartitionPassword: string (required)
  ##                       : The password required to access the HSM partition.
  ##   HsmServerPublicCertificate: string (required)
  ##                             : The HSMs public certificate file. When using Cloud HSM, the file name is server.pem.
  ##   HsmPartitionName: string (required)
  ##                   : The name of the partition in the HSM where the Amazon Redshift clusters will store their database encryption keys.
  ##   Action: string (required)
  ##   Description: string (required)
  ##              : A text description of the HSM configuration to be created.
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier to be assigned to the new Amazon Redshift HSM configuration.
  ##   Version: string (required)
  var query_593543 = newJObject()
  if Tags != nil:
    query_593543.add "Tags", Tags
  add(query_593543, "HsmIpAddress", newJString(HsmIpAddress))
  add(query_593543, "HsmPartitionPassword", newJString(HsmPartitionPassword))
  add(query_593543, "HsmServerPublicCertificate",
      newJString(HsmServerPublicCertificate))
  add(query_593543, "HsmPartitionName", newJString(HsmPartitionName))
  add(query_593543, "Action", newJString(Action))
  add(query_593543, "Description", newJString(Description))
  add(query_593543, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_593543, "Version", newJString(Version))
  result = call_593542.call(nil, query_593543, nil, nil, nil)

var getCreateHsmConfiguration* = Call_GetCreateHsmConfiguration_593522(
    name: "getCreateHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateHsmConfiguration",
    validator: validate_GetCreateHsmConfiguration_593523, base: "/",
    url: url_GetCreateHsmConfiguration_593524,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotCopyGrant_593585 = ref object of OpenApiRestCall_592348
proc url_PostCreateSnapshotCopyGrant_593587(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateSnapshotCopyGrant_593586(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593588 = query.getOrDefault("Action")
  valid_593588 = validateParameter(valid_593588, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_593588 != nil:
    section.add "Action", valid_593588
  var valid_593589 = query.getOrDefault("Version")
  valid_593589 = validateParameter(valid_593589, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593589 != nil:
    section.add "Version", valid_593589
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593590 = header.getOrDefault("X-Amz-Signature")
  valid_593590 = validateParameter(valid_593590, JString, required = false,
                                 default = nil)
  if valid_593590 != nil:
    section.add "X-Amz-Signature", valid_593590
  var valid_593591 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593591 = validateParameter(valid_593591, JString, required = false,
                                 default = nil)
  if valid_593591 != nil:
    section.add "X-Amz-Content-Sha256", valid_593591
  var valid_593592 = header.getOrDefault("X-Amz-Date")
  valid_593592 = validateParameter(valid_593592, JString, required = false,
                                 default = nil)
  if valid_593592 != nil:
    section.add "X-Amz-Date", valid_593592
  var valid_593593 = header.getOrDefault("X-Amz-Credential")
  valid_593593 = validateParameter(valid_593593, JString, required = false,
                                 default = nil)
  if valid_593593 != nil:
    section.add "X-Amz-Credential", valid_593593
  var valid_593594 = header.getOrDefault("X-Amz-Security-Token")
  valid_593594 = validateParameter(valid_593594, JString, required = false,
                                 default = nil)
  if valid_593594 != nil:
    section.add "X-Amz-Security-Token", valid_593594
  var valid_593595 = header.getOrDefault("X-Amz-Algorithm")
  valid_593595 = validateParameter(valid_593595, JString, required = false,
                                 default = nil)
  if valid_593595 != nil:
    section.add "X-Amz-Algorithm", valid_593595
  var valid_593596 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593596 = validateParameter(valid_593596, JString, required = false,
                                 default = nil)
  if valid_593596 != nil:
    section.add "X-Amz-SignedHeaders", valid_593596
  result.add "header", section
  ## parameters in `formData` object:
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  section = newJObject()
  var valid_593597 = formData.getOrDefault("KmsKeyId")
  valid_593597 = validateParameter(valid_593597, JString, required = false,
                                 default = nil)
  if valid_593597 != nil:
    section.add "KmsKeyId", valid_593597
  var valid_593598 = formData.getOrDefault("Tags")
  valid_593598 = validateParameter(valid_593598, JArray, required = false,
                                 default = nil)
  if valid_593598 != nil:
    section.add "Tags", valid_593598
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_593599 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_593599 = validateParameter(valid_593599, JString, required = true,
                                 default = nil)
  if valid_593599 != nil:
    section.add "SnapshotCopyGrantName", valid_593599
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593600: Call_PostCreateSnapshotCopyGrant_593585; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_593600.validator(path, query, header, formData, body)
  let scheme = call_593600.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593600.url(scheme.get, call_593600.host, call_593600.base,
                         call_593600.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593600, url, valid)

proc call*(call_593601: Call_PostCreateSnapshotCopyGrant_593585;
          SnapshotCopyGrantName: string; KmsKeyId: string = "";
          Action: string = "CreateSnapshotCopyGrant"; Tags: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Version: string (required)
  var query_593602 = newJObject()
  var formData_593603 = newJObject()
  add(formData_593603, "KmsKeyId", newJString(KmsKeyId))
  add(query_593602, "Action", newJString(Action))
  if Tags != nil:
    formData_593603.add "Tags", Tags
  add(formData_593603, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_593602, "Version", newJString(Version))
  result = call_593601.call(nil, query_593602, nil, formData_593603, nil)

var postCreateSnapshotCopyGrant* = Call_PostCreateSnapshotCopyGrant_593585(
    name: "postCreateSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_PostCreateSnapshotCopyGrant_593586, base: "/",
    url: url_PostCreateSnapshotCopyGrant_593587,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotCopyGrant_593567 = ref object of OpenApiRestCall_592348
proc url_GetCreateSnapshotCopyGrant_593569(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateSnapshotCopyGrant_593568(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: JString
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  section = newJObject()
  var valid_593570 = query.getOrDefault("Tags")
  valid_593570 = validateParameter(valid_593570, JArray, required = false,
                                 default = nil)
  if valid_593570 != nil:
    section.add "Tags", valid_593570
  var valid_593571 = query.getOrDefault("KmsKeyId")
  valid_593571 = validateParameter(valid_593571, JString, required = false,
                                 default = nil)
  if valid_593571 != nil:
    section.add "KmsKeyId", valid_593571
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593572 = query.getOrDefault("Action")
  valid_593572 = validateParameter(valid_593572, JString, required = true, default = newJString(
      "CreateSnapshotCopyGrant"))
  if valid_593572 != nil:
    section.add "Action", valid_593572
  var valid_593573 = query.getOrDefault("Version")
  valid_593573 = validateParameter(valid_593573, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593573 != nil:
    section.add "Version", valid_593573
  var valid_593574 = query.getOrDefault("SnapshotCopyGrantName")
  valid_593574 = validateParameter(valid_593574, JString, required = true,
                                 default = nil)
  if valid_593574 != nil:
    section.add "SnapshotCopyGrantName", valid_593574
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593575 = header.getOrDefault("X-Amz-Signature")
  valid_593575 = validateParameter(valid_593575, JString, required = false,
                                 default = nil)
  if valid_593575 != nil:
    section.add "X-Amz-Signature", valid_593575
  var valid_593576 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593576 = validateParameter(valid_593576, JString, required = false,
                                 default = nil)
  if valid_593576 != nil:
    section.add "X-Amz-Content-Sha256", valid_593576
  var valid_593577 = header.getOrDefault("X-Amz-Date")
  valid_593577 = validateParameter(valid_593577, JString, required = false,
                                 default = nil)
  if valid_593577 != nil:
    section.add "X-Amz-Date", valid_593577
  var valid_593578 = header.getOrDefault("X-Amz-Credential")
  valid_593578 = validateParameter(valid_593578, JString, required = false,
                                 default = nil)
  if valid_593578 != nil:
    section.add "X-Amz-Credential", valid_593578
  var valid_593579 = header.getOrDefault("X-Amz-Security-Token")
  valid_593579 = validateParameter(valid_593579, JString, required = false,
                                 default = nil)
  if valid_593579 != nil:
    section.add "X-Amz-Security-Token", valid_593579
  var valid_593580 = header.getOrDefault("X-Amz-Algorithm")
  valid_593580 = validateParameter(valid_593580, JString, required = false,
                                 default = nil)
  if valid_593580 != nil:
    section.add "X-Amz-Algorithm", valid_593580
  var valid_593581 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593581 = validateParameter(valid_593581, JString, required = false,
                                 default = nil)
  if valid_593581 != nil:
    section.add "X-Amz-SignedHeaders", valid_593581
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593582: Call_GetCreateSnapshotCopyGrant_593567; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_593582.validator(path, query, header, formData, body)
  let scheme = call_593582.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593582.url(scheme.get, call_593582.host, call_593582.base,
                         call_593582.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593582, url, valid)

proc call*(call_593583: Call_GetCreateSnapshotCopyGrant_593567;
          SnapshotCopyGrantName: string; Tags: JsonNode = nil; KmsKeyId: string = "";
          Action: string = "CreateSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotCopyGrant
  ## <p>Creates a snapshot copy grant that permits Amazon Redshift to use a customer master key (CMK) from AWS Key Management Service (AWS KMS) to encrypt copied snapshots in a destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Tags: JArray
  ##       : A list of tag instances.
  ##   KmsKeyId: string
  ##           : The unique identifier of the customer master key (CMK) to which to grant Amazon Redshift permission. If no key is specified, the default key is used.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : <p>The name of the snapshot copy grant. This name must be unique in the region for the AWS account.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  var query_593584 = newJObject()
  if Tags != nil:
    query_593584.add "Tags", Tags
  add(query_593584, "KmsKeyId", newJString(KmsKeyId))
  add(query_593584, "Action", newJString(Action))
  add(query_593584, "Version", newJString(Version))
  add(query_593584, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_593583.call(nil, query_593584, nil, nil, nil)

var getCreateSnapshotCopyGrant* = Call_GetCreateSnapshotCopyGrant_593567(
    name: "getCreateSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotCopyGrant",
    validator: validate_GetCreateSnapshotCopyGrant_593568, base: "/",
    url: url_GetCreateSnapshotCopyGrant_593569,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateSnapshotSchedule_593625 = ref object of OpenApiRestCall_592348
proc url_PostCreateSnapshotSchedule_593627(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateSnapshotSchedule_593626(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593628 = query.getOrDefault("Action")
  valid_593628 = validateParameter(valid_593628, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_593628 != nil:
    section.add "Action", valid_593628
  var valid_593629 = query.getOrDefault("Version")
  valid_593629 = validateParameter(valid_593629, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593629 != nil:
    section.add "Version", valid_593629
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593630 = header.getOrDefault("X-Amz-Signature")
  valid_593630 = validateParameter(valid_593630, JString, required = false,
                                 default = nil)
  if valid_593630 != nil:
    section.add "X-Amz-Signature", valid_593630
  var valid_593631 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593631 = validateParameter(valid_593631, JString, required = false,
                                 default = nil)
  if valid_593631 != nil:
    section.add "X-Amz-Content-Sha256", valid_593631
  var valid_593632 = header.getOrDefault("X-Amz-Date")
  valid_593632 = validateParameter(valid_593632, JString, required = false,
                                 default = nil)
  if valid_593632 != nil:
    section.add "X-Amz-Date", valid_593632
  var valid_593633 = header.getOrDefault("X-Amz-Credential")
  valid_593633 = validateParameter(valid_593633, JString, required = false,
                                 default = nil)
  if valid_593633 != nil:
    section.add "X-Amz-Credential", valid_593633
  var valid_593634 = header.getOrDefault("X-Amz-Security-Token")
  valid_593634 = validateParameter(valid_593634, JString, required = false,
                                 default = nil)
  if valid_593634 != nil:
    section.add "X-Amz-Security-Token", valid_593634
  var valid_593635 = header.getOrDefault("X-Amz-Algorithm")
  valid_593635 = validateParameter(valid_593635, JString, required = false,
                                 default = nil)
  if valid_593635 != nil:
    section.add "X-Amz-Algorithm", valid_593635
  var valid_593636 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593636 = validateParameter(valid_593636, JString, required = false,
                                 default = nil)
  if valid_593636 != nil:
    section.add "X-Amz-SignedHeaders", valid_593636
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   DryRun: JBool
  ##         : <p/>
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  section = newJObject()
  var valid_593637 = formData.getOrDefault("ScheduleDefinitions")
  valid_593637 = validateParameter(valid_593637, JArray, required = false,
                                 default = nil)
  if valid_593637 != nil:
    section.add "ScheduleDefinitions", valid_593637
  var valid_593638 = formData.getOrDefault("ScheduleDescription")
  valid_593638 = validateParameter(valid_593638, JString, required = false,
                                 default = nil)
  if valid_593638 != nil:
    section.add "ScheduleDescription", valid_593638
  var valid_593639 = formData.getOrDefault("DryRun")
  valid_593639 = validateParameter(valid_593639, JBool, required = false, default = nil)
  if valid_593639 != nil:
    section.add "DryRun", valid_593639
  var valid_593640 = formData.getOrDefault("NextInvocations")
  valid_593640 = validateParameter(valid_593640, JInt, required = false, default = nil)
  if valid_593640 != nil:
    section.add "NextInvocations", valid_593640
  var valid_593641 = formData.getOrDefault("Tags")
  valid_593641 = validateParameter(valid_593641, JArray, required = false,
                                 default = nil)
  if valid_593641 != nil:
    section.add "Tags", valid_593641
  var valid_593642 = formData.getOrDefault("ScheduleIdentifier")
  valid_593642 = validateParameter(valid_593642, JString, required = false,
                                 default = nil)
  if valid_593642 != nil:
    section.add "ScheduleIdentifier", valid_593642
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593643: Call_PostCreateSnapshotSchedule_593625; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_593643.validator(path, query, header, formData, body)
  let scheme = call_593643.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593643.url(scheme.get, call_593643.host, call_593643.base,
                         call_593643.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593643, url, valid)

proc call*(call_593644: Call_PostCreateSnapshotSchedule_593625;
          ScheduleDefinitions: JsonNode = nil; ScheduleDescription: string = "";
          DryRun: bool = false; NextInvocations: int = 0;
          Action: string = "CreateSnapshotSchedule"; Tags: JsonNode = nil;
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   DryRun: bool
  ##         : <p/>
  ##   NextInvocations: int
  ##                  : <p/>
  ##   Action: string (required)
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   Version: string (required)
  var query_593645 = newJObject()
  var formData_593646 = newJObject()
  if ScheduleDefinitions != nil:
    formData_593646.add "ScheduleDefinitions", ScheduleDefinitions
  add(formData_593646, "ScheduleDescription", newJString(ScheduleDescription))
  add(formData_593646, "DryRun", newJBool(DryRun))
  add(formData_593646, "NextInvocations", newJInt(NextInvocations))
  add(query_593645, "Action", newJString(Action))
  if Tags != nil:
    formData_593646.add "Tags", Tags
  add(formData_593646, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_593645, "Version", newJString(Version))
  result = call_593644.call(nil, query_593645, nil, formData_593646, nil)

var postCreateSnapshotSchedule* = Call_PostCreateSnapshotSchedule_593625(
    name: "postCreateSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_PostCreateSnapshotSchedule_593626, base: "/",
    url: url_PostCreateSnapshotSchedule_593627,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateSnapshotSchedule_593604 = ref object of OpenApiRestCall_592348
proc url_GetCreateSnapshotSchedule_593606(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateSnapshotSchedule_593605(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Creates a new snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   DryRun: JBool
  ##         : <p/>
  ##   NextInvocations: JInt
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: JString
  ##                      : The description of the snapshot schedule.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_593607 = query.getOrDefault("Tags")
  valid_593607 = validateParameter(valid_593607, JArray, required = false,
                                 default = nil)
  if valid_593607 != nil:
    section.add "Tags", valid_593607
  var valid_593608 = query.getOrDefault("ScheduleIdentifier")
  valid_593608 = validateParameter(valid_593608, JString, required = false,
                                 default = nil)
  if valid_593608 != nil:
    section.add "ScheduleIdentifier", valid_593608
  var valid_593609 = query.getOrDefault("DryRun")
  valid_593609 = validateParameter(valid_593609, JBool, required = false, default = nil)
  if valid_593609 != nil:
    section.add "DryRun", valid_593609
  var valid_593610 = query.getOrDefault("NextInvocations")
  valid_593610 = validateParameter(valid_593610, JInt, required = false, default = nil)
  if valid_593610 != nil:
    section.add "NextInvocations", valid_593610
  var valid_593611 = query.getOrDefault("ScheduleDefinitions")
  valid_593611 = validateParameter(valid_593611, JArray, required = false,
                                 default = nil)
  if valid_593611 != nil:
    section.add "ScheduleDefinitions", valid_593611
  var valid_593612 = query.getOrDefault("ScheduleDescription")
  valid_593612 = validateParameter(valid_593612, JString, required = false,
                                 default = nil)
  if valid_593612 != nil:
    section.add "ScheduleDescription", valid_593612
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593613 = query.getOrDefault("Action")
  valid_593613 = validateParameter(valid_593613, JString, required = true,
                                 default = newJString("CreateSnapshotSchedule"))
  if valid_593613 != nil:
    section.add "Action", valid_593613
  var valid_593614 = query.getOrDefault("Version")
  valid_593614 = validateParameter(valid_593614, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593614 != nil:
    section.add "Version", valid_593614
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593615 = header.getOrDefault("X-Amz-Signature")
  valid_593615 = validateParameter(valid_593615, JString, required = false,
                                 default = nil)
  if valid_593615 != nil:
    section.add "X-Amz-Signature", valid_593615
  var valid_593616 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593616 = validateParameter(valid_593616, JString, required = false,
                                 default = nil)
  if valid_593616 != nil:
    section.add "X-Amz-Content-Sha256", valid_593616
  var valid_593617 = header.getOrDefault("X-Amz-Date")
  valid_593617 = validateParameter(valid_593617, JString, required = false,
                                 default = nil)
  if valid_593617 != nil:
    section.add "X-Amz-Date", valid_593617
  var valid_593618 = header.getOrDefault("X-Amz-Credential")
  valid_593618 = validateParameter(valid_593618, JString, required = false,
                                 default = nil)
  if valid_593618 != nil:
    section.add "X-Amz-Credential", valid_593618
  var valid_593619 = header.getOrDefault("X-Amz-Security-Token")
  valid_593619 = validateParameter(valid_593619, JString, required = false,
                                 default = nil)
  if valid_593619 != nil:
    section.add "X-Amz-Security-Token", valid_593619
  var valid_593620 = header.getOrDefault("X-Amz-Algorithm")
  valid_593620 = validateParameter(valid_593620, JString, required = false,
                                 default = nil)
  if valid_593620 != nil:
    section.add "X-Amz-Algorithm", valid_593620
  var valid_593621 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593621 = validateParameter(valid_593621, JString, required = false,
                                 default = nil)
  if valid_593621 != nil:
    section.add "X-Amz-SignedHeaders", valid_593621
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593622: Call_GetCreateSnapshotSchedule_593604; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Creates a new snapshot schedule.
  ## 
  let valid = call_593622.validator(path, query, header, formData, body)
  let scheme = call_593622.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593622.url(scheme.get, call_593622.host, call_593622.base,
                         call_593622.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593622, url, valid)

proc call*(call_593623: Call_GetCreateSnapshotSchedule_593604;
          Tags: JsonNode = nil; ScheduleIdentifier: string = ""; DryRun: bool = false;
          NextInvocations: int = 0; ScheduleDefinitions: JsonNode = nil;
          ScheduleDescription: string = "";
          Action: string = "CreateSnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getCreateSnapshotSchedule
  ## Creates a new snapshot schedule.
  ##   Tags: JArray
  ##       : An optional set of tags you can use to search for the schedule.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule. Only alphanumeric characters are allowed for the identifier.
  ##   DryRun: bool
  ##         : <p/>
  ##   NextInvocations: int
  ##                  : <p/>
  ##   ScheduleDefinitions: JArray
  ##                      : The definition of the snapshot schedule. The definition is made up of schedule expressions, for example "cron(30 12 *)" or "rate(12 hours)". 
  ##   ScheduleDescription: string
  ##                      : The description of the snapshot schedule.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593624 = newJObject()
  if Tags != nil:
    query_593624.add "Tags", Tags
  add(query_593624, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_593624, "DryRun", newJBool(DryRun))
  add(query_593624, "NextInvocations", newJInt(NextInvocations))
  if ScheduleDefinitions != nil:
    query_593624.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_593624, "ScheduleDescription", newJString(ScheduleDescription))
  add(query_593624, "Action", newJString(Action))
  add(query_593624, "Version", newJString(Version))
  result = call_593623.call(nil, query_593624, nil, nil, nil)

var getCreateSnapshotSchedule* = Call_GetCreateSnapshotSchedule_593604(
    name: "getCreateSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=CreateSnapshotSchedule",
    validator: validate_GetCreateSnapshotSchedule_593605, base: "/",
    url: url_GetCreateSnapshotSchedule_593606,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostCreateTags_593664 = ref object of OpenApiRestCall_592348
proc url_PostCreateTags_593666(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostCreateTags_593665(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593667 = query.getOrDefault("Action")
  valid_593667 = validateParameter(valid_593667, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_593667 != nil:
    section.add "Action", valid_593667
  var valid_593668 = query.getOrDefault("Version")
  valid_593668 = validateParameter(valid_593668, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593668 != nil:
    section.add "Version", valid_593668
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593669 = header.getOrDefault("X-Amz-Signature")
  valid_593669 = validateParameter(valid_593669, JString, required = false,
                                 default = nil)
  if valid_593669 != nil:
    section.add "X-Amz-Signature", valid_593669
  var valid_593670 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593670 = validateParameter(valid_593670, JString, required = false,
                                 default = nil)
  if valid_593670 != nil:
    section.add "X-Amz-Content-Sha256", valid_593670
  var valid_593671 = header.getOrDefault("X-Amz-Date")
  valid_593671 = validateParameter(valid_593671, JString, required = false,
                                 default = nil)
  if valid_593671 != nil:
    section.add "X-Amz-Date", valid_593671
  var valid_593672 = header.getOrDefault("X-Amz-Credential")
  valid_593672 = validateParameter(valid_593672, JString, required = false,
                                 default = nil)
  if valid_593672 != nil:
    section.add "X-Amz-Credential", valid_593672
  var valid_593673 = header.getOrDefault("X-Amz-Security-Token")
  valid_593673 = validateParameter(valid_593673, JString, required = false,
                                 default = nil)
  if valid_593673 != nil:
    section.add "X-Amz-Security-Token", valid_593673
  var valid_593674 = header.getOrDefault("X-Amz-Algorithm")
  valid_593674 = validateParameter(valid_593674, JString, required = false,
                                 default = nil)
  if valid_593674 != nil:
    section.add "X-Amz-Algorithm", valid_593674
  var valid_593675 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593675 = validateParameter(valid_593675, JString, required = false,
                                 default = nil)
  if valid_593675 != nil:
    section.add "X-Amz-SignedHeaders", valid_593675
  result.add "header", section
  ## parameters in `formData` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Tags` field"
  var valid_593676 = formData.getOrDefault("Tags")
  valid_593676 = validateParameter(valid_593676, JArray, required = true, default = nil)
  if valid_593676 != nil:
    section.add "Tags", valid_593676
  var valid_593677 = formData.getOrDefault("ResourceName")
  valid_593677 = validateParameter(valid_593677, JString, required = true,
                                 default = nil)
  if valid_593677 != nil:
    section.add "ResourceName", valid_593677
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593678: Call_PostCreateTags_593664; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_593678.validator(path, query, header, formData, body)
  let scheme = call_593678.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593678.url(scheme.get, call_593678.host, call_593678.base,
                         call_593678.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593678, url, valid)

proc call*(call_593679: Call_PostCreateTags_593664; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## postCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Action: string (required)
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   Version: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  var query_593680 = newJObject()
  var formData_593681 = newJObject()
  add(query_593680, "Action", newJString(Action))
  if Tags != nil:
    formData_593681.add "Tags", Tags
  add(query_593680, "Version", newJString(Version))
  add(formData_593681, "ResourceName", newJString(ResourceName))
  result = call_593679.call(nil, query_593680, nil, formData_593681, nil)

var postCreateTags* = Call_PostCreateTags_593664(name: "postCreateTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_PostCreateTags_593665,
    base: "/", url: url_PostCreateTags_593666, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetCreateTags_593647 = ref object of OpenApiRestCall_592348
proc url_GetCreateTags_593649(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetCreateTags_593648(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Tags` field"
  var valid_593650 = query.getOrDefault("Tags")
  valid_593650 = validateParameter(valid_593650, JArray, required = true, default = nil)
  if valid_593650 != nil:
    section.add "Tags", valid_593650
  var valid_593651 = query.getOrDefault("ResourceName")
  valid_593651 = validateParameter(valid_593651, JString, required = true,
                                 default = nil)
  if valid_593651 != nil:
    section.add "ResourceName", valid_593651
  var valid_593652 = query.getOrDefault("Action")
  valid_593652 = validateParameter(valid_593652, JString, required = true,
                                 default = newJString("CreateTags"))
  if valid_593652 != nil:
    section.add "Action", valid_593652
  var valid_593653 = query.getOrDefault("Version")
  valid_593653 = validateParameter(valid_593653, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593653 != nil:
    section.add "Version", valid_593653
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593654 = header.getOrDefault("X-Amz-Signature")
  valid_593654 = validateParameter(valid_593654, JString, required = false,
                                 default = nil)
  if valid_593654 != nil:
    section.add "X-Amz-Signature", valid_593654
  var valid_593655 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593655 = validateParameter(valid_593655, JString, required = false,
                                 default = nil)
  if valid_593655 != nil:
    section.add "X-Amz-Content-Sha256", valid_593655
  var valid_593656 = header.getOrDefault("X-Amz-Date")
  valid_593656 = validateParameter(valid_593656, JString, required = false,
                                 default = nil)
  if valid_593656 != nil:
    section.add "X-Amz-Date", valid_593656
  var valid_593657 = header.getOrDefault("X-Amz-Credential")
  valid_593657 = validateParameter(valid_593657, JString, required = false,
                                 default = nil)
  if valid_593657 != nil:
    section.add "X-Amz-Credential", valid_593657
  var valid_593658 = header.getOrDefault("X-Amz-Security-Token")
  valid_593658 = validateParameter(valid_593658, JString, required = false,
                                 default = nil)
  if valid_593658 != nil:
    section.add "X-Amz-Security-Token", valid_593658
  var valid_593659 = header.getOrDefault("X-Amz-Algorithm")
  valid_593659 = validateParameter(valid_593659, JString, required = false,
                                 default = nil)
  if valid_593659 != nil:
    section.add "X-Amz-Algorithm", valid_593659
  var valid_593660 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593660 = validateParameter(valid_593660, JString, required = false,
                                 default = nil)
  if valid_593660 != nil:
    section.add "X-Amz-SignedHeaders", valid_593660
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593661: Call_GetCreateTags_593647; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ## 
  let valid = call_593661.validator(path, query, header, formData, body)
  let scheme = call_593661.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593661.url(scheme.get, call_593661.host, call_593661.base,
                         call_593661.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593661, url, valid)

proc call*(call_593662: Call_GetCreateTags_593647; Tags: JsonNode;
          ResourceName: string; Action: string = "CreateTags";
          Version: string = "2012-12-01"): Recallable =
  ## getCreateTags
  ## <p>Adds one or more tags to a specified resource.</p> <p>A resource can have up to 50 tags. If you try to create more than 50 tags for a resource, you will receive an error and the attempt will fail.</p> <p>If you specify a key that already exists for the resource, the value for that key will be updated with the new value.</p>
  ##   Tags: JArray (required)
  ##       : One or more name/value pairs to add as tags to the specified resource. Each tag name is passed in with the parameter <code>Key</code> and the corresponding value is passed in with the parameter <code>Value</code>. The <code>Key</code> and <code>Value</code> parameters are separated by a comma (,). Separate multiple tags with a space. For example, <code>--tags "Key"="owner","Value"="admin" "Key"="environment","Value"="test" "Key"="version","Value"="1.0"</code>. 
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) to which you want to add the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593663 = newJObject()
  if Tags != nil:
    query_593663.add "Tags", Tags
  add(query_593663, "ResourceName", newJString(ResourceName))
  add(query_593663, "Action", newJString(Action))
  add(query_593663, "Version", newJString(Version))
  result = call_593662.call(nil, query_593663, nil, nil, nil)

var getCreateTags* = Call_GetCreateTags_593647(name: "getCreateTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=CreateTags", validator: validate_GetCreateTags_593648,
    base: "/", url: url_GetCreateTags_593649, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteCluster_593701 = ref object of OpenApiRestCall_592348
proc url_PostDeleteCluster_593703(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteCluster_593702(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593704 = query.getOrDefault("Action")
  valid_593704 = validateParameter(valid_593704, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_593704 != nil:
    section.add "Action", valid_593704
  var valid_593705 = query.getOrDefault("Version")
  valid_593705 = validateParameter(valid_593705, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593705 != nil:
    section.add "Version", valid_593705
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593706 = header.getOrDefault("X-Amz-Signature")
  valid_593706 = validateParameter(valid_593706, JString, required = false,
                                 default = nil)
  if valid_593706 != nil:
    section.add "X-Amz-Signature", valid_593706
  var valid_593707 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593707 = validateParameter(valid_593707, JString, required = false,
                                 default = nil)
  if valid_593707 != nil:
    section.add "X-Amz-Content-Sha256", valid_593707
  var valid_593708 = header.getOrDefault("X-Amz-Date")
  valid_593708 = validateParameter(valid_593708, JString, required = false,
                                 default = nil)
  if valid_593708 != nil:
    section.add "X-Amz-Date", valid_593708
  var valid_593709 = header.getOrDefault("X-Amz-Credential")
  valid_593709 = validateParameter(valid_593709, JString, required = false,
                                 default = nil)
  if valid_593709 != nil:
    section.add "X-Amz-Credential", valid_593709
  var valid_593710 = header.getOrDefault("X-Amz-Security-Token")
  valid_593710 = validateParameter(valid_593710, JString, required = false,
                                 default = nil)
  if valid_593710 != nil:
    section.add "X-Amz-Security-Token", valid_593710
  var valid_593711 = header.getOrDefault("X-Amz-Algorithm")
  valid_593711 = validateParameter(valid_593711, JString, required = false,
                                 default = nil)
  if valid_593711 != nil:
    section.add "X-Amz-Algorithm", valid_593711
  var valid_593712 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593712 = validateParameter(valid_593712, JString, required = false,
                                 default = nil)
  if valid_593712 != nil:
    section.add "X-Amz-SignedHeaders", valid_593712
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_593713 = formData.getOrDefault("ClusterIdentifier")
  valid_593713 = validateParameter(valid_593713, JString, required = true,
                                 default = nil)
  if valid_593713 != nil:
    section.add "ClusterIdentifier", valid_593713
  var valid_593714 = formData.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_593714 = validateParameter(valid_593714, JString, required = false,
                                 default = nil)
  if valid_593714 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_593714
  var valid_593715 = formData.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_593715 = validateParameter(valid_593715, JInt, required = false, default = nil)
  if valid_593715 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_593715
  var valid_593716 = formData.getOrDefault("SkipFinalClusterSnapshot")
  valid_593716 = validateParameter(valid_593716, JBool, required = false, default = nil)
  if valid_593716 != nil:
    section.add "SkipFinalClusterSnapshot", valid_593716
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593717: Call_PostDeleteCluster_593701; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593717.validator(path, query, header, formData, body)
  let scheme = call_593717.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593717.url(scheme.get, call_593717.host, call_593717.base,
                         call_593717.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593717, url, valid)

proc call*(call_593718: Call_PostDeleteCluster_593701; ClusterIdentifier: string;
          FinalClusterSnapshotIdentifier: string = "";
          Action: string = "DeleteCluster";
          FinalClusterSnapshotRetentionPeriod: int = 0;
          Version: string = "2012-12-01"; SkipFinalClusterSnapshot: bool = false): Recallable =
  ## postDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Action: string (required)
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   Version: string (required)
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  var query_593719 = newJObject()
  var formData_593720 = newJObject()
  add(formData_593720, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_593720, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_593719, "Action", newJString(Action))
  add(formData_593720, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  add(query_593719, "Version", newJString(Version))
  add(formData_593720, "SkipFinalClusterSnapshot",
      newJBool(SkipFinalClusterSnapshot))
  result = call_593718.call(nil, query_593719, nil, formData_593720, nil)

var postDeleteCluster* = Call_PostDeleteCluster_593701(name: "postDeleteCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_PostDeleteCluster_593702,
    base: "/", url: url_PostDeleteCluster_593703,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteCluster_593682 = ref object of OpenApiRestCall_592348
proc url_GetDeleteCluster_593684(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteCluster_593683(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   SkipFinalClusterSnapshot: JBool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: JString (required)
  ##   FinalClusterSnapshotIdentifier: JString
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: JInt
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593685 = query.getOrDefault("Action")
  valid_593685 = validateParameter(valid_593685, JString, required = true,
                                 default = newJString("DeleteCluster"))
  if valid_593685 != nil:
    section.add "Action", valid_593685
  var valid_593686 = query.getOrDefault("SkipFinalClusterSnapshot")
  valid_593686 = validateParameter(valid_593686, JBool, required = false, default = nil)
  if valid_593686 != nil:
    section.add "SkipFinalClusterSnapshot", valid_593686
  var valid_593687 = query.getOrDefault("ClusterIdentifier")
  valid_593687 = validateParameter(valid_593687, JString, required = true,
                                 default = nil)
  if valid_593687 != nil:
    section.add "ClusterIdentifier", valid_593687
  var valid_593688 = query.getOrDefault("Version")
  valid_593688 = validateParameter(valid_593688, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593688 != nil:
    section.add "Version", valid_593688
  var valid_593689 = query.getOrDefault("FinalClusterSnapshotIdentifier")
  valid_593689 = validateParameter(valid_593689, JString, required = false,
                                 default = nil)
  if valid_593689 != nil:
    section.add "FinalClusterSnapshotIdentifier", valid_593689
  var valid_593690 = query.getOrDefault("FinalClusterSnapshotRetentionPeriod")
  valid_593690 = validateParameter(valid_593690, JInt, required = false, default = nil)
  if valid_593690 != nil:
    section.add "FinalClusterSnapshotRetentionPeriod", valid_593690
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593691 = header.getOrDefault("X-Amz-Signature")
  valid_593691 = validateParameter(valid_593691, JString, required = false,
                                 default = nil)
  if valid_593691 != nil:
    section.add "X-Amz-Signature", valid_593691
  var valid_593692 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593692 = validateParameter(valid_593692, JString, required = false,
                                 default = nil)
  if valid_593692 != nil:
    section.add "X-Amz-Content-Sha256", valid_593692
  var valid_593693 = header.getOrDefault("X-Amz-Date")
  valid_593693 = validateParameter(valid_593693, JString, required = false,
                                 default = nil)
  if valid_593693 != nil:
    section.add "X-Amz-Date", valid_593693
  var valid_593694 = header.getOrDefault("X-Amz-Credential")
  valid_593694 = validateParameter(valid_593694, JString, required = false,
                                 default = nil)
  if valid_593694 != nil:
    section.add "X-Amz-Credential", valid_593694
  var valid_593695 = header.getOrDefault("X-Amz-Security-Token")
  valid_593695 = validateParameter(valid_593695, JString, required = false,
                                 default = nil)
  if valid_593695 != nil:
    section.add "X-Amz-Security-Token", valid_593695
  var valid_593696 = header.getOrDefault("X-Amz-Algorithm")
  valid_593696 = validateParameter(valid_593696, JString, required = false,
                                 default = nil)
  if valid_593696 != nil:
    section.add "X-Amz-Algorithm", valid_593696
  var valid_593697 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593697 = validateParameter(valid_593697, JString, required = false,
                                 default = nil)
  if valid_593697 != nil:
    section.add "X-Amz-SignedHeaders", valid_593697
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593698: Call_GetDeleteCluster_593682; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593698.validator(path, query, header, formData, body)
  let scheme = call_593698.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593698.url(scheme.get, call_593698.host, call_593698.base,
                         call_593698.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593698, url, valid)

proc call*(call_593699: Call_GetDeleteCluster_593682; ClusterIdentifier: string;
          Action: string = "DeleteCluster"; SkipFinalClusterSnapshot: bool = false;
          Version: string = "2012-12-01";
          FinalClusterSnapshotIdentifier: string = "";
          FinalClusterSnapshotRetentionPeriod: int = 0): Recallable =
  ## getDeleteCluster
  ## <p>Deletes a previously provisioned cluster. A successful response from the web service indicates that the request was received correctly. Use <a>DescribeClusters</a> to monitor the status of the deletion. The delete operation cannot be canceled or reverted once submitted. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you want to shut down the cluster and retain it for future use, set <i>SkipFinalClusterSnapshot</i> to <code>false</code> and specify a name for <i>FinalClusterSnapshotIdentifier</i>. You can later restore this snapshot to resume using the cluster. If a final cluster snapshot is requested, the status of the cluster will be "final-snapshot" while the snapshot is being taken, then it's "deleting" once Amazon Redshift begins deleting the cluster. </p> <p> For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   SkipFinalClusterSnapshot: bool
  ##                           : <p>Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If <code>true</code>, a final cluster snapshot is not created. If <code>false</code>, a final cluster snapshot is created before the cluster is deleted. </p> <note> <p>The <i>FinalClusterSnapshotIdentifier</i> parameter must be specified if <i>SkipFinalClusterSnapshot</i> is <code>false</code>.</p> </note> <p>Default: <code>false</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must contain lowercase characters.</p> </li> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   Version: string (required)
  ##   FinalClusterSnapshotIdentifier: string
  ##                                 : <p>The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, <i>SkipFinalClusterSnapshot</i> must be <code>false</code>. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   FinalClusterSnapshotRetentionPeriod: int
  ##                                      : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_593700 = newJObject()
  add(query_593700, "Action", newJString(Action))
  add(query_593700, "SkipFinalClusterSnapshot", newJBool(SkipFinalClusterSnapshot))
  add(query_593700, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_593700, "Version", newJString(Version))
  add(query_593700, "FinalClusterSnapshotIdentifier",
      newJString(FinalClusterSnapshotIdentifier))
  add(query_593700, "FinalClusterSnapshotRetentionPeriod",
      newJInt(FinalClusterSnapshotRetentionPeriod))
  result = call_593699.call(nil, query_593700, nil, nil, nil)

var getDeleteCluster* = Call_GetDeleteCluster_593682(name: "getDeleteCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteCluster", validator: validate_GetDeleteCluster_593683,
    base: "/", url: url_GetDeleteCluster_593684,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterParameterGroup_593737 = ref object of OpenApiRestCall_592348
proc url_PostDeleteClusterParameterGroup_593739(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterParameterGroup_593738(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593740 = query.getOrDefault("Action")
  valid_593740 = validateParameter(valid_593740, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_593740 != nil:
    section.add "Action", valid_593740
  var valid_593741 = query.getOrDefault("Version")
  valid_593741 = validateParameter(valid_593741, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593741 != nil:
    section.add "Version", valid_593741
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593742 = header.getOrDefault("X-Amz-Signature")
  valid_593742 = validateParameter(valid_593742, JString, required = false,
                                 default = nil)
  if valid_593742 != nil:
    section.add "X-Amz-Signature", valid_593742
  var valid_593743 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593743 = validateParameter(valid_593743, JString, required = false,
                                 default = nil)
  if valid_593743 != nil:
    section.add "X-Amz-Content-Sha256", valid_593743
  var valid_593744 = header.getOrDefault("X-Amz-Date")
  valid_593744 = validateParameter(valid_593744, JString, required = false,
                                 default = nil)
  if valid_593744 != nil:
    section.add "X-Amz-Date", valid_593744
  var valid_593745 = header.getOrDefault("X-Amz-Credential")
  valid_593745 = validateParameter(valid_593745, JString, required = false,
                                 default = nil)
  if valid_593745 != nil:
    section.add "X-Amz-Credential", valid_593745
  var valid_593746 = header.getOrDefault("X-Amz-Security-Token")
  valid_593746 = validateParameter(valid_593746, JString, required = false,
                                 default = nil)
  if valid_593746 != nil:
    section.add "X-Amz-Security-Token", valid_593746
  var valid_593747 = header.getOrDefault("X-Amz-Algorithm")
  valid_593747 = validateParameter(valid_593747, JString, required = false,
                                 default = nil)
  if valid_593747 != nil:
    section.add "X-Amz-Algorithm", valid_593747
  var valid_593748 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593748 = validateParameter(valid_593748, JString, required = false,
                                 default = nil)
  if valid_593748 != nil:
    section.add "X-Amz-SignedHeaders", valid_593748
  result.add "header", section
  ## parameters in `formData` object:
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_593749 = formData.getOrDefault("ParameterGroupName")
  valid_593749 = validateParameter(valid_593749, JString, required = true,
                                 default = nil)
  if valid_593749 != nil:
    section.add "ParameterGroupName", valid_593749
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593750: Call_PostDeleteClusterParameterGroup_593737;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_593750.validator(path, query, header, formData, body)
  let scheme = call_593750.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593750.url(scheme.get, call_593750.host, call_593750.base,
                         call_593750.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593750, url, valid)

proc call*(call_593751: Call_PostDeleteClusterParameterGroup_593737;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: string (required)
  var query_593752 = newJObject()
  var formData_593753 = newJObject()
  add(query_593752, "Action", newJString(Action))
  add(formData_593753, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_593752, "Version", newJString(Version))
  result = call_593751.call(nil, query_593752, nil, formData_593753, nil)

var postDeleteClusterParameterGroup* = Call_PostDeleteClusterParameterGroup_593737(
    name: "postDeleteClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_PostDeleteClusterParameterGroup_593738, base: "/",
    url: url_PostDeleteClusterParameterGroup_593739,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterParameterGroup_593721 = ref object of OpenApiRestCall_592348
proc url_GetDeleteClusterParameterGroup_593723(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterParameterGroup_593722(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593724 = query.getOrDefault("Action")
  valid_593724 = validateParameter(valid_593724, JString, required = true, default = newJString(
      "DeleteClusterParameterGroup"))
  if valid_593724 != nil:
    section.add "Action", valid_593724
  var valid_593725 = query.getOrDefault("ParameterGroupName")
  valid_593725 = validateParameter(valid_593725, JString, required = true,
                                 default = nil)
  if valid_593725 != nil:
    section.add "ParameterGroupName", valid_593725
  var valid_593726 = query.getOrDefault("Version")
  valid_593726 = validateParameter(valid_593726, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593726 != nil:
    section.add "Version", valid_593726
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593727 = header.getOrDefault("X-Amz-Signature")
  valid_593727 = validateParameter(valid_593727, JString, required = false,
                                 default = nil)
  if valid_593727 != nil:
    section.add "X-Amz-Signature", valid_593727
  var valid_593728 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593728 = validateParameter(valid_593728, JString, required = false,
                                 default = nil)
  if valid_593728 != nil:
    section.add "X-Amz-Content-Sha256", valid_593728
  var valid_593729 = header.getOrDefault("X-Amz-Date")
  valid_593729 = validateParameter(valid_593729, JString, required = false,
                                 default = nil)
  if valid_593729 != nil:
    section.add "X-Amz-Date", valid_593729
  var valid_593730 = header.getOrDefault("X-Amz-Credential")
  valid_593730 = validateParameter(valid_593730, JString, required = false,
                                 default = nil)
  if valid_593730 != nil:
    section.add "X-Amz-Credential", valid_593730
  var valid_593731 = header.getOrDefault("X-Amz-Security-Token")
  valid_593731 = validateParameter(valid_593731, JString, required = false,
                                 default = nil)
  if valid_593731 != nil:
    section.add "X-Amz-Security-Token", valid_593731
  var valid_593732 = header.getOrDefault("X-Amz-Algorithm")
  valid_593732 = validateParameter(valid_593732, JString, required = false,
                                 default = nil)
  if valid_593732 != nil:
    section.add "X-Amz-Algorithm", valid_593732
  var valid_593733 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593733 = validateParameter(valid_593733, JString, required = false,
                                 default = nil)
  if valid_593733 != nil:
    section.add "X-Amz-SignedHeaders", valid_593733
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593734: Call_GetDeleteClusterParameterGroup_593721; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ## 
  let valid = call_593734.validator(path, query, header, formData, body)
  let scheme = call_593734.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593734.url(scheme.get, call_593734.host, call_593734.base,
                         call_593734.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593734, url, valid)

proc call*(call_593735: Call_GetDeleteClusterParameterGroup_593721;
          ParameterGroupName: string;
          Action: string = "DeleteClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterParameterGroup
  ## <p>Deletes a specified Amazon Redshift parameter group.</p> <note> <p>You cannot delete a parameter group if it is associated with a cluster.</p> </note>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : <p>The name of the parameter group to be deleted.</p> <p>Constraints:</p> <ul> <li> <p>Must be the name of an existing cluster parameter group.</p> </li> <li> <p>Cannot delete a default cluster parameter group.</p> </li> </ul>
  ##   Version: string (required)
  var query_593736 = newJObject()
  add(query_593736, "Action", newJString(Action))
  add(query_593736, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_593736, "Version", newJString(Version))
  result = call_593735.call(nil, query_593736, nil, nil, nil)

var getDeleteClusterParameterGroup* = Call_GetDeleteClusterParameterGroup_593721(
    name: "getDeleteClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterParameterGroup",
    validator: validate_GetDeleteClusterParameterGroup_593722, base: "/",
    url: url_GetDeleteClusterParameterGroup_593723,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSecurityGroup_593770 = ref object of OpenApiRestCall_592348
proc url_PostDeleteClusterSecurityGroup_593772(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterSecurityGroup_593771(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593773 = query.getOrDefault("Action")
  valid_593773 = validateParameter(valid_593773, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_593773 != nil:
    section.add "Action", valid_593773
  var valid_593774 = query.getOrDefault("Version")
  valid_593774 = validateParameter(valid_593774, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593774 != nil:
    section.add "Version", valid_593774
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593775 = header.getOrDefault("X-Amz-Signature")
  valid_593775 = validateParameter(valid_593775, JString, required = false,
                                 default = nil)
  if valid_593775 != nil:
    section.add "X-Amz-Signature", valid_593775
  var valid_593776 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593776 = validateParameter(valid_593776, JString, required = false,
                                 default = nil)
  if valid_593776 != nil:
    section.add "X-Amz-Content-Sha256", valid_593776
  var valid_593777 = header.getOrDefault("X-Amz-Date")
  valid_593777 = validateParameter(valid_593777, JString, required = false,
                                 default = nil)
  if valid_593777 != nil:
    section.add "X-Amz-Date", valid_593777
  var valid_593778 = header.getOrDefault("X-Amz-Credential")
  valid_593778 = validateParameter(valid_593778, JString, required = false,
                                 default = nil)
  if valid_593778 != nil:
    section.add "X-Amz-Credential", valid_593778
  var valid_593779 = header.getOrDefault("X-Amz-Security-Token")
  valid_593779 = validateParameter(valid_593779, JString, required = false,
                                 default = nil)
  if valid_593779 != nil:
    section.add "X-Amz-Security-Token", valid_593779
  var valid_593780 = header.getOrDefault("X-Amz-Algorithm")
  valid_593780 = validateParameter(valid_593780, JString, required = false,
                                 default = nil)
  if valid_593780 != nil:
    section.add "X-Amz-Algorithm", valid_593780
  var valid_593781 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593781 = validateParameter(valid_593781, JString, required = false,
                                 default = nil)
  if valid_593781 != nil:
    section.add "X-Amz-SignedHeaders", valid_593781
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_593782 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_593782 = validateParameter(valid_593782, JString, required = true,
                                 default = nil)
  if valid_593782 != nil:
    section.add "ClusterSecurityGroupName", valid_593782
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593783: Call_PostDeleteClusterSecurityGroup_593770; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593783.validator(path, query, header, formData, body)
  let scheme = call_593783.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593783.url(scheme.get, call_593783.host, call_593783.base,
                         call_593783.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593783, url, valid)

proc call*(call_593784: Call_PostDeleteClusterSecurityGroup_593770;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593785 = newJObject()
  var formData_593786 = newJObject()
  add(formData_593786, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_593785, "Action", newJString(Action))
  add(query_593785, "Version", newJString(Version))
  result = call_593784.call(nil, query_593785, nil, formData_593786, nil)

var postDeleteClusterSecurityGroup* = Call_PostDeleteClusterSecurityGroup_593770(
    name: "postDeleteClusterSecurityGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_PostDeleteClusterSecurityGroup_593771, base: "/",
    url: url_PostDeleteClusterSecurityGroup_593772,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSecurityGroup_593754 = ref object of OpenApiRestCall_592348
proc url_GetDeleteClusterSecurityGroup_593756(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterSecurityGroup_593755(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_593757 = query.getOrDefault("ClusterSecurityGroupName")
  valid_593757 = validateParameter(valid_593757, JString, required = true,
                                 default = nil)
  if valid_593757 != nil:
    section.add "ClusterSecurityGroupName", valid_593757
  var valid_593758 = query.getOrDefault("Action")
  valid_593758 = validateParameter(valid_593758, JString, required = true, default = newJString(
      "DeleteClusterSecurityGroup"))
  if valid_593758 != nil:
    section.add "Action", valid_593758
  var valid_593759 = query.getOrDefault("Version")
  valid_593759 = validateParameter(valid_593759, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593759 != nil:
    section.add "Version", valid_593759
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593760 = header.getOrDefault("X-Amz-Signature")
  valid_593760 = validateParameter(valid_593760, JString, required = false,
                                 default = nil)
  if valid_593760 != nil:
    section.add "X-Amz-Signature", valid_593760
  var valid_593761 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593761 = validateParameter(valid_593761, JString, required = false,
                                 default = nil)
  if valid_593761 != nil:
    section.add "X-Amz-Content-Sha256", valid_593761
  var valid_593762 = header.getOrDefault("X-Amz-Date")
  valid_593762 = validateParameter(valid_593762, JString, required = false,
                                 default = nil)
  if valid_593762 != nil:
    section.add "X-Amz-Date", valid_593762
  var valid_593763 = header.getOrDefault("X-Amz-Credential")
  valid_593763 = validateParameter(valid_593763, JString, required = false,
                                 default = nil)
  if valid_593763 != nil:
    section.add "X-Amz-Credential", valid_593763
  var valid_593764 = header.getOrDefault("X-Amz-Security-Token")
  valid_593764 = validateParameter(valid_593764, JString, required = false,
                                 default = nil)
  if valid_593764 != nil:
    section.add "X-Amz-Security-Token", valid_593764
  var valid_593765 = header.getOrDefault("X-Amz-Algorithm")
  valid_593765 = validateParameter(valid_593765, JString, required = false,
                                 default = nil)
  if valid_593765 != nil:
    section.add "X-Amz-Algorithm", valid_593765
  var valid_593766 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593766 = validateParameter(valid_593766, JString, required = false,
                                 default = nil)
  if valid_593766 != nil:
    section.add "X-Amz-SignedHeaders", valid_593766
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593767: Call_GetDeleteClusterSecurityGroup_593754; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_593767.validator(path, query, header, formData, body)
  let scheme = call_593767.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593767.url(scheme.get, call_593767.host, call_593767.base,
                         call_593767.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593767, url, valid)

proc call*(call_593768: Call_GetDeleteClusterSecurityGroup_593754;
          ClusterSecurityGroupName: string;
          Action: string = "DeleteClusterSecurityGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSecurityGroup
  ## <p>Deletes an Amazon Redshift security group.</p> <note> <p>You cannot delete a security group that is associated with any clusters. You cannot delete the default security group.</p> </note> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the cluster security group to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593769 = newJObject()
  add(query_593769, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_593769, "Action", newJString(Action))
  add(query_593769, "Version", newJString(Version))
  result = call_593768.call(nil, query_593769, nil, nil, nil)

var getDeleteClusterSecurityGroup* = Call_GetDeleteClusterSecurityGroup_593754(
    name: "getDeleteClusterSecurityGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSecurityGroup",
    validator: validate_GetDeleteClusterSecurityGroup_593755, base: "/",
    url: url_GetDeleteClusterSecurityGroup_593756,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSnapshot_593804 = ref object of OpenApiRestCall_592348
proc url_PostDeleteClusterSnapshot_593806(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterSnapshot_593805(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593807 = query.getOrDefault("Action")
  valid_593807 = validateParameter(valid_593807, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_593807 != nil:
    section.add "Action", valid_593807
  var valid_593808 = query.getOrDefault("Version")
  valid_593808 = validateParameter(valid_593808, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593808 != nil:
    section.add "Version", valid_593808
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593809 = header.getOrDefault("X-Amz-Signature")
  valid_593809 = validateParameter(valid_593809, JString, required = false,
                                 default = nil)
  if valid_593809 != nil:
    section.add "X-Amz-Signature", valid_593809
  var valid_593810 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593810 = validateParameter(valid_593810, JString, required = false,
                                 default = nil)
  if valid_593810 != nil:
    section.add "X-Amz-Content-Sha256", valid_593810
  var valid_593811 = header.getOrDefault("X-Amz-Date")
  valid_593811 = validateParameter(valid_593811, JString, required = false,
                                 default = nil)
  if valid_593811 != nil:
    section.add "X-Amz-Date", valid_593811
  var valid_593812 = header.getOrDefault("X-Amz-Credential")
  valid_593812 = validateParameter(valid_593812, JString, required = false,
                                 default = nil)
  if valid_593812 != nil:
    section.add "X-Amz-Credential", valid_593812
  var valid_593813 = header.getOrDefault("X-Amz-Security-Token")
  valid_593813 = validateParameter(valid_593813, JString, required = false,
                                 default = nil)
  if valid_593813 != nil:
    section.add "X-Amz-Security-Token", valid_593813
  var valid_593814 = header.getOrDefault("X-Amz-Algorithm")
  valid_593814 = validateParameter(valid_593814, JString, required = false,
                                 default = nil)
  if valid_593814 != nil:
    section.add "X-Amz-Algorithm", valid_593814
  var valid_593815 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593815 = validateParameter(valid_593815, JString, required = false,
                                 default = nil)
  if valid_593815 != nil:
    section.add "X-Amz-SignedHeaders", valid_593815
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_593816 = formData.getOrDefault("SnapshotIdentifier")
  valid_593816 = validateParameter(valid_593816, JString, required = true,
                                 default = nil)
  if valid_593816 != nil:
    section.add "SnapshotIdentifier", valid_593816
  var valid_593817 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_593817 = validateParameter(valid_593817, JString, required = false,
                                 default = nil)
  if valid_593817 != nil:
    section.add "SnapshotClusterIdentifier", valid_593817
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593818: Call_PostDeleteClusterSnapshot_593804; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_593818.validator(path, query, header, formData, body)
  let scheme = call_593818.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593818.url(scheme.get, call_593818.host, call_593818.base,
                         call_593818.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593818, url, valid)

proc call*(call_593819: Call_PostDeleteClusterSnapshot_593804;
          SnapshotIdentifier: string; Action: string = "DeleteClusterSnapshot";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   Action: string (required)
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Version: string (required)
  var query_593820 = newJObject()
  var formData_593821 = newJObject()
  add(formData_593821, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_593820, "Action", newJString(Action))
  add(formData_593821, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_593820, "Version", newJString(Version))
  result = call_593819.call(nil, query_593820, nil, formData_593821, nil)

var postDeleteClusterSnapshot* = Call_PostDeleteClusterSnapshot_593804(
    name: "postDeleteClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_PostDeleteClusterSnapshot_593805, base: "/",
    url: url_PostDeleteClusterSnapshot_593806,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSnapshot_593787 = ref object of OpenApiRestCall_592348
proc url_GetDeleteClusterSnapshot_593789(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterSnapshot_593788(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: JString
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_593790 = query.getOrDefault("SnapshotIdentifier")
  valid_593790 = validateParameter(valid_593790, JString, required = true,
                                 default = nil)
  if valid_593790 != nil:
    section.add "SnapshotIdentifier", valid_593790
  var valid_593791 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_593791 = validateParameter(valid_593791, JString, required = false,
                                 default = nil)
  if valid_593791 != nil:
    section.add "SnapshotClusterIdentifier", valid_593791
  var valid_593792 = query.getOrDefault("Action")
  valid_593792 = validateParameter(valid_593792, JString, required = true,
                                 default = newJString("DeleteClusterSnapshot"))
  if valid_593792 != nil:
    section.add "Action", valid_593792
  var valid_593793 = query.getOrDefault("Version")
  valid_593793 = validateParameter(valid_593793, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593793 != nil:
    section.add "Version", valid_593793
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593794 = header.getOrDefault("X-Amz-Signature")
  valid_593794 = validateParameter(valid_593794, JString, required = false,
                                 default = nil)
  if valid_593794 != nil:
    section.add "X-Amz-Signature", valid_593794
  var valid_593795 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593795 = validateParameter(valid_593795, JString, required = false,
                                 default = nil)
  if valid_593795 != nil:
    section.add "X-Amz-Content-Sha256", valid_593795
  var valid_593796 = header.getOrDefault("X-Amz-Date")
  valid_593796 = validateParameter(valid_593796, JString, required = false,
                                 default = nil)
  if valid_593796 != nil:
    section.add "X-Amz-Date", valid_593796
  var valid_593797 = header.getOrDefault("X-Amz-Credential")
  valid_593797 = validateParameter(valid_593797, JString, required = false,
                                 default = nil)
  if valid_593797 != nil:
    section.add "X-Amz-Credential", valid_593797
  var valid_593798 = header.getOrDefault("X-Amz-Security-Token")
  valid_593798 = validateParameter(valid_593798, JString, required = false,
                                 default = nil)
  if valid_593798 != nil:
    section.add "X-Amz-Security-Token", valid_593798
  var valid_593799 = header.getOrDefault("X-Amz-Algorithm")
  valid_593799 = validateParameter(valid_593799, JString, required = false,
                                 default = nil)
  if valid_593799 != nil:
    section.add "X-Amz-Algorithm", valid_593799
  var valid_593800 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593800 = validateParameter(valid_593800, JString, required = false,
                                 default = nil)
  if valid_593800 != nil:
    section.add "X-Amz-SignedHeaders", valid_593800
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593801: Call_GetDeleteClusterSnapshot_593787; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ## 
  let valid = call_593801.validator(path, query, header, formData, body)
  let scheme = call_593801.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593801.url(scheme.get, call_593801.host, call_593801.base,
                         call_593801.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593801, url, valid)

proc call*(call_593802: Call_GetDeleteClusterSnapshot_593787;
          SnapshotIdentifier: string; SnapshotClusterIdentifier: string = "";
          Action: string = "DeleteClusterSnapshot"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSnapshot
  ## <p>Deletes the specified manual snapshot. The snapshot must be in the <code>available</code> state, with no other users authorized to access the snapshot. </p> <p>Unlike automated snapshots, manual snapshots are retained even after you delete your cluster. Amazon Redshift does not delete your manual snapshots. You must delete manual snapshot explicitly to avoid getting charged. If other accounts are authorized to access the snapshot, you must revoke all of the authorizations before you can delete the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The unique identifier of the manual snapshot to be deleted.</p> <p>Constraints: Must be the name of an existing snapshot that is in the <code>available</code>, <code>failed</code>, or <code>cancelled</code> state.</p>
  ##   SnapshotClusterIdentifier: string
  ##                            : <p>The unique identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.</p> <p>Constraints: Must be the name of valid cluster.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593803 = newJObject()
  add(query_593803, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_593803, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_593803, "Action", newJString(Action))
  add(query_593803, "Version", newJString(Version))
  result = call_593802.call(nil, query_593803, nil, nil, nil)

var getDeleteClusterSnapshot* = Call_GetDeleteClusterSnapshot_593787(
    name: "getDeleteClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSnapshot",
    validator: validate_GetDeleteClusterSnapshot_593788, base: "/",
    url: url_GetDeleteClusterSnapshot_593789, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteClusterSubnetGroup_593838 = ref object of OpenApiRestCall_592348
proc url_PostDeleteClusterSubnetGroup_593840(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteClusterSubnetGroup_593839(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593841 = query.getOrDefault("Action")
  valid_593841 = validateParameter(valid_593841, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_593841 != nil:
    section.add "Action", valid_593841
  var valid_593842 = query.getOrDefault("Version")
  valid_593842 = validateParameter(valid_593842, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593842 != nil:
    section.add "Version", valid_593842
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593843 = header.getOrDefault("X-Amz-Signature")
  valid_593843 = validateParameter(valid_593843, JString, required = false,
                                 default = nil)
  if valid_593843 != nil:
    section.add "X-Amz-Signature", valid_593843
  var valid_593844 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593844 = validateParameter(valid_593844, JString, required = false,
                                 default = nil)
  if valid_593844 != nil:
    section.add "X-Amz-Content-Sha256", valid_593844
  var valid_593845 = header.getOrDefault("X-Amz-Date")
  valid_593845 = validateParameter(valid_593845, JString, required = false,
                                 default = nil)
  if valid_593845 != nil:
    section.add "X-Amz-Date", valid_593845
  var valid_593846 = header.getOrDefault("X-Amz-Credential")
  valid_593846 = validateParameter(valid_593846, JString, required = false,
                                 default = nil)
  if valid_593846 != nil:
    section.add "X-Amz-Credential", valid_593846
  var valid_593847 = header.getOrDefault("X-Amz-Security-Token")
  valid_593847 = validateParameter(valid_593847, JString, required = false,
                                 default = nil)
  if valid_593847 != nil:
    section.add "X-Amz-Security-Token", valid_593847
  var valid_593848 = header.getOrDefault("X-Amz-Algorithm")
  valid_593848 = validateParameter(valid_593848, JString, required = false,
                                 default = nil)
  if valid_593848 != nil:
    section.add "X-Amz-Algorithm", valid_593848
  var valid_593849 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593849 = validateParameter(valid_593849, JString, required = false,
                                 default = nil)
  if valid_593849 != nil:
    section.add "X-Amz-SignedHeaders", valid_593849
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_593850 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_593850 = validateParameter(valid_593850, JString, required = true,
                                 default = nil)
  if valid_593850 != nil:
    section.add "ClusterSubnetGroupName", valid_593850
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593851: Call_PostDeleteClusterSubnetGroup_593838; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_593851.validator(path, query, header, formData, body)
  let scheme = call_593851.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593851.url(scheme.get, call_593851.host, call_593851.base,
                         call_593851.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593851, url, valid)

proc call*(call_593852: Call_PostDeleteClusterSubnetGroup_593838;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593853 = newJObject()
  var formData_593854 = newJObject()
  add(formData_593854, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_593853, "Action", newJString(Action))
  add(query_593853, "Version", newJString(Version))
  result = call_593852.call(nil, query_593853, nil, formData_593854, nil)

var postDeleteClusterSubnetGroup* = Call_PostDeleteClusterSubnetGroup_593838(
    name: "postDeleteClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_PostDeleteClusterSubnetGroup_593839, base: "/",
    url: url_PostDeleteClusterSubnetGroup_593840,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteClusterSubnetGroup_593822 = ref object of OpenApiRestCall_592348
proc url_GetDeleteClusterSubnetGroup_593824(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteClusterSubnetGroup_593823(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified cluster subnet group.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_593825 = query.getOrDefault("ClusterSubnetGroupName")
  valid_593825 = validateParameter(valid_593825, JString, required = true,
                                 default = nil)
  if valid_593825 != nil:
    section.add "ClusterSubnetGroupName", valid_593825
  var valid_593826 = query.getOrDefault("Action")
  valid_593826 = validateParameter(valid_593826, JString, required = true, default = newJString(
      "DeleteClusterSubnetGroup"))
  if valid_593826 != nil:
    section.add "Action", valid_593826
  var valid_593827 = query.getOrDefault("Version")
  valid_593827 = validateParameter(valid_593827, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593827 != nil:
    section.add "Version", valid_593827
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593828 = header.getOrDefault("X-Amz-Signature")
  valid_593828 = validateParameter(valid_593828, JString, required = false,
                                 default = nil)
  if valid_593828 != nil:
    section.add "X-Amz-Signature", valid_593828
  var valid_593829 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593829 = validateParameter(valid_593829, JString, required = false,
                                 default = nil)
  if valid_593829 != nil:
    section.add "X-Amz-Content-Sha256", valid_593829
  var valid_593830 = header.getOrDefault("X-Amz-Date")
  valid_593830 = validateParameter(valid_593830, JString, required = false,
                                 default = nil)
  if valid_593830 != nil:
    section.add "X-Amz-Date", valid_593830
  var valid_593831 = header.getOrDefault("X-Amz-Credential")
  valid_593831 = validateParameter(valid_593831, JString, required = false,
                                 default = nil)
  if valid_593831 != nil:
    section.add "X-Amz-Credential", valid_593831
  var valid_593832 = header.getOrDefault("X-Amz-Security-Token")
  valid_593832 = validateParameter(valid_593832, JString, required = false,
                                 default = nil)
  if valid_593832 != nil:
    section.add "X-Amz-Security-Token", valid_593832
  var valid_593833 = header.getOrDefault("X-Amz-Algorithm")
  valid_593833 = validateParameter(valid_593833, JString, required = false,
                                 default = nil)
  if valid_593833 != nil:
    section.add "X-Amz-Algorithm", valid_593833
  var valid_593834 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593834 = validateParameter(valid_593834, JString, required = false,
                                 default = nil)
  if valid_593834 != nil:
    section.add "X-Amz-SignedHeaders", valid_593834
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593835: Call_GetDeleteClusterSubnetGroup_593822; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified cluster subnet group.
  ## 
  let valid = call_593835.validator(path, query, header, formData, body)
  let scheme = call_593835.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593835.url(scheme.get, call_593835.host, call_593835.base,
                         call_593835.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593835, url, valid)

proc call*(call_593836: Call_GetDeleteClusterSubnetGroup_593822;
          ClusterSubnetGroupName: string;
          Action: string = "DeleteClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteClusterSubnetGroup
  ## Deletes the specified cluster subnet group.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the cluster subnet group name to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593837 = newJObject()
  add(query_593837, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_593837, "Action", newJString(Action))
  add(query_593837, "Version", newJString(Version))
  result = call_593836.call(nil, query_593837, nil, nil, nil)

var getDeleteClusterSubnetGroup* = Call_GetDeleteClusterSubnetGroup_593822(
    name: "getDeleteClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteClusterSubnetGroup",
    validator: validate_GetDeleteClusterSubnetGroup_593823, base: "/",
    url: url_GetDeleteClusterSubnetGroup_593824,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteEventSubscription_593871 = ref object of OpenApiRestCall_592348
proc url_PostDeleteEventSubscription_593873(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteEventSubscription_593872(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593874 = query.getOrDefault("Action")
  valid_593874 = validateParameter(valid_593874, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_593874 != nil:
    section.add "Action", valid_593874
  var valid_593875 = query.getOrDefault("Version")
  valid_593875 = validateParameter(valid_593875, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593875 != nil:
    section.add "Version", valid_593875
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593876 = header.getOrDefault("X-Amz-Signature")
  valid_593876 = validateParameter(valid_593876, JString, required = false,
                                 default = nil)
  if valid_593876 != nil:
    section.add "X-Amz-Signature", valid_593876
  var valid_593877 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593877 = validateParameter(valid_593877, JString, required = false,
                                 default = nil)
  if valid_593877 != nil:
    section.add "X-Amz-Content-Sha256", valid_593877
  var valid_593878 = header.getOrDefault("X-Amz-Date")
  valid_593878 = validateParameter(valid_593878, JString, required = false,
                                 default = nil)
  if valid_593878 != nil:
    section.add "X-Amz-Date", valid_593878
  var valid_593879 = header.getOrDefault("X-Amz-Credential")
  valid_593879 = validateParameter(valid_593879, JString, required = false,
                                 default = nil)
  if valid_593879 != nil:
    section.add "X-Amz-Credential", valid_593879
  var valid_593880 = header.getOrDefault("X-Amz-Security-Token")
  valid_593880 = validateParameter(valid_593880, JString, required = false,
                                 default = nil)
  if valid_593880 != nil:
    section.add "X-Amz-Security-Token", valid_593880
  var valid_593881 = header.getOrDefault("X-Amz-Algorithm")
  valid_593881 = validateParameter(valid_593881, JString, required = false,
                                 default = nil)
  if valid_593881 != nil:
    section.add "X-Amz-Algorithm", valid_593881
  var valid_593882 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593882 = validateParameter(valid_593882, JString, required = false,
                                 default = nil)
  if valid_593882 != nil:
    section.add "X-Amz-SignedHeaders", valid_593882
  result.add "header", section
  ## parameters in `formData` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_593883 = formData.getOrDefault("SubscriptionName")
  valid_593883 = validateParameter(valid_593883, JString, required = true,
                                 default = nil)
  if valid_593883 != nil:
    section.add "SubscriptionName", valid_593883
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593884: Call_PostDeleteEventSubscription_593871; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_593884.validator(path, query, header, formData, body)
  let scheme = call_593884.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593884.url(scheme.get, call_593884.host, call_593884.base,
                         call_593884.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593884, url, valid)

proc call*(call_593885: Call_PostDeleteEventSubscription_593871;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593886 = newJObject()
  var formData_593887 = newJObject()
  add(formData_593887, "SubscriptionName", newJString(SubscriptionName))
  add(query_593886, "Action", newJString(Action))
  add(query_593886, "Version", newJString(Version))
  result = call_593885.call(nil, query_593886, nil, formData_593887, nil)

var postDeleteEventSubscription* = Call_PostDeleteEventSubscription_593871(
    name: "postDeleteEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_PostDeleteEventSubscription_593872, base: "/",
    url: url_PostDeleteEventSubscription_593873,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteEventSubscription_593855 = ref object of OpenApiRestCall_592348
proc url_GetDeleteEventSubscription_593857(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteEventSubscription_593856(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SubscriptionName: JString (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_593858 = query.getOrDefault("SubscriptionName")
  valid_593858 = validateParameter(valid_593858, JString, required = true,
                                 default = nil)
  if valid_593858 != nil:
    section.add "SubscriptionName", valid_593858
  var valid_593859 = query.getOrDefault("Action")
  valid_593859 = validateParameter(valid_593859, JString, required = true, default = newJString(
      "DeleteEventSubscription"))
  if valid_593859 != nil:
    section.add "Action", valid_593859
  var valid_593860 = query.getOrDefault("Version")
  valid_593860 = validateParameter(valid_593860, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593860 != nil:
    section.add "Version", valid_593860
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593861 = header.getOrDefault("X-Amz-Signature")
  valid_593861 = validateParameter(valid_593861, JString, required = false,
                                 default = nil)
  if valid_593861 != nil:
    section.add "X-Amz-Signature", valid_593861
  var valid_593862 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593862 = validateParameter(valid_593862, JString, required = false,
                                 default = nil)
  if valid_593862 != nil:
    section.add "X-Amz-Content-Sha256", valid_593862
  var valid_593863 = header.getOrDefault("X-Amz-Date")
  valid_593863 = validateParameter(valid_593863, JString, required = false,
                                 default = nil)
  if valid_593863 != nil:
    section.add "X-Amz-Date", valid_593863
  var valid_593864 = header.getOrDefault("X-Amz-Credential")
  valid_593864 = validateParameter(valid_593864, JString, required = false,
                                 default = nil)
  if valid_593864 != nil:
    section.add "X-Amz-Credential", valid_593864
  var valid_593865 = header.getOrDefault("X-Amz-Security-Token")
  valid_593865 = validateParameter(valid_593865, JString, required = false,
                                 default = nil)
  if valid_593865 != nil:
    section.add "X-Amz-Security-Token", valid_593865
  var valid_593866 = header.getOrDefault("X-Amz-Algorithm")
  valid_593866 = validateParameter(valid_593866, JString, required = false,
                                 default = nil)
  if valid_593866 != nil:
    section.add "X-Amz-Algorithm", valid_593866
  var valid_593867 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593867 = validateParameter(valid_593867, JString, required = false,
                                 default = nil)
  if valid_593867 != nil:
    section.add "X-Amz-SignedHeaders", valid_593867
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593868: Call_GetDeleteEventSubscription_593855; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes an Amazon Redshift event notification subscription.
  ## 
  let valid = call_593868.validator(path, query, header, formData, body)
  let scheme = call_593868.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593868.url(scheme.get, call_593868.host, call_593868.base,
                         call_593868.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593868, url, valid)

proc call*(call_593869: Call_GetDeleteEventSubscription_593855;
          SubscriptionName: string; Action: string = "DeleteEventSubscription";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteEventSubscription
  ## Deletes an Amazon Redshift event notification subscription.
  ##   SubscriptionName: string (required)
  ##                   : The name of the Amazon Redshift event notification subscription to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593870 = newJObject()
  add(query_593870, "SubscriptionName", newJString(SubscriptionName))
  add(query_593870, "Action", newJString(Action))
  add(query_593870, "Version", newJString(Version))
  result = call_593869.call(nil, query_593870, nil, nil, nil)

var getDeleteEventSubscription* = Call_GetDeleteEventSubscription_593855(
    name: "getDeleteEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteEventSubscription",
    validator: validate_GetDeleteEventSubscription_593856, base: "/",
    url: url_GetDeleteEventSubscription_593857,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmClientCertificate_593904 = ref object of OpenApiRestCall_592348
proc url_PostDeleteHsmClientCertificate_593906(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteHsmClientCertificate_593905(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593907 = query.getOrDefault("Action")
  valid_593907 = validateParameter(valid_593907, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_593907 != nil:
    section.add "Action", valid_593907
  var valid_593908 = query.getOrDefault("Version")
  valid_593908 = validateParameter(valid_593908, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593908 != nil:
    section.add "Version", valid_593908
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593909 = header.getOrDefault("X-Amz-Signature")
  valid_593909 = validateParameter(valid_593909, JString, required = false,
                                 default = nil)
  if valid_593909 != nil:
    section.add "X-Amz-Signature", valid_593909
  var valid_593910 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593910 = validateParameter(valid_593910, JString, required = false,
                                 default = nil)
  if valid_593910 != nil:
    section.add "X-Amz-Content-Sha256", valid_593910
  var valid_593911 = header.getOrDefault("X-Amz-Date")
  valid_593911 = validateParameter(valid_593911, JString, required = false,
                                 default = nil)
  if valid_593911 != nil:
    section.add "X-Amz-Date", valid_593911
  var valid_593912 = header.getOrDefault("X-Amz-Credential")
  valid_593912 = validateParameter(valid_593912, JString, required = false,
                                 default = nil)
  if valid_593912 != nil:
    section.add "X-Amz-Credential", valid_593912
  var valid_593913 = header.getOrDefault("X-Amz-Security-Token")
  valid_593913 = validateParameter(valid_593913, JString, required = false,
                                 default = nil)
  if valid_593913 != nil:
    section.add "X-Amz-Security-Token", valid_593913
  var valid_593914 = header.getOrDefault("X-Amz-Algorithm")
  valid_593914 = validateParameter(valid_593914, JString, required = false,
                                 default = nil)
  if valid_593914 != nil:
    section.add "X-Amz-Algorithm", valid_593914
  var valid_593915 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593915 = validateParameter(valid_593915, JString, required = false,
                                 default = nil)
  if valid_593915 != nil:
    section.add "X-Amz-SignedHeaders", valid_593915
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_593916 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_593916 = validateParameter(valid_593916, JString, required = true,
                                 default = nil)
  if valid_593916 != nil:
    section.add "HsmClientCertificateIdentifier", valid_593916
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593917: Call_PostDeleteHsmClientCertificate_593904; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_593917.validator(path, query, header, formData, body)
  let scheme = call_593917.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593917.url(scheme.get, call_593917.host, call_593917.base,
                         call_593917.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593917, url, valid)

proc call*(call_593918: Call_PostDeleteHsmClientCertificate_593904;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Version: string (required)
  var query_593919 = newJObject()
  var formData_593920 = newJObject()
  add(query_593919, "Action", newJString(Action))
  add(formData_593920, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_593919, "Version", newJString(Version))
  result = call_593918.call(nil, query_593919, nil, formData_593920, nil)

var postDeleteHsmClientCertificate* = Call_PostDeleteHsmClientCertificate_593904(
    name: "postDeleteHsmClientCertificate", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_PostDeleteHsmClientCertificate_593905, base: "/",
    url: url_PostDeleteHsmClientCertificate_593906,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmClientCertificate_593888 = ref object of OpenApiRestCall_592348
proc url_GetDeleteHsmClientCertificate_593890(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteHsmClientCertificate_593889(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified HSM client certificate.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   HsmClientCertificateIdentifier: JString (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `HsmClientCertificateIdentifier` field"
  var valid_593891 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_593891 = validateParameter(valid_593891, JString, required = true,
                                 default = nil)
  if valid_593891 != nil:
    section.add "HsmClientCertificateIdentifier", valid_593891
  var valid_593892 = query.getOrDefault("Action")
  valid_593892 = validateParameter(valid_593892, JString, required = true, default = newJString(
      "DeleteHsmClientCertificate"))
  if valid_593892 != nil:
    section.add "Action", valid_593892
  var valid_593893 = query.getOrDefault("Version")
  valid_593893 = validateParameter(valid_593893, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593893 != nil:
    section.add "Version", valid_593893
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593894 = header.getOrDefault("X-Amz-Signature")
  valid_593894 = validateParameter(valid_593894, JString, required = false,
                                 default = nil)
  if valid_593894 != nil:
    section.add "X-Amz-Signature", valid_593894
  var valid_593895 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593895 = validateParameter(valid_593895, JString, required = false,
                                 default = nil)
  if valid_593895 != nil:
    section.add "X-Amz-Content-Sha256", valid_593895
  var valid_593896 = header.getOrDefault("X-Amz-Date")
  valid_593896 = validateParameter(valid_593896, JString, required = false,
                                 default = nil)
  if valid_593896 != nil:
    section.add "X-Amz-Date", valid_593896
  var valid_593897 = header.getOrDefault("X-Amz-Credential")
  valid_593897 = validateParameter(valid_593897, JString, required = false,
                                 default = nil)
  if valid_593897 != nil:
    section.add "X-Amz-Credential", valid_593897
  var valid_593898 = header.getOrDefault("X-Amz-Security-Token")
  valid_593898 = validateParameter(valid_593898, JString, required = false,
                                 default = nil)
  if valid_593898 != nil:
    section.add "X-Amz-Security-Token", valid_593898
  var valid_593899 = header.getOrDefault("X-Amz-Algorithm")
  valid_593899 = validateParameter(valid_593899, JString, required = false,
                                 default = nil)
  if valid_593899 != nil:
    section.add "X-Amz-Algorithm", valid_593899
  var valid_593900 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593900 = validateParameter(valid_593900, JString, required = false,
                                 default = nil)
  if valid_593900 != nil:
    section.add "X-Amz-SignedHeaders", valid_593900
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593901: Call_GetDeleteHsmClientCertificate_593888; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified HSM client certificate.
  ## 
  let valid = call_593901.validator(path, query, header, formData, body)
  let scheme = call_593901.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593901.url(scheme.get, call_593901.host, call_593901.base,
                         call_593901.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593901, url, valid)

proc call*(call_593902: Call_GetDeleteHsmClientCertificate_593888;
          HsmClientCertificateIdentifier: string;
          Action: string = "DeleteHsmClientCertificate";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmClientCertificate
  ## Deletes the specified HSM client certificate.
  ##   HsmClientCertificateIdentifier: string (required)
  ##                                 : The identifier of the HSM client certificate to be deleted.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_593903 = newJObject()
  add(query_593903, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_593903, "Action", newJString(Action))
  add(query_593903, "Version", newJString(Version))
  result = call_593902.call(nil, query_593903, nil, nil, nil)

var getDeleteHsmClientCertificate* = Call_GetDeleteHsmClientCertificate_593888(
    name: "getDeleteHsmClientCertificate", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmClientCertificate",
    validator: validate_GetDeleteHsmClientCertificate_593889, base: "/",
    url: url_GetDeleteHsmClientCertificate_593890,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteHsmConfiguration_593937 = ref object of OpenApiRestCall_592348
proc url_PostDeleteHsmConfiguration_593939(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteHsmConfiguration_593938(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593940 = query.getOrDefault("Action")
  valid_593940 = validateParameter(valid_593940, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_593940 != nil:
    section.add "Action", valid_593940
  var valid_593941 = query.getOrDefault("Version")
  valid_593941 = validateParameter(valid_593941, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593941 != nil:
    section.add "Version", valid_593941
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593942 = header.getOrDefault("X-Amz-Signature")
  valid_593942 = validateParameter(valid_593942, JString, required = false,
                                 default = nil)
  if valid_593942 != nil:
    section.add "X-Amz-Signature", valid_593942
  var valid_593943 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593943 = validateParameter(valid_593943, JString, required = false,
                                 default = nil)
  if valid_593943 != nil:
    section.add "X-Amz-Content-Sha256", valid_593943
  var valid_593944 = header.getOrDefault("X-Amz-Date")
  valid_593944 = validateParameter(valid_593944, JString, required = false,
                                 default = nil)
  if valid_593944 != nil:
    section.add "X-Amz-Date", valid_593944
  var valid_593945 = header.getOrDefault("X-Amz-Credential")
  valid_593945 = validateParameter(valid_593945, JString, required = false,
                                 default = nil)
  if valid_593945 != nil:
    section.add "X-Amz-Credential", valid_593945
  var valid_593946 = header.getOrDefault("X-Amz-Security-Token")
  valid_593946 = validateParameter(valid_593946, JString, required = false,
                                 default = nil)
  if valid_593946 != nil:
    section.add "X-Amz-Security-Token", valid_593946
  var valid_593947 = header.getOrDefault("X-Amz-Algorithm")
  valid_593947 = validateParameter(valid_593947, JString, required = false,
                                 default = nil)
  if valid_593947 != nil:
    section.add "X-Amz-Algorithm", valid_593947
  var valid_593948 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593948 = validateParameter(valid_593948, JString, required = false,
                                 default = nil)
  if valid_593948 != nil:
    section.add "X-Amz-SignedHeaders", valid_593948
  result.add "header", section
  ## parameters in `formData` object:
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `HsmConfigurationIdentifier` field"
  var valid_593949 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_593949 = validateParameter(valid_593949, JString, required = true,
                                 default = nil)
  if valid_593949 != nil:
    section.add "HsmConfigurationIdentifier", valid_593949
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593950: Call_PostDeleteHsmConfiguration_593937; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_593950.validator(path, query, header, formData, body)
  let scheme = call_593950.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593950.url(scheme.get, call_593950.host, call_593950.base,
                         call_593950.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593950, url, valid)

proc call*(call_593951: Call_PostDeleteHsmConfiguration_593937;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  var query_593952 = newJObject()
  var formData_593953 = newJObject()
  add(query_593952, "Action", newJString(Action))
  add(query_593952, "Version", newJString(Version))
  add(formData_593953, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  result = call_593951.call(nil, query_593952, nil, formData_593953, nil)

var postDeleteHsmConfiguration* = Call_PostDeleteHsmConfiguration_593937(
    name: "postDeleteHsmConfiguration", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_PostDeleteHsmConfiguration_593938, base: "/",
    url: url_PostDeleteHsmConfiguration_593939,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteHsmConfiguration_593921 = ref object of OpenApiRestCall_592348
proc url_GetDeleteHsmConfiguration_593923(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteHsmConfiguration_593922(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   HsmConfigurationIdentifier: JString (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593924 = query.getOrDefault("Action")
  valid_593924 = validateParameter(valid_593924, JString, required = true,
                                 default = newJString("DeleteHsmConfiguration"))
  if valid_593924 != nil:
    section.add "Action", valid_593924
  var valid_593925 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_593925 = validateParameter(valid_593925, JString, required = true,
                                 default = nil)
  if valid_593925 != nil:
    section.add "HsmConfigurationIdentifier", valid_593925
  var valid_593926 = query.getOrDefault("Version")
  valid_593926 = validateParameter(valid_593926, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593926 != nil:
    section.add "Version", valid_593926
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593927 = header.getOrDefault("X-Amz-Signature")
  valid_593927 = validateParameter(valid_593927, JString, required = false,
                                 default = nil)
  if valid_593927 != nil:
    section.add "X-Amz-Signature", valid_593927
  var valid_593928 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593928 = validateParameter(valid_593928, JString, required = false,
                                 default = nil)
  if valid_593928 != nil:
    section.add "X-Amz-Content-Sha256", valid_593928
  var valid_593929 = header.getOrDefault("X-Amz-Date")
  valid_593929 = validateParameter(valid_593929, JString, required = false,
                                 default = nil)
  if valid_593929 != nil:
    section.add "X-Amz-Date", valid_593929
  var valid_593930 = header.getOrDefault("X-Amz-Credential")
  valid_593930 = validateParameter(valid_593930, JString, required = false,
                                 default = nil)
  if valid_593930 != nil:
    section.add "X-Amz-Credential", valid_593930
  var valid_593931 = header.getOrDefault("X-Amz-Security-Token")
  valid_593931 = validateParameter(valid_593931, JString, required = false,
                                 default = nil)
  if valid_593931 != nil:
    section.add "X-Amz-Security-Token", valid_593931
  var valid_593932 = header.getOrDefault("X-Amz-Algorithm")
  valid_593932 = validateParameter(valid_593932, JString, required = false,
                                 default = nil)
  if valid_593932 != nil:
    section.add "X-Amz-Algorithm", valid_593932
  var valid_593933 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593933 = validateParameter(valid_593933, JString, required = false,
                                 default = nil)
  if valid_593933 != nil:
    section.add "X-Amz-SignedHeaders", valid_593933
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593934: Call_GetDeleteHsmConfiguration_593921; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified Amazon Redshift HSM configuration.
  ## 
  let valid = call_593934.validator(path, query, header, formData, body)
  let scheme = call_593934.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593934.url(scheme.get, call_593934.host, call_593934.base,
                         call_593934.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593934, url, valid)

proc call*(call_593935: Call_GetDeleteHsmConfiguration_593921;
          HsmConfigurationIdentifier: string;
          Action: string = "DeleteHsmConfiguration"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteHsmConfiguration
  ## Deletes the specified Amazon Redshift HSM configuration.
  ##   Action: string (required)
  ##   HsmConfigurationIdentifier: string (required)
  ##                             : The identifier of the Amazon Redshift HSM configuration to be deleted.
  ##   Version: string (required)
  var query_593936 = newJObject()
  add(query_593936, "Action", newJString(Action))
  add(query_593936, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_593936, "Version", newJString(Version))
  result = call_593935.call(nil, query_593936, nil, nil, nil)

var getDeleteHsmConfiguration* = Call_GetDeleteHsmConfiguration_593921(
    name: "getDeleteHsmConfiguration", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteHsmConfiguration",
    validator: validate_GetDeleteHsmConfiguration_593922, base: "/",
    url: url_GetDeleteHsmConfiguration_593923,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotCopyGrant_593970 = ref object of OpenApiRestCall_592348
proc url_PostDeleteSnapshotCopyGrant_593972(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteSnapshotCopyGrant_593971(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593973 = query.getOrDefault("Action")
  valid_593973 = validateParameter(valid_593973, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_593973 != nil:
    section.add "Action", valid_593973
  var valid_593974 = query.getOrDefault("Version")
  valid_593974 = validateParameter(valid_593974, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593974 != nil:
    section.add "Version", valid_593974
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593975 = header.getOrDefault("X-Amz-Signature")
  valid_593975 = validateParameter(valid_593975, JString, required = false,
                                 default = nil)
  if valid_593975 != nil:
    section.add "X-Amz-Signature", valid_593975
  var valid_593976 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593976 = validateParameter(valid_593976, JString, required = false,
                                 default = nil)
  if valid_593976 != nil:
    section.add "X-Amz-Content-Sha256", valid_593976
  var valid_593977 = header.getOrDefault("X-Amz-Date")
  valid_593977 = validateParameter(valid_593977, JString, required = false,
                                 default = nil)
  if valid_593977 != nil:
    section.add "X-Amz-Date", valid_593977
  var valid_593978 = header.getOrDefault("X-Amz-Credential")
  valid_593978 = validateParameter(valid_593978, JString, required = false,
                                 default = nil)
  if valid_593978 != nil:
    section.add "X-Amz-Credential", valid_593978
  var valid_593979 = header.getOrDefault("X-Amz-Security-Token")
  valid_593979 = validateParameter(valid_593979, JString, required = false,
                                 default = nil)
  if valid_593979 != nil:
    section.add "X-Amz-Security-Token", valid_593979
  var valid_593980 = header.getOrDefault("X-Amz-Algorithm")
  valid_593980 = validateParameter(valid_593980, JString, required = false,
                                 default = nil)
  if valid_593980 != nil:
    section.add "X-Amz-Algorithm", valid_593980
  var valid_593981 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593981 = validateParameter(valid_593981, JString, required = false,
                                 default = nil)
  if valid_593981 != nil:
    section.add "X-Amz-SignedHeaders", valid_593981
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotCopyGrantName` field"
  var valid_593982 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_593982 = validateParameter(valid_593982, JString, required = true,
                                 default = nil)
  if valid_593982 != nil:
    section.add "SnapshotCopyGrantName", valid_593982
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593983: Call_PostDeleteSnapshotCopyGrant_593970; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_593983.validator(path, query, header, formData, body)
  let scheme = call_593983.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593983.url(scheme.get, call_593983.host, call_593983.base,
                         call_593983.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593983, url, valid)

proc call*(call_593984: Call_PostDeleteSnapshotCopyGrant_593970;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  ##   Version: string (required)
  var query_593985 = newJObject()
  var formData_593986 = newJObject()
  add(query_593985, "Action", newJString(Action))
  add(formData_593986, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_593985, "Version", newJString(Version))
  result = call_593984.call(nil, query_593985, nil, formData_593986, nil)

var postDeleteSnapshotCopyGrant* = Call_PostDeleteSnapshotCopyGrant_593970(
    name: "postDeleteSnapshotCopyGrant", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_PostDeleteSnapshotCopyGrant_593971, base: "/",
    url: url_PostDeleteSnapshotCopyGrant_593972,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotCopyGrant_593954 = ref object of OpenApiRestCall_592348
proc url_GetDeleteSnapshotCopyGrant_593956(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteSnapshotCopyGrant_593955(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes the specified snapshot copy grant.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString (required)
  ##                        : The name of the snapshot copy grant to delete.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_593957 = query.getOrDefault("Action")
  valid_593957 = validateParameter(valid_593957, JString, required = true, default = newJString(
      "DeleteSnapshotCopyGrant"))
  if valid_593957 != nil:
    section.add "Action", valid_593957
  var valid_593958 = query.getOrDefault("Version")
  valid_593958 = validateParameter(valid_593958, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593958 != nil:
    section.add "Version", valid_593958
  var valid_593959 = query.getOrDefault("SnapshotCopyGrantName")
  valid_593959 = validateParameter(valid_593959, JString, required = true,
                                 default = nil)
  if valid_593959 != nil:
    section.add "SnapshotCopyGrantName", valid_593959
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593960 = header.getOrDefault("X-Amz-Signature")
  valid_593960 = validateParameter(valid_593960, JString, required = false,
                                 default = nil)
  if valid_593960 != nil:
    section.add "X-Amz-Signature", valid_593960
  var valid_593961 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593961 = validateParameter(valid_593961, JString, required = false,
                                 default = nil)
  if valid_593961 != nil:
    section.add "X-Amz-Content-Sha256", valid_593961
  var valid_593962 = header.getOrDefault("X-Amz-Date")
  valid_593962 = validateParameter(valid_593962, JString, required = false,
                                 default = nil)
  if valid_593962 != nil:
    section.add "X-Amz-Date", valid_593962
  var valid_593963 = header.getOrDefault("X-Amz-Credential")
  valid_593963 = validateParameter(valid_593963, JString, required = false,
                                 default = nil)
  if valid_593963 != nil:
    section.add "X-Amz-Credential", valid_593963
  var valid_593964 = header.getOrDefault("X-Amz-Security-Token")
  valid_593964 = validateParameter(valid_593964, JString, required = false,
                                 default = nil)
  if valid_593964 != nil:
    section.add "X-Amz-Security-Token", valid_593964
  var valid_593965 = header.getOrDefault("X-Amz-Algorithm")
  valid_593965 = validateParameter(valid_593965, JString, required = false,
                                 default = nil)
  if valid_593965 != nil:
    section.add "X-Amz-Algorithm", valid_593965
  var valid_593966 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593966 = validateParameter(valid_593966, JString, required = false,
                                 default = nil)
  if valid_593966 != nil:
    section.add "X-Amz-SignedHeaders", valid_593966
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_593967: Call_GetDeleteSnapshotCopyGrant_593954; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes the specified snapshot copy grant.
  ## 
  let valid = call_593967.validator(path, query, header, formData, body)
  let scheme = call_593967.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_593967.url(scheme.get, call_593967.host, call_593967.base,
                         call_593967.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_593967, url, valid)

proc call*(call_593968: Call_GetDeleteSnapshotCopyGrant_593954;
          SnapshotCopyGrantName: string;
          Action: string = "DeleteSnapshotCopyGrant"; Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotCopyGrant
  ## Deletes the specified snapshot copy grant.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string (required)
  ##                        : The name of the snapshot copy grant to delete.
  var query_593969 = newJObject()
  add(query_593969, "Action", newJString(Action))
  add(query_593969, "Version", newJString(Version))
  add(query_593969, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_593968.call(nil, query_593969, nil, nil, nil)

var getDeleteSnapshotCopyGrant* = Call_GetDeleteSnapshotCopyGrant_593954(
    name: "getDeleteSnapshotCopyGrant", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotCopyGrant",
    validator: validate_GetDeleteSnapshotCopyGrant_593955, base: "/",
    url: url_GetDeleteSnapshotCopyGrant_593956,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteSnapshotSchedule_594003 = ref object of OpenApiRestCall_592348
proc url_PostDeleteSnapshotSchedule_594005(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteSnapshotSchedule_594004(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594006 = query.getOrDefault("Action")
  valid_594006 = validateParameter(valid_594006, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_594006 != nil:
    section.add "Action", valid_594006
  var valid_594007 = query.getOrDefault("Version")
  valid_594007 = validateParameter(valid_594007, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594007 != nil:
    section.add "Version", valid_594007
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594008 = header.getOrDefault("X-Amz-Signature")
  valid_594008 = validateParameter(valid_594008, JString, required = false,
                                 default = nil)
  if valid_594008 != nil:
    section.add "X-Amz-Signature", valid_594008
  var valid_594009 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594009 = validateParameter(valid_594009, JString, required = false,
                                 default = nil)
  if valid_594009 != nil:
    section.add "X-Amz-Content-Sha256", valid_594009
  var valid_594010 = header.getOrDefault("X-Amz-Date")
  valid_594010 = validateParameter(valid_594010, JString, required = false,
                                 default = nil)
  if valid_594010 != nil:
    section.add "X-Amz-Date", valid_594010
  var valid_594011 = header.getOrDefault("X-Amz-Credential")
  valid_594011 = validateParameter(valid_594011, JString, required = false,
                                 default = nil)
  if valid_594011 != nil:
    section.add "X-Amz-Credential", valid_594011
  var valid_594012 = header.getOrDefault("X-Amz-Security-Token")
  valid_594012 = validateParameter(valid_594012, JString, required = false,
                                 default = nil)
  if valid_594012 != nil:
    section.add "X-Amz-Security-Token", valid_594012
  var valid_594013 = header.getOrDefault("X-Amz-Algorithm")
  valid_594013 = validateParameter(valid_594013, JString, required = false,
                                 default = nil)
  if valid_594013 != nil:
    section.add "X-Amz-Algorithm", valid_594013
  var valid_594014 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594014 = validateParameter(valid_594014, JString, required = false,
                                 default = nil)
  if valid_594014 != nil:
    section.add "X-Amz-SignedHeaders", valid_594014
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleIdentifier` field"
  var valid_594015 = formData.getOrDefault("ScheduleIdentifier")
  valid_594015 = validateParameter(valid_594015, JString, required = true,
                                 default = nil)
  if valid_594015 != nil:
    section.add "ScheduleIdentifier", valid_594015
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594016: Call_PostDeleteSnapshotSchedule_594003; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_594016.validator(path, query, header, formData, body)
  let scheme = call_594016.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594016.url(scheme.get, call_594016.host, call_594016.base,
                         call_594016.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594016, url, valid)

proc call*(call_594017: Call_PostDeleteSnapshotSchedule_594003;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Version: string (required)
  var query_594018 = newJObject()
  var formData_594019 = newJObject()
  add(query_594018, "Action", newJString(Action))
  add(formData_594019, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_594018, "Version", newJString(Version))
  result = call_594017.call(nil, query_594018, nil, formData_594019, nil)

var postDeleteSnapshotSchedule* = Call_PostDeleteSnapshotSchedule_594003(
    name: "postDeleteSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_PostDeleteSnapshotSchedule_594004, base: "/",
    url: url_PostDeleteSnapshotSchedule_594005,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteSnapshotSchedule_593987 = ref object of OpenApiRestCall_592348
proc url_GetDeleteSnapshotSchedule_593989(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteSnapshotSchedule_593988(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a snapshot schedule.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleIdentifier` field"
  var valid_593990 = query.getOrDefault("ScheduleIdentifier")
  valid_593990 = validateParameter(valid_593990, JString, required = true,
                                 default = nil)
  if valid_593990 != nil:
    section.add "ScheduleIdentifier", valid_593990
  var valid_593991 = query.getOrDefault("Action")
  valid_593991 = validateParameter(valid_593991, JString, required = true,
                                 default = newJString("DeleteSnapshotSchedule"))
  if valid_593991 != nil:
    section.add "Action", valid_593991
  var valid_593992 = query.getOrDefault("Version")
  valid_593992 = validateParameter(valid_593992, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_593992 != nil:
    section.add "Version", valid_593992
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_593993 = header.getOrDefault("X-Amz-Signature")
  valid_593993 = validateParameter(valid_593993, JString, required = false,
                                 default = nil)
  if valid_593993 != nil:
    section.add "X-Amz-Signature", valid_593993
  var valid_593994 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_593994 = validateParameter(valid_593994, JString, required = false,
                                 default = nil)
  if valid_593994 != nil:
    section.add "X-Amz-Content-Sha256", valid_593994
  var valid_593995 = header.getOrDefault("X-Amz-Date")
  valid_593995 = validateParameter(valid_593995, JString, required = false,
                                 default = nil)
  if valid_593995 != nil:
    section.add "X-Amz-Date", valid_593995
  var valid_593996 = header.getOrDefault("X-Amz-Credential")
  valid_593996 = validateParameter(valid_593996, JString, required = false,
                                 default = nil)
  if valid_593996 != nil:
    section.add "X-Amz-Credential", valid_593996
  var valid_593997 = header.getOrDefault("X-Amz-Security-Token")
  valid_593997 = validateParameter(valid_593997, JString, required = false,
                                 default = nil)
  if valid_593997 != nil:
    section.add "X-Amz-Security-Token", valid_593997
  var valid_593998 = header.getOrDefault("X-Amz-Algorithm")
  valid_593998 = validateParameter(valid_593998, JString, required = false,
                                 default = nil)
  if valid_593998 != nil:
    section.add "X-Amz-Algorithm", valid_593998
  var valid_593999 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_593999 = validateParameter(valid_593999, JString, required = false,
                                 default = nil)
  if valid_593999 != nil:
    section.add "X-Amz-SignedHeaders", valid_593999
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594000: Call_GetDeleteSnapshotSchedule_593987; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a snapshot schedule.
  ## 
  let valid = call_594000.validator(path, query, header, formData, body)
  let scheme = call_594000.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594000.url(scheme.get, call_594000.host, call_594000.base,
                         call_594000.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594000, url, valid)

proc call*(call_594001: Call_GetDeleteSnapshotSchedule_593987;
          ScheduleIdentifier: string; Action: string = "DeleteSnapshotSchedule";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteSnapshotSchedule
  ## Deletes a snapshot schedule.
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique identifier of the snapshot schedule to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594002 = newJObject()
  add(query_594002, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_594002, "Action", newJString(Action))
  add(query_594002, "Version", newJString(Version))
  result = call_594001.call(nil, query_594002, nil, nil, nil)

var getDeleteSnapshotSchedule* = Call_GetDeleteSnapshotSchedule_593987(
    name: "getDeleteSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DeleteSnapshotSchedule",
    validator: validate_GetDeleteSnapshotSchedule_593988, base: "/",
    url: url_GetDeleteSnapshotSchedule_593989,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDeleteTags_594037 = ref object of OpenApiRestCall_592348
proc url_PostDeleteTags_594039(protocol: Scheme; host: string; base: string;
                              route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDeleteTags_594038(path: JsonNode; query: JsonNode;
                                   header: JsonNode; formData: JsonNode;
                                   body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594040 = query.getOrDefault("Action")
  valid_594040 = validateParameter(valid_594040, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_594040 != nil:
    section.add "Action", valid_594040
  var valid_594041 = query.getOrDefault("Version")
  valid_594041 = validateParameter(valid_594041, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594041 != nil:
    section.add "Version", valid_594041
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594042 = header.getOrDefault("X-Amz-Signature")
  valid_594042 = validateParameter(valid_594042, JString, required = false,
                                 default = nil)
  if valid_594042 != nil:
    section.add "X-Amz-Signature", valid_594042
  var valid_594043 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594043 = validateParameter(valid_594043, JString, required = false,
                                 default = nil)
  if valid_594043 != nil:
    section.add "X-Amz-Content-Sha256", valid_594043
  var valid_594044 = header.getOrDefault("X-Amz-Date")
  valid_594044 = validateParameter(valid_594044, JString, required = false,
                                 default = nil)
  if valid_594044 != nil:
    section.add "X-Amz-Date", valid_594044
  var valid_594045 = header.getOrDefault("X-Amz-Credential")
  valid_594045 = validateParameter(valid_594045, JString, required = false,
                                 default = nil)
  if valid_594045 != nil:
    section.add "X-Amz-Credential", valid_594045
  var valid_594046 = header.getOrDefault("X-Amz-Security-Token")
  valid_594046 = validateParameter(valid_594046, JString, required = false,
                                 default = nil)
  if valid_594046 != nil:
    section.add "X-Amz-Security-Token", valid_594046
  var valid_594047 = header.getOrDefault("X-Amz-Algorithm")
  valid_594047 = validateParameter(valid_594047, JString, required = false,
                                 default = nil)
  if valid_594047 != nil:
    section.add "X-Amz-Algorithm", valid_594047
  var valid_594048 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594048 = validateParameter(valid_594048, JString, required = false,
                                 default = nil)
  if valid_594048 != nil:
    section.add "X-Amz-SignedHeaders", valid_594048
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `TagKeys` field"
  var valid_594049 = formData.getOrDefault("TagKeys")
  valid_594049 = validateParameter(valid_594049, JArray, required = true, default = nil)
  if valid_594049 != nil:
    section.add "TagKeys", valid_594049
  var valid_594050 = formData.getOrDefault("ResourceName")
  valid_594050 = validateParameter(valid_594050, JString, required = true,
                                 default = nil)
  if valid_594050 != nil:
    section.add "ResourceName", valid_594050
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594051: Call_PostDeleteTags_594037; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_594051.validator(path, query, header, formData, body)
  let scheme = call_594051.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594051.url(scheme.get, call_594051.host, call_594051.base,
                         call_594051.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594051, url, valid)

proc call*(call_594052: Call_PostDeleteTags_594037; TagKeys: JsonNode;
          ResourceName: string; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## postDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  var query_594053 = newJObject()
  var formData_594054 = newJObject()
  if TagKeys != nil:
    formData_594054.add "TagKeys", TagKeys
  add(query_594053, "Action", newJString(Action))
  add(query_594053, "Version", newJString(Version))
  add(formData_594054, "ResourceName", newJString(ResourceName))
  result = call_594052.call(nil, query_594053, nil, formData_594054, nil)

var postDeleteTags* = Call_PostDeleteTags_594037(name: "postDeleteTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_PostDeleteTags_594038,
    base: "/", url: url_PostDeleteTags_594039, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDeleteTags_594020 = ref object of OpenApiRestCall_592348
proc url_GetDeleteTags_594022(protocol: Scheme; host: string; base: string;
                             route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDeleteTags_594021(path: JsonNode; query: JsonNode; header: JsonNode;
                                  formData: JsonNode; body: JsonNode): JsonNode =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ResourceName: JString (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `ResourceName` field"
  var valid_594023 = query.getOrDefault("ResourceName")
  valid_594023 = validateParameter(valid_594023, JString, required = true,
                                 default = nil)
  if valid_594023 != nil:
    section.add "ResourceName", valid_594023
  var valid_594024 = query.getOrDefault("TagKeys")
  valid_594024 = validateParameter(valid_594024, JArray, required = true, default = nil)
  if valid_594024 != nil:
    section.add "TagKeys", valid_594024
  var valid_594025 = query.getOrDefault("Action")
  valid_594025 = validateParameter(valid_594025, JString, required = true,
                                 default = newJString("DeleteTags"))
  if valid_594025 != nil:
    section.add "Action", valid_594025
  var valid_594026 = query.getOrDefault("Version")
  valid_594026 = validateParameter(valid_594026, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594026 != nil:
    section.add "Version", valid_594026
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594027 = header.getOrDefault("X-Amz-Signature")
  valid_594027 = validateParameter(valid_594027, JString, required = false,
                                 default = nil)
  if valid_594027 != nil:
    section.add "X-Amz-Signature", valid_594027
  var valid_594028 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594028 = validateParameter(valid_594028, JString, required = false,
                                 default = nil)
  if valid_594028 != nil:
    section.add "X-Amz-Content-Sha256", valid_594028
  var valid_594029 = header.getOrDefault("X-Amz-Date")
  valid_594029 = validateParameter(valid_594029, JString, required = false,
                                 default = nil)
  if valid_594029 != nil:
    section.add "X-Amz-Date", valid_594029
  var valid_594030 = header.getOrDefault("X-Amz-Credential")
  valid_594030 = validateParameter(valid_594030, JString, required = false,
                                 default = nil)
  if valid_594030 != nil:
    section.add "X-Amz-Credential", valid_594030
  var valid_594031 = header.getOrDefault("X-Amz-Security-Token")
  valid_594031 = validateParameter(valid_594031, JString, required = false,
                                 default = nil)
  if valid_594031 != nil:
    section.add "X-Amz-Security-Token", valid_594031
  var valid_594032 = header.getOrDefault("X-Amz-Algorithm")
  valid_594032 = validateParameter(valid_594032, JString, required = false,
                                 default = nil)
  if valid_594032 != nil:
    section.add "X-Amz-Algorithm", valid_594032
  var valid_594033 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594033 = validateParameter(valid_594033, JString, required = false,
                                 default = nil)
  if valid_594033 != nil:
    section.add "X-Amz-SignedHeaders", valid_594033
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594034: Call_GetDeleteTags_594020; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ## 
  let valid = call_594034.validator(path, query, header, formData, body)
  let scheme = call_594034.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594034.url(scheme.get, call_594034.host, call_594034.base,
                         call_594034.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594034, url, valid)

proc call*(call_594035: Call_GetDeleteTags_594020; ResourceName: string;
          TagKeys: JsonNode; Action: string = "DeleteTags";
          Version: string = "2012-12-01"): Recallable =
  ## getDeleteTags
  ## Deletes a tag or tags from a resource. You must provide the ARN of the resource from which you want to delete the tag or tags.
  ##   ResourceName: string (required)
  ##               : The Amazon Resource Name (ARN) from which you want to remove the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   TagKeys: JArray (required)
  ##          : The tag key that you want to delete.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594036 = newJObject()
  add(query_594036, "ResourceName", newJString(ResourceName))
  if TagKeys != nil:
    query_594036.add "TagKeys", TagKeys
  add(query_594036, "Action", newJString(Action))
  add(query_594036, "Version", newJString(Version))
  result = call_594035.call(nil, query_594036, nil, nil, nil)

var getDeleteTags* = Call_GetDeleteTags_594020(name: "getDeleteTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DeleteTags", validator: validate_GetDeleteTags_594021,
    base: "/", url: url_GetDeleteTags_594022, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeAccountAttributes_594071 = ref object of OpenApiRestCall_592348
proc url_PostDescribeAccountAttributes_594073(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeAccountAttributes_594072(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594074 = query.getOrDefault("Action")
  valid_594074 = validateParameter(valid_594074, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_594074 != nil:
    section.add "Action", valid_594074
  var valid_594075 = query.getOrDefault("Version")
  valid_594075 = validateParameter(valid_594075, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594075 != nil:
    section.add "Version", valid_594075
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594076 = header.getOrDefault("X-Amz-Signature")
  valid_594076 = validateParameter(valid_594076, JString, required = false,
                                 default = nil)
  if valid_594076 != nil:
    section.add "X-Amz-Signature", valid_594076
  var valid_594077 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594077 = validateParameter(valid_594077, JString, required = false,
                                 default = nil)
  if valid_594077 != nil:
    section.add "X-Amz-Content-Sha256", valid_594077
  var valid_594078 = header.getOrDefault("X-Amz-Date")
  valid_594078 = validateParameter(valid_594078, JString, required = false,
                                 default = nil)
  if valid_594078 != nil:
    section.add "X-Amz-Date", valid_594078
  var valid_594079 = header.getOrDefault("X-Amz-Credential")
  valid_594079 = validateParameter(valid_594079, JString, required = false,
                                 default = nil)
  if valid_594079 != nil:
    section.add "X-Amz-Credential", valid_594079
  var valid_594080 = header.getOrDefault("X-Amz-Security-Token")
  valid_594080 = validateParameter(valid_594080, JString, required = false,
                                 default = nil)
  if valid_594080 != nil:
    section.add "X-Amz-Security-Token", valid_594080
  var valid_594081 = header.getOrDefault("X-Amz-Algorithm")
  valid_594081 = validateParameter(valid_594081, JString, required = false,
                                 default = nil)
  if valid_594081 != nil:
    section.add "X-Amz-Algorithm", valid_594081
  var valid_594082 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594082 = validateParameter(valid_594082, JString, required = false,
                                 default = nil)
  if valid_594082 != nil:
    section.add "X-Amz-SignedHeaders", valid_594082
  result.add "header", section
  ## parameters in `formData` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  section = newJObject()
  var valid_594083 = formData.getOrDefault("AttributeNames")
  valid_594083 = validateParameter(valid_594083, JArray, required = false,
                                 default = nil)
  if valid_594083 != nil:
    section.add "AttributeNames", valid_594083
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594084: Call_PostDescribeAccountAttributes_594071; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_594084.validator(path, query, header, formData, body)
  let scheme = call_594084.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594084.url(scheme.get, call_594084.host, call_594084.base,
                         call_594084.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594084, url, valid)

proc call*(call_594085: Call_PostDescribeAccountAttributes_594071;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594086 = newJObject()
  var formData_594087 = newJObject()
  if AttributeNames != nil:
    formData_594087.add "AttributeNames", AttributeNames
  add(query_594086, "Action", newJString(Action))
  add(query_594086, "Version", newJString(Version))
  result = call_594085.call(nil, query_594086, nil, formData_594087, nil)

var postDescribeAccountAttributes* = Call_PostDescribeAccountAttributes_594071(
    name: "postDescribeAccountAttributes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_PostDescribeAccountAttributes_594072, base: "/",
    url: url_PostDescribeAccountAttributes_594073,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeAccountAttributes_594055 = ref object of OpenApiRestCall_592348
proc url_GetDescribeAccountAttributes_594057(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeAccountAttributes_594056(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of attributes attached to an account
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_594058 = query.getOrDefault("AttributeNames")
  valid_594058 = validateParameter(valid_594058, JArray, required = false,
                                 default = nil)
  if valid_594058 != nil:
    section.add "AttributeNames", valid_594058
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594059 = query.getOrDefault("Action")
  valid_594059 = validateParameter(valid_594059, JString, required = true, default = newJString(
      "DescribeAccountAttributes"))
  if valid_594059 != nil:
    section.add "Action", valid_594059
  var valid_594060 = query.getOrDefault("Version")
  valid_594060 = validateParameter(valid_594060, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594060 != nil:
    section.add "Version", valid_594060
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594061 = header.getOrDefault("X-Amz-Signature")
  valid_594061 = validateParameter(valid_594061, JString, required = false,
                                 default = nil)
  if valid_594061 != nil:
    section.add "X-Amz-Signature", valid_594061
  var valid_594062 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594062 = validateParameter(valid_594062, JString, required = false,
                                 default = nil)
  if valid_594062 != nil:
    section.add "X-Amz-Content-Sha256", valid_594062
  var valid_594063 = header.getOrDefault("X-Amz-Date")
  valid_594063 = validateParameter(valid_594063, JString, required = false,
                                 default = nil)
  if valid_594063 != nil:
    section.add "X-Amz-Date", valid_594063
  var valid_594064 = header.getOrDefault("X-Amz-Credential")
  valid_594064 = validateParameter(valid_594064, JString, required = false,
                                 default = nil)
  if valid_594064 != nil:
    section.add "X-Amz-Credential", valid_594064
  var valid_594065 = header.getOrDefault("X-Amz-Security-Token")
  valid_594065 = validateParameter(valid_594065, JString, required = false,
                                 default = nil)
  if valid_594065 != nil:
    section.add "X-Amz-Security-Token", valid_594065
  var valid_594066 = header.getOrDefault("X-Amz-Algorithm")
  valid_594066 = validateParameter(valid_594066, JString, required = false,
                                 default = nil)
  if valid_594066 != nil:
    section.add "X-Amz-Algorithm", valid_594066
  var valid_594067 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594067 = validateParameter(valid_594067, JString, required = false,
                                 default = nil)
  if valid_594067 != nil:
    section.add "X-Amz-SignedHeaders", valid_594067
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594068: Call_GetDescribeAccountAttributes_594055; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of attributes attached to an account
  ## 
  let valid = call_594068.validator(path, query, header, formData, body)
  let scheme = call_594068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594068.url(scheme.get, call_594068.host, call_594068.base,
                         call_594068.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594068, url, valid)

proc call*(call_594069: Call_GetDescribeAccountAttributes_594055;
          AttributeNames: JsonNode = nil;
          Action: string = "DescribeAccountAttributes";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeAccountAttributes
  ## Returns a list of attributes attached to an account
  ##   AttributeNames: JArray
  ##                 : A list of attribute names.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594070 = newJObject()
  if AttributeNames != nil:
    query_594070.add "AttributeNames", AttributeNames
  add(query_594070, "Action", newJString(Action))
  add(query_594070, "Version", newJString(Version))
  result = call_594069.call(nil, query_594070, nil, nil, nil)

var getDescribeAccountAttributes* = Call_GetDescribeAccountAttributes_594055(
    name: "getDescribeAccountAttributes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeAccountAttributes",
    validator: validate_GetDescribeAccountAttributes_594056, base: "/",
    url: url_GetDescribeAccountAttributes_594057,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterDbRevisions_594106 = ref object of OpenApiRestCall_592348
proc url_PostDescribeClusterDbRevisions_594108(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterDbRevisions_594107(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594109 = query.getOrDefault("Action")
  valid_594109 = validateParameter(valid_594109, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_594109 != nil:
    section.add "Action", valid_594109
  var valid_594110 = query.getOrDefault("Version")
  valid_594110 = validateParameter(valid_594110, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594110 != nil:
    section.add "Version", valid_594110
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594111 = header.getOrDefault("X-Amz-Signature")
  valid_594111 = validateParameter(valid_594111, JString, required = false,
                                 default = nil)
  if valid_594111 != nil:
    section.add "X-Amz-Signature", valid_594111
  var valid_594112 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594112 = validateParameter(valid_594112, JString, required = false,
                                 default = nil)
  if valid_594112 != nil:
    section.add "X-Amz-Content-Sha256", valid_594112
  var valid_594113 = header.getOrDefault("X-Amz-Date")
  valid_594113 = validateParameter(valid_594113, JString, required = false,
                                 default = nil)
  if valid_594113 != nil:
    section.add "X-Amz-Date", valid_594113
  var valid_594114 = header.getOrDefault("X-Amz-Credential")
  valid_594114 = validateParameter(valid_594114, JString, required = false,
                                 default = nil)
  if valid_594114 != nil:
    section.add "X-Amz-Credential", valid_594114
  var valid_594115 = header.getOrDefault("X-Amz-Security-Token")
  valid_594115 = validateParameter(valid_594115, JString, required = false,
                                 default = nil)
  if valid_594115 != nil:
    section.add "X-Amz-Security-Token", valid_594115
  var valid_594116 = header.getOrDefault("X-Amz-Algorithm")
  valid_594116 = validateParameter(valid_594116, JString, required = false,
                                 default = nil)
  if valid_594116 != nil:
    section.add "X-Amz-Algorithm", valid_594116
  var valid_594117 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594117 = validateParameter(valid_594117, JString, required = false,
                                 default = nil)
  if valid_594117 != nil:
    section.add "X-Amz-SignedHeaders", valid_594117
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  section = newJObject()
  var valid_594118 = formData.getOrDefault("ClusterIdentifier")
  valid_594118 = validateParameter(valid_594118, JString, required = false,
                                 default = nil)
  if valid_594118 != nil:
    section.add "ClusterIdentifier", valid_594118
  var valid_594119 = formData.getOrDefault("MaxRecords")
  valid_594119 = validateParameter(valid_594119, JInt, required = false, default = nil)
  if valid_594119 != nil:
    section.add "MaxRecords", valid_594119
  var valid_594120 = formData.getOrDefault("Marker")
  valid_594120 = validateParameter(valid_594120, JString, required = false,
                                 default = nil)
  if valid_594120 != nil:
    section.add "Marker", valid_594120
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594121: Call_PostDescribeClusterDbRevisions_594106; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_594121.validator(path, query, header, formData, body)
  let scheme = call_594121.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594121.url(scheme.get, call_594121.host, call_594121.base,
                         call_594121.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594121, url, valid)

proc call*(call_594122: Call_PostDescribeClusterDbRevisions_594106;
          ClusterIdentifier: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeClusterDbRevisions";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594123 = newJObject()
  var formData_594124 = newJObject()
  add(formData_594124, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_594124, "MaxRecords", newJInt(MaxRecords))
  add(formData_594124, "Marker", newJString(Marker))
  add(query_594123, "Action", newJString(Action))
  add(query_594123, "Version", newJString(Version))
  result = call_594122.call(nil, query_594123, nil, formData_594124, nil)

var postDescribeClusterDbRevisions* = Call_PostDescribeClusterDbRevisions_594106(
    name: "postDescribeClusterDbRevisions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_PostDescribeClusterDbRevisions_594107, base: "/",
    url: url_PostDescribeClusterDbRevisions_594108,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterDbRevisions_594088 = ref object of OpenApiRestCall_592348
proc url_GetDescribeClusterDbRevisions_594090(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterDbRevisions_594089(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_594091 = query.getOrDefault("Marker")
  valid_594091 = validateParameter(valid_594091, JString, required = false,
                                 default = nil)
  if valid_594091 != nil:
    section.add "Marker", valid_594091
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594092 = query.getOrDefault("Action")
  valid_594092 = validateParameter(valid_594092, JString, required = true, default = newJString(
      "DescribeClusterDbRevisions"))
  if valid_594092 != nil:
    section.add "Action", valid_594092
  var valid_594093 = query.getOrDefault("ClusterIdentifier")
  valid_594093 = validateParameter(valid_594093, JString, required = false,
                                 default = nil)
  if valid_594093 != nil:
    section.add "ClusterIdentifier", valid_594093
  var valid_594094 = query.getOrDefault("Version")
  valid_594094 = validateParameter(valid_594094, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594094 != nil:
    section.add "Version", valid_594094
  var valid_594095 = query.getOrDefault("MaxRecords")
  valid_594095 = validateParameter(valid_594095, JInt, required = false, default = nil)
  if valid_594095 != nil:
    section.add "MaxRecords", valid_594095
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594096 = header.getOrDefault("X-Amz-Signature")
  valid_594096 = validateParameter(valid_594096, JString, required = false,
                                 default = nil)
  if valid_594096 != nil:
    section.add "X-Amz-Signature", valid_594096
  var valid_594097 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594097 = validateParameter(valid_594097, JString, required = false,
                                 default = nil)
  if valid_594097 != nil:
    section.add "X-Amz-Content-Sha256", valid_594097
  var valid_594098 = header.getOrDefault("X-Amz-Date")
  valid_594098 = validateParameter(valid_594098, JString, required = false,
                                 default = nil)
  if valid_594098 != nil:
    section.add "X-Amz-Date", valid_594098
  var valid_594099 = header.getOrDefault("X-Amz-Credential")
  valid_594099 = validateParameter(valid_594099, JString, required = false,
                                 default = nil)
  if valid_594099 != nil:
    section.add "X-Amz-Credential", valid_594099
  var valid_594100 = header.getOrDefault("X-Amz-Security-Token")
  valid_594100 = validateParameter(valid_594100, JString, required = false,
                                 default = nil)
  if valid_594100 != nil:
    section.add "X-Amz-Security-Token", valid_594100
  var valid_594101 = header.getOrDefault("X-Amz-Algorithm")
  valid_594101 = validateParameter(valid_594101, JString, required = false,
                                 default = nil)
  if valid_594101 != nil:
    section.add "X-Amz-Algorithm", valid_594101
  var valid_594102 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594102 = validateParameter(valid_594102, JString, required = false,
                                 default = nil)
  if valid_594102 != nil:
    section.add "X-Amz-SignedHeaders", valid_594102
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594103: Call_GetDescribeClusterDbRevisions_594088; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ## 
  let valid = call_594103.validator(path, query, header, formData, body)
  let scheme = call_594103.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594103.url(scheme.get, call_594103.host, call_594103.base,
                         call_594103.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594103, url, valid)

proc call*(call_594104: Call_GetDescribeClusterDbRevisions_594088;
          Marker: string = ""; Action: string = "DescribeClusterDbRevisions";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0): Recallable =
  ## getDescribeClusterDbRevisions
  ## Returns an array of <code>ClusterDbRevision</code> objects.
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point for returning a set of response records. When the results of a <code>DescribeClusterDbRevisions</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <code>ClusterIdentifier</code> parameter, or the <code>marker</code> parameter, but not both.</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : A unique identifier for a cluster whose <code>ClusterDbRevisions</code> you are requesting. This parameter is case sensitive. All clusters defined for an account are returned by default.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified MaxRecords value, a value is returned in the <code>marker</code> field of the response. You can retrieve the next set of response records by providing the returned <code>marker</code> value in the <code>marker</code> parameter and retrying the request. </p> <p>Default: 100</p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_594105 = newJObject()
  add(query_594105, "Marker", newJString(Marker))
  add(query_594105, "Action", newJString(Action))
  add(query_594105, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594105, "Version", newJString(Version))
  add(query_594105, "MaxRecords", newJInt(MaxRecords))
  result = call_594104.call(nil, query_594105, nil, nil, nil)

var getDescribeClusterDbRevisions* = Call_GetDescribeClusterDbRevisions_594088(
    name: "getDescribeClusterDbRevisions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterDbRevisions",
    validator: validate_GetDescribeClusterDbRevisions_594089, base: "/",
    url: url_GetDescribeClusterDbRevisions_594090,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameterGroups_594145 = ref object of OpenApiRestCall_592348
proc url_PostDescribeClusterParameterGroups_594147(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterParameterGroups_594146(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594148 = query.getOrDefault("Action")
  valid_594148 = validateParameter(valid_594148, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_594148 != nil:
    section.add "Action", valid_594148
  var valid_594149 = query.getOrDefault("Version")
  valid_594149 = validateParameter(valid_594149, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594149 != nil:
    section.add "Version", valid_594149
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594150 = header.getOrDefault("X-Amz-Signature")
  valid_594150 = validateParameter(valid_594150, JString, required = false,
                                 default = nil)
  if valid_594150 != nil:
    section.add "X-Amz-Signature", valid_594150
  var valid_594151 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594151 = validateParameter(valid_594151, JString, required = false,
                                 default = nil)
  if valid_594151 != nil:
    section.add "X-Amz-Content-Sha256", valid_594151
  var valid_594152 = header.getOrDefault("X-Amz-Date")
  valid_594152 = validateParameter(valid_594152, JString, required = false,
                                 default = nil)
  if valid_594152 != nil:
    section.add "X-Amz-Date", valid_594152
  var valid_594153 = header.getOrDefault("X-Amz-Credential")
  valid_594153 = validateParameter(valid_594153, JString, required = false,
                                 default = nil)
  if valid_594153 != nil:
    section.add "X-Amz-Credential", valid_594153
  var valid_594154 = header.getOrDefault("X-Amz-Security-Token")
  valid_594154 = validateParameter(valid_594154, JString, required = false,
                                 default = nil)
  if valid_594154 != nil:
    section.add "X-Amz-Security-Token", valid_594154
  var valid_594155 = header.getOrDefault("X-Amz-Algorithm")
  valid_594155 = validateParameter(valid_594155, JString, required = false,
                                 default = nil)
  if valid_594155 != nil:
    section.add "X-Amz-Algorithm", valid_594155
  var valid_594156 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594156 = validateParameter(valid_594156, JString, required = false,
                                 default = nil)
  if valid_594156 != nil:
    section.add "X-Amz-SignedHeaders", valid_594156
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  section = newJObject()
  var valid_594157 = formData.getOrDefault("TagKeys")
  valid_594157 = validateParameter(valid_594157, JArray, required = false,
                                 default = nil)
  if valid_594157 != nil:
    section.add "TagKeys", valid_594157
  var valid_594158 = formData.getOrDefault("MaxRecords")
  valid_594158 = validateParameter(valid_594158, JInt, required = false, default = nil)
  if valid_594158 != nil:
    section.add "MaxRecords", valid_594158
  var valid_594159 = formData.getOrDefault("Marker")
  valid_594159 = validateParameter(valid_594159, JString, required = false,
                                 default = nil)
  if valid_594159 != nil:
    section.add "Marker", valid_594159
  var valid_594160 = formData.getOrDefault("TagValues")
  valid_594160 = validateParameter(valid_594160, JArray, required = false,
                                 default = nil)
  if valid_594160 != nil:
    section.add "TagValues", valid_594160
  var valid_594161 = formData.getOrDefault("ParameterGroupName")
  valid_594161 = validateParameter(valid_594161, JString, required = false,
                                 default = nil)
  if valid_594161 != nil:
    section.add "ParameterGroupName", valid_594161
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594162: Call_PostDescribeClusterParameterGroups_594145;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594162.validator(path, query, header, formData, body)
  let scheme = call_594162.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594162.url(scheme.get, call_594162.host, call_594162.base,
                         call_594162.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594162, url, valid)

proc call*(call_594163: Call_PostDescribeClusterParameterGroups_594145;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil;
          Action: string = "DescribeClusterParameterGroups";
          ParameterGroupName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: string (required)
  var query_594164 = newJObject()
  var formData_594165 = newJObject()
  if TagKeys != nil:
    formData_594165.add "TagKeys", TagKeys
  add(formData_594165, "MaxRecords", newJInt(MaxRecords))
  add(formData_594165, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_594165.add "TagValues", TagValues
  add(query_594164, "Action", newJString(Action))
  add(formData_594165, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_594164, "Version", newJString(Version))
  result = call_594163.call(nil, query_594164, nil, formData_594165, nil)

var postDescribeClusterParameterGroups* = Call_PostDescribeClusterParameterGroups_594145(
    name: "postDescribeClusterParameterGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_PostDescribeClusterParameterGroups_594146, base: "/",
    url: url_PostDescribeClusterParameterGroups_594147,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameterGroups_594125 = ref object of OpenApiRestCall_592348
proc url_GetDescribeClusterParameterGroups_594127(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterParameterGroups_594126(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   ParameterGroupName: JString
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594128 = query.getOrDefault("Marker")
  valid_594128 = validateParameter(valid_594128, JString, required = false,
                                 default = nil)
  if valid_594128 != nil:
    section.add "Marker", valid_594128
  var valid_594129 = query.getOrDefault("TagKeys")
  valid_594129 = validateParameter(valid_594129, JArray, required = false,
                                 default = nil)
  if valid_594129 != nil:
    section.add "TagKeys", valid_594129
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594130 = query.getOrDefault("Action")
  valid_594130 = validateParameter(valid_594130, JString, required = true, default = newJString(
      "DescribeClusterParameterGroups"))
  if valid_594130 != nil:
    section.add "Action", valid_594130
  var valid_594131 = query.getOrDefault("ParameterGroupName")
  valid_594131 = validateParameter(valid_594131, JString, required = false,
                                 default = nil)
  if valid_594131 != nil:
    section.add "ParameterGroupName", valid_594131
  var valid_594132 = query.getOrDefault("Version")
  valid_594132 = validateParameter(valid_594132, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594132 != nil:
    section.add "Version", valid_594132
  var valid_594133 = query.getOrDefault("MaxRecords")
  valid_594133 = validateParameter(valid_594133, JInt, required = false, default = nil)
  if valid_594133 != nil:
    section.add "MaxRecords", valid_594133
  var valid_594134 = query.getOrDefault("TagValues")
  valid_594134 = validateParameter(valid_594134, JArray, required = false,
                                 default = nil)
  if valid_594134 != nil:
    section.add "TagValues", valid_594134
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594135 = header.getOrDefault("X-Amz-Signature")
  valid_594135 = validateParameter(valid_594135, JString, required = false,
                                 default = nil)
  if valid_594135 != nil:
    section.add "X-Amz-Signature", valid_594135
  var valid_594136 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594136 = validateParameter(valid_594136, JString, required = false,
                                 default = nil)
  if valid_594136 != nil:
    section.add "X-Amz-Content-Sha256", valid_594136
  var valid_594137 = header.getOrDefault("X-Amz-Date")
  valid_594137 = validateParameter(valid_594137, JString, required = false,
                                 default = nil)
  if valid_594137 != nil:
    section.add "X-Amz-Date", valid_594137
  var valid_594138 = header.getOrDefault("X-Amz-Credential")
  valid_594138 = validateParameter(valid_594138, JString, required = false,
                                 default = nil)
  if valid_594138 != nil:
    section.add "X-Amz-Credential", valid_594138
  var valid_594139 = header.getOrDefault("X-Amz-Security-Token")
  valid_594139 = validateParameter(valid_594139, JString, required = false,
                                 default = nil)
  if valid_594139 != nil:
    section.add "X-Amz-Security-Token", valid_594139
  var valid_594140 = header.getOrDefault("X-Amz-Algorithm")
  valid_594140 = validateParameter(valid_594140, JString, required = false,
                                 default = nil)
  if valid_594140 != nil:
    section.add "X-Amz-Algorithm", valid_594140
  var valid_594141 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594141 = validateParameter(valid_594141, JString, required = false,
                                 default = nil)
  if valid_594141 != nil:
    section.add "X-Amz-SignedHeaders", valid_594141
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594142: Call_GetDescribeClusterParameterGroups_594125;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594142.validator(path, query, header, formData, body)
  let scheme = call_594142.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594142.url(scheme.get, call_594142.host, call_594142.base,
                         call_594142.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594142, url, valid)

proc call*(call_594143: Call_GetDescribeClusterParameterGroups_594125;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeClusterParameterGroups";
          ParameterGroupName: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterParameterGroups
  ## <p>Returns a list of Amazon Redshift parameter groups, including parameter groups you created and the default parameter group. For each parameter group, the response includes the parameter group name, description, and parameter group family name. You can optionally specify a name to retrieve the description of a specific parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all parameter groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all parameter groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, parameter groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameterGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster parameter groups that are associated with the specified key or keys. For example, suppose that you have parameter groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   ParameterGroupName: string
  ##                     : The name of a specific parameter group for which to return details. By default, details about all parameter groups and the default parameter group are returned.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster parameter groups that are associated with the specified tag value or values. For example, suppose that you have parameter groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the parameter groups that have either or both of these tag values associated with them.
  var query_594144 = newJObject()
  add(query_594144, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_594144.add "TagKeys", TagKeys
  add(query_594144, "Action", newJString(Action))
  add(query_594144, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_594144, "Version", newJString(Version))
  add(query_594144, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_594144.add "TagValues", TagValues
  result = call_594143.call(nil, query_594144, nil, nil, nil)

var getDescribeClusterParameterGroups* = Call_GetDescribeClusterParameterGroups_594125(
    name: "getDescribeClusterParameterGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterParameterGroups",
    validator: validate_GetDescribeClusterParameterGroups_594126, base: "/",
    url: url_GetDescribeClusterParameterGroups_594127,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterParameters_594185 = ref object of OpenApiRestCall_592348
proc url_PostDescribeClusterParameters_594187(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterParameters_594186(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594188 = query.getOrDefault("Action")
  valid_594188 = validateParameter(valid_594188, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_594188 != nil:
    section.add "Action", valid_594188
  var valid_594189 = query.getOrDefault("Version")
  valid_594189 = validateParameter(valid_594189, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594189 != nil:
    section.add "Version", valid_594189
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594190 = header.getOrDefault("X-Amz-Signature")
  valid_594190 = validateParameter(valid_594190, JString, required = false,
                                 default = nil)
  if valid_594190 != nil:
    section.add "X-Amz-Signature", valid_594190
  var valid_594191 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594191 = validateParameter(valid_594191, JString, required = false,
                                 default = nil)
  if valid_594191 != nil:
    section.add "X-Amz-Content-Sha256", valid_594191
  var valid_594192 = header.getOrDefault("X-Amz-Date")
  valid_594192 = validateParameter(valid_594192, JString, required = false,
                                 default = nil)
  if valid_594192 != nil:
    section.add "X-Amz-Date", valid_594192
  var valid_594193 = header.getOrDefault("X-Amz-Credential")
  valid_594193 = validateParameter(valid_594193, JString, required = false,
                                 default = nil)
  if valid_594193 != nil:
    section.add "X-Amz-Credential", valid_594193
  var valid_594194 = header.getOrDefault("X-Amz-Security-Token")
  valid_594194 = validateParameter(valid_594194, JString, required = false,
                                 default = nil)
  if valid_594194 != nil:
    section.add "X-Amz-Security-Token", valid_594194
  var valid_594195 = header.getOrDefault("X-Amz-Algorithm")
  valid_594195 = validateParameter(valid_594195, JString, required = false,
                                 default = nil)
  if valid_594195 != nil:
    section.add "X-Amz-Algorithm", valid_594195
  var valid_594196 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594196 = validateParameter(valid_594196, JString, required = false,
                                 default = nil)
  if valid_594196 != nil:
    section.add "X-Amz-SignedHeaders", valid_594196
  result.add "header", section
  ## parameters in `formData` object:
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  section = newJObject()
  var valid_594197 = formData.getOrDefault("Source")
  valid_594197 = validateParameter(valid_594197, JString, required = false,
                                 default = nil)
  if valid_594197 != nil:
    section.add "Source", valid_594197
  var valid_594198 = formData.getOrDefault("MaxRecords")
  valid_594198 = validateParameter(valid_594198, JInt, required = false, default = nil)
  if valid_594198 != nil:
    section.add "MaxRecords", valid_594198
  var valid_594199 = formData.getOrDefault("Marker")
  valid_594199 = validateParameter(valid_594199, JString, required = false,
                                 default = nil)
  if valid_594199 != nil:
    section.add "Marker", valid_594199
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_594200 = formData.getOrDefault("ParameterGroupName")
  valid_594200 = validateParameter(valid_594200, JString, required = true,
                                 default = nil)
  if valid_594200 != nil:
    section.add "ParameterGroupName", valid_594200
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594201: Call_PostDescribeClusterParameters_594185; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594201.validator(path, query, header, formData, body)
  let scheme = call_594201.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594201.url(scheme.get, call_594201.host, call_594201.base,
                         call_594201.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594201, url, valid)

proc call*(call_594202: Call_PostDescribeClusterParameters_594185;
          ParameterGroupName: string; Source: string = ""; MaxRecords: int = 0;
          Marker: string = ""; Action: string = "DescribeClusterParameters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: string (required)
  var query_594203 = newJObject()
  var formData_594204 = newJObject()
  add(formData_594204, "Source", newJString(Source))
  add(formData_594204, "MaxRecords", newJInt(MaxRecords))
  add(formData_594204, "Marker", newJString(Marker))
  add(query_594203, "Action", newJString(Action))
  add(formData_594204, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_594203, "Version", newJString(Version))
  result = call_594202.call(nil, query_594203, nil, formData_594204, nil)

var postDescribeClusterParameters* = Call_PostDescribeClusterParameters_594185(
    name: "postDescribeClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_PostDescribeClusterParameters_594186, base: "/",
    url: url_PostDescribeClusterParameters_594187,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterParameters_594166 = ref object of OpenApiRestCall_592348
proc url_GetDescribeClusterParameters_594168(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterParameters_594167(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: JString
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_594169 = query.getOrDefault("Marker")
  valid_594169 = validateParameter(valid_594169, JString, required = false,
                                 default = nil)
  if valid_594169 != nil:
    section.add "Marker", valid_594169
  var valid_594170 = query.getOrDefault("Source")
  valid_594170 = validateParameter(valid_594170, JString, required = false,
                                 default = nil)
  if valid_594170 != nil:
    section.add "Source", valid_594170
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594171 = query.getOrDefault("Action")
  valid_594171 = validateParameter(valid_594171, JString, required = true, default = newJString(
      "DescribeClusterParameters"))
  if valid_594171 != nil:
    section.add "Action", valid_594171
  var valid_594172 = query.getOrDefault("ParameterGroupName")
  valid_594172 = validateParameter(valid_594172, JString, required = true,
                                 default = nil)
  if valid_594172 != nil:
    section.add "ParameterGroupName", valid_594172
  var valid_594173 = query.getOrDefault("Version")
  valid_594173 = validateParameter(valid_594173, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594173 != nil:
    section.add "Version", valid_594173
  var valid_594174 = query.getOrDefault("MaxRecords")
  valid_594174 = validateParameter(valid_594174, JInt, required = false, default = nil)
  if valid_594174 != nil:
    section.add "MaxRecords", valid_594174
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594175 = header.getOrDefault("X-Amz-Signature")
  valid_594175 = validateParameter(valid_594175, JString, required = false,
                                 default = nil)
  if valid_594175 != nil:
    section.add "X-Amz-Signature", valid_594175
  var valid_594176 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594176 = validateParameter(valid_594176, JString, required = false,
                                 default = nil)
  if valid_594176 != nil:
    section.add "X-Amz-Content-Sha256", valid_594176
  var valid_594177 = header.getOrDefault("X-Amz-Date")
  valid_594177 = validateParameter(valid_594177, JString, required = false,
                                 default = nil)
  if valid_594177 != nil:
    section.add "X-Amz-Date", valid_594177
  var valid_594178 = header.getOrDefault("X-Amz-Credential")
  valid_594178 = validateParameter(valid_594178, JString, required = false,
                                 default = nil)
  if valid_594178 != nil:
    section.add "X-Amz-Credential", valid_594178
  var valid_594179 = header.getOrDefault("X-Amz-Security-Token")
  valid_594179 = validateParameter(valid_594179, JString, required = false,
                                 default = nil)
  if valid_594179 != nil:
    section.add "X-Amz-Security-Token", valid_594179
  var valid_594180 = header.getOrDefault("X-Amz-Algorithm")
  valid_594180 = validateParameter(valid_594180, JString, required = false,
                                 default = nil)
  if valid_594180 != nil:
    section.add "X-Amz-Algorithm", valid_594180
  var valid_594181 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594181 = validateParameter(valid_594181, JString, required = false,
                                 default = nil)
  if valid_594181 != nil:
    section.add "X-Amz-SignedHeaders", valid_594181
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594182: Call_GetDescribeClusterParameters_594166; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594182.validator(path, query, header, formData, body)
  let scheme = call_594182.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594182.url(scheme.get, call_594182.host, call_594182.base,
                         call_594182.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594182, url, valid)

proc call*(call_594183: Call_GetDescribeClusterParameters_594166;
          ParameterGroupName: string; Marker: string = ""; Source: string = "";
          Action: string = "DescribeClusterParameters";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeClusterParameters
  ## <p>Returns a detailed list of parameters contained within the specified Amazon Redshift parameter group. For each parameter the response includes information such as parameter name, description, data type, value, whether the parameter value is modifiable, and so on.</p> <p>You can specify <i>source</i> filter to retrieve parameters of only specific type. For example, to retrieve parameters that were modified by a user action such as from <a>ModifyClusterParameterGroup</a>, you can specify <i>source</i> equal to <i>user</i>.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Source: string
  ##         : <p>The parameter types to return. Specify <code>user</code> to show parameters that are different form the default. Similarly, specify <code>engine-default</code> to show parameters that are the same as the default parameter group. </p> <p>Default: All parameter types returned.</p> <p>Valid Values: <code>user</code> | <code>engine-default</code> </p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of a cluster parameter group for which to return details.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_594184 = newJObject()
  add(query_594184, "Marker", newJString(Marker))
  add(query_594184, "Source", newJString(Source))
  add(query_594184, "Action", newJString(Action))
  add(query_594184, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_594184, "Version", newJString(Version))
  add(query_594184, "MaxRecords", newJInt(MaxRecords))
  result = call_594183.call(nil, query_594184, nil, nil, nil)

var getDescribeClusterParameters* = Call_GetDescribeClusterParameters_594166(
    name: "getDescribeClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterParameters",
    validator: validate_GetDescribeClusterParameters_594167, base: "/",
    url: url_GetDescribeClusterParameters_594168,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSecurityGroups_594225 = ref object of OpenApiRestCall_592348
proc url_PostDescribeClusterSecurityGroups_594227(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterSecurityGroups_594226(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594228 = query.getOrDefault("Action")
  valid_594228 = validateParameter(valid_594228, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_594228 != nil:
    section.add "Action", valid_594228
  var valid_594229 = query.getOrDefault("Version")
  valid_594229 = validateParameter(valid_594229, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594229 != nil:
    section.add "Version", valid_594229
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594230 = header.getOrDefault("X-Amz-Signature")
  valid_594230 = validateParameter(valid_594230, JString, required = false,
                                 default = nil)
  if valid_594230 != nil:
    section.add "X-Amz-Signature", valid_594230
  var valid_594231 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594231 = validateParameter(valid_594231, JString, required = false,
                                 default = nil)
  if valid_594231 != nil:
    section.add "X-Amz-Content-Sha256", valid_594231
  var valid_594232 = header.getOrDefault("X-Amz-Date")
  valid_594232 = validateParameter(valid_594232, JString, required = false,
                                 default = nil)
  if valid_594232 != nil:
    section.add "X-Amz-Date", valid_594232
  var valid_594233 = header.getOrDefault("X-Amz-Credential")
  valid_594233 = validateParameter(valid_594233, JString, required = false,
                                 default = nil)
  if valid_594233 != nil:
    section.add "X-Amz-Credential", valid_594233
  var valid_594234 = header.getOrDefault("X-Amz-Security-Token")
  valid_594234 = validateParameter(valid_594234, JString, required = false,
                                 default = nil)
  if valid_594234 != nil:
    section.add "X-Amz-Security-Token", valid_594234
  var valid_594235 = header.getOrDefault("X-Amz-Algorithm")
  valid_594235 = validateParameter(valid_594235, JString, required = false,
                                 default = nil)
  if valid_594235 != nil:
    section.add "X-Amz-Algorithm", valid_594235
  var valid_594236 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594236 = validateParameter(valid_594236, JString, required = false,
                                 default = nil)
  if valid_594236 != nil:
    section.add "X-Amz-SignedHeaders", valid_594236
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594237 = formData.getOrDefault("TagKeys")
  valid_594237 = validateParameter(valid_594237, JArray, required = false,
                                 default = nil)
  if valid_594237 != nil:
    section.add "TagKeys", valid_594237
  var valid_594238 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_594238 = validateParameter(valid_594238, JString, required = false,
                                 default = nil)
  if valid_594238 != nil:
    section.add "ClusterSecurityGroupName", valid_594238
  var valid_594239 = formData.getOrDefault("MaxRecords")
  valid_594239 = validateParameter(valid_594239, JInt, required = false, default = nil)
  if valid_594239 != nil:
    section.add "MaxRecords", valid_594239
  var valid_594240 = formData.getOrDefault("Marker")
  valid_594240 = validateParameter(valid_594240, JString, required = false,
                                 default = nil)
  if valid_594240 != nil:
    section.add "Marker", valid_594240
  var valid_594241 = formData.getOrDefault("TagValues")
  valid_594241 = validateParameter(valid_594241, JArray, required = false,
                                 default = nil)
  if valid_594241 != nil:
    section.add "TagValues", valid_594241
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594242: Call_PostDescribeClusterSecurityGroups_594225;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594242.validator(path, query, header, formData, body)
  let scheme = call_594242.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594242.url(scheme.get, call_594242.host, call_594242.base,
                         call_594242.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594242, url, valid)

proc call*(call_594243: Call_PostDescribeClusterSecurityGroups_594225;
          TagKeys: JsonNode = nil; ClusterSecurityGroupName: string = "";
          MaxRecords: int = 0; Marker: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeClusterSecurityGroups";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594244 = newJObject()
  var formData_594245 = newJObject()
  if TagKeys != nil:
    formData_594245.add "TagKeys", TagKeys
  add(formData_594245, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_594245, "MaxRecords", newJInt(MaxRecords))
  add(formData_594245, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_594245.add "TagValues", TagValues
  add(query_594244, "Action", newJString(Action))
  add(query_594244, "Version", newJString(Version))
  result = call_594243.call(nil, query_594244, nil, formData_594245, nil)

var postDescribeClusterSecurityGroups* = Call_PostDescribeClusterSecurityGroups_594225(
    name: "postDescribeClusterSecurityGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_PostDescribeClusterSecurityGroups_594226, base: "/",
    url: url_PostDescribeClusterSecurityGroups_594227,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSecurityGroups_594205 = ref object of OpenApiRestCall_592348
proc url_GetDescribeClusterSecurityGroups_594207(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterSecurityGroups_594206(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: JString
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594208 = query.getOrDefault("Marker")
  valid_594208 = validateParameter(valid_594208, JString, required = false,
                                 default = nil)
  if valid_594208 != nil:
    section.add "Marker", valid_594208
  var valid_594209 = query.getOrDefault("TagKeys")
  valid_594209 = validateParameter(valid_594209, JArray, required = false,
                                 default = nil)
  if valid_594209 != nil:
    section.add "TagKeys", valid_594209
  var valid_594210 = query.getOrDefault("ClusterSecurityGroupName")
  valid_594210 = validateParameter(valid_594210, JString, required = false,
                                 default = nil)
  if valid_594210 != nil:
    section.add "ClusterSecurityGroupName", valid_594210
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594211 = query.getOrDefault("Action")
  valid_594211 = validateParameter(valid_594211, JString, required = true, default = newJString(
      "DescribeClusterSecurityGroups"))
  if valid_594211 != nil:
    section.add "Action", valid_594211
  var valid_594212 = query.getOrDefault("Version")
  valid_594212 = validateParameter(valid_594212, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594212 != nil:
    section.add "Version", valid_594212
  var valid_594213 = query.getOrDefault("MaxRecords")
  valid_594213 = validateParameter(valid_594213, JInt, required = false, default = nil)
  if valid_594213 != nil:
    section.add "MaxRecords", valid_594213
  var valid_594214 = query.getOrDefault("TagValues")
  valid_594214 = validateParameter(valid_594214, JArray, required = false,
                                 default = nil)
  if valid_594214 != nil:
    section.add "TagValues", valid_594214
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594215 = header.getOrDefault("X-Amz-Signature")
  valid_594215 = validateParameter(valid_594215, JString, required = false,
                                 default = nil)
  if valid_594215 != nil:
    section.add "X-Amz-Signature", valid_594215
  var valid_594216 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594216 = validateParameter(valid_594216, JString, required = false,
                                 default = nil)
  if valid_594216 != nil:
    section.add "X-Amz-Content-Sha256", valid_594216
  var valid_594217 = header.getOrDefault("X-Amz-Date")
  valid_594217 = validateParameter(valid_594217, JString, required = false,
                                 default = nil)
  if valid_594217 != nil:
    section.add "X-Amz-Date", valid_594217
  var valid_594218 = header.getOrDefault("X-Amz-Credential")
  valid_594218 = validateParameter(valid_594218, JString, required = false,
                                 default = nil)
  if valid_594218 != nil:
    section.add "X-Amz-Credential", valid_594218
  var valid_594219 = header.getOrDefault("X-Amz-Security-Token")
  valid_594219 = validateParameter(valid_594219, JString, required = false,
                                 default = nil)
  if valid_594219 != nil:
    section.add "X-Amz-Security-Token", valid_594219
  var valid_594220 = header.getOrDefault("X-Amz-Algorithm")
  valid_594220 = validateParameter(valid_594220, JString, required = false,
                                 default = nil)
  if valid_594220 != nil:
    section.add "X-Amz-Algorithm", valid_594220
  var valid_594221 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594221 = validateParameter(valid_594221, JString, required = false,
                                 default = nil)
  if valid_594221 != nil:
    section.add "X-Amz-SignedHeaders", valid_594221
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594222: Call_GetDescribeClusterSecurityGroups_594205;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594222.validator(path, query, header, formData, body)
  let scheme = call_594222.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594222.url(scheme.get, call_594222.host, call_594222.base,
                         call_594222.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594222, url, valid)

proc call*(call_594223: Call_GetDescribeClusterSecurityGroups_594205;
          Marker: string = ""; TagKeys: JsonNode = nil;
          ClusterSecurityGroupName: string = "";
          Action: string = "DescribeClusterSecurityGroups";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSecurityGroups
  ## <p>Returns information about Amazon Redshift security groups. If the name of a security group is specified, the response will contain only information about only that security group.</p> <p> For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all security groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all security groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, security groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSecurityGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterSecurityGroupName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster security groups that are associated with the specified key or keys. For example, suppose that you have security groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag keys associated with them.
  ##   ClusterSecurityGroupName: string
  ##                           : <p>The name of a cluster security group for which you are requesting details. You can specify either the <b>Marker</b> parameter or a <b>ClusterSecurityGroupName</b> parameter, but not both. </p> <p> Example: <code>securitygroup1</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster security groups that are associated with the specified tag value or values. For example, suppose that you have security groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the security groups that have either or both of these tag values associated with them.
  var query_594224 = newJObject()
  add(query_594224, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_594224.add "TagKeys", TagKeys
  add(query_594224, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_594224, "Action", newJString(Action))
  add(query_594224, "Version", newJString(Version))
  add(query_594224, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_594224.add "TagValues", TagValues
  result = call_594223.call(nil, query_594224, nil, nil, nil)

var getDescribeClusterSecurityGroups* = Call_GetDescribeClusterSecurityGroups_594205(
    name: "getDescribeClusterSecurityGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeClusterSecurityGroups",
    validator: validate_GetDescribeClusterSecurityGroups_594206, base: "/",
    url: url_GetDescribeClusterSecurityGroups_594207,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSnapshots_594273 = ref object of OpenApiRestCall_592348
proc url_PostDescribeClusterSnapshots_594275(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterSnapshots_594274(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594276 = query.getOrDefault("Action")
  valid_594276 = validateParameter(valid_594276, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_594276 != nil:
    section.add "Action", valid_594276
  var valid_594277 = query.getOrDefault("Version")
  valid_594277 = validateParameter(valid_594277, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594277 != nil:
    section.add "Version", valid_594277
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594278 = header.getOrDefault("X-Amz-Signature")
  valid_594278 = validateParameter(valid_594278, JString, required = false,
                                 default = nil)
  if valid_594278 != nil:
    section.add "X-Amz-Signature", valid_594278
  var valid_594279 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594279 = validateParameter(valid_594279, JString, required = false,
                                 default = nil)
  if valid_594279 != nil:
    section.add "X-Amz-Content-Sha256", valid_594279
  var valid_594280 = header.getOrDefault("X-Amz-Date")
  valid_594280 = validateParameter(valid_594280, JString, required = false,
                                 default = nil)
  if valid_594280 != nil:
    section.add "X-Amz-Date", valid_594280
  var valid_594281 = header.getOrDefault("X-Amz-Credential")
  valid_594281 = validateParameter(valid_594281, JString, required = false,
                                 default = nil)
  if valid_594281 != nil:
    section.add "X-Amz-Credential", valid_594281
  var valid_594282 = header.getOrDefault("X-Amz-Security-Token")
  valid_594282 = validateParameter(valid_594282, JString, required = false,
                                 default = nil)
  if valid_594282 != nil:
    section.add "X-Amz-Security-Token", valid_594282
  var valid_594283 = header.getOrDefault("X-Amz-Algorithm")
  valid_594283 = validateParameter(valid_594283, JString, required = false,
                                 default = nil)
  if valid_594283 != nil:
    section.add "X-Amz-Algorithm", valid_594283
  var valid_594284 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594284 = validateParameter(valid_594284, JString, required = false,
                                 default = nil)
  if valid_594284 != nil:
    section.add "X-Amz-SignedHeaders", valid_594284
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   SortingEntities: JArray
  ##                  : <p/>
  section = newJObject()
  var valid_594285 = formData.getOrDefault("TagKeys")
  valid_594285 = validateParameter(valid_594285, JArray, required = false,
                                 default = nil)
  if valid_594285 != nil:
    section.add "TagKeys", valid_594285
  var valid_594286 = formData.getOrDefault("ClusterIdentifier")
  valid_594286 = validateParameter(valid_594286, JString, required = false,
                                 default = nil)
  if valid_594286 != nil:
    section.add "ClusterIdentifier", valid_594286
  var valid_594287 = formData.getOrDefault("SnapshotType")
  valid_594287 = validateParameter(valid_594287, JString, required = false,
                                 default = nil)
  if valid_594287 != nil:
    section.add "SnapshotType", valid_594287
  var valid_594288 = formData.getOrDefault("MaxRecords")
  valid_594288 = validateParameter(valid_594288, JInt, required = false, default = nil)
  if valid_594288 != nil:
    section.add "MaxRecords", valid_594288
  var valid_594289 = formData.getOrDefault("OwnerAccount")
  valid_594289 = validateParameter(valid_594289, JString, required = false,
                                 default = nil)
  if valid_594289 != nil:
    section.add "OwnerAccount", valid_594289
  var valid_594290 = formData.getOrDefault("Marker")
  valid_594290 = validateParameter(valid_594290, JString, required = false,
                                 default = nil)
  if valid_594290 != nil:
    section.add "Marker", valid_594290
  var valid_594291 = formData.getOrDefault("ClusterExists")
  valid_594291 = validateParameter(valid_594291, JBool, required = false, default = nil)
  if valid_594291 != nil:
    section.add "ClusterExists", valid_594291
  var valid_594292 = formData.getOrDefault("TagValues")
  valid_594292 = validateParameter(valid_594292, JArray, required = false,
                                 default = nil)
  if valid_594292 != nil:
    section.add "TagValues", valid_594292
  var valid_594293 = formData.getOrDefault("EndTime")
  valid_594293 = validateParameter(valid_594293, JString, required = false,
                                 default = nil)
  if valid_594293 != nil:
    section.add "EndTime", valid_594293
  var valid_594294 = formData.getOrDefault("StartTime")
  valid_594294 = validateParameter(valid_594294, JString, required = false,
                                 default = nil)
  if valid_594294 != nil:
    section.add "StartTime", valid_594294
  var valid_594295 = formData.getOrDefault("SnapshotIdentifier")
  valid_594295 = validateParameter(valid_594295, JString, required = false,
                                 default = nil)
  if valid_594295 != nil:
    section.add "SnapshotIdentifier", valid_594295
  var valid_594296 = formData.getOrDefault("SortingEntities")
  valid_594296 = validateParameter(valid_594296, JArray, required = false,
                                 default = nil)
  if valid_594296 != nil:
    section.add "SortingEntities", valid_594296
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594297: Call_PostDescribeClusterSnapshots_594273; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594297.validator(path, query, header, formData, body)
  let scheme = call_594297.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594297.url(scheme.get, call_594297.host, call_594297.base,
                         call_594297.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594297, url, valid)

proc call*(call_594298: Call_PostDescribeClusterSnapshots_594273;
          TagKeys: JsonNode = nil; ClusterIdentifier: string = "";
          SnapshotType: string = ""; MaxRecords: int = 0; OwnerAccount: string = "";
          Marker: string = ""; ClusterExists: bool = false; TagValues: JsonNode = nil;
          EndTime: string = ""; StartTime: string = ""; SnapshotIdentifier: string = "";
          Action: string = "DescribeClusterSnapshots";
          SortingEntities: JsonNode = nil; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   Action: string (required)
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   Version: string (required)
  var query_594299 = newJObject()
  var formData_594300 = newJObject()
  if TagKeys != nil:
    formData_594300.add "TagKeys", TagKeys
  add(formData_594300, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_594300, "SnapshotType", newJString(SnapshotType))
  add(formData_594300, "MaxRecords", newJInt(MaxRecords))
  add(formData_594300, "OwnerAccount", newJString(OwnerAccount))
  add(formData_594300, "Marker", newJString(Marker))
  add(formData_594300, "ClusterExists", newJBool(ClusterExists))
  if TagValues != nil:
    formData_594300.add "TagValues", TagValues
  add(formData_594300, "EndTime", newJString(EndTime))
  add(formData_594300, "StartTime", newJString(StartTime))
  add(formData_594300, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_594299, "Action", newJString(Action))
  if SortingEntities != nil:
    formData_594300.add "SortingEntities", SortingEntities
  add(query_594299, "Version", newJString(Version))
  result = call_594298.call(nil, query_594299, nil, formData_594300, nil)

var postDescribeClusterSnapshots* = Call_PostDescribeClusterSnapshots_594273(
    name: "postDescribeClusterSnapshots", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_PostDescribeClusterSnapshots_594274, base: "/",
    url: url_PostDescribeClusterSnapshots_594275,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSnapshots_594246 = ref object of OpenApiRestCall_592348
proc url_GetDescribeClusterSnapshots_594248(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterSnapshots_594247(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: JString
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   ClusterExists: JBool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: JString
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterIdentifier: JString
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   EndTime: JString
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594249 = query.getOrDefault("Marker")
  valid_594249 = validateParameter(valid_594249, JString, required = false,
                                 default = nil)
  if valid_594249 != nil:
    section.add "Marker", valid_594249
  var valid_594250 = query.getOrDefault("SortingEntities")
  valid_594250 = validateParameter(valid_594250, JArray, required = false,
                                 default = nil)
  if valid_594250 != nil:
    section.add "SortingEntities", valid_594250
  var valid_594251 = query.getOrDefault("SnapshotIdentifier")
  valid_594251 = validateParameter(valid_594251, JString, required = false,
                                 default = nil)
  if valid_594251 != nil:
    section.add "SnapshotIdentifier", valid_594251
  var valid_594252 = query.getOrDefault("ClusterExists")
  valid_594252 = validateParameter(valid_594252, JBool, required = false, default = nil)
  if valid_594252 != nil:
    section.add "ClusterExists", valid_594252
  var valid_594253 = query.getOrDefault("TagKeys")
  valid_594253 = validateParameter(valid_594253, JArray, required = false,
                                 default = nil)
  if valid_594253 != nil:
    section.add "TagKeys", valid_594253
  var valid_594254 = query.getOrDefault("SnapshotType")
  valid_594254 = validateParameter(valid_594254, JString, required = false,
                                 default = nil)
  if valid_594254 != nil:
    section.add "SnapshotType", valid_594254
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594255 = query.getOrDefault("Action")
  valid_594255 = validateParameter(valid_594255, JString, required = true, default = newJString(
      "DescribeClusterSnapshots"))
  if valid_594255 != nil:
    section.add "Action", valid_594255
  var valid_594256 = query.getOrDefault("StartTime")
  valid_594256 = validateParameter(valid_594256, JString, required = false,
                                 default = nil)
  if valid_594256 != nil:
    section.add "StartTime", valid_594256
  var valid_594257 = query.getOrDefault("ClusterIdentifier")
  valid_594257 = validateParameter(valid_594257, JString, required = false,
                                 default = nil)
  if valid_594257 != nil:
    section.add "ClusterIdentifier", valid_594257
  var valid_594258 = query.getOrDefault("EndTime")
  valid_594258 = validateParameter(valid_594258, JString, required = false,
                                 default = nil)
  if valid_594258 != nil:
    section.add "EndTime", valid_594258
  var valid_594259 = query.getOrDefault("OwnerAccount")
  valid_594259 = validateParameter(valid_594259, JString, required = false,
                                 default = nil)
  if valid_594259 != nil:
    section.add "OwnerAccount", valid_594259
  var valid_594260 = query.getOrDefault("Version")
  valid_594260 = validateParameter(valid_594260, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594260 != nil:
    section.add "Version", valid_594260
  var valid_594261 = query.getOrDefault("MaxRecords")
  valid_594261 = validateParameter(valid_594261, JInt, required = false, default = nil)
  if valid_594261 != nil:
    section.add "MaxRecords", valid_594261
  var valid_594262 = query.getOrDefault("TagValues")
  valid_594262 = validateParameter(valid_594262, JArray, required = false,
                                 default = nil)
  if valid_594262 != nil:
    section.add "TagValues", valid_594262
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594263 = header.getOrDefault("X-Amz-Signature")
  valid_594263 = validateParameter(valid_594263, JString, required = false,
                                 default = nil)
  if valid_594263 != nil:
    section.add "X-Amz-Signature", valid_594263
  var valid_594264 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594264 = validateParameter(valid_594264, JString, required = false,
                                 default = nil)
  if valid_594264 != nil:
    section.add "X-Amz-Content-Sha256", valid_594264
  var valid_594265 = header.getOrDefault("X-Amz-Date")
  valid_594265 = validateParameter(valid_594265, JString, required = false,
                                 default = nil)
  if valid_594265 != nil:
    section.add "X-Amz-Date", valid_594265
  var valid_594266 = header.getOrDefault("X-Amz-Credential")
  valid_594266 = validateParameter(valid_594266, JString, required = false,
                                 default = nil)
  if valid_594266 != nil:
    section.add "X-Amz-Credential", valid_594266
  var valid_594267 = header.getOrDefault("X-Amz-Security-Token")
  valid_594267 = validateParameter(valid_594267, JString, required = false,
                                 default = nil)
  if valid_594267 != nil:
    section.add "X-Amz-Security-Token", valid_594267
  var valid_594268 = header.getOrDefault("X-Amz-Algorithm")
  valid_594268 = validateParameter(valid_594268, JString, required = false,
                                 default = nil)
  if valid_594268 != nil:
    section.add "X-Amz-Algorithm", valid_594268
  var valid_594269 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594269 = validateParameter(valid_594269, JString, required = false,
                                 default = nil)
  if valid_594269 != nil:
    section.add "X-Amz-SignedHeaders", valid_594269
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594270: Call_GetDescribeClusterSnapshots_594246; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594270.validator(path, query, header, formData, body)
  let scheme = call_594270.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594270.url(scheme.get, call_594270.host, call_594270.base,
                         call_594270.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594270, url, valid)

proc call*(call_594271: Call_GetDescribeClusterSnapshots_594246;
          Marker: string = ""; SortingEntities: JsonNode = nil;
          SnapshotIdentifier: string = ""; ClusterExists: bool = false;
          TagKeys: JsonNode = nil; SnapshotType: string = "";
          Action: string = "DescribeClusterSnapshots"; StartTime: string = "";
          ClusterIdentifier: string = ""; EndTime: string = "";
          OwnerAccount: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSnapshots
  ## <p>Returns one or more snapshot objects, which contain metadata about your cluster snapshots. By default, this operation returns information about all snapshots of all clusters that are owned by you AWS customer account. No information is returned for snapshots owned by inactive AWS customer accounts.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all snapshots that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all snapshots that have any combination of those values are returned. Only snapshots that you own are returned in the response; shared snapshots are not returned with the tag key and tag value request parameters.</p> <p>If both tag keys and values are omitted from the request, snapshots are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSnapshots</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SortingEntities: JArray
  ##                  : <p/>
  ##   SnapshotIdentifier: string
  ##                     : The snapshot identifier of the snapshot about which to return information.
  ##   ClusterExists: bool
  ##                : <p>A value that indicates whether to return snapshots only for an existing cluster. You can perform table-level restore only by using a snapshot of an existing cluster, that is, a cluster that has not been deleted. Values for this parameter work as follows: </p> <ul> <li> <p>If <code>ClusterExists</code> is set to <code>true</code>, <code>ClusterIdentifier</code> is required.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> isn't specified, all snapshots associated with deleted clusters (orphaned snapshots) are returned. </p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for a deleted cluster, snapshots associated with that cluster are returned.</p> </li> <li> <p>If <code>ClusterExists</code> is set to <code>false</code> and <code>ClusterIdentifier</code> is specified for an existing cluster, no snapshots are returned. </p> </li> </ul>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster snapshots that are associated with the specified key or keys. For example, suppose that you have snapshots that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag keys associated with them.
  ##   SnapshotType: string
  ##               : <p>The type of snapshots for which you are requesting information. By default, snapshots of all types are returned.</p> <p>Valid Values: <code>automated</code> | <code>manual</code> </p>
  ##   Action: string (required)
  ##   StartTime: string
  ##            : <p>A value that requests only snapshots created at or after the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   ClusterIdentifier: string
  ##                    : The identifier of the cluster which generated the requested snapshots.
  ##   EndTime: string
  ##          : <p>A time value that requests only snapshots created at or before the specified time. The time value is specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2012-07-16T18:00:00Z</code> </p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Use this field to filter the results to snapshots owned by a particular account. To describe snapshots you own, either specify your AWS customer account, or do not specify the parameter.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster snapshots that are associated with the specified tag value or values. For example, suppose that you have snapshots that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the snapshots that have either or both of these tag values associated with them.
  var query_594272 = newJObject()
  add(query_594272, "Marker", newJString(Marker))
  if SortingEntities != nil:
    query_594272.add "SortingEntities", SortingEntities
  add(query_594272, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_594272, "ClusterExists", newJBool(ClusterExists))
  if TagKeys != nil:
    query_594272.add "TagKeys", TagKeys
  add(query_594272, "SnapshotType", newJString(SnapshotType))
  add(query_594272, "Action", newJString(Action))
  add(query_594272, "StartTime", newJString(StartTime))
  add(query_594272, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594272, "EndTime", newJString(EndTime))
  add(query_594272, "OwnerAccount", newJString(OwnerAccount))
  add(query_594272, "Version", newJString(Version))
  add(query_594272, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_594272.add "TagValues", TagValues
  result = call_594271.call(nil, query_594272, nil, nil, nil)

var getDescribeClusterSnapshots* = Call_GetDescribeClusterSnapshots_594246(
    name: "getDescribeClusterSnapshots", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSnapshots",
    validator: validate_GetDescribeClusterSnapshots_594247, base: "/",
    url: url_GetDescribeClusterSnapshots_594248,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterSubnetGroups_594321 = ref object of OpenApiRestCall_592348
proc url_PostDescribeClusterSubnetGroups_594323(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterSubnetGroups_594322(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594324 = query.getOrDefault("Action")
  valid_594324 = validateParameter(valid_594324, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_594324 != nil:
    section.add "Action", valid_594324
  var valid_594325 = query.getOrDefault("Version")
  valid_594325 = validateParameter(valid_594325, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594325 != nil:
    section.add "Version", valid_594325
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594326 = header.getOrDefault("X-Amz-Signature")
  valid_594326 = validateParameter(valid_594326, JString, required = false,
                                 default = nil)
  if valid_594326 != nil:
    section.add "X-Amz-Signature", valid_594326
  var valid_594327 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594327 = validateParameter(valid_594327, JString, required = false,
                                 default = nil)
  if valid_594327 != nil:
    section.add "X-Amz-Content-Sha256", valid_594327
  var valid_594328 = header.getOrDefault("X-Amz-Date")
  valid_594328 = validateParameter(valid_594328, JString, required = false,
                                 default = nil)
  if valid_594328 != nil:
    section.add "X-Amz-Date", valid_594328
  var valid_594329 = header.getOrDefault("X-Amz-Credential")
  valid_594329 = validateParameter(valid_594329, JString, required = false,
                                 default = nil)
  if valid_594329 != nil:
    section.add "X-Amz-Credential", valid_594329
  var valid_594330 = header.getOrDefault("X-Amz-Security-Token")
  valid_594330 = validateParameter(valid_594330, JString, required = false,
                                 default = nil)
  if valid_594330 != nil:
    section.add "X-Amz-Security-Token", valid_594330
  var valid_594331 = header.getOrDefault("X-Amz-Algorithm")
  valid_594331 = validateParameter(valid_594331, JString, required = false,
                                 default = nil)
  if valid_594331 != nil:
    section.add "X-Amz-Algorithm", valid_594331
  var valid_594332 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594332 = validateParameter(valid_594332, JString, required = false,
                                 default = nil)
  if valid_594332 != nil:
    section.add "X-Amz-SignedHeaders", valid_594332
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594333 = formData.getOrDefault("TagKeys")
  valid_594333 = validateParameter(valid_594333, JArray, required = false,
                                 default = nil)
  if valid_594333 != nil:
    section.add "TagKeys", valid_594333
  var valid_594334 = formData.getOrDefault("MaxRecords")
  valid_594334 = validateParameter(valid_594334, JInt, required = false, default = nil)
  if valid_594334 != nil:
    section.add "MaxRecords", valid_594334
  var valid_594335 = formData.getOrDefault("Marker")
  valid_594335 = validateParameter(valid_594335, JString, required = false,
                                 default = nil)
  if valid_594335 != nil:
    section.add "Marker", valid_594335
  var valid_594336 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_594336 = validateParameter(valid_594336, JString, required = false,
                                 default = nil)
  if valid_594336 != nil:
    section.add "ClusterSubnetGroupName", valid_594336
  var valid_594337 = formData.getOrDefault("TagValues")
  valid_594337 = validateParameter(valid_594337, JArray, required = false,
                                 default = nil)
  if valid_594337 != nil:
    section.add "TagValues", valid_594337
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594338: Call_PostDescribeClusterSubnetGroups_594321;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594338.validator(path, query, header, formData, body)
  let scheme = call_594338.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594338.url(scheme.get, call_594338.host, call_594338.base,
                         call_594338.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594338, url, valid)

proc call*(call_594339: Call_PostDescribeClusterSubnetGroups_594321;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          ClusterSubnetGroupName: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeClusterSubnetGroups";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594340 = newJObject()
  var formData_594341 = newJObject()
  if TagKeys != nil:
    formData_594341.add "TagKeys", TagKeys
  add(formData_594341, "MaxRecords", newJInt(MaxRecords))
  add(formData_594341, "Marker", newJString(Marker))
  add(formData_594341, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  if TagValues != nil:
    formData_594341.add "TagValues", TagValues
  add(query_594340, "Action", newJString(Action))
  add(query_594340, "Version", newJString(Version))
  result = call_594339.call(nil, query_594340, nil, formData_594341, nil)

var postDescribeClusterSubnetGroups* = Call_PostDescribeClusterSubnetGroups_594321(
    name: "postDescribeClusterSubnetGroups", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_PostDescribeClusterSubnetGroups_594322, base: "/",
    url: url_PostDescribeClusterSubnetGroups_594323,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterSubnetGroups_594301 = ref object of OpenApiRestCall_592348
proc url_GetDescribeClusterSubnetGroups_594303(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterSubnetGroups_594302(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594304 = query.getOrDefault("ClusterSubnetGroupName")
  valid_594304 = validateParameter(valid_594304, JString, required = false,
                                 default = nil)
  if valid_594304 != nil:
    section.add "ClusterSubnetGroupName", valid_594304
  var valid_594305 = query.getOrDefault("Marker")
  valid_594305 = validateParameter(valid_594305, JString, required = false,
                                 default = nil)
  if valid_594305 != nil:
    section.add "Marker", valid_594305
  var valid_594306 = query.getOrDefault("TagKeys")
  valid_594306 = validateParameter(valid_594306, JArray, required = false,
                                 default = nil)
  if valid_594306 != nil:
    section.add "TagKeys", valid_594306
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594307 = query.getOrDefault("Action")
  valid_594307 = validateParameter(valid_594307, JString, required = true, default = newJString(
      "DescribeClusterSubnetGroups"))
  if valid_594307 != nil:
    section.add "Action", valid_594307
  var valid_594308 = query.getOrDefault("Version")
  valid_594308 = validateParameter(valid_594308, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594308 != nil:
    section.add "Version", valid_594308
  var valid_594309 = query.getOrDefault("MaxRecords")
  valid_594309 = validateParameter(valid_594309, JInt, required = false, default = nil)
  if valid_594309 != nil:
    section.add "MaxRecords", valid_594309
  var valid_594310 = query.getOrDefault("TagValues")
  valid_594310 = validateParameter(valid_594310, JArray, required = false,
                                 default = nil)
  if valid_594310 != nil:
    section.add "TagValues", valid_594310
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594311 = header.getOrDefault("X-Amz-Signature")
  valid_594311 = validateParameter(valid_594311, JString, required = false,
                                 default = nil)
  if valid_594311 != nil:
    section.add "X-Amz-Signature", valid_594311
  var valid_594312 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594312 = validateParameter(valid_594312, JString, required = false,
                                 default = nil)
  if valid_594312 != nil:
    section.add "X-Amz-Content-Sha256", valid_594312
  var valid_594313 = header.getOrDefault("X-Amz-Date")
  valid_594313 = validateParameter(valid_594313, JString, required = false,
                                 default = nil)
  if valid_594313 != nil:
    section.add "X-Amz-Date", valid_594313
  var valid_594314 = header.getOrDefault("X-Amz-Credential")
  valid_594314 = validateParameter(valid_594314, JString, required = false,
                                 default = nil)
  if valid_594314 != nil:
    section.add "X-Amz-Credential", valid_594314
  var valid_594315 = header.getOrDefault("X-Amz-Security-Token")
  valid_594315 = validateParameter(valid_594315, JString, required = false,
                                 default = nil)
  if valid_594315 != nil:
    section.add "X-Amz-Security-Token", valid_594315
  var valid_594316 = header.getOrDefault("X-Amz-Algorithm")
  valid_594316 = validateParameter(valid_594316, JString, required = false,
                                 default = nil)
  if valid_594316 != nil:
    section.add "X-Amz-Algorithm", valid_594316
  var valid_594317 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594317 = validateParameter(valid_594317, JString, required = false,
                                 default = nil)
  if valid_594317 != nil:
    section.add "X-Amz-SignedHeaders", valid_594317
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594318: Call_GetDescribeClusterSubnetGroups_594301; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594318.validator(path, query, header, formData, body)
  let scheme = call_594318.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594318.url(scheme.get, call_594318.host, call_594318.base,
                         call_594318.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594318, url, valid)

proc call*(call_594319: Call_GetDescribeClusterSubnetGroups_594301;
          ClusterSubnetGroupName: string = ""; Marker: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeClusterSubnetGroups";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusterSubnetGroups
  ## <p>Returns one or more cluster subnet group objects, which contain metadata about your cluster subnet groups. By default, this operation returns information about all cluster subnet groups that are defined in you AWS account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all subnet groups that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subnet groups that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subnet groups are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : The name of the cluster subnet group for which information is requested.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterSubnetGroups</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching cluster subnet groups that are associated with the specified key or keys. For example, suppose that you have subnet groups that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching cluster subnet groups that are associated with the specified tag value or values. For example, suppose that you have subnet groups that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subnet groups that have either or both of these tag values associated with them.
  var query_594320 = newJObject()
  add(query_594320, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_594320, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_594320.add "TagKeys", TagKeys
  add(query_594320, "Action", newJString(Action))
  add(query_594320, "Version", newJString(Version))
  add(query_594320, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_594320.add "TagValues", TagValues
  result = call_594319.call(nil, query_594320, nil, nil, nil)

var getDescribeClusterSubnetGroups* = Call_GetDescribeClusterSubnetGroups_594301(
    name: "getDescribeClusterSubnetGroups", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterSubnetGroups",
    validator: validate_GetDescribeClusterSubnetGroups_594302, base: "/",
    url: url_GetDescribeClusterSubnetGroups_594303,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterTracks_594360 = ref object of OpenApiRestCall_592348
proc url_PostDescribeClusterTracks_594362(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterTracks_594361(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594363 = query.getOrDefault("Action")
  valid_594363 = validateParameter(valid_594363, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_594363 != nil:
    section.add "Action", valid_594363
  var valid_594364 = query.getOrDefault("Version")
  valid_594364 = validateParameter(valid_594364, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594364 != nil:
    section.add "Version", valid_594364
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594365 = header.getOrDefault("X-Amz-Signature")
  valid_594365 = validateParameter(valid_594365, JString, required = false,
                                 default = nil)
  if valid_594365 != nil:
    section.add "X-Amz-Signature", valid_594365
  var valid_594366 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594366 = validateParameter(valid_594366, JString, required = false,
                                 default = nil)
  if valid_594366 != nil:
    section.add "X-Amz-Content-Sha256", valid_594366
  var valid_594367 = header.getOrDefault("X-Amz-Date")
  valid_594367 = validateParameter(valid_594367, JString, required = false,
                                 default = nil)
  if valid_594367 != nil:
    section.add "X-Amz-Date", valid_594367
  var valid_594368 = header.getOrDefault("X-Amz-Credential")
  valid_594368 = validateParameter(valid_594368, JString, required = false,
                                 default = nil)
  if valid_594368 != nil:
    section.add "X-Amz-Credential", valid_594368
  var valid_594369 = header.getOrDefault("X-Amz-Security-Token")
  valid_594369 = validateParameter(valid_594369, JString, required = false,
                                 default = nil)
  if valid_594369 != nil:
    section.add "X-Amz-Security-Token", valid_594369
  var valid_594370 = header.getOrDefault("X-Amz-Algorithm")
  valid_594370 = validateParameter(valid_594370, JString, required = false,
                                 default = nil)
  if valid_594370 != nil:
    section.add "X-Amz-Algorithm", valid_594370
  var valid_594371 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594371 = validateParameter(valid_594371, JString, required = false,
                                 default = nil)
  if valid_594371 != nil:
    section.add "X-Amz-SignedHeaders", valid_594371
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_594372 = formData.getOrDefault("MaintenanceTrackName")
  valid_594372 = validateParameter(valid_594372, JString, required = false,
                                 default = nil)
  if valid_594372 != nil:
    section.add "MaintenanceTrackName", valid_594372
  var valid_594373 = formData.getOrDefault("MaxRecords")
  valid_594373 = validateParameter(valid_594373, JInt, required = false, default = nil)
  if valid_594373 != nil:
    section.add "MaxRecords", valid_594373
  var valid_594374 = formData.getOrDefault("Marker")
  valid_594374 = validateParameter(valid_594374, JString, required = false,
                                 default = nil)
  if valid_594374 != nil:
    section.add "Marker", valid_594374
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594375: Call_PostDescribeClusterTracks_594360; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_594375.validator(path, query, header, formData, body)
  let scheme = call_594375.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594375.url(scheme.get, call_594375.host, call_594375.base,
                         call_594375.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594375, url, valid)

proc call*(call_594376: Call_PostDescribeClusterTracks_594360;
          MaintenanceTrackName: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeClusterTracks"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594377 = newJObject()
  var formData_594378 = newJObject()
  add(formData_594378, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(formData_594378, "MaxRecords", newJInt(MaxRecords))
  add(formData_594378, "Marker", newJString(Marker))
  add(query_594377, "Action", newJString(Action))
  add(query_594377, "Version", newJString(Version))
  result = call_594376.call(nil, query_594377, nil, formData_594378, nil)

var postDescribeClusterTracks* = Call_PostDescribeClusterTracks_594360(
    name: "postDescribeClusterTracks", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_PostDescribeClusterTracks_594361, base: "/",
    url: url_PostDescribeClusterTracks_594362,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterTracks_594342 = ref object of OpenApiRestCall_592348
proc url_GetDescribeClusterTracks_594344(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterTracks_594343(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of all the available maintenance tracks.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track. 
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : An integer value for the maximum number of maintenance tracks to return.
  section = newJObject()
  var valid_594345 = query.getOrDefault("Marker")
  valid_594345 = validateParameter(valid_594345, JString, required = false,
                                 default = nil)
  if valid_594345 != nil:
    section.add "Marker", valid_594345
  var valid_594346 = query.getOrDefault("MaintenanceTrackName")
  valid_594346 = validateParameter(valid_594346, JString, required = false,
                                 default = nil)
  if valid_594346 != nil:
    section.add "MaintenanceTrackName", valid_594346
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594347 = query.getOrDefault("Action")
  valid_594347 = validateParameter(valid_594347, JString, required = true,
                                 default = newJString("DescribeClusterTracks"))
  if valid_594347 != nil:
    section.add "Action", valid_594347
  var valid_594348 = query.getOrDefault("Version")
  valid_594348 = validateParameter(valid_594348, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594348 != nil:
    section.add "Version", valid_594348
  var valid_594349 = query.getOrDefault("MaxRecords")
  valid_594349 = validateParameter(valid_594349, JInt, required = false, default = nil)
  if valid_594349 != nil:
    section.add "MaxRecords", valid_594349
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594350 = header.getOrDefault("X-Amz-Signature")
  valid_594350 = validateParameter(valid_594350, JString, required = false,
                                 default = nil)
  if valid_594350 != nil:
    section.add "X-Amz-Signature", valid_594350
  var valid_594351 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594351 = validateParameter(valid_594351, JString, required = false,
                                 default = nil)
  if valid_594351 != nil:
    section.add "X-Amz-Content-Sha256", valid_594351
  var valid_594352 = header.getOrDefault("X-Amz-Date")
  valid_594352 = validateParameter(valid_594352, JString, required = false,
                                 default = nil)
  if valid_594352 != nil:
    section.add "X-Amz-Date", valid_594352
  var valid_594353 = header.getOrDefault("X-Amz-Credential")
  valid_594353 = validateParameter(valid_594353, JString, required = false,
                                 default = nil)
  if valid_594353 != nil:
    section.add "X-Amz-Credential", valid_594353
  var valid_594354 = header.getOrDefault("X-Amz-Security-Token")
  valid_594354 = validateParameter(valid_594354, JString, required = false,
                                 default = nil)
  if valid_594354 != nil:
    section.add "X-Amz-Security-Token", valid_594354
  var valid_594355 = header.getOrDefault("X-Amz-Algorithm")
  valid_594355 = validateParameter(valid_594355, JString, required = false,
                                 default = nil)
  if valid_594355 != nil:
    section.add "X-Amz-Algorithm", valid_594355
  var valid_594356 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594356 = validateParameter(valid_594356, JString, required = false,
                                 default = nil)
  if valid_594356 != nil:
    section.add "X-Amz-SignedHeaders", valid_594356
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594357: Call_GetDescribeClusterTracks_594342; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of all the available maintenance tracks.
  ## 
  let valid = call_594357.validator(path, query, header, formData, body)
  let scheme = call_594357.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594357.url(scheme.get, call_594357.host, call_594357.base,
                         call_594357.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594357, url, valid)

proc call*(call_594358: Call_GetDescribeClusterTracks_594342; Marker: string = "";
          MaintenanceTrackName: string = "";
          Action: string = "DescribeClusterTracks"; Version: string = "2012-12-01";
          MaxRecords: int = 0): Recallable =
  ## getDescribeClusterTracks
  ## Returns a list of all the available maintenance tracks.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeClusterTracks</code> request exceed the value specified in <code>MaxRecords</code>, Amazon Redshift returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track. 
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : An integer value for the maximum number of maintenance tracks to return.
  var query_594359 = newJObject()
  add(query_594359, "Marker", newJString(Marker))
  add(query_594359, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_594359, "Action", newJString(Action))
  add(query_594359, "Version", newJString(Version))
  add(query_594359, "MaxRecords", newJInt(MaxRecords))
  result = call_594358.call(nil, query_594359, nil, nil, nil)

var getDescribeClusterTracks* = Call_GetDescribeClusterTracks_594342(
    name: "getDescribeClusterTracks", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterTracks",
    validator: validate_GetDescribeClusterTracks_594343, base: "/",
    url: url_GetDescribeClusterTracks_594344, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusterVersions_594398 = ref object of OpenApiRestCall_592348
proc url_PostDescribeClusterVersions_594400(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusterVersions_594399(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594401 = query.getOrDefault("Action")
  valid_594401 = validateParameter(valid_594401, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_594401 != nil:
    section.add "Action", valid_594401
  var valid_594402 = query.getOrDefault("Version")
  valid_594402 = validateParameter(valid_594402, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594402 != nil:
    section.add "Version", valid_594402
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594403 = header.getOrDefault("X-Amz-Signature")
  valid_594403 = validateParameter(valid_594403, JString, required = false,
                                 default = nil)
  if valid_594403 != nil:
    section.add "X-Amz-Signature", valid_594403
  var valid_594404 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594404 = validateParameter(valid_594404, JString, required = false,
                                 default = nil)
  if valid_594404 != nil:
    section.add "X-Amz-Content-Sha256", valid_594404
  var valid_594405 = header.getOrDefault("X-Amz-Date")
  valid_594405 = validateParameter(valid_594405, JString, required = false,
                                 default = nil)
  if valid_594405 != nil:
    section.add "X-Amz-Date", valid_594405
  var valid_594406 = header.getOrDefault("X-Amz-Credential")
  valid_594406 = validateParameter(valid_594406, JString, required = false,
                                 default = nil)
  if valid_594406 != nil:
    section.add "X-Amz-Credential", valid_594406
  var valid_594407 = header.getOrDefault("X-Amz-Security-Token")
  valid_594407 = validateParameter(valid_594407, JString, required = false,
                                 default = nil)
  if valid_594407 != nil:
    section.add "X-Amz-Security-Token", valid_594407
  var valid_594408 = header.getOrDefault("X-Amz-Algorithm")
  valid_594408 = validateParameter(valid_594408, JString, required = false,
                                 default = nil)
  if valid_594408 != nil:
    section.add "X-Amz-Algorithm", valid_594408
  var valid_594409 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594409 = validateParameter(valid_594409, JString, required = false,
                                 default = nil)
  if valid_594409 != nil:
    section.add "X-Amz-SignedHeaders", valid_594409
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  section = newJObject()
  var valid_594410 = formData.getOrDefault("MaxRecords")
  valid_594410 = validateParameter(valid_594410, JInt, required = false, default = nil)
  if valid_594410 != nil:
    section.add "MaxRecords", valid_594410
  var valid_594411 = formData.getOrDefault("ClusterParameterGroupFamily")
  valid_594411 = validateParameter(valid_594411, JString, required = false,
                                 default = nil)
  if valid_594411 != nil:
    section.add "ClusterParameterGroupFamily", valid_594411
  var valid_594412 = formData.getOrDefault("Marker")
  valid_594412 = validateParameter(valid_594412, JString, required = false,
                                 default = nil)
  if valid_594412 != nil:
    section.add "Marker", valid_594412
  var valid_594413 = formData.getOrDefault("ClusterVersion")
  valid_594413 = validateParameter(valid_594413, JString, required = false,
                                 default = nil)
  if valid_594413 != nil:
    section.add "ClusterVersion", valid_594413
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594414: Call_PostDescribeClusterVersions_594398; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_594414.validator(path, query, header, formData, body)
  let scheme = call_594414.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594414.url(scheme.get, call_594414.host, call_594414.base,
                         call_594414.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594414, url, valid)

proc call*(call_594415: Call_PostDescribeClusterVersions_594398;
          MaxRecords: int = 0; ClusterParameterGroupFamily: string = "";
          Marker: string = ""; Action: string = "DescribeClusterVersions";
          ClusterVersion: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Version: string (required)
  var query_594416 = newJObject()
  var formData_594417 = newJObject()
  add(formData_594417, "MaxRecords", newJInt(MaxRecords))
  add(formData_594417, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(formData_594417, "Marker", newJString(Marker))
  add(query_594416, "Action", newJString(Action))
  add(formData_594417, "ClusterVersion", newJString(ClusterVersion))
  add(query_594416, "Version", newJString(Version))
  result = call_594415.call(nil, query_594416, nil, formData_594417, nil)

var postDescribeClusterVersions* = Call_PostDescribeClusterVersions_594398(
    name: "postDescribeClusterVersions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_PostDescribeClusterVersions_594399, base: "/",
    url: url_PostDescribeClusterVersions_594400,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusterVersions_594379 = ref object of OpenApiRestCall_592348
proc url_GetDescribeClusterVersions_594381(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusterVersions_594380(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: JString
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   ClusterVersion: JString
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_594382 = query.getOrDefault("Marker")
  valid_594382 = validateParameter(valid_594382, JString, required = false,
                                 default = nil)
  if valid_594382 != nil:
    section.add "Marker", valid_594382
  var valid_594383 = query.getOrDefault("ClusterParameterGroupFamily")
  valid_594383 = validateParameter(valid_594383, JString, required = false,
                                 default = nil)
  if valid_594383 != nil:
    section.add "ClusterParameterGroupFamily", valid_594383
  var valid_594384 = query.getOrDefault("ClusterVersion")
  valid_594384 = validateParameter(valid_594384, JString, required = false,
                                 default = nil)
  if valid_594384 != nil:
    section.add "ClusterVersion", valid_594384
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594385 = query.getOrDefault("Action")
  valid_594385 = validateParameter(valid_594385, JString, required = true, default = newJString(
      "DescribeClusterVersions"))
  if valid_594385 != nil:
    section.add "Action", valid_594385
  var valid_594386 = query.getOrDefault("Version")
  valid_594386 = validateParameter(valid_594386, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594386 != nil:
    section.add "Version", valid_594386
  var valid_594387 = query.getOrDefault("MaxRecords")
  valid_594387 = validateParameter(valid_594387, JInt, required = false, default = nil)
  if valid_594387 != nil:
    section.add "MaxRecords", valid_594387
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594388 = header.getOrDefault("X-Amz-Signature")
  valid_594388 = validateParameter(valid_594388, JString, required = false,
                                 default = nil)
  if valid_594388 != nil:
    section.add "X-Amz-Signature", valid_594388
  var valid_594389 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594389 = validateParameter(valid_594389, JString, required = false,
                                 default = nil)
  if valid_594389 != nil:
    section.add "X-Amz-Content-Sha256", valid_594389
  var valid_594390 = header.getOrDefault("X-Amz-Date")
  valid_594390 = validateParameter(valid_594390, JString, required = false,
                                 default = nil)
  if valid_594390 != nil:
    section.add "X-Amz-Date", valid_594390
  var valid_594391 = header.getOrDefault("X-Amz-Credential")
  valid_594391 = validateParameter(valid_594391, JString, required = false,
                                 default = nil)
  if valid_594391 != nil:
    section.add "X-Amz-Credential", valid_594391
  var valid_594392 = header.getOrDefault("X-Amz-Security-Token")
  valid_594392 = validateParameter(valid_594392, JString, required = false,
                                 default = nil)
  if valid_594392 != nil:
    section.add "X-Amz-Security-Token", valid_594392
  var valid_594393 = header.getOrDefault("X-Amz-Algorithm")
  valid_594393 = validateParameter(valid_594393, JString, required = false,
                                 default = nil)
  if valid_594393 != nil:
    section.add "X-Amz-Algorithm", valid_594393
  var valid_594394 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594394 = validateParameter(valid_594394, JString, required = false,
                                 default = nil)
  if valid_594394 != nil:
    section.add "X-Amz-SignedHeaders", valid_594394
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594395: Call_GetDescribeClusterVersions_594379; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_594395.validator(path, query, header, formData, body)
  let scheme = call_594395.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594395.url(scheme.get, call_594395.host, call_594395.base,
                         call_594395.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594395, url, valid)

proc call*(call_594396: Call_GetDescribeClusterVersions_594379;
          Marker: string = ""; ClusterParameterGroupFamily: string = "";
          ClusterVersion: string = ""; Action: string = "DescribeClusterVersions";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeClusterVersions
  ## Returns descriptions of the available Amazon Redshift cluster versions. You can call this operation even before creating any clusters to learn more about the Amazon Redshift versions. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusterVersions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterParameterGroupFamily: string
  ##                              : <p>The name of a specific cluster parameter group family to return details for.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   ClusterVersion: string
  ##                 : <p>The specific cluster version to return.</p> <p>Example: <code>1.0</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_594397 = newJObject()
  add(query_594397, "Marker", newJString(Marker))
  add(query_594397, "ClusterParameterGroupFamily",
      newJString(ClusterParameterGroupFamily))
  add(query_594397, "ClusterVersion", newJString(ClusterVersion))
  add(query_594397, "Action", newJString(Action))
  add(query_594397, "Version", newJString(Version))
  add(query_594397, "MaxRecords", newJInt(MaxRecords))
  result = call_594396.call(nil, query_594397, nil, nil, nil)

var getDescribeClusterVersions* = Call_GetDescribeClusterVersions_594379(
    name: "getDescribeClusterVersions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusterVersions",
    validator: validate_GetDescribeClusterVersions_594380, base: "/",
    url: url_GetDescribeClusterVersions_594381,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeClusters_594438 = ref object of OpenApiRestCall_592348
proc url_PostDescribeClusters_594440(protocol: Scheme; host: string; base: string;
                                    route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeClusters_594439(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594441 = query.getOrDefault("Action")
  valid_594441 = validateParameter(valid_594441, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_594441 != nil:
    section.add "Action", valid_594441
  var valid_594442 = query.getOrDefault("Version")
  valid_594442 = validateParameter(valid_594442, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594442 != nil:
    section.add "Version", valid_594442
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594443 = header.getOrDefault("X-Amz-Signature")
  valid_594443 = validateParameter(valid_594443, JString, required = false,
                                 default = nil)
  if valid_594443 != nil:
    section.add "X-Amz-Signature", valid_594443
  var valid_594444 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594444 = validateParameter(valid_594444, JString, required = false,
                                 default = nil)
  if valid_594444 != nil:
    section.add "X-Amz-Content-Sha256", valid_594444
  var valid_594445 = header.getOrDefault("X-Amz-Date")
  valid_594445 = validateParameter(valid_594445, JString, required = false,
                                 default = nil)
  if valid_594445 != nil:
    section.add "X-Amz-Date", valid_594445
  var valid_594446 = header.getOrDefault("X-Amz-Credential")
  valid_594446 = validateParameter(valid_594446, JString, required = false,
                                 default = nil)
  if valid_594446 != nil:
    section.add "X-Amz-Credential", valid_594446
  var valid_594447 = header.getOrDefault("X-Amz-Security-Token")
  valid_594447 = validateParameter(valid_594447, JString, required = false,
                                 default = nil)
  if valid_594447 != nil:
    section.add "X-Amz-Security-Token", valid_594447
  var valid_594448 = header.getOrDefault("X-Amz-Algorithm")
  valid_594448 = validateParameter(valid_594448, JString, required = false,
                                 default = nil)
  if valid_594448 != nil:
    section.add "X-Amz-Algorithm", valid_594448
  var valid_594449 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594449 = validateParameter(valid_594449, JString, required = false,
                                 default = nil)
  if valid_594449 != nil:
    section.add "X-Amz-SignedHeaders", valid_594449
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594450 = formData.getOrDefault("TagKeys")
  valid_594450 = validateParameter(valid_594450, JArray, required = false,
                                 default = nil)
  if valid_594450 != nil:
    section.add "TagKeys", valid_594450
  var valid_594451 = formData.getOrDefault("ClusterIdentifier")
  valid_594451 = validateParameter(valid_594451, JString, required = false,
                                 default = nil)
  if valid_594451 != nil:
    section.add "ClusterIdentifier", valid_594451
  var valid_594452 = formData.getOrDefault("MaxRecords")
  valid_594452 = validateParameter(valid_594452, JInt, required = false, default = nil)
  if valid_594452 != nil:
    section.add "MaxRecords", valid_594452
  var valid_594453 = formData.getOrDefault("Marker")
  valid_594453 = validateParameter(valid_594453, JString, required = false,
                                 default = nil)
  if valid_594453 != nil:
    section.add "Marker", valid_594453
  var valid_594454 = formData.getOrDefault("TagValues")
  valid_594454 = validateParameter(valid_594454, JArray, required = false,
                                 default = nil)
  if valid_594454 != nil:
    section.add "TagValues", valid_594454
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594455: Call_PostDescribeClusters_594438; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594455.validator(path, query, header, formData, body)
  let scheme = call_594455.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594455.url(scheme.get, call_594455.host, call_594455.base,
                         call_594455.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594455, url, valid)

proc call*(call_594456: Call_PostDescribeClusters_594438; TagKeys: JsonNode = nil;
          ClusterIdentifier: string = ""; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeClusters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594457 = newJObject()
  var formData_594458 = newJObject()
  if TagKeys != nil:
    formData_594458.add "TagKeys", TagKeys
  add(formData_594458, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_594458, "MaxRecords", newJInt(MaxRecords))
  add(formData_594458, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_594458.add "TagValues", TagValues
  add(query_594457, "Action", newJString(Action))
  add(query_594457, "Version", newJString(Version))
  result = call_594456.call(nil, query_594457, nil, formData_594458, nil)

var postDescribeClusters* = Call_PostDescribeClusters_594438(
    name: "postDescribeClusters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_PostDescribeClusters_594439, base: "/",
    url: url_PostDescribeClusters_594440, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeClusters_594418 = ref object of OpenApiRestCall_592348
proc url_GetDescribeClusters_594420(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeClusters_594419(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594421 = query.getOrDefault("Marker")
  valid_594421 = validateParameter(valid_594421, JString, required = false,
                                 default = nil)
  if valid_594421 != nil:
    section.add "Marker", valid_594421
  var valid_594422 = query.getOrDefault("TagKeys")
  valid_594422 = validateParameter(valid_594422, JArray, required = false,
                                 default = nil)
  if valid_594422 != nil:
    section.add "TagKeys", valid_594422
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594423 = query.getOrDefault("Action")
  valid_594423 = validateParameter(valid_594423, JString, required = true,
                                 default = newJString("DescribeClusters"))
  if valid_594423 != nil:
    section.add "Action", valid_594423
  var valid_594424 = query.getOrDefault("ClusterIdentifier")
  valid_594424 = validateParameter(valid_594424, JString, required = false,
                                 default = nil)
  if valid_594424 != nil:
    section.add "ClusterIdentifier", valid_594424
  var valid_594425 = query.getOrDefault("Version")
  valid_594425 = validateParameter(valid_594425, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594425 != nil:
    section.add "Version", valid_594425
  var valid_594426 = query.getOrDefault("MaxRecords")
  valid_594426 = validateParameter(valid_594426, JInt, required = false, default = nil)
  if valid_594426 != nil:
    section.add "MaxRecords", valid_594426
  var valid_594427 = query.getOrDefault("TagValues")
  valid_594427 = validateParameter(valid_594427, JArray, required = false,
                                 default = nil)
  if valid_594427 != nil:
    section.add "TagValues", valid_594427
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594428 = header.getOrDefault("X-Amz-Signature")
  valid_594428 = validateParameter(valid_594428, JString, required = false,
                                 default = nil)
  if valid_594428 != nil:
    section.add "X-Amz-Signature", valid_594428
  var valid_594429 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594429 = validateParameter(valid_594429, JString, required = false,
                                 default = nil)
  if valid_594429 != nil:
    section.add "X-Amz-Content-Sha256", valid_594429
  var valid_594430 = header.getOrDefault("X-Amz-Date")
  valid_594430 = validateParameter(valid_594430, JString, required = false,
                                 default = nil)
  if valid_594430 != nil:
    section.add "X-Amz-Date", valid_594430
  var valid_594431 = header.getOrDefault("X-Amz-Credential")
  valid_594431 = validateParameter(valid_594431, JString, required = false,
                                 default = nil)
  if valid_594431 != nil:
    section.add "X-Amz-Credential", valid_594431
  var valid_594432 = header.getOrDefault("X-Amz-Security-Token")
  valid_594432 = validateParameter(valid_594432, JString, required = false,
                                 default = nil)
  if valid_594432 != nil:
    section.add "X-Amz-Security-Token", valid_594432
  var valid_594433 = header.getOrDefault("X-Amz-Algorithm")
  valid_594433 = validateParameter(valid_594433, JString, required = false,
                                 default = nil)
  if valid_594433 != nil:
    section.add "X-Amz-Algorithm", valid_594433
  var valid_594434 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594434 = validateParameter(valid_594434, JString, required = false,
                                 default = nil)
  if valid_594434 != nil:
    section.add "X-Amz-SignedHeaders", valid_594434
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594435: Call_GetDescribeClusters_594418; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594435.validator(path, query, header, formData, body)
  let scheme = call_594435.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594435.url(scheme.get, call_594435.host, call_594435.base,
                         call_594435.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594435, url, valid)

proc call*(call_594436: Call_GetDescribeClusters_594418; Marker: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeClusters";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeClusters
  ## <p>Returns properties of provisioned clusters including general cluster properties, cluster database properties, maintenance and backup properties, and security and access properties. This operation supports pagination. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all clusters that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all clusters that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, clusters are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeClusters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>ClusterIdentifier</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching clusters that are associated with the specified key or keys. For example, suppose that you have clusters that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : <p>The unique identifier of a cluster whose properties you are requesting. This parameter is case sensitive.</p> <p>The default is that all clusters defined for an account are returned.</p>
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching clusters that are associated with the specified tag value or values. For example, suppose that you have clusters that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the clusters that have either or both of these tag values associated with them.
  var query_594437 = newJObject()
  add(query_594437, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_594437.add "TagKeys", TagKeys
  add(query_594437, "Action", newJString(Action))
  add(query_594437, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594437, "Version", newJString(Version))
  add(query_594437, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_594437.add "TagValues", TagValues
  result = call_594436.call(nil, query_594437, nil, nil, nil)

var getDescribeClusters* = Call_GetDescribeClusters_594418(
    name: "getDescribeClusters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeClusters",
    validator: validate_GetDescribeClusters_594419, base: "/",
    url: url_GetDescribeClusters_594420, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeDefaultClusterParameters_594477 = ref object of OpenApiRestCall_592348
proc url_PostDescribeDefaultClusterParameters_594479(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeDefaultClusterParameters_594478(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594480 = query.getOrDefault("Action")
  valid_594480 = validateParameter(valid_594480, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_594480 != nil:
    section.add "Action", valid_594480
  var valid_594481 = query.getOrDefault("Version")
  valid_594481 = validateParameter(valid_594481, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594481 != nil:
    section.add "Version", valid_594481
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594482 = header.getOrDefault("X-Amz-Signature")
  valid_594482 = validateParameter(valid_594482, JString, required = false,
                                 default = nil)
  if valid_594482 != nil:
    section.add "X-Amz-Signature", valid_594482
  var valid_594483 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594483 = validateParameter(valid_594483, JString, required = false,
                                 default = nil)
  if valid_594483 != nil:
    section.add "X-Amz-Content-Sha256", valid_594483
  var valid_594484 = header.getOrDefault("X-Amz-Date")
  valid_594484 = validateParameter(valid_594484, JString, required = false,
                                 default = nil)
  if valid_594484 != nil:
    section.add "X-Amz-Date", valid_594484
  var valid_594485 = header.getOrDefault("X-Amz-Credential")
  valid_594485 = validateParameter(valid_594485, JString, required = false,
                                 default = nil)
  if valid_594485 != nil:
    section.add "X-Amz-Credential", valid_594485
  var valid_594486 = header.getOrDefault("X-Amz-Security-Token")
  valid_594486 = validateParameter(valid_594486, JString, required = false,
                                 default = nil)
  if valid_594486 != nil:
    section.add "X-Amz-Security-Token", valid_594486
  var valid_594487 = header.getOrDefault("X-Amz-Algorithm")
  valid_594487 = validateParameter(valid_594487, JString, required = false,
                                 default = nil)
  if valid_594487 != nil:
    section.add "X-Amz-Algorithm", valid_594487
  var valid_594488 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594488 = validateParameter(valid_594488, JString, required = false,
                                 default = nil)
  if valid_594488 != nil:
    section.add "X-Amz-SignedHeaders", valid_594488
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  section = newJObject()
  var valid_594489 = formData.getOrDefault("MaxRecords")
  valid_594489 = validateParameter(valid_594489, JInt, required = false, default = nil)
  if valid_594489 != nil:
    section.add "MaxRecords", valid_594489
  var valid_594490 = formData.getOrDefault("Marker")
  valid_594490 = validateParameter(valid_594490, JString, required = false,
                                 default = nil)
  if valid_594490 != nil:
    section.add "Marker", valid_594490
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupFamily` field"
  var valid_594491 = formData.getOrDefault("ParameterGroupFamily")
  valid_594491 = validateParameter(valid_594491, JString, required = true,
                                 default = nil)
  if valid_594491 != nil:
    section.add "ParameterGroupFamily", valid_594491
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594492: Call_PostDescribeDefaultClusterParameters_594477;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594492.validator(path, query, header, formData, body)
  let scheme = call_594492.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594492.url(scheme.get, call_594492.host, call_594492.base,
                         call_594492.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594492, url, valid)

proc call*(call_594493: Call_PostDescribeDefaultClusterParameters_594477;
          ParameterGroupFamily: string; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594494 = newJObject()
  var formData_594495 = newJObject()
  add(formData_594495, "MaxRecords", newJInt(MaxRecords))
  add(formData_594495, "Marker", newJString(Marker))
  add(formData_594495, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_594494, "Action", newJString(Action))
  add(query_594494, "Version", newJString(Version))
  result = call_594493.call(nil, query_594494, nil, formData_594495, nil)

var postDescribeDefaultClusterParameters* = Call_PostDescribeDefaultClusterParameters_594477(
    name: "postDescribeDefaultClusterParameters", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_PostDescribeDefaultClusterParameters_594478, base: "/",
    url: url_PostDescribeDefaultClusterParameters_594479,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeDefaultClusterParameters_594459 = ref object of OpenApiRestCall_592348
proc url_GetDescribeDefaultClusterParameters_594461(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeDefaultClusterParameters_594460(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: JString (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_594462 = query.getOrDefault("Marker")
  valid_594462 = validateParameter(valid_594462, JString, required = false,
                                 default = nil)
  if valid_594462 != nil:
    section.add "Marker", valid_594462
  assert query != nil, "query argument is necessary due to required `ParameterGroupFamily` field"
  var valid_594463 = query.getOrDefault("ParameterGroupFamily")
  valid_594463 = validateParameter(valid_594463, JString, required = true,
                                 default = nil)
  if valid_594463 != nil:
    section.add "ParameterGroupFamily", valid_594463
  var valid_594464 = query.getOrDefault("Action")
  valid_594464 = validateParameter(valid_594464, JString, required = true, default = newJString(
      "DescribeDefaultClusterParameters"))
  if valid_594464 != nil:
    section.add "Action", valid_594464
  var valid_594465 = query.getOrDefault("Version")
  valid_594465 = validateParameter(valid_594465, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594465 != nil:
    section.add "Version", valid_594465
  var valid_594466 = query.getOrDefault("MaxRecords")
  valid_594466 = validateParameter(valid_594466, JInt, required = false, default = nil)
  if valid_594466 != nil:
    section.add "MaxRecords", valid_594466
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594467 = header.getOrDefault("X-Amz-Signature")
  valid_594467 = validateParameter(valid_594467, JString, required = false,
                                 default = nil)
  if valid_594467 != nil:
    section.add "X-Amz-Signature", valid_594467
  var valid_594468 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594468 = validateParameter(valid_594468, JString, required = false,
                                 default = nil)
  if valid_594468 != nil:
    section.add "X-Amz-Content-Sha256", valid_594468
  var valid_594469 = header.getOrDefault("X-Amz-Date")
  valid_594469 = validateParameter(valid_594469, JString, required = false,
                                 default = nil)
  if valid_594469 != nil:
    section.add "X-Amz-Date", valid_594469
  var valid_594470 = header.getOrDefault("X-Amz-Credential")
  valid_594470 = validateParameter(valid_594470, JString, required = false,
                                 default = nil)
  if valid_594470 != nil:
    section.add "X-Amz-Credential", valid_594470
  var valid_594471 = header.getOrDefault("X-Amz-Security-Token")
  valid_594471 = validateParameter(valid_594471, JString, required = false,
                                 default = nil)
  if valid_594471 != nil:
    section.add "X-Amz-Security-Token", valid_594471
  var valid_594472 = header.getOrDefault("X-Amz-Algorithm")
  valid_594472 = validateParameter(valid_594472, JString, required = false,
                                 default = nil)
  if valid_594472 != nil:
    section.add "X-Amz-Algorithm", valid_594472
  var valid_594473 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594473 = validateParameter(valid_594473, JString, required = false,
                                 default = nil)
  if valid_594473 != nil:
    section.add "X-Amz-SignedHeaders", valid_594473
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594474: Call_GetDescribeDefaultClusterParameters_594459;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594474.validator(path, query, header, formData, body)
  let scheme = call_594474.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594474.url(scheme.get, call_594474.host, call_594474.base,
                         call_594474.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594474, url, valid)

proc call*(call_594475: Call_GetDescribeDefaultClusterParameters_594459;
          ParameterGroupFamily: string; Marker: string = "";
          Action: string = "DescribeDefaultClusterParameters";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeDefaultClusterParameters
  ## <p>Returns a list of parameter settings for the specified parameter group family.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeDefaultClusterParameters</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ParameterGroupFamily: string (required)
  ##                       : The name of the cluster parameter group family.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_594476 = newJObject()
  add(query_594476, "Marker", newJString(Marker))
  add(query_594476, "ParameterGroupFamily", newJString(ParameterGroupFamily))
  add(query_594476, "Action", newJString(Action))
  add(query_594476, "Version", newJString(Version))
  add(query_594476, "MaxRecords", newJInt(MaxRecords))
  result = call_594475.call(nil, query_594476, nil, nil, nil)

var getDescribeDefaultClusterParameters* = Call_GetDescribeDefaultClusterParameters_594459(
    name: "getDescribeDefaultClusterParameters", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeDefaultClusterParameters",
    validator: validate_GetDescribeDefaultClusterParameters_594460, base: "/",
    url: url_GetDescribeDefaultClusterParameters_594461,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventCategories_594512 = ref object of OpenApiRestCall_592348
proc url_PostDescribeEventCategories_594514(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeEventCategories_594513(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594515 = query.getOrDefault("Action")
  valid_594515 = validateParameter(valid_594515, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_594515 != nil:
    section.add "Action", valid_594515
  var valid_594516 = query.getOrDefault("Version")
  valid_594516 = validateParameter(valid_594516, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594516 != nil:
    section.add "Version", valid_594516
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594517 = header.getOrDefault("X-Amz-Signature")
  valid_594517 = validateParameter(valid_594517, JString, required = false,
                                 default = nil)
  if valid_594517 != nil:
    section.add "X-Amz-Signature", valid_594517
  var valid_594518 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594518 = validateParameter(valid_594518, JString, required = false,
                                 default = nil)
  if valid_594518 != nil:
    section.add "X-Amz-Content-Sha256", valid_594518
  var valid_594519 = header.getOrDefault("X-Amz-Date")
  valid_594519 = validateParameter(valid_594519, JString, required = false,
                                 default = nil)
  if valid_594519 != nil:
    section.add "X-Amz-Date", valid_594519
  var valid_594520 = header.getOrDefault("X-Amz-Credential")
  valid_594520 = validateParameter(valid_594520, JString, required = false,
                                 default = nil)
  if valid_594520 != nil:
    section.add "X-Amz-Credential", valid_594520
  var valid_594521 = header.getOrDefault("X-Amz-Security-Token")
  valid_594521 = validateParameter(valid_594521, JString, required = false,
                                 default = nil)
  if valid_594521 != nil:
    section.add "X-Amz-Security-Token", valid_594521
  var valid_594522 = header.getOrDefault("X-Amz-Algorithm")
  valid_594522 = validateParameter(valid_594522, JString, required = false,
                                 default = nil)
  if valid_594522 != nil:
    section.add "X-Amz-Algorithm", valid_594522
  var valid_594523 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594523 = validateParameter(valid_594523, JString, required = false,
                                 default = nil)
  if valid_594523 != nil:
    section.add "X-Amz-SignedHeaders", valid_594523
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  section = newJObject()
  var valid_594524 = formData.getOrDefault("SourceType")
  valid_594524 = validateParameter(valid_594524, JString, required = false,
                                 default = nil)
  if valid_594524 != nil:
    section.add "SourceType", valid_594524
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594525: Call_PostDescribeEventCategories_594512; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_594525.validator(path, query, header, formData, body)
  let scheme = call_594525.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594525.url(scheme.get, call_594525.host, call_594525.base,
                         call_594525.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594525, url, valid)

proc call*(call_594526: Call_PostDescribeEventCategories_594512;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594527 = newJObject()
  var formData_594528 = newJObject()
  add(formData_594528, "SourceType", newJString(SourceType))
  add(query_594527, "Action", newJString(Action))
  add(query_594527, "Version", newJString(Version))
  result = call_594526.call(nil, query_594527, nil, formData_594528, nil)

var postDescribeEventCategories* = Call_PostDescribeEventCategories_594512(
    name: "postDescribeEventCategories", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_PostDescribeEventCategories_594513, base: "/",
    url: url_PostDescribeEventCategories_594514,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventCategories_594496 = ref object of OpenApiRestCall_592348
proc url_GetDescribeEventCategories_594498(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeEventCategories_594497(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  var valid_594499 = query.getOrDefault("SourceType")
  valid_594499 = validateParameter(valid_594499, JString, required = false,
                                 default = nil)
  if valid_594499 != nil:
    section.add "SourceType", valid_594499
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594500 = query.getOrDefault("Action")
  valid_594500 = validateParameter(valid_594500, JString, required = true, default = newJString(
      "DescribeEventCategories"))
  if valid_594500 != nil:
    section.add "Action", valid_594500
  var valid_594501 = query.getOrDefault("Version")
  valid_594501 = validateParameter(valid_594501, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594501 != nil:
    section.add "Version", valid_594501
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594502 = header.getOrDefault("X-Amz-Signature")
  valid_594502 = validateParameter(valid_594502, JString, required = false,
                                 default = nil)
  if valid_594502 != nil:
    section.add "X-Amz-Signature", valid_594502
  var valid_594503 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594503 = validateParameter(valid_594503, JString, required = false,
                                 default = nil)
  if valid_594503 != nil:
    section.add "X-Amz-Content-Sha256", valid_594503
  var valid_594504 = header.getOrDefault("X-Amz-Date")
  valid_594504 = validateParameter(valid_594504, JString, required = false,
                                 default = nil)
  if valid_594504 != nil:
    section.add "X-Amz-Date", valid_594504
  var valid_594505 = header.getOrDefault("X-Amz-Credential")
  valid_594505 = validateParameter(valid_594505, JString, required = false,
                                 default = nil)
  if valid_594505 != nil:
    section.add "X-Amz-Credential", valid_594505
  var valid_594506 = header.getOrDefault("X-Amz-Security-Token")
  valid_594506 = validateParameter(valid_594506, JString, required = false,
                                 default = nil)
  if valid_594506 != nil:
    section.add "X-Amz-Security-Token", valid_594506
  var valid_594507 = header.getOrDefault("X-Amz-Algorithm")
  valid_594507 = validateParameter(valid_594507, JString, required = false,
                                 default = nil)
  if valid_594507 != nil:
    section.add "X-Amz-Algorithm", valid_594507
  var valid_594508 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594508 = validateParameter(valid_594508, JString, required = false,
                                 default = nil)
  if valid_594508 != nil:
    section.add "X-Amz-SignedHeaders", valid_594508
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594509: Call_GetDescribeEventCategories_594496; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ## 
  let valid = call_594509.validator(path, query, header, formData, body)
  let scheme = call_594509.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594509.url(scheme.get, call_594509.host, call_594509.base,
                         call_594509.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594509, url, valid)

proc call*(call_594510: Call_GetDescribeEventCategories_594496;
          SourceType: string = ""; Action: string = "DescribeEventCategories";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeEventCategories
  ## Displays a list of event categories for all event source types, or for a specified source type. For a list of the event categories and source types, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-event-notifications.html">Amazon Redshift Event Notifications</a>.
  ##   SourceType: string
  ##             : <p>The source type, such as cluster or parameter group, to which the described event categories apply.</p> <p>Valid values: cluster, cluster-snapshot, cluster-parameter-group, and cluster-security-group.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594511 = newJObject()
  add(query_594511, "SourceType", newJString(SourceType))
  add(query_594511, "Action", newJString(Action))
  add(query_594511, "Version", newJString(Version))
  result = call_594510.call(nil, query_594511, nil, nil, nil)

var getDescribeEventCategories* = Call_GetDescribeEventCategories_594496(
    name: "getDescribeEventCategories", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventCategories",
    validator: validate_GetDescribeEventCategories_594497, base: "/",
    url: url_GetDescribeEventCategories_594498,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEventSubscriptions_594549 = ref object of OpenApiRestCall_592348
proc url_PostDescribeEventSubscriptions_594551(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeEventSubscriptions_594550(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594552 = query.getOrDefault("Action")
  valid_594552 = validateParameter(valid_594552, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_594552 != nil:
    section.add "Action", valid_594552
  var valid_594553 = query.getOrDefault("Version")
  valid_594553 = validateParameter(valid_594553, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594553 != nil:
    section.add "Version", valid_594553
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594554 = header.getOrDefault("X-Amz-Signature")
  valid_594554 = validateParameter(valid_594554, JString, required = false,
                                 default = nil)
  if valid_594554 != nil:
    section.add "X-Amz-Signature", valid_594554
  var valid_594555 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594555 = validateParameter(valid_594555, JString, required = false,
                                 default = nil)
  if valid_594555 != nil:
    section.add "X-Amz-Content-Sha256", valid_594555
  var valid_594556 = header.getOrDefault("X-Amz-Date")
  valid_594556 = validateParameter(valid_594556, JString, required = false,
                                 default = nil)
  if valid_594556 != nil:
    section.add "X-Amz-Date", valid_594556
  var valid_594557 = header.getOrDefault("X-Amz-Credential")
  valid_594557 = validateParameter(valid_594557, JString, required = false,
                                 default = nil)
  if valid_594557 != nil:
    section.add "X-Amz-Credential", valid_594557
  var valid_594558 = header.getOrDefault("X-Amz-Security-Token")
  valid_594558 = validateParameter(valid_594558, JString, required = false,
                                 default = nil)
  if valid_594558 != nil:
    section.add "X-Amz-Security-Token", valid_594558
  var valid_594559 = header.getOrDefault("X-Amz-Algorithm")
  valid_594559 = validateParameter(valid_594559, JString, required = false,
                                 default = nil)
  if valid_594559 != nil:
    section.add "X-Amz-Algorithm", valid_594559
  var valid_594560 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594560 = validateParameter(valid_594560, JString, required = false,
                                 default = nil)
  if valid_594560 != nil:
    section.add "X-Amz-SignedHeaders", valid_594560
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594561 = formData.getOrDefault("TagKeys")
  valid_594561 = validateParameter(valid_594561, JArray, required = false,
                                 default = nil)
  if valid_594561 != nil:
    section.add "TagKeys", valid_594561
  var valid_594562 = formData.getOrDefault("MaxRecords")
  valid_594562 = validateParameter(valid_594562, JInt, required = false, default = nil)
  if valid_594562 != nil:
    section.add "MaxRecords", valid_594562
  var valid_594563 = formData.getOrDefault("Marker")
  valid_594563 = validateParameter(valid_594563, JString, required = false,
                                 default = nil)
  if valid_594563 != nil:
    section.add "Marker", valid_594563
  var valid_594564 = formData.getOrDefault("SubscriptionName")
  valid_594564 = validateParameter(valid_594564, JString, required = false,
                                 default = nil)
  if valid_594564 != nil:
    section.add "SubscriptionName", valid_594564
  var valid_594565 = formData.getOrDefault("TagValues")
  valid_594565 = validateParameter(valid_594565, JArray, required = false,
                                 default = nil)
  if valid_594565 != nil:
    section.add "TagValues", valid_594565
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594566: Call_PostDescribeEventSubscriptions_594549; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594566.validator(path, query, header, formData, body)
  let scheme = call_594566.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594566.url(scheme.get, call_594566.host, call_594566.base,
                         call_594566.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594566, url, valid)

proc call*(call_594567: Call_PostDescribeEventSubscriptions_594549;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          SubscriptionName: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeEventSubscriptions";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594568 = newJObject()
  var formData_594569 = newJObject()
  if TagKeys != nil:
    formData_594569.add "TagKeys", TagKeys
  add(formData_594569, "MaxRecords", newJInt(MaxRecords))
  add(formData_594569, "Marker", newJString(Marker))
  add(formData_594569, "SubscriptionName", newJString(SubscriptionName))
  if TagValues != nil:
    formData_594569.add "TagValues", TagValues
  add(query_594568, "Action", newJString(Action))
  add(query_594568, "Version", newJString(Version))
  result = call_594567.call(nil, query_594568, nil, formData_594569, nil)

var postDescribeEventSubscriptions* = Call_PostDescribeEventSubscriptions_594549(
    name: "postDescribeEventSubscriptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_PostDescribeEventSubscriptions_594550, base: "/",
    url: url_PostDescribeEventSubscriptions_594551,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEventSubscriptions_594529 = ref object of OpenApiRestCall_592348
proc url_GetDescribeEventSubscriptions_594531(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeEventSubscriptions_594530(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   SubscriptionName: JString
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594532 = query.getOrDefault("Marker")
  valid_594532 = validateParameter(valid_594532, JString, required = false,
                                 default = nil)
  if valid_594532 != nil:
    section.add "Marker", valid_594532
  var valid_594533 = query.getOrDefault("TagKeys")
  valid_594533 = validateParameter(valid_594533, JArray, required = false,
                                 default = nil)
  if valid_594533 != nil:
    section.add "TagKeys", valid_594533
  var valid_594534 = query.getOrDefault("SubscriptionName")
  valid_594534 = validateParameter(valid_594534, JString, required = false,
                                 default = nil)
  if valid_594534 != nil:
    section.add "SubscriptionName", valid_594534
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594535 = query.getOrDefault("Action")
  valid_594535 = validateParameter(valid_594535, JString, required = true, default = newJString(
      "DescribeEventSubscriptions"))
  if valid_594535 != nil:
    section.add "Action", valid_594535
  var valid_594536 = query.getOrDefault("Version")
  valid_594536 = validateParameter(valid_594536, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594536 != nil:
    section.add "Version", valid_594536
  var valid_594537 = query.getOrDefault("MaxRecords")
  valid_594537 = validateParameter(valid_594537, JInt, required = false, default = nil)
  if valid_594537 != nil:
    section.add "MaxRecords", valid_594537
  var valid_594538 = query.getOrDefault("TagValues")
  valid_594538 = validateParameter(valid_594538, JArray, required = false,
                                 default = nil)
  if valid_594538 != nil:
    section.add "TagValues", valid_594538
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594539 = header.getOrDefault("X-Amz-Signature")
  valid_594539 = validateParameter(valid_594539, JString, required = false,
                                 default = nil)
  if valid_594539 != nil:
    section.add "X-Amz-Signature", valid_594539
  var valid_594540 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594540 = validateParameter(valid_594540, JString, required = false,
                                 default = nil)
  if valid_594540 != nil:
    section.add "X-Amz-Content-Sha256", valid_594540
  var valid_594541 = header.getOrDefault("X-Amz-Date")
  valid_594541 = validateParameter(valid_594541, JString, required = false,
                                 default = nil)
  if valid_594541 != nil:
    section.add "X-Amz-Date", valid_594541
  var valid_594542 = header.getOrDefault("X-Amz-Credential")
  valid_594542 = validateParameter(valid_594542, JString, required = false,
                                 default = nil)
  if valid_594542 != nil:
    section.add "X-Amz-Credential", valid_594542
  var valid_594543 = header.getOrDefault("X-Amz-Security-Token")
  valid_594543 = validateParameter(valid_594543, JString, required = false,
                                 default = nil)
  if valid_594543 != nil:
    section.add "X-Amz-Security-Token", valid_594543
  var valid_594544 = header.getOrDefault("X-Amz-Algorithm")
  valid_594544 = validateParameter(valid_594544, JString, required = false,
                                 default = nil)
  if valid_594544 != nil:
    section.add "X-Amz-Algorithm", valid_594544
  var valid_594545 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594545 = validateParameter(valid_594545, JString, required = false,
                                 default = nil)
  if valid_594545 != nil:
    section.add "X-Amz-SignedHeaders", valid_594545
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594546: Call_GetDescribeEventSubscriptions_594529; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594546.validator(path, query, header, formData, body)
  let scheme = call_594546.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594546.url(scheme.get, call_594546.host, call_594546.base,
                         call_594546.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594546, url, valid)

proc call*(call_594547: Call_GetDescribeEventSubscriptions_594529;
          Marker: string = ""; TagKeys: JsonNode = nil; SubscriptionName: string = "";
          Action: string = "DescribeEventSubscriptions";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeEventSubscriptions
  ## <p>Lists descriptions of all the Amazon Redshift event notification subscriptions for a customer account. If you specify a subscription name, lists the description for that subscription.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all event notification subscriptions that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all subscriptions that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, subscriptions are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a DescribeEventSubscriptions request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching event notification subscriptions that are associated with the specified key or keys. For example, suppose that you have subscriptions that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag keys associated with them.
  ##   SubscriptionName: string
  ##                   : The name of the Amazon Redshift event notification subscription to be described.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching event notification subscriptions that are associated with the specified tag value or values. For example, suppose that you have subscriptions that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the subscriptions that have either or both of these tag values associated with them.
  var query_594548 = newJObject()
  add(query_594548, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_594548.add "TagKeys", TagKeys
  add(query_594548, "SubscriptionName", newJString(SubscriptionName))
  add(query_594548, "Action", newJString(Action))
  add(query_594548, "Version", newJString(Version))
  add(query_594548, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_594548.add "TagValues", TagValues
  result = call_594547.call(nil, query_594548, nil, nil, nil)

var getDescribeEventSubscriptions* = Call_GetDescribeEventSubscriptions_594529(
    name: "getDescribeEventSubscriptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEventSubscriptions",
    validator: validate_GetDescribeEventSubscriptions_594530, base: "/",
    url: url_GetDescribeEventSubscriptions_594531,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeEvents_594592 = ref object of OpenApiRestCall_592348
proc url_PostDescribeEvents_594594(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeEvents_594593(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594595 = query.getOrDefault("Action")
  valid_594595 = validateParameter(valid_594595, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_594595 != nil:
    section.add "Action", valid_594595
  var valid_594596 = query.getOrDefault("Version")
  valid_594596 = validateParameter(valid_594596, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594596 != nil:
    section.add "Version", valid_594596
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594597 = header.getOrDefault("X-Amz-Signature")
  valid_594597 = validateParameter(valid_594597, JString, required = false,
                                 default = nil)
  if valid_594597 != nil:
    section.add "X-Amz-Signature", valid_594597
  var valid_594598 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594598 = validateParameter(valid_594598, JString, required = false,
                                 default = nil)
  if valid_594598 != nil:
    section.add "X-Amz-Content-Sha256", valid_594598
  var valid_594599 = header.getOrDefault("X-Amz-Date")
  valid_594599 = validateParameter(valid_594599, JString, required = false,
                                 default = nil)
  if valid_594599 != nil:
    section.add "X-Amz-Date", valid_594599
  var valid_594600 = header.getOrDefault("X-Amz-Credential")
  valid_594600 = validateParameter(valid_594600, JString, required = false,
                                 default = nil)
  if valid_594600 != nil:
    section.add "X-Amz-Credential", valid_594600
  var valid_594601 = header.getOrDefault("X-Amz-Security-Token")
  valid_594601 = validateParameter(valid_594601, JString, required = false,
                                 default = nil)
  if valid_594601 != nil:
    section.add "X-Amz-Security-Token", valid_594601
  var valid_594602 = header.getOrDefault("X-Amz-Algorithm")
  valid_594602 = validateParameter(valid_594602, JString, required = false,
                                 default = nil)
  if valid_594602 != nil:
    section.add "X-Amz-Algorithm", valid_594602
  var valid_594603 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594603 = validateParameter(valid_594603, JString, required = false,
                                 default = nil)
  if valid_594603 != nil:
    section.add "X-Amz-SignedHeaders", valid_594603
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  section = newJObject()
  var valid_594604 = formData.getOrDefault("MaxRecords")
  valid_594604 = validateParameter(valid_594604, JInt, required = false, default = nil)
  if valid_594604 != nil:
    section.add "MaxRecords", valid_594604
  var valid_594605 = formData.getOrDefault("Marker")
  valid_594605 = validateParameter(valid_594605, JString, required = false,
                                 default = nil)
  if valid_594605 != nil:
    section.add "Marker", valid_594605
  var valid_594606 = formData.getOrDefault("SourceIdentifier")
  valid_594606 = validateParameter(valid_594606, JString, required = false,
                                 default = nil)
  if valid_594606 != nil:
    section.add "SourceIdentifier", valid_594606
  var valid_594607 = formData.getOrDefault("SourceType")
  valid_594607 = validateParameter(valid_594607, JString, required = false,
                                 default = newJString("cluster"))
  if valid_594607 != nil:
    section.add "SourceType", valid_594607
  var valid_594608 = formData.getOrDefault("Duration")
  valid_594608 = validateParameter(valid_594608, JInt, required = false, default = nil)
  if valid_594608 != nil:
    section.add "Duration", valid_594608
  var valid_594609 = formData.getOrDefault("EndTime")
  valid_594609 = validateParameter(valid_594609, JString, required = false,
                                 default = nil)
  if valid_594609 != nil:
    section.add "EndTime", valid_594609
  var valid_594610 = formData.getOrDefault("StartTime")
  valid_594610 = validateParameter(valid_594610, JString, required = false,
                                 default = nil)
  if valid_594610 != nil:
    section.add "StartTime", valid_594610
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594611: Call_PostDescribeEvents_594592; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_594611.validator(path, query, header, formData, body)
  let scheme = call_594611.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594611.url(scheme.get, call_594611.host, call_594611.base,
                         call_594611.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594611, url, valid)

proc call*(call_594612: Call_PostDescribeEvents_594592; MaxRecords: int = 0;
          Marker: string = ""; SourceIdentifier: string = "";
          SourceType: string = "cluster"; Duration: int = 0; EndTime: string = "";
          StartTime: string = ""; Action: string = "DescribeEvents";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594613 = newJObject()
  var formData_594614 = newJObject()
  add(formData_594614, "MaxRecords", newJInt(MaxRecords))
  add(formData_594614, "Marker", newJString(Marker))
  add(formData_594614, "SourceIdentifier", newJString(SourceIdentifier))
  add(formData_594614, "SourceType", newJString(SourceType))
  add(formData_594614, "Duration", newJInt(Duration))
  add(formData_594614, "EndTime", newJString(EndTime))
  add(formData_594614, "StartTime", newJString(StartTime))
  add(query_594613, "Action", newJString(Action))
  add(query_594613, "Version", newJString(Version))
  result = call_594612.call(nil, query_594613, nil, formData_594614, nil)

var postDescribeEvents* = Call_PostDescribeEvents_594592(
    name: "postDescribeEvents", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeEvents",
    validator: validate_PostDescribeEvents_594593, base: "/",
    url: url_PostDescribeEvents_594594, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeEvents_594570 = ref object of OpenApiRestCall_592348
proc url_GetDescribeEvents_594572(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeEvents_594571(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceType: JString
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   SourceIdentifier: JString
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Action: JString (required)
  ##   StartTime: JString
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: JInt
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: JString
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_594573 = query.getOrDefault("Marker")
  valid_594573 = validateParameter(valid_594573, JString, required = false,
                                 default = nil)
  if valid_594573 != nil:
    section.add "Marker", valid_594573
  var valid_594574 = query.getOrDefault("SourceType")
  valid_594574 = validateParameter(valid_594574, JString, required = false,
                                 default = newJString("cluster"))
  if valid_594574 != nil:
    section.add "SourceType", valid_594574
  var valid_594575 = query.getOrDefault("SourceIdentifier")
  valid_594575 = validateParameter(valid_594575, JString, required = false,
                                 default = nil)
  if valid_594575 != nil:
    section.add "SourceIdentifier", valid_594575
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594576 = query.getOrDefault("Action")
  valid_594576 = validateParameter(valid_594576, JString, required = true,
                                 default = newJString("DescribeEvents"))
  if valid_594576 != nil:
    section.add "Action", valid_594576
  var valid_594577 = query.getOrDefault("StartTime")
  valid_594577 = validateParameter(valid_594577, JString, required = false,
                                 default = nil)
  if valid_594577 != nil:
    section.add "StartTime", valid_594577
  var valid_594578 = query.getOrDefault("Duration")
  valid_594578 = validateParameter(valid_594578, JInt, required = false, default = nil)
  if valid_594578 != nil:
    section.add "Duration", valid_594578
  var valid_594579 = query.getOrDefault("EndTime")
  valid_594579 = validateParameter(valid_594579, JString, required = false,
                                 default = nil)
  if valid_594579 != nil:
    section.add "EndTime", valid_594579
  var valid_594580 = query.getOrDefault("Version")
  valid_594580 = validateParameter(valid_594580, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594580 != nil:
    section.add "Version", valid_594580
  var valid_594581 = query.getOrDefault("MaxRecords")
  valid_594581 = validateParameter(valid_594581, JInt, required = false, default = nil)
  if valid_594581 != nil:
    section.add "MaxRecords", valid_594581
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594582 = header.getOrDefault("X-Amz-Signature")
  valid_594582 = validateParameter(valid_594582, JString, required = false,
                                 default = nil)
  if valid_594582 != nil:
    section.add "X-Amz-Signature", valid_594582
  var valid_594583 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594583 = validateParameter(valid_594583, JString, required = false,
                                 default = nil)
  if valid_594583 != nil:
    section.add "X-Amz-Content-Sha256", valid_594583
  var valid_594584 = header.getOrDefault("X-Amz-Date")
  valid_594584 = validateParameter(valid_594584, JString, required = false,
                                 default = nil)
  if valid_594584 != nil:
    section.add "X-Amz-Date", valid_594584
  var valid_594585 = header.getOrDefault("X-Amz-Credential")
  valid_594585 = validateParameter(valid_594585, JString, required = false,
                                 default = nil)
  if valid_594585 != nil:
    section.add "X-Amz-Credential", valid_594585
  var valid_594586 = header.getOrDefault("X-Amz-Security-Token")
  valid_594586 = validateParameter(valid_594586, JString, required = false,
                                 default = nil)
  if valid_594586 != nil:
    section.add "X-Amz-Security-Token", valid_594586
  var valid_594587 = header.getOrDefault("X-Amz-Algorithm")
  valid_594587 = validateParameter(valid_594587, JString, required = false,
                                 default = nil)
  if valid_594587 != nil:
    section.add "X-Amz-Algorithm", valid_594587
  var valid_594588 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594588 = validateParameter(valid_594588, JString, required = false,
                                 default = nil)
  if valid_594588 != nil:
    section.add "X-Amz-SignedHeaders", valid_594588
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594589: Call_GetDescribeEvents_594570; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ## 
  let valid = call_594589.validator(path, query, header, formData, body)
  let scheme = call_594589.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594589.url(scheme.get, call_594589.host, call_594589.base,
                         call_594589.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594589, url, valid)

proc call*(call_594590: Call_GetDescribeEvents_594570; Marker: string = "";
          SourceType: string = "cluster"; SourceIdentifier: string = "";
          Action: string = "DescribeEvents"; StartTime: string = ""; Duration: int = 0;
          EndTime: string = ""; Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeEvents
  ## Returns events related to clusters, security groups, snapshots, and parameter groups for the past 14 days. Events specific to a particular cluster, security group, snapshot or parameter group can be obtained by providing the name as a parameter. By default, the past hour of events are returned.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeEvents</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SourceType: string
  ##             : <p>The event source to retrieve events for. If no value is specified, all events are returned.</p> <p>Constraints:</p> <p>If <i>SourceType</i> is supplied, <i>SourceIdentifier</i> must also be provided.</p> <ul> <li> <p>Specify <code>cluster</code> when <i>SourceIdentifier</i> is a cluster identifier.</p> </li> <li> <p>Specify <code>cluster-security-group</code> when <i>SourceIdentifier</i> is a cluster security group name.</p> </li> <li> <p>Specify <code>cluster-parameter-group</code> when <i>SourceIdentifier</i> is a cluster parameter group name.</p> </li> <li> <p>Specify <code>cluster-snapshot</code> when <i>SourceIdentifier</i> is a cluster snapshot identifier.</p> </li> </ul>
  ##   SourceIdentifier: string
  ##                   : <p>The identifier of the event source for which events will be returned. If this parameter is not specified, then all sources are included in the response.</p> <p>Constraints:</p> <p>If <i>SourceIdentifier</i> is supplied, <i>SourceType</i> must also be provided.</p> <ul> <li> <p>Specify a cluster identifier when <i>SourceType</i> is <code>cluster</code>.</p> </li> <li> <p>Specify a cluster security group name when <i>SourceType</i> is <code>cluster-security-group</code>.</p> </li> <li> <p>Specify a cluster parameter group name when <i>SourceType</i> is <code>cluster-parameter-group</code>.</p> </li> <li> <p>Specify a cluster snapshot identifier when <i>SourceType</i> is <code>cluster-snapshot</code>.</p> </li> </ul>
  ##   Action: string (required)
  ##   StartTime: string
  ##            : <p>The beginning of the time interval to retrieve events for, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Duration: int
  ##           : <p>The number of minutes prior to the time of the request for which to retrieve events. For example, if the request is sent at 18:00 and you specify a duration of 60, then only events which have occurred after 17:00 will be returned.</p> <p>Default: <code>60</code> </p>
  ##   EndTime: string
  ##          : <p>The end of the time interval for which to retrieve events, specified in ISO 8601 format. For more information about ISO 8601, go to the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO8601 Wikipedia page.</a> </p> <p>Example: <code>2009-07-08T18:00Z</code> </p>
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_594591 = newJObject()
  add(query_594591, "Marker", newJString(Marker))
  add(query_594591, "SourceType", newJString(SourceType))
  add(query_594591, "SourceIdentifier", newJString(SourceIdentifier))
  add(query_594591, "Action", newJString(Action))
  add(query_594591, "StartTime", newJString(StartTime))
  add(query_594591, "Duration", newJInt(Duration))
  add(query_594591, "EndTime", newJString(EndTime))
  add(query_594591, "Version", newJString(Version))
  add(query_594591, "MaxRecords", newJInt(MaxRecords))
  result = call_594590.call(nil, query_594591, nil, nil, nil)

var getDescribeEvents* = Call_GetDescribeEvents_594570(name: "getDescribeEvents",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeEvents", validator: validate_GetDescribeEvents_594571,
    base: "/", url: url_GetDescribeEvents_594572,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmClientCertificates_594635 = ref object of OpenApiRestCall_592348
proc url_PostDescribeHsmClientCertificates_594637(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeHsmClientCertificates_594636(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594638 = query.getOrDefault("Action")
  valid_594638 = validateParameter(valid_594638, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_594638 != nil:
    section.add "Action", valid_594638
  var valid_594639 = query.getOrDefault("Version")
  valid_594639 = validateParameter(valid_594639, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594639 != nil:
    section.add "Version", valid_594639
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594640 = header.getOrDefault("X-Amz-Signature")
  valid_594640 = validateParameter(valid_594640, JString, required = false,
                                 default = nil)
  if valid_594640 != nil:
    section.add "X-Amz-Signature", valid_594640
  var valid_594641 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594641 = validateParameter(valid_594641, JString, required = false,
                                 default = nil)
  if valid_594641 != nil:
    section.add "X-Amz-Content-Sha256", valid_594641
  var valid_594642 = header.getOrDefault("X-Amz-Date")
  valid_594642 = validateParameter(valid_594642, JString, required = false,
                                 default = nil)
  if valid_594642 != nil:
    section.add "X-Amz-Date", valid_594642
  var valid_594643 = header.getOrDefault("X-Amz-Credential")
  valid_594643 = validateParameter(valid_594643, JString, required = false,
                                 default = nil)
  if valid_594643 != nil:
    section.add "X-Amz-Credential", valid_594643
  var valid_594644 = header.getOrDefault("X-Amz-Security-Token")
  valid_594644 = validateParameter(valid_594644, JString, required = false,
                                 default = nil)
  if valid_594644 != nil:
    section.add "X-Amz-Security-Token", valid_594644
  var valid_594645 = header.getOrDefault("X-Amz-Algorithm")
  valid_594645 = validateParameter(valid_594645, JString, required = false,
                                 default = nil)
  if valid_594645 != nil:
    section.add "X-Amz-Algorithm", valid_594645
  var valid_594646 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594646 = validateParameter(valid_594646, JString, required = false,
                                 default = nil)
  if valid_594646 != nil:
    section.add "X-Amz-SignedHeaders", valid_594646
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  section = newJObject()
  var valid_594647 = formData.getOrDefault("TagKeys")
  valid_594647 = validateParameter(valid_594647, JArray, required = false,
                                 default = nil)
  if valid_594647 != nil:
    section.add "TagKeys", valid_594647
  var valid_594648 = formData.getOrDefault("MaxRecords")
  valid_594648 = validateParameter(valid_594648, JInt, required = false, default = nil)
  if valid_594648 != nil:
    section.add "MaxRecords", valid_594648
  var valid_594649 = formData.getOrDefault("Marker")
  valid_594649 = validateParameter(valid_594649, JString, required = false,
                                 default = nil)
  if valid_594649 != nil:
    section.add "Marker", valid_594649
  var valid_594650 = formData.getOrDefault("TagValues")
  valid_594650 = validateParameter(valid_594650, JArray, required = false,
                                 default = nil)
  if valid_594650 != nil:
    section.add "TagValues", valid_594650
  var valid_594651 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_594651 = validateParameter(valid_594651, JString, required = false,
                                 default = nil)
  if valid_594651 != nil:
    section.add "HsmClientCertificateIdentifier", valid_594651
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594652: Call_PostDescribeHsmClientCertificates_594635;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594652.validator(path, query, header, formData, body)
  let scheme = call_594652.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594652.url(scheme.get, call_594652.host, call_594652.base,
                         call_594652.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594652, url, valid)

proc call*(call_594653: Call_PostDescribeHsmClientCertificates_594635;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil;
          Action: string = "DescribeHsmClientCertificates";
          HsmClientCertificateIdentifier: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   Version: string (required)
  var query_594654 = newJObject()
  var formData_594655 = newJObject()
  if TagKeys != nil:
    formData_594655.add "TagKeys", TagKeys
  add(formData_594655, "MaxRecords", newJInt(MaxRecords))
  add(formData_594655, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_594655.add "TagValues", TagValues
  add(query_594654, "Action", newJString(Action))
  add(formData_594655, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_594654, "Version", newJString(Version))
  result = call_594653.call(nil, query_594654, nil, formData_594655, nil)

var postDescribeHsmClientCertificates* = Call_PostDescribeHsmClientCertificates_594635(
    name: "postDescribeHsmClientCertificates", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_PostDescribeHsmClientCertificates_594636, base: "/",
    url: url_PostDescribeHsmClientCertificates_594637,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmClientCertificates_594615 = ref object of OpenApiRestCall_592348
proc url_GetDescribeHsmClientCertificates_594617(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeHsmClientCertificates_594616(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594618 = query.getOrDefault("Marker")
  valid_594618 = validateParameter(valid_594618, JString, required = false,
                                 default = nil)
  if valid_594618 != nil:
    section.add "Marker", valid_594618
  var valid_594619 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_594619 = validateParameter(valid_594619, JString, required = false,
                                 default = nil)
  if valid_594619 != nil:
    section.add "HsmClientCertificateIdentifier", valid_594619
  var valid_594620 = query.getOrDefault("TagKeys")
  valid_594620 = validateParameter(valid_594620, JArray, required = false,
                                 default = nil)
  if valid_594620 != nil:
    section.add "TagKeys", valid_594620
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594621 = query.getOrDefault("Action")
  valid_594621 = validateParameter(valid_594621, JString, required = true, default = newJString(
      "DescribeHsmClientCertificates"))
  if valid_594621 != nil:
    section.add "Action", valid_594621
  var valid_594622 = query.getOrDefault("Version")
  valid_594622 = validateParameter(valid_594622, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594622 != nil:
    section.add "Version", valid_594622
  var valid_594623 = query.getOrDefault("MaxRecords")
  valid_594623 = validateParameter(valid_594623, JInt, required = false, default = nil)
  if valid_594623 != nil:
    section.add "MaxRecords", valid_594623
  var valid_594624 = query.getOrDefault("TagValues")
  valid_594624 = validateParameter(valid_594624, JArray, required = false,
                                 default = nil)
  if valid_594624 != nil:
    section.add "TagValues", valid_594624
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594625 = header.getOrDefault("X-Amz-Signature")
  valid_594625 = validateParameter(valid_594625, JString, required = false,
                                 default = nil)
  if valid_594625 != nil:
    section.add "X-Amz-Signature", valid_594625
  var valid_594626 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594626 = validateParameter(valid_594626, JString, required = false,
                                 default = nil)
  if valid_594626 != nil:
    section.add "X-Amz-Content-Sha256", valid_594626
  var valid_594627 = header.getOrDefault("X-Amz-Date")
  valid_594627 = validateParameter(valid_594627, JString, required = false,
                                 default = nil)
  if valid_594627 != nil:
    section.add "X-Amz-Date", valid_594627
  var valid_594628 = header.getOrDefault("X-Amz-Credential")
  valid_594628 = validateParameter(valid_594628, JString, required = false,
                                 default = nil)
  if valid_594628 != nil:
    section.add "X-Amz-Credential", valid_594628
  var valid_594629 = header.getOrDefault("X-Amz-Security-Token")
  valid_594629 = validateParameter(valid_594629, JString, required = false,
                                 default = nil)
  if valid_594629 != nil:
    section.add "X-Amz-Security-Token", valid_594629
  var valid_594630 = header.getOrDefault("X-Amz-Algorithm")
  valid_594630 = validateParameter(valid_594630, JString, required = false,
                                 default = nil)
  if valid_594630 != nil:
    section.add "X-Amz-Algorithm", valid_594630
  var valid_594631 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594631 = validateParameter(valid_594631, JString, required = false,
                                 default = nil)
  if valid_594631 != nil:
    section.add "X-Amz-SignedHeaders", valid_594631
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594632: Call_GetDescribeHsmClientCertificates_594615;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594632.validator(path, query, header, formData, body)
  let scheme = call_594632.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594632.url(scheme.get, call_594632.host, call_594632.base,
                         call_594632.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594632, url, valid)

proc call*(call_594633: Call_GetDescribeHsmClientCertificates_594615;
          Marker: string = ""; HsmClientCertificateIdentifier: string = "";
          TagKeys: JsonNode = nil; Action: string = "DescribeHsmClientCertificates";
          Version: string = "2012-12-01"; MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeHsmClientCertificates
  ## <p>Returns information about the specified HSM client certificate. If no certificate ID is specified, returns information about all the HSM certificates owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM client certificates that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM client certificates that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM client certificates are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmClientCertificates</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   HsmClientCertificateIdentifier: string
  ##                                 : The identifier of a specific HSM client certificate for which you want information. If no identifier is specified, information is returned for all HSM client certificates owned by your AWS customer account.
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM client certificates that are associated with the specified key or keys. For example, suppose that you have HSM client certificates that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM client certificates that are associated with the specified tag value or values. For example, suppose that you have HSM client certificates that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM client certificates that have either or both of these tag values associated with them.
  var query_594634 = newJObject()
  add(query_594634, "Marker", newJString(Marker))
  add(query_594634, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if TagKeys != nil:
    query_594634.add "TagKeys", TagKeys
  add(query_594634, "Action", newJString(Action))
  add(query_594634, "Version", newJString(Version))
  add(query_594634, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_594634.add "TagValues", TagValues
  result = call_594633.call(nil, query_594634, nil, nil, nil)

var getDescribeHsmClientCertificates* = Call_GetDescribeHsmClientCertificates_594615(
    name: "getDescribeHsmClientCertificates", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeHsmClientCertificates",
    validator: validate_GetDescribeHsmClientCertificates_594616, base: "/",
    url: url_GetDescribeHsmClientCertificates_594617,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeHsmConfigurations_594676 = ref object of OpenApiRestCall_592348
proc url_PostDescribeHsmConfigurations_594678(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeHsmConfigurations_594677(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594679 = query.getOrDefault("Action")
  valid_594679 = validateParameter(valid_594679, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_594679 != nil:
    section.add "Action", valid_594679
  var valid_594680 = query.getOrDefault("Version")
  valid_594680 = validateParameter(valid_594680, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594680 != nil:
    section.add "Version", valid_594680
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594681 = header.getOrDefault("X-Amz-Signature")
  valid_594681 = validateParameter(valid_594681, JString, required = false,
                                 default = nil)
  if valid_594681 != nil:
    section.add "X-Amz-Signature", valid_594681
  var valid_594682 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594682 = validateParameter(valid_594682, JString, required = false,
                                 default = nil)
  if valid_594682 != nil:
    section.add "X-Amz-Content-Sha256", valid_594682
  var valid_594683 = header.getOrDefault("X-Amz-Date")
  valid_594683 = validateParameter(valid_594683, JString, required = false,
                                 default = nil)
  if valid_594683 != nil:
    section.add "X-Amz-Date", valid_594683
  var valid_594684 = header.getOrDefault("X-Amz-Credential")
  valid_594684 = validateParameter(valid_594684, JString, required = false,
                                 default = nil)
  if valid_594684 != nil:
    section.add "X-Amz-Credential", valid_594684
  var valid_594685 = header.getOrDefault("X-Amz-Security-Token")
  valid_594685 = validateParameter(valid_594685, JString, required = false,
                                 default = nil)
  if valid_594685 != nil:
    section.add "X-Amz-Security-Token", valid_594685
  var valid_594686 = header.getOrDefault("X-Amz-Algorithm")
  valid_594686 = validateParameter(valid_594686, JString, required = false,
                                 default = nil)
  if valid_594686 != nil:
    section.add "X-Amz-Algorithm", valid_594686
  var valid_594687 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594687 = validateParameter(valid_594687, JString, required = false,
                                 default = nil)
  if valid_594687 != nil:
    section.add "X-Amz-SignedHeaders", valid_594687
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  section = newJObject()
  var valid_594688 = formData.getOrDefault("TagKeys")
  valid_594688 = validateParameter(valid_594688, JArray, required = false,
                                 default = nil)
  if valid_594688 != nil:
    section.add "TagKeys", valid_594688
  var valid_594689 = formData.getOrDefault("MaxRecords")
  valid_594689 = validateParameter(valid_594689, JInt, required = false, default = nil)
  if valid_594689 != nil:
    section.add "MaxRecords", valid_594689
  var valid_594690 = formData.getOrDefault("Marker")
  valid_594690 = validateParameter(valid_594690, JString, required = false,
                                 default = nil)
  if valid_594690 != nil:
    section.add "Marker", valid_594690
  var valid_594691 = formData.getOrDefault("TagValues")
  valid_594691 = validateParameter(valid_594691, JArray, required = false,
                                 default = nil)
  if valid_594691 != nil:
    section.add "TagValues", valid_594691
  var valid_594692 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_594692 = validateParameter(valid_594692, JString, required = false,
                                 default = nil)
  if valid_594692 != nil:
    section.add "HsmConfigurationIdentifier", valid_594692
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594693: Call_PostDescribeHsmConfigurations_594676; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594693.validator(path, query, header, formData, body)
  let scheme = call_594693.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594693.url(scheme.get, call_594693.host, call_594693.base,
                         call_594693.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594693, url, valid)

proc call*(call_594694: Call_PostDescribeHsmConfigurations_594676;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeHsmConfigurations";
          Version: string = "2012-12-01"; HsmConfigurationIdentifier: string = ""): Recallable =
  ## postDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  var query_594695 = newJObject()
  var formData_594696 = newJObject()
  if TagKeys != nil:
    formData_594696.add "TagKeys", TagKeys
  add(formData_594696, "MaxRecords", newJInt(MaxRecords))
  add(formData_594696, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_594696.add "TagValues", TagValues
  add(query_594695, "Action", newJString(Action))
  add(query_594695, "Version", newJString(Version))
  add(formData_594696, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  result = call_594694.call(nil, query_594695, nil, formData_594696, nil)

var postDescribeHsmConfigurations* = Call_PostDescribeHsmConfigurations_594676(
    name: "postDescribeHsmConfigurations", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_PostDescribeHsmConfigurations_594677, base: "/",
    url: url_PostDescribeHsmConfigurations_594678,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeHsmConfigurations_594656 = ref object of OpenApiRestCall_592348
proc url_GetDescribeHsmConfigurations_594658(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeHsmConfigurations_594657(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   HsmConfigurationIdentifier: JString
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594659 = query.getOrDefault("Marker")
  valid_594659 = validateParameter(valid_594659, JString, required = false,
                                 default = nil)
  if valid_594659 != nil:
    section.add "Marker", valid_594659
  var valid_594660 = query.getOrDefault("TagKeys")
  valid_594660 = validateParameter(valid_594660, JArray, required = false,
                                 default = nil)
  if valid_594660 != nil:
    section.add "TagKeys", valid_594660
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594661 = query.getOrDefault("Action")
  valid_594661 = validateParameter(valid_594661, JString, required = true, default = newJString(
      "DescribeHsmConfigurations"))
  if valid_594661 != nil:
    section.add "Action", valid_594661
  var valid_594662 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_594662 = validateParameter(valid_594662, JString, required = false,
                                 default = nil)
  if valid_594662 != nil:
    section.add "HsmConfigurationIdentifier", valid_594662
  var valid_594663 = query.getOrDefault("Version")
  valid_594663 = validateParameter(valid_594663, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594663 != nil:
    section.add "Version", valid_594663
  var valid_594664 = query.getOrDefault("MaxRecords")
  valid_594664 = validateParameter(valid_594664, JInt, required = false, default = nil)
  if valid_594664 != nil:
    section.add "MaxRecords", valid_594664
  var valid_594665 = query.getOrDefault("TagValues")
  valid_594665 = validateParameter(valid_594665, JArray, required = false,
                                 default = nil)
  if valid_594665 != nil:
    section.add "TagValues", valid_594665
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594666 = header.getOrDefault("X-Amz-Signature")
  valid_594666 = validateParameter(valid_594666, JString, required = false,
                                 default = nil)
  if valid_594666 != nil:
    section.add "X-Amz-Signature", valid_594666
  var valid_594667 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594667 = validateParameter(valid_594667, JString, required = false,
                                 default = nil)
  if valid_594667 != nil:
    section.add "X-Amz-Content-Sha256", valid_594667
  var valid_594668 = header.getOrDefault("X-Amz-Date")
  valid_594668 = validateParameter(valid_594668, JString, required = false,
                                 default = nil)
  if valid_594668 != nil:
    section.add "X-Amz-Date", valid_594668
  var valid_594669 = header.getOrDefault("X-Amz-Credential")
  valid_594669 = validateParameter(valid_594669, JString, required = false,
                                 default = nil)
  if valid_594669 != nil:
    section.add "X-Amz-Credential", valid_594669
  var valid_594670 = header.getOrDefault("X-Amz-Security-Token")
  valid_594670 = validateParameter(valid_594670, JString, required = false,
                                 default = nil)
  if valid_594670 != nil:
    section.add "X-Amz-Security-Token", valid_594670
  var valid_594671 = header.getOrDefault("X-Amz-Algorithm")
  valid_594671 = validateParameter(valid_594671, JString, required = false,
                                 default = nil)
  if valid_594671 != nil:
    section.add "X-Amz-Algorithm", valid_594671
  var valid_594672 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594672 = validateParameter(valid_594672, JString, required = false,
                                 default = nil)
  if valid_594672 != nil:
    section.add "X-Amz-SignedHeaders", valid_594672
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594673: Call_GetDescribeHsmConfigurations_594656; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_594673.validator(path, query, header, formData, body)
  let scheme = call_594673.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594673.url(scheme.get, call_594673.host, call_594673.base,
                         call_594673.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594673, url, valid)

proc call*(call_594674: Call_GetDescribeHsmConfigurations_594656;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeHsmConfigurations";
          HsmConfigurationIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeHsmConfigurations
  ## <p>Returns information about the specified Amazon Redshift HSM configuration. If no configuration ID is specified, returns information about all the HSM configurations owned by your AWS customer account.</p> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all HSM connections that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all HSM connections that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, HSM connections are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeHsmConfigurations</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching HSM configurations that are associated with the specified key or keys. For example, suppose that you have HSM configurations that are tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   HsmConfigurationIdentifier: string
  ##                             : The identifier of a specific Amazon Redshift HSM configuration to be described. If no identifier is specified, information is returned for all HSM configurations owned by your AWS customer account.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching HSM configurations that are associated with the specified tag value or values. For example, suppose that you have HSM configurations that are tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with the HSM configurations that have either or both of these tag values associated with them.
  var query_594675 = newJObject()
  add(query_594675, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_594675.add "TagKeys", TagKeys
  add(query_594675, "Action", newJString(Action))
  add(query_594675, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_594675, "Version", newJString(Version))
  add(query_594675, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_594675.add "TagValues", TagValues
  result = call_594674.call(nil, query_594675, nil, nil, nil)

var getDescribeHsmConfigurations* = Call_GetDescribeHsmConfigurations_594656(
    name: "getDescribeHsmConfigurations", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeHsmConfigurations",
    validator: validate_GetDescribeHsmConfigurations_594657, base: "/",
    url: url_GetDescribeHsmConfigurations_594658,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeLoggingStatus_594713 = ref object of OpenApiRestCall_592348
proc url_PostDescribeLoggingStatus_594715(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeLoggingStatus_594714(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594716 = query.getOrDefault("Action")
  valid_594716 = validateParameter(valid_594716, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_594716 != nil:
    section.add "Action", valid_594716
  var valid_594717 = query.getOrDefault("Version")
  valid_594717 = validateParameter(valid_594717, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594717 != nil:
    section.add "Version", valid_594717
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594718 = header.getOrDefault("X-Amz-Signature")
  valid_594718 = validateParameter(valid_594718, JString, required = false,
                                 default = nil)
  if valid_594718 != nil:
    section.add "X-Amz-Signature", valid_594718
  var valid_594719 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594719 = validateParameter(valid_594719, JString, required = false,
                                 default = nil)
  if valid_594719 != nil:
    section.add "X-Amz-Content-Sha256", valid_594719
  var valid_594720 = header.getOrDefault("X-Amz-Date")
  valid_594720 = validateParameter(valid_594720, JString, required = false,
                                 default = nil)
  if valid_594720 != nil:
    section.add "X-Amz-Date", valid_594720
  var valid_594721 = header.getOrDefault("X-Amz-Credential")
  valid_594721 = validateParameter(valid_594721, JString, required = false,
                                 default = nil)
  if valid_594721 != nil:
    section.add "X-Amz-Credential", valid_594721
  var valid_594722 = header.getOrDefault("X-Amz-Security-Token")
  valid_594722 = validateParameter(valid_594722, JString, required = false,
                                 default = nil)
  if valid_594722 != nil:
    section.add "X-Amz-Security-Token", valid_594722
  var valid_594723 = header.getOrDefault("X-Amz-Algorithm")
  valid_594723 = validateParameter(valid_594723, JString, required = false,
                                 default = nil)
  if valid_594723 != nil:
    section.add "X-Amz-Algorithm", valid_594723
  var valid_594724 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594724 = validateParameter(valid_594724, JString, required = false,
                                 default = nil)
  if valid_594724 != nil:
    section.add "X-Amz-SignedHeaders", valid_594724
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_594725 = formData.getOrDefault("ClusterIdentifier")
  valid_594725 = validateParameter(valid_594725, JString, required = true,
                                 default = nil)
  if valid_594725 != nil:
    section.add "ClusterIdentifier", valid_594725
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594726: Call_PostDescribeLoggingStatus_594713; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_594726.validator(path, query, header, formData, body)
  let scheme = call_594726.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594726.url(scheme.get, call_594726.host, call_594726.base,
                         call_594726.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594726, url, valid)

proc call*(call_594727: Call_PostDescribeLoggingStatus_594713;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594728 = newJObject()
  var formData_594729 = newJObject()
  add(formData_594729, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594728, "Action", newJString(Action))
  add(query_594728, "Version", newJString(Version))
  result = call_594727.call(nil, query_594728, nil, formData_594729, nil)

var postDescribeLoggingStatus* = Call_PostDescribeLoggingStatus_594713(
    name: "postDescribeLoggingStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_PostDescribeLoggingStatus_594714, base: "/",
    url: url_PostDescribeLoggingStatus_594715,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeLoggingStatus_594697 = ref object of OpenApiRestCall_592348
proc url_GetDescribeLoggingStatus_594699(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeLoggingStatus_594698(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594700 = query.getOrDefault("Action")
  valid_594700 = validateParameter(valid_594700, JString, required = true,
                                 default = newJString("DescribeLoggingStatus"))
  if valid_594700 != nil:
    section.add "Action", valid_594700
  var valid_594701 = query.getOrDefault("ClusterIdentifier")
  valid_594701 = validateParameter(valid_594701, JString, required = true,
                                 default = nil)
  if valid_594701 != nil:
    section.add "ClusterIdentifier", valid_594701
  var valid_594702 = query.getOrDefault("Version")
  valid_594702 = validateParameter(valid_594702, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594702 != nil:
    section.add "Version", valid_594702
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594703 = header.getOrDefault("X-Amz-Signature")
  valid_594703 = validateParameter(valid_594703, JString, required = false,
                                 default = nil)
  if valid_594703 != nil:
    section.add "X-Amz-Signature", valid_594703
  var valid_594704 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594704 = validateParameter(valid_594704, JString, required = false,
                                 default = nil)
  if valid_594704 != nil:
    section.add "X-Amz-Content-Sha256", valid_594704
  var valid_594705 = header.getOrDefault("X-Amz-Date")
  valid_594705 = validateParameter(valid_594705, JString, required = false,
                                 default = nil)
  if valid_594705 != nil:
    section.add "X-Amz-Date", valid_594705
  var valid_594706 = header.getOrDefault("X-Amz-Credential")
  valid_594706 = validateParameter(valid_594706, JString, required = false,
                                 default = nil)
  if valid_594706 != nil:
    section.add "X-Amz-Credential", valid_594706
  var valid_594707 = header.getOrDefault("X-Amz-Security-Token")
  valid_594707 = validateParameter(valid_594707, JString, required = false,
                                 default = nil)
  if valid_594707 != nil:
    section.add "X-Amz-Security-Token", valid_594707
  var valid_594708 = header.getOrDefault("X-Amz-Algorithm")
  valid_594708 = validateParameter(valid_594708, JString, required = false,
                                 default = nil)
  if valid_594708 != nil:
    section.add "X-Amz-Algorithm", valid_594708
  var valid_594709 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594709 = validateParameter(valid_594709, JString, required = false,
                                 default = nil)
  if valid_594709 != nil:
    section.add "X-Amz-SignedHeaders", valid_594709
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594710: Call_GetDescribeLoggingStatus_594697; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ## 
  let valid = call_594710.validator(path, query, header, formData, body)
  let scheme = call_594710.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594710.url(scheme.get, call_594710.host, call_594710.base,
                         call_594710.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594710, url, valid)

proc call*(call_594711: Call_GetDescribeLoggingStatus_594697;
          ClusterIdentifier: string; Action: string = "DescribeLoggingStatus";
          Version: string = "2012-12-01"): Recallable =
  ## getDescribeLoggingStatus
  ## Describes whether information, such as queries and connection attempts, is being logged for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster from which to get the logging status.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_594712 = newJObject()
  add(query_594712, "Action", newJString(Action))
  add(query_594712, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594712, "Version", newJString(Version))
  result = call_594711.call(nil, query_594712, nil, nil, nil)

var getDescribeLoggingStatus* = Call_GetDescribeLoggingStatus_594697(
    name: "getDescribeLoggingStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeLoggingStatus",
    validator: validate_GetDescribeLoggingStatus_594698, base: "/",
    url: url_GetDescribeLoggingStatus_594699, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeNodeConfigurationOptions_594751 = ref object of OpenApiRestCall_592348
proc url_PostDescribeNodeConfigurationOptions_594753(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeNodeConfigurationOptions_594752(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594754 = query.getOrDefault("Action")
  valid_594754 = validateParameter(valid_594754, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_594754 != nil:
    section.add "Action", valid_594754
  var valid_594755 = query.getOrDefault("Version")
  valid_594755 = validateParameter(valid_594755, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594755 != nil:
    section.add "Version", valid_594755
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594756 = header.getOrDefault("X-Amz-Signature")
  valid_594756 = validateParameter(valid_594756, JString, required = false,
                                 default = nil)
  if valid_594756 != nil:
    section.add "X-Amz-Signature", valid_594756
  var valid_594757 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594757 = validateParameter(valid_594757, JString, required = false,
                                 default = nil)
  if valid_594757 != nil:
    section.add "X-Amz-Content-Sha256", valid_594757
  var valid_594758 = header.getOrDefault("X-Amz-Date")
  valid_594758 = validateParameter(valid_594758, JString, required = false,
                                 default = nil)
  if valid_594758 != nil:
    section.add "X-Amz-Date", valid_594758
  var valid_594759 = header.getOrDefault("X-Amz-Credential")
  valid_594759 = validateParameter(valid_594759, JString, required = false,
                                 default = nil)
  if valid_594759 != nil:
    section.add "X-Amz-Credential", valid_594759
  var valid_594760 = header.getOrDefault("X-Amz-Security-Token")
  valid_594760 = validateParameter(valid_594760, JString, required = false,
                                 default = nil)
  if valid_594760 != nil:
    section.add "X-Amz-Security-Token", valid_594760
  var valid_594761 = header.getOrDefault("X-Amz-Algorithm")
  valid_594761 = validateParameter(valid_594761, JString, required = false,
                                 default = nil)
  if valid_594761 != nil:
    section.add "X-Amz-Algorithm", valid_594761
  var valid_594762 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594762 = validateParameter(valid_594762, JString, required = false,
                                 default = nil)
  if valid_594762 != nil:
    section.add "X-Amz-SignedHeaders", valid_594762
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  section = newJObject()
  var valid_594763 = formData.getOrDefault("MaxRecords")
  valid_594763 = validateParameter(valid_594763, JInt, required = false, default = nil)
  if valid_594763 != nil:
    section.add "MaxRecords", valid_594763
  var valid_594764 = formData.getOrDefault("OwnerAccount")
  valid_594764 = validateParameter(valid_594764, JString, required = false,
                                 default = nil)
  if valid_594764 != nil:
    section.add "OwnerAccount", valid_594764
  var valid_594765 = formData.getOrDefault("Marker")
  valid_594765 = validateParameter(valid_594765, JString, required = false,
                                 default = nil)
  if valid_594765 != nil:
    section.add "Marker", valid_594765
  var valid_594766 = formData.getOrDefault("SnapshotIdentifier")
  valid_594766 = validateParameter(valid_594766, JString, required = false,
                                 default = nil)
  if valid_594766 != nil:
    section.add "SnapshotIdentifier", valid_594766
  assert formData != nil,
        "formData argument is necessary due to required `ActionType` field"
  var valid_594767 = formData.getOrDefault("ActionType")
  valid_594767 = validateParameter(valid_594767, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_594767 != nil:
    section.add "ActionType", valid_594767
  var valid_594768 = formData.getOrDefault("Filter")
  valid_594768 = validateParameter(valid_594768, JArray, required = false,
                                 default = nil)
  if valid_594768 != nil:
    section.add "Filter", valid_594768
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594769: Call_PostDescribeNodeConfigurationOptions_594751;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_594769.validator(path, query, header, formData, body)
  let scheme = call_594769.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594769.url(scheme.get, call_594769.host, call_594769.base,
                         call_594769.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594769, url, valid)

proc call*(call_594770: Call_PostDescribeNodeConfigurationOptions_594751;
          MaxRecords: int = 0; OwnerAccount: string = ""; Marker: string = "";
          SnapshotIdentifier: string = "";
          Action: string = "DescribeNodeConfigurationOptions";
          Version: string = "2012-12-01"; ActionType: string = "restore-cluster";
          Filter: JsonNode = nil): Recallable =
  ## postDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  var query_594771 = newJObject()
  var formData_594772 = newJObject()
  add(formData_594772, "MaxRecords", newJInt(MaxRecords))
  add(formData_594772, "OwnerAccount", newJString(OwnerAccount))
  add(formData_594772, "Marker", newJString(Marker))
  add(formData_594772, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_594771, "Action", newJString(Action))
  add(query_594771, "Version", newJString(Version))
  add(formData_594772, "ActionType", newJString(ActionType))
  if Filter != nil:
    formData_594772.add "Filter", Filter
  result = call_594770.call(nil, query_594771, nil, formData_594772, nil)

var postDescribeNodeConfigurationOptions* = Call_PostDescribeNodeConfigurationOptions_594751(
    name: "postDescribeNodeConfigurationOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_PostDescribeNodeConfigurationOptions_594752, base: "/",
    url: url_PostDescribeNodeConfigurationOptions_594753,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeNodeConfigurationOptions_594730 = ref object of OpenApiRestCall_592348
proc url_GetDescribeNodeConfigurationOptions_594732(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeNodeConfigurationOptions_594731(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: JString
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: JString (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Action: JString (required)
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  section = newJObject()
  var valid_594733 = query.getOrDefault("Marker")
  valid_594733 = validateParameter(valid_594733, JString, required = false,
                                 default = nil)
  if valid_594733 != nil:
    section.add "Marker", valid_594733
  var valid_594734 = query.getOrDefault("SnapshotIdentifier")
  valid_594734 = validateParameter(valid_594734, JString, required = false,
                                 default = nil)
  if valid_594734 != nil:
    section.add "SnapshotIdentifier", valid_594734
  assert query != nil,
        "query argument is necessary due to required `ActionType` field"
  var valid_594735 = query.getOrDefault("ActionType")
  valid_594735 = validateParameter(valid_594735, JString, required = true,
                                 default = newJString("restore-cluster"))
  if valid_594735 != nil:
    section.add "ActionType", valid_594735
  var valid_594736 = query.getOrDefault("Filter")
  valid_594736 = validateParameter(valid_594736, JArray, required = false,
                                 default = nil)
  if valid_594736 != nil:
    section.add "Filter", valid_594736
  var valid_594737 = query.getOrDefault("Action")
  valid_594737 = validateParameter(valid_594737, JString, required = true, default = newJString(
      "DescribeNodeConfigurationOptions"))
  if valid_594737 != nil:
    section.add "Action", valid_594737
  var valid_594738 = query.getOrDefault("OwnerAccount")
  valid_594738 = validateParameter(valid_594738, JString, required = false,
                                 default = nil)
  if valid_594738 != nil:
    section.add "OwnerAccount", valid_594738
  var valid_594739 = query.getOrDefault("Version")
  valid_594739 = validateParameter(valid_594739, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594739 != nil:
    section.add "Version", valid_594739
  var valid_594740 = query.getOrDefault("MaxRecords")
  valid_594740 = validateParameter(valid_594740, JInt, required = false, default = nil)
  if valid_594740 != nil:
    section.add "MaxRecords", valid_594740
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594741 = header.getOrDefault("X-Amz-Signature")
  valid_594741 = validateParameter(valid_594741, JString, required = false,
                                 default = nil)
  if valid_594741 != nil:
    section.add "X-Amz-Signature", valid_594741
  var valid_594742 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594742 = validateParameter(valid_594742, JString, required = false,
                                 default = nil)
  if valid_594742 != nil:
    section.add "X-Amz-Content-Sha256", valid_594742
  var valid_594743 = header.getOrDefault("X-Amz-Date")
  valid_594743 = validateParameter(valid_594743, JString, required = false,
                                 default = nil)
  if valid_594743 != nil:
    section.add "X-Amz-Date", valid_594743
  var valid_594744 = header.getOrDefault("X-Amz-Credential")
  valid_594744 = validateParameter(valid_594744, JString, required = false,
                                 default = nil)
  if valid_594744 != nil:
    section.add "X-Amz-Credential", valid_594744
  var valid_594745 = header.getOrDefault("X-Amz-Security-Token")
  valid_594745 = validateParameter(valid_594745, JString, required = false,
                                 default = nil)
  if valid_594745 != nil:
    section.add "X-Amz-Security-Token", valid_594745
  var valid_594746 = header.getOrDefault("X-Amz-Algorithm")
  valid_594746 = validateParameter(valid_594746, JString, required = false,
                                 default = nil)
  if valid_594746 != nil:
    section.add "X-Amz-Algorithm", valid_594746
  var valid_594747 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594747 = validateParameter(valid_594747, JString, required = false,
                                 default = nil)
  if valid_594747 != nil:
    section.add "X-Amz-SignedHeaders", valid_594747
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594748: Call_GetDescribeNodeConfigurationOptions_594730;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ## 
  let valid = call_594748.validator(path, query, header, formData, body)
  let scheme = call_594748.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594748.url(scheme.get, call_594748.host, call_594748.base,
                         call_594748.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594748, url, valid)

proc call*(call_594749: Call_GetDescribeNodeConfigurationOptions_594730;
          Marker: string = ""; SnapshotIdentifier: string = "";
          ActionType: string = "restore-cluster"; Filter: JsonNode = nil;
          Action: string = "DescribeNodeConfigurationOptions";
          OwnerAccount: string = ""; Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeNodeConfigurationOptions
  ## Returns properties of possible node configurations such as node type, number of nodes, and disk usage for the specified action type.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeNodeConfigurationOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   SnapshotIdentifier: string
  ##                     : The identifier of the snapshot to evaluate for possible node configurations.
  ##   ActionType: string (required)
  ##             : The action type to evaluate for possible node configurations. Currently, it must be "restore-cluster".
  ##   Filter: JArray
  ##         : A set of name, operator, and value items to filter the results.
  ##   Action: string (required)
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>500</code> </p> <p>Constraints: minimum 100, maximum 500.</p>
  var query_594750 = newJObject()
  add(query_594750, "Marker", newJString(Marker))
  add(query_594750, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_594750, "ActionType", newJString(ActionType))
  if Filter != nil:
    query_594750.add "Filter", Filter
  add(query_594750, "Action", newJString(Action))
  add(query_594750, "OwnerAccount", newJString(OwnerAccount))
  add(query_594750, "Version", newJString(Version))
  add(query_594750, "MaxRecords", newJInt(MaxRecords))
  result = call_594749.call(nil, query_594750, nil, nil, nil)

var getDescribeNodeConfigurationOptions* = Call_GetDescribeNodeConfigurationOptions_594730(
    name: "getDescribeNodeConfigurationOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeNodeConfigurationOptions",
    validator: validate_GetDescribeNodeConfigurationOptions_594731, base: "/",
    url: url_GetDescribeNodeConfigurationOptions_594732,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeOrderableClusterOptions_594792 = ref object of OpenApiRestCall_592348
proc url_PostDescribeOrderableClusterOptions_594794(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeOrderableClusterOptions_594793(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594795 = query.getOrDefault("Action")
  valid_594795 = validateParameter(valid_594795, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_594795 != nil:
    section.add "Action", valid_594795
  var valid_594796 = query.getOrDefault("Version")
  valid_594796 = validateParameter(valid_594796, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594796 != nil:
    section.add "Version", valid_594796
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594797 = header.getOrDefault("X-Amz-Signature")
  valid_594797 = validateParameter(valid_594797, JString, required = false,
                                 default = nil)
  if valid_594797 != nil:
    section.add "X-Amz-Signature", valid_594797
  var valid_594798 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594798 = validateParameter(valid_594798, JString, required = false,
                                 default = nil)
  if valid_594798 != nil:
    section.add "X-Amz-Content-Sha256", valid_594798
  var valid_594799 = header.getOrDefault("X-Amz-Date")
  valid_594799 = validateParameter(valid_594799, JString, required = false,
                                 default = nil)
  if valid_594799 != nil:
    section.add "X-Amz-Date", valid_594799
  var valid_594800 = header.getOrDefault("X-Amz-Credential")
  valid_594800 = validateParameter(valid_594800, JString, required = false,
                                 default = nil)
  if valid_594800 != nil:
    section.add "X-Amz-Credential", valid_594800
  var valid_594801 = header.getOrDefault("X-Amz-Security-Token")
  valid_594801 = validateParameter(valid_594801, JString, required = false,
                                 default = nil)
  if valid_594801 != nil:
    section.add "X-Amz-Security-Token", valid_594801
  var valid_594802 = header.getOrDefault("X-Amz-Algorithm")
  valid_594802 = validateParameter(valid_594802, JString, required = false,
                                 default = nil)
  if valid_594802 != nil:
    section.add "X-Amz-Algorithm", valid_594802
  var valid_594803 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594803 = validateParameter(valid_594803, JString, required = false,
                                 default = nil)
  if valid_594803 != nil:
    section.add "X-Amz-SignedHeaders", valid_594803
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  section = newJObject()
  var valid_594804 = formData.getOrDefault("NodeType")
  valid_594804 = validateParameter(valid_594804, JString, required = false,
                                 default = nil)
  if valid_594804 != nil:
    section.add "NodeType", valid_594804
  var valid_594805 = formData.getOrDefault("MaxRecords")
  valid_594805 = validateParameter(valid_594805, JInt, required = false, default = nil)
  if valid_594805 != nil:
    section.add "MaxRecords", valid_594805
  var valid_594806 = formData.getOrDefault("Marker")
  valid_594806 = validateParameter(valid_594806, JString, required = false,
                                 default = nil)
  if valid_594806 != nil:
    section.add "Marker", valid_594806
  var valid_594807 = formData.getOrDefault("ClusterVersion")
  valid_594807 = validateParameter(valid_594807, JString, required = false,
                                 default = nil)
  if valid_594807 != nil:
    section.add "ClusterVersion", valid_594807
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594808: Call_PostDescribeOrderableClusterOptions_594792;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_594808.validator(path, query, header, formData, body)
  let scheme = call_594808.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594808.url(scheme.get, call_594808.host, call_594808.base,
                         call_594808.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594808, url, valid)

proc call*(call_594809: Call_PostDescribeOrderableClusterOptions_594792;
          NodeType: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeOrderableClusterOptions";
          ClusterVersion: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   Version: string (required)
  var query_594810 = newJObject()
  var formData_594811 = newJObject()
  add(formData_594811, "NodeType", newJString(NodeType))
  add(formData_594811, "MaxRecords", newJInt(MaxRecords))
  add(formData_594811, "Marker", newJString(Marker))
  add(query_594810, "Action", newJString(Action))
  add(formData_594811, "ClusterVersion", newJString(ClusterVersion))
  add(query_594810, "Version", newJString(Version))
  result = call_594809.call(nil, query_594810, nil, formData_594811, nil)

var postDescribeOrderableClusterOptions* = Call_PostDescribeOrderableClusterOptions_594792(
    name: "postDescribeOrderableClusterOptions", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_PostDescribeOrderableClusterOptions_594793, base: "/",
    url: url_PostDescribeOrderableClusterOptions_594794,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeOrderableClusterOptions_594773 = ref object of OpenApiRestCall_592348
proc url_GetDescribeOrderableClusterOptions_594775(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeOrderableClusterOptions_594774(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: JString
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   NodeType: JString
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_594776 = query.getOrDefault("Marker")
  valid_594776 = validateParameter(valid_594776, JString, required = false,
                                 default = nil)
  if valid_594776 != nil:
    section.add "Marker", valid_594776
  var valid_594777 = query.getOrDefault("ClusterVersion")
  valid_594777 = validateParameter(valid_594777, JString, required = false,
                                 default = nil)
  if valid_594777 != nil:
    section.add "ClusterVersion", valid_594777
  var valid_594778 = query.getOrDefault("NodeType")
  valid_594778 = validateParameter(valid_594778, JString, required = false,
                                 default = nil)
  if valid_594778 != nil:
    section.add "NodeType", valid_594778
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594779 = query.getOrDefault("Action")
  valid_594779 = validateParameter(valid_594779, JString, required = true, default = newJString(
      "DescribeOrderableClusterOptions"))
  if valid_594779 != nil:
    section.add "Action", valid_594779
  var valid_594780 = query.getOrDefault("Version")
  valid_594780 = validateParameter(valid_594780, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594780 != nil:
    section.add "Version", valid_594780
  var valid_594781 = query.getOrDefault("MaxRecords")
  valid_594781 = validateParameter(valid_594781, JInt, required = false, default = nil)
  if valid_594781 != nil:
    section.add "MaxRecords", valid_594781
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594782 = header.getOrDefault("X-Amz-Signature")
  valid_594782 = validateParameter(valid_594782, JString, required = false,
                                 default = nil)
  if valid_594782 != nil:
    section.add "X-Amz-Signature", valid_594782
  var valid_594783 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594783 = validateParameter(valid_594783, JString, required = false,
                                 default = nil)
  if valid_594783 != nil:
    section.add "X-Amz-Content-Sha256", valid_594783
  var valid_594784 = header.getOrDefault("X-Amz-Date")
  valid_594784 = validateParameter(valid_594784, JString, required = false,
                                 default = nil)
  if valid_594784 != nil:
    section.add "X-Amz-Date", valid_594784
  var valid_594785 = header.getOrDefault("X-Amz-Credential")
  valid_594785 = validateParameter(valid_594785, JString, required = false,
                                 default = nil)
  if valid_594785 != nil:
    section.add "X-Amz-Credential", valid_594785
  var valid_594786 = header.getOrDefault("X-Amz-Security-Token")
  valid_594786 = validateParameter(valid_594786, JString, required = false,
                                 default = nil)
  if valid_594786 != nil:
    section.add "X-Amz-Security-Token", valid_594786
  var valid_594787 = header.getOrDefault("X-Amz-Algorithm")
  valid_594787 = validateParameter(valid_594787, JString, required = false,
                                 default = nil)
  if valid_594787 != nil:
    section.add "X-Amz-Algorithm", valid_594787
  var valid_594788 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594788 = validateParameter(valid_594788, JString, required = false,
                                 default = nil)
  if valid_594788 != nil:
    section.add "X-Amz-SignedHeaders", valid_594788
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594789: Call_GetDescribeOrderableClusterOptions_594773;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ## 
  let valid = call_594789.validator(path, query, header, formData, body)
  let scheme = call_594789.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594789.url(scheme.get, call_594789.host, call_594789.base,
                         call_594789.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594789, url, valid)

proc call*(call_594790: Call_GetDescribeOrderableClusterOptions_594773;
          Marker: string = ""; ClusterVersion: string = ""; NodeType: string = "";
          Action: string = "DescribeOrderableClusterOptions";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeOrderableClusterOptions
  ## Returns a list of orderable cluster options. Before you create a new cluster you can use this operation to find what options are available, such as the EC2 Availability Zones (AZ) in the specific AWS Region that you can specify, and the node types you can request. The node types differ by available storage, memory, CPU and price. With the cost involved you might want to obtain a list of cluster options in the specific region and specify values when creating a cluster. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeOrderableClusterOptions</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ClusterVersion: string
  ##                 : <p>The version filter value. Specify this parameter to show only the available offerings matching the specified version.</p> <p>Default: All versions.</p> <p>Constraints: Must be one of the version returned from <a>DescribeClusterVersions</a>.</p>
  ##   NodeType: string
  ##           : The node type filter value. Specify this parameter to show only the available offerings matching the specified node type.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_594791 = newJObject()
  add(query_594791, "Marker", newJString(Marker))
  add(query_594791, "ClusterVersion", newJString(ClusterVersion))
  add(query_594791, "NodeType", newJString(NodeType))
  add(query_594791, "Action", newJString(Action))
  add(query_594791, "Version", newJString(Version))
  add(query_594791, "MaxRecords", newJInt(MaxRecords))
  result = call_594790.call(nil, query_594791, nil, nil, nil)

var getDescribeOrderableClusterOptions* = Call_GetDescribeOrderableClusterOptions_594773(
    name: "getDescribeOrderableClusterOptions", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeOrderableClusterOptions",
    validator: validate_GetDescribeOrderableClusterOptions_594774, base: "/",
    url: url_GetDescribeOrderableClusterOptions_594775,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodeOfferings_594830 = ref object of OpenApiRestCall_592348
proc url_PostDescribeReservedNodeOfferings_594832(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeReservedNodeOfferings_594831(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594833 = query.getOrDefault("Action")
  valid_594833 = validateParameter(valid_594833, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_594833 != nil:
    section.add "Action", valid_594833
  var valid_594834 = query.getOrDefault("Version")
  valid_594834 = validateParameter(valid_594834, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594834 != nil:
    section.add "Version", valid_594834
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594835 = header.getOrDefault("X-Amz-Signature")
  valid_594835 = validateParameter(valid_594835, JString, required = false,
                                 default = nil)
  if valid_594835 != nil:
    section.add "X-Amz-Signature", valid_594835
  var valid_594836 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594836 = validateParameter(valid_594836, JString, required = false,
                                 default = nil)
  if valid_594836 != nil:
    section.add "X-Amz-Content-Sha256", valid_594836
  var valid_594837 = header.getOrDefault("X-Amz-Date")
  valid_594837 = validateParameter(valid_594837, JString, required = false,
                                 default = nil)
  if valid_594837 != nil:
    section.add "X-Amz-Date", valid_594837
  var valid_594838 = header.getOrDefault("X-Amz-Credential")
  valid_594838 = validateParameter(valid_594838, JString, required = false,
                                 default = nil)
  if valid_594838 != nil:
    section.add "X-Amz-Credential", valid_594838
  var valid_594839 = header.getOrDefault("X-Amz-Security-Token")
  valid_594839 = validateParameter(valid_594839, JString, required = false,
                                 default = nil)
  if valid_594839 != nil:
    section.add "X-Amz-Security-Token", valid_594839
  var valid_594840 = header.getOrDefault("X-Amz-Algorithm")
  valid_594840 = validateParameter(valid_594840, JString, required = false,
                                 default = nil)
  if valid_594840 != nil:
    section.add "X-Amz-Algorithm", valid_594840
  var valid_594841 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594841 = validateParameter(valid_594841, JString, required = false,
                                 default = nil)
  if valid_594841 != nil:
    section.add "X-Amz-SignedHeaders", valid_594841
  result.add "header", section
  ## parameters in `formData` object:
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_594842 = formData.getOrDefault("MaxRecords")
  valid_594842 = validateParameter(valid_594842, JInt, required = false, default = nil)
  if valid_594842 != nil:
    section.add "MaxRecords", valid_594842
  var valid_594843 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_594843 = validateParameter(valid_594843, JString, required = false,
                                 default = nil)
  if valid_594843 != nil:
    section.add "ReservedNodeOfferingId", valid_594843
  var valid_594844 = formData.getOrDefault("Marker")
  valid_594844 = validateParameter(valid_594844, JString, required = false,
                                 default = nil)
  if valid_594844 != nil:
    section.add "Marker", valid_594844
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594845: Call_PostDescribeReservedNodeOfferings_594830;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594845.validator(path, query, header, formData, body)
  let scheme = call_594845.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594845.url(scheme.get, call_594845.host, call_594845.base,
                         call_594845.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594845, url, valid)

proc call*(call_594846: Call_PostDescribeReservedNodeOfferings_594830;
          MaxRecords: int = 0; ReservedNodeOfferingId: string = ""; Marker: string = "";
          Action: string = "DescribeReservedNodeOfferings";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594847 = newJObject()
  var formData_594848 = newJObject()
  add(formData_594848, "MaxRecords", newJInt(MaxRecords))
  add(formData_594848, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(formData_594848, "Marker", newJString(Marker))
  add(query_594847, "Action", newJString(Action))
  add(query_594847, "Version", newJString(Version))
  result = call_594846.call(nil, query_594847, nil, formData_594848, nil)

var postDescribeReservedNodeOfferings* = Call_PostDescribeReservedNodeOfferings_594830(
    name: "postDescribeReservedNodeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_PostDescribeReservedNodeOfferings_594831, base: "/",
    url: url_PostDescribeReservedNodeOfferings_594832,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodeOfferings_594812 = ref object of OpenApiRestCall_592348
proc url_GetDescribeReservedNodeOfferings_594814(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeReservedNodeOfferings_594813(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ReservedNodeOfferingId: JString
  ##                         : The unique identifier for the offering.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_594815 = query.getOrDefault("Marker")
  valid_594815 = validateParameter(valid_594815, JString, required = false,
                                 default = nil)
  if valid_594815 != nil:
    section.add "Marker", valid_594815
  var valid_594816 = query.getOrDefault("ReservedNodeOfferingId")
  valid_594816 = validateParameter(valid_594816, JString, required = false,
                                 default = nil)
  if valid_594816 != nil:
    section.add "ReservedNodeOfferingId", valid_594816
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594817 = query.getOrDefault("Action")
  valid_594817 = validateParameter(valid_594817, JString, required = true, default = newJString(
      "DescribeReservedNodeOfferings"))
  if valid_594817 != nil:
    section.add "Action", valid_594817
  var valid_594818 = query.getOrDefault("Version")
  valid_594818 = validateParameter(valid_594818, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594818 != nil:
    section.add "Version", valid_594818
  var valid_594819 = query.getOrDefault("MaxRecords")
  valid_594819 = validateParameter(valid_594819, JInt, required = false, default = nil)
  if valid_594819 != nil:
    section.add "MaxRecords", valid_594819
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594820 = header.getOrDefault("X-Amz-Signature")
  valid_594820 = validateParameter(valid_594820, JString, required = false,
                                 default = nil)
  if valid_594820 != nil:
    section.add "X-Amz-Signature", valid_594820
  var valid_594821 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594821 = validateParameter(valid_594821, JString, required = false,
                                 default = nil)
  if valid_594821 != nil:
    section.add "X-Amz-Content-Sha256", valid_594821
  var valid_594822 = header.getOrDefault("X-Amz-Date")
  valid_594822 = validateParameter(valid_594822, JString, required = false,
                                 default = nil)
  if valid_594822 != nil:
    section.add "X-Amz-Date", valid_594822
  var valid_594823 = header.getOrDefault("X-Amz-Credential")
  valid_594823 = validateParameter(valid_594823, JString, required = false,
                                 default = nil)
  if valid_594823 != nil:
    section.add "X-Amz-Credential", valid_594823
  var valid_594824 = header.getOrDefault("X-Amz-Security-Token")
  valid_594824 = validateParameter(valid_594824, JString, required = false,
                                 default = nil)
  if valid_594824 != nil:
    section.add "X-Amz-Security-Token", valid_594824
  var valid_594825 = header.getOrDefault("X-Amz-Algorithm")
  valid_594825 = validateParameter(valid_594825, JString, required = false,
                                 default = nil)
  if valid_594825 != nil:
    section.add "X-Amz-Algorithm", valid_594825
  var valid_594826 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594826 = validateParameter(valid_594826, JString, required = false,
                                 default = nil)
  if valid_594826 != nil:
    section.add "X-Amz-SignedHeaders", valid_594826
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594827: Call_GetDescribeReservedNodeOfferings_594812;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_594827.validator(path, query, header, formData, body)
  let scheme = call_594827.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594827.url(scheme.get, call_594827.host, call_594827.base,
                         call_594827.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594827, url, valid)

proc call*(call_594828: Call_GetDescribeReservedNodeOfferings_594812;
          Marker: string = ""; ReservedNodeOfferingId: string = "";
          Action: string = "DescribeReservedNodeOfferings";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeReservedNodeOfferings
  ## <p>Returns a list of the available reserved node offerings by Amazon Redshift with their descriptions including the node type, the fixed and recurring costs of reserving the node and duration the node will be reserved for you. These descriptions help you determine which reserve node offering you want to purchase. You then use the unique offering ID in you call to <a>PurchaseReservedNodeOffering</a> to reserve one or more nodes for your Amazon Redshift cluster. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodeOfferings</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   ReservedNodeOfferingId: string
  ##                         : The unique identifier for the offering.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_594829 = newJObject()
  add(query_594829, "Marker", newJString(Marker))
  add(query_594829, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_594829, "Action", newJString(Action))
  add(query_594829, "Version", newJString(Version))
  add(query_594829, "MaxRecords", newJInt(MaxRecords))
  result = call_594828.call(nil, query_594829, nil, nil, nil)

var getDescribeReservedNodeOfferings* = Call_GetDescribeReservedNodeOfferings_594812(
    name: "getDescribeReservedNodeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=DescribeReservedNodeOfferings",
    validator: validate_GetDescribeReservedNodeOfferings_594813, base: "/",
    url: url_GetDescribeReservedNodeOfferings_594814,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeReservedNodes_594867 = ref object of OpenApiRestCall_592348
proc url_PostDescribeReservedNodes_594869(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeReservedNodes_594868(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594870 = query.getOrDefault("Action")
  valid_594870 = validateParameter(valid_594870, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_594870 != nil:
    section.add "Action", valid_594870
  var valid_594871 = query.getOrDefault("Version")
  valid_594871 = validateParameter(valid_594871, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594871 != nil:
    section.add "Version", valid_594871
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594872 = header.getOrDefault("X-Amz-Signature")
  valid_594872 = validateParameter(valid_594872, JString, required = false,
                                 default = nil)
  if valid_594872 != nil:
    section.add "X-Amz-Signature", valid_594872
  var valid_594873 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594873 = validateParameter(valid_594873, JString, required = false,
                                 default = nil)
  if valid_594873 != nil:
    section.add "X-Amz-Content-Sha256", valid_594873
  var valid_594874 = header.getOrDefault("X-Amz-Date")
  valid_594874 = validateParameter(valid_594874, JString, required = false,
                                 default = nil)
  if valid_594874 != nil:
    section.add "X-Amz-Date", valid_594874
  var valid_594875 = header.getOrDefault("X-Amz-Credential")
  valid_594875 = validateParameter(valid_594875, JString, required = false,
                                 default = nil)
  if valid_594875 != nil:
    section.add "X-Amz-Credential", valid_594875
  var valid_594876 = header.getOrDefault("X-Amz-Security-Token")
  valid_594876 = validateParameter(valid_594876, JString, required = false,
                                 default = nil)
  if valid_594876 != nil:
    section.add "X-Amz-Security-Token", valid_594876
  var valid_594877 = header.getOrDefault("X-Amz-Algorithm")
  valid_594877 = validateParameter(valid_594877, JString, required = false,
                                 default = nil)
  if valid_594877 != nil:
    section.add "X-Amz-Algorithm", valid_594877
  var valid_594878 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594878 = validateParameter(valid_594878, JString, required = false,
                                 default = nil)
  if valid_594878 != nil:
    section.add "X-Amz-SignedHeaders", valid_594878
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  section = newJObject()
  var valid_594879 = formData.getOrDefault("ReservedNodeId")
  valid_594879 = validateParameter(valid_594879, JString, required = false,
                                 default = nil)
  if valid_594879 != nil:
    section.add "ReservedNodeId", valid_594879
  var valid_594880 = formData.getOrDefault("MaxRecords")
  valid_594880 = validateParameter(valid_594880, JInt, required = false, default = nil)
  if valid_594880 != nil:
    section.add "MaxRecords", valid_594880
  var valid_594881 = formData.getOrDefault("Marker")
  valid_594881 = validateParameter(valid_594881, JString, required = false,
                                 default = nil)
  if valid_594881 != nil:
    section.add "Marker", valid_594881
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594882: Call_PostDescribeReservedNodes_594867; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_594882.validator(path, query, header, formData, body)
  let scheme = call_594882.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594882.url(scheme.get, call_594882.host, call_594882.base,
                         call_594882.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594882, url, valid)

proc call*(call_594883: Call_PostDescribeReservedNodes_594867;
          ReservedNodeId: string = ""; MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeReservedNodes"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594884 = newJObject()
  var formData_594885 = newJObject()
  add(formData_594885, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_594885, "MaxRecords", newJInt(MaxRecords))
  add(formData_594885, "Marker", newJString(Marker))
  add(query_594884, "Action", newJString(Action))
  add(query_594884, "Version", newJString(Version))
  result = call_594883.call(nil, query_594884, nil, formData_594885, nil)

var postDescribeReservedNodes* = Call_PostDescribeReservedNodes_594867(
    name: "postDescribeReservedNodes", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_PostDescribeReservedNodes_594868, base: "/",
    url: url_PostDescribeReservedNodes_594869,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeReservedNodes_594849 = ref object of OpenApiRestCall_592348
proc url_GetDescribeReservedNodes_594851(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeReservedNodes_594850(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns the descriptions of the reserved nodes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: JString (required)
  ##   ReservedNodeId: JString
  ##                 : Identifier for the node reservation.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  section = newJObject()
  var valid_594852 = query.getOrDefault("Marker")
  valid_594852 = validateParameter(valid_594852, JString, required = false,
                                 default = nil)
  if valid_594852 != nil:
    section.add "Marker", valid_594852
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594853 = query.getOrDefault("Action")
  valid_594853 = validateParameter(valid_594853, JString, required = true,
                                 default = newJString("DescribeReservedNodes"))
  if valid_594853 != nil:
    section.add "Action", valid_594853
  var valid_594854 = query.getOrDefault("ReservedNodeId")
  valid_594854 = validateParameter(valid_594854, JString, required = false,
                                 default = nil)
  if valid_594854 != nil:
    section.add "ReservedNodeId", valid_594854
  var valid_594855 = query.getOrDefault("Version")
  valid_594855 = validateParameter(valid_594855, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594855 != nil:
    section.add "Version", valid_594855
  var valid_594856 = query.getOrDefault("MaxRecords")
  valid_594856 = validateParameter(valid_594856, JInt, required = false, default = nil)
  if valid_594856 != nil:
    section.add "MaxRecords", valid_594856
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594857 = header.getOrDefault("X-Amz-Signature")
  valid_594857 = validateParameter(valid_594857, JString, required = false,
                                 default = nil)
  if valid_594857 != nil:
    section.add "X-Amz-Signature", valid_594857
  var valid_594858 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594858 = validateParameter(valid_594858, JString, required = false,
                                 default = nil)
  if valid_594858 != nil:
    section.add "X-Amz-Content-Sha256", valid_594858
  var valid_594859 = header.getOrDefault("X-Amz-Date")
  valid_594859 = validateParameter(valid_594859, JString, required = false,
                                 default = nil)
  if valid_594859 != nil:
    section.add "X-Amz-Date", valid_594859
  var valid_594860 = header.getOrDefault("X-Amz-Credential")
  valid_594860 = validateParameter(valid_594860, JString, required = false,
                                 default = nil)
  if valid_594860 != nil:
    section.add "X-Amz-Credential", valid_594860
  var valid_594861 = header.getOrDefault("X-Amz-Security-Token")
  valid_594861 = validateParameter(valid_594861, JString, required = false,
                                 default = nil)
  if valid_594861 != nil:
    section.add "X-Amz-Security-Token", valid_594861
  var valid_594862 = header.getOrDefault("X-Amz-Algorithm")
  valid_594862 = validateParameter(valid_594862, JString, required = false,
                                 default = nil)
  if valid_594862 != nil:
    section.add "X-Amz-Algorithm", valid_594862
  var valid_594863 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594863 = validateParameter(valid_594863, JString, required = false,
                                 default = nil)
  if valid_594863 != nil:
    section.add "X-Amz-SignedHeaders", valid_594863
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594864: Call_GetDescribeReservedNodes_594849; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the descriptions of the reserved nodes.
  ## 
  let valid = call_594864.validator(path, query, header, formData, body)
  let scheme = call_594864.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594864.url(scheme.get, call_594864.host, call_594864.base,
                         call_594864.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594864, url, valid)

proc call*(call_594865: Call_GetDescribeReservedNodes_594849; Marker: string = "";
          Action: string = "DescribeReservedNodes"; ReservedNodeId: string = "";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getDescribeReservedNodes
  ## Returns the descriptions of the reserved nodes.
  ##   Marker: string
  ##         : An optional parameter that specifies the starting point to return a set of response records. When the results of a <a>DescribeReservedNodes</a> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. 
  ##   Action: string (required)
  ##   ReservedNodeId: string
  ##                 : Identifier for the node reservation.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  var query_594866 = newJObject()
  add(query_594866, "Marker", newJString(Marker))
  add(query_594866, "Action", newJString(Action))
  add(query_594866, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_594866, "Version", newJString(Version))
  add(query_594866, "MaxRecords", newJInt(MaxRecords))
  result = call_594865.call(nil, query_594866, nil, nil, nil)

var getDescribeReservedNodes* = Call_GetDescribeReservedNodes_594849(
    name: "getDescribeReservedNodes", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeReservedNodes",
    validator: validate_GetDescribeReservedNodes_594850, base: "/",
    url: url_GetDescribeReservedNodes_594851, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeResize_594902 = ref object of OpenApiRestCall_592348
proc url_PostDescribeResize_594904(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeResize_594903(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594905 = query.getOrDefault("Action")
  valid_594905 = validateParameter(valid_594905, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_594905 != nil:
    section.add "Action", valid_594905
  var valid_594906 = query.getOrDefault("Version")
  valid_594906 = validateParameter(valid_594906, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594906 != nil:
    section.add "Version", valid_594906
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594907 = header.getOrDefault("X-Amz-Signature")
  valid_594907 = validateParameter(valid_594907, JString, required = false,
                                 default = nil)
  if valid_594907 != nil:
    section.add "X-Amz-Signature", valid_594907
  var valid_594908 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594908 = validateParameter(valid_594908, JString, required = false,
                                 default = nil)
  if valid_594908 != nil:
    section.add "X-Amz-Content-Sha256", valid_594908
  var valid_594909 = header.getOrDefault("X-Amz-Date")
  valid_594909 = validateParameter(valid_594909, JString, required = false,
                                 default = nil)
  if valid_594909 != nil:
    section.add "X-Amz-Date", valid_594909
  var valid_594910 = header.getOrDefault("X-Amz-Credential")
  valid_594910 = validateParameter(valid_594910, JString, required = false,
                                 default = nil)
  if valid_594910 != nil:
    section.add "X-Amz-Credential", valid_594910
  var valid_594911 = header.getOrDefault("X-Amz-Security-Token")
  valid_594911 = validateParameter(valid_594911, JString, required = false,
                                 default = nil)
  if valid_594911 != nil:
    section.add "X-Amz-Security-Token", valid_594911
  var valid_594912 = header.getOrDefault("X-Amz-Algorithm")
  valid_594912 = validateParameter(valid_594912, JString, required = false,
                                 default = nil)
  if valid_594912 != nil:
    section.add "X-Amz-Algorithm", valid_594912
  var valid_594913 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594913 = validateParameter(valid_594913, JString, required = false,
                                 default = nil)
  if valid_594913 != nil:
    section.add "X-Amz-SignedHeaders", valid_594913
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_594914 = formData.getOrDefault("ClusterIdentifier")
  valid_594914 = validateParameter(valid_594914, JString, required = true,
                                 default = nil)
  if valid_594914 != nil:
    section.add "ClusterIdentifier", valid_594914
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594915: Call_PostDescribeResize_594902; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_594915.validator(path, query, header, formData, body)
  let scheme = call_594915.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594915.url(scheme.get, call_594915.host, call_594915.base,
                         call_594915.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594915, url, valid)

proc call*(call_594916: Call_PostDescribeResize_594902; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_594917 = newJObject()
  var formData_594918 = newJObject()
  add(formData_594918, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594917, "Action", newJString(Action))
  add(query_594917, "Version", newJString(Version))
  result = call_594916.call(nil, query_594917, nil, formData_594918, nil)

var postDescribeResize* = Call_PostDescribeResize_594902(
    name: "postDescribeResize", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeResize",
    validator: validate_PostDescribeResize_594903, base: "/",
    url: url_PostDescribeResize_594904, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeResize_594886 = ref object of OpenApiRestCall_592348
proc url_GetDescribeResize_594888(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeResize_594887(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594889 = query.getOrDefault("Action")
  valid_594889 = validateParameter(valid_594889, JString, required = true,
                                 default = newJString("DescribeResize"))
  if valid_594889 != nil:
    section.add "Action", valid_594889
  var valid_594890 = query.getOrDefault("ClusterIdentifier")
  valid_594890 = validateParameter(valid_594890, JString, required = true,
                                 default = nil)
  if valid_594890 != nil:
    section.add "ClusterIdentifier", valid_594890
  var valid_594891 = query.getOrDefault("Version")
  valid_594891 = validateParameter(valid_594891, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594891 != nil:
    section.add "Version", valid_594891
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594892 = header.getOrDefault("X-Amz-Signature")
  valid_594892 = validateParameter(valid_594892, JString, required = false,
                                 default = nil)
  if valid_594892 != nil:
    section.add "X-Amz-Signature", valid_594892
  var valid_594893 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594893 = validateParameter(valid_594893, JString, required = false,
                                 default = nil)
  if valid_594893 != nil:
    section.add "X-Amz-Content-Sha256", valid_594893
  var valid_594894 = header.getOrDefault("X-Amz-Date")
  valid_594894 = validateParameter(valid_594894, JString, required = false,
                                 default = nil)
  if valid_594894 != nil:
    section.add "X-Amz-Date", valid_594894
  var valid_594895 = header.getOrDefault("X-Amz-Credential")
  valid_594895 = validateParameter(valid_594895, JString, required = false,
                                 default = nil)
  if valid_594895 != nil:
    section.add "X-Amz-Credential", valid_594895
  var valid_594896 = header.getOrDefault("X-Amz-Security-Token")
  valid_594896 = validateParameter(valid_594896, JString, required = false,
                                 default = nil)
  if valid_594896 != nil:
    section.add "X-Amz-Security-Token", valid_594896
  var valid_594897 = header.getOrDefault("X-Amz-Algorithm")
  valid_594897 = validateParameter(valid_594897, JString, required = false,
                                 default = nil)
  if valid_594897 != nil:
    section.add "X-Amz-Algorithm", valid_594897
  var valid_594898 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594898 = validateParameter(valid_594898, JString, required = false,
                                 default = nil)
  if valid_594898 != nil:
    section.add "X-Amz-SignedHeaders", valid_594898
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594899: Call_GetDescribeResize_594886; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ## 
  let valid = call_594899.validator(path, query, header, formData, body)
  let scheme = call_594899.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594899.url(scheme.get, call_594899.host, call_594899.base,
                         call_594899.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594899, url, valid)

proc call*(call_594900: Call_GetDescribeResize_594886; ClusterIdentifier: string;
          Action: string = "DescribeResize"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeResize
  ## <p>Returns information about the last resize operation for the specified cluster. If no resize operation has ever been initiated for the specified cluster, a <code>HTTP 404</code> error is returned. If a resize operation was initiated and completed, the status of the resize remains as <code>SUCCEEDED</code> until the next resize. </p> <p>A resize operation can be requested using <a>ModifyCluster</a> and specifying a different number or type of nodes for the cluster. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose resize progress you are requesting. This parameter is case-sensitive.</p> <p>By default, resize operations for all clusters defined for an AWS account are returned.</p>
  ##   Version: string (required)
  var query_594901 = newJObject()
  add(query_594901, "Action", newJString(Action))
  add(query_594901, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594901, "Version", newJString(Version))
  result = call_594900.call(nil, query_594901, nil, nil, nil)

var getDescribeResize* = Call_GetDescribeResize_594886(name: "getDescribeResize",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeResize", validator: validate_GetDescribeResize_594887,
    base: "/", url: url_GetDescribeResize_594888,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotCopyGrants_594939 = ref object of OpenApiRestCall_592348
proc url_PostDescribeSnapshotCopyGrants_594941(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeSnapshotCopyGrants_594940(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594942 = query.getOrDefault("Action")
  valid_594942 = validateParameter(valid_594942, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_594942 != nil:
    section.add "Action", valid_594942
  var valid_594943 = query.getOrDefault("Version")
  valid_594943 = validateParameter(valid_594943, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594943 != nil:
    section.add "Version", valid_594943
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594944 = header.getOrDefault("X-Amz-Signature")
  valid_594944 = validateParameter(valid_594944, JString, required = false,
                                 default = nil)
  if valid_594944 != nil:
    section.add "X-Amz-Signature", valid_594944
  var valid_594945 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594945 = validateParameter(valid_594945, JString, required = false,
                                 default = nil)
  if valid_594945 != nil:
    section.add "X-Amz-Content-Sha256", valid_594945
  var valid_594946 = header.getOrDefault("X-Amz-Date")
  valid_594946 = validateParameter(valid_594946, JString, required = false,
                                 default = nil)
  if valid_594946 != nil:
    section.add "X-Amz-Date", valid_594946
  var valid_594947 = header.getOrDefault("X-Amz-Credential")
  valid_594947 = validateParameter(valid_594947, JString, required = false,
                                 default = nil)
  if valid_594947 != nil:
    section.add "X-Amz-Credential", valid_594947
  var valid_594948 = header.getOrDefault("X-Amz-Security-Token")
  valid_594948 = validateParameter(valid_594948, JString, required = false,
                                 default = nil)
  if valid_594948 != nil:
    section.add "X-Amz-Security-Token", valid_594948
  var valid_594949 = header.getOrDefault("X-Amz-Algorithm")
  valid_594949 = validateParameter(valid_594949, JString, required = false,
                                 default = nil)
  if valid_594949 != nil:
    section.add "X-Amz-Algorithm", valid_594949
  var valid_594950 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594950 = validateParameter(valid_594950, JString, required = false,
                                 default = nil)
  if valid_594950 != nil:
    section.add "X-Amz-SignedHeaders", valid_594950
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  section = newJObject()
  var valid_594951 = formData.getOrDefault("TagKeys")
  valid_594951 = validateParameter(valid_594951, JArray, required = false,
                                 default = nil)
  if valid_594951 != nil:
    section.add "TagKeys", valid_594951
  var valid_594952 = formData.getOrDefault("MaxRecords")
  valid_594952 = validateParameter(valid_594952, JInt, required = false, default = nil)
  if valid_594952 != nil:
    section.add "MaxRecords", valid_594952
  var valid_594953 = formData.getOrDefault("Marker")
  valid_594953 = validateParameter(valid_594953, JString, required = false,
                                 default = nil)
  if valid_594953 != nil:
    section.add "Marker", valid_594953
  var valid_594954 = formData.getOrDefault("TagValues")
  valid_594954 = validateParameter(valid_594954, JArray, required = false,
                                 default = nil)
  if valid_594954 != nil:
    section.add "TagValues", valid_594954
  var valid_594955 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_594955 = validateParameter(valid_594955, JString, required = false,
                                 default = nil)
  if valid_594955 != nil:
    section.add "SnapshotCopyGrantName", valid_594955
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594956: Call_PostDescribeSnapshotCopyGrants_594939; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_594956.validator(path, query, header, formData, body)
  let scheme = call_594956.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594956.url(scheme.get, call_594956.host, call_594956.base,
                         call_594956.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594956, url, valid)

proc call*(call_594957: Call_PostDescribeSnapshotCopyGrants_594939;
          TagKeys: JsonNode = nil; MaxRecords: int = 0; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeSnapshotCopyGrants";
          SnapshotCopyGrantName: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   Version: string (required)
  var query_594958 = newJObject()
  var formData_594959 = newJObject()
  if TagKeys != nil:
    formData_594959.add "TagKeys", TagKeys
  add(formData_594959, "MaxRecords", newJInt(MaxRecords))
  add(formData_594959, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_594959.add "TagValues", TagValues
  add(query_594958, "Action", newJString(Action))
  add(formData_594959, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_594958, "Version", newJString(Version))
  result = call_594957.call(nil, query_594958, nil, formData_594959, nil)

var postDescribeSnapshotCopyGrants* = Call_PostDescribeSnapshotCopyGrants_594939(
    name: "postDescribeSnapshotCopyGrants", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_PostDescribeSnapshotCopyGrants_594940, base: "/",
    url: url_PostDescribeSnapshotCopyGrants_594941,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotCopyGrants_594919 = ref object of OpenApiRestCall_592348
proc url_GetDescribeSnapshotCopyGrants_594921(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeSnapshotCopyGrants_594920(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant.
  ##   MaxRecords: JInt
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_594922 = query.getOrDefault("Marker")
  valid_594922 = validateParameter(valid_594922, JString, required = false,
                                 default = nil)
  if valid_594922 != nil:
    section.add "Marker", valid_594922
  var valid_594923 = query.getOrDefault("TagKeys")
  valid_594923 = validateParameter(valid_594923, JArray, required = false,
                                 default = nil)
  if valid_594923 != nil:
    section.add "TagKeys", valid_594923
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594924 = query.getOrDefault("Action")
  valid_594924 = validateParameter(valid_594924, JString, required = true, default = newJString(
      "DescribeSnapshotCopyGrants"))
  if valid_594924 != nil:
    section.add "Action", valid_594924
  var valid_594925 = query.getOrDefault("Version")
  valid_594925 = validateParameter(valid_594925, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594925 != nil:
    section.add "Version", valid_594925
  var valid_594926 = query.getOrDefault("SnapshotCopyGrantName")
  valid_594926 = validateParameter(valid_594926, JString, required = false,
                                 default = nil)
  if valid_594926 != nil:
    section.add "SnapshotCopyGrantName", valid_594926
  var valid_594927 = query.getOrDefault("MaxRecords")
  valid_594927 = validateParameter(valid_594927, JInt, required = false, default = nil)
  if valid_594927 != nil:
    section.add "MaxRecords", valid_594927
  var valid_594928 = query.getOrDefault("TagValues")
  valid_594928 = validateParameter(valid_594928, JArray, required = false,
                                 default = nil)
  if valid_594928 != nil:
    section.add "TagValues", valid_594928
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594929 = header.getOrDefault("X-Amz-Signature")
  valid_594929 = validateParameter(valid_594929, JString, required = false,
                                 default = nil)
  if valid_594929 != nil:
    section.add "X-Amz-Signature", valid_594929
  var valid_594930 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594930 = validateParameter(valid_594930, JString, required = false,
                                 default = nil)
  if valid_594930 != nil:
    section.add "X-Amz-Content-Sha256", valid_594930
  var valid_594931 = header.getOrDefault("X-Amz-Date")
  valid_594931 = validateParameter(valid_594931, JString, required = false,
                                 default = nil)
  if valid_594931 != nil:
    section.add "X-Amz-Date", valid_594931
  var valid_594932 = header.getOrDefault("X-Amz-Credential")
  valid_594932 = validateParameter(valid_594932, JString, required = false,
                                 default = nil)
  if valid_594932 != nil:
    section.add "X-Amz-Credential", valid_594932
  var valid_594933 = header.getOrDefault("X-Amz-Security-Token")
  valid_594933 = validateParameter(valid_594933, JString, required = false,
                                 default = nil)
  if valid_594933 != nil:
    section.add "X-Amz-Security-Token", valid_594933
  var valid_594934 = header.getOrDefault("X-Amz-Algorithm")
  valid_594934 = validateParameter(valid_594934, JString, required = false,
                                 default = nil)
  if valid_594934 != nil:
    section.add "X-Amz-Algorithm", valid_594934
  var valid_594935 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594935 = validateParameter(valid_594935, JString, required = false,
                                 default = nil)
  if valid_594935 != nil:
    section.add "X-Amz-SignedHeaders", valid_594935
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594936: Call_GetDescribeSnapshotCopyGrants_594919; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ## 
  let valid = call_594936.validator(path, query, header, formData, body)
  let scheme = call_594936.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594936.url(scheme.get, call_594936.host, call_594936.base,
                         call_594936.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594936, url, valid)

proc call*(call_594937: Call_GetDescribeSnapshotCopyGrants_594919;
          Marker: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeSnapshotCopyGrants";
          Version: string = "2012-12-01"; SnapshotCopyGrantName: string = "";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeSnapshotCopyGrants
  ## <p>Returns a list of snapshot copy grants owned by the AWS account in the destination region.</p> <p> For more information about managing snapshot copy grants, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-db-encryption.html">Amazon Redshift Database Encryption</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   Marker: string
  ##         : <p>An optional parameter that specifies the starting point to return a set of response records. When the results of a <code>DescribeSnapshotCopyGrant</code> request exceed the value specified in <code>MaxRecords</code>, AWS returns a value in the <code>Marker</code> field of the response. You can retrieve the next set of response records by providing the returned marker value in the <code>Marker</code> parameter and retrying the request. </p> <p>Constraints: You can specify either the <b>SnapshotCopyGrantName</b> parameter or the <b>Marker</b> parameter, but not both. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant.
  ##   MaxRecords: int
  ##             : <p>The maximum number of response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned marker value. </p> <p>Default: <code>100</code> </p> <p>Constraints: minimum 20, maximum 100.</p>
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  var query_594938 = newJObject()
  add(query_594938, "Marker", newJString(Marker))
  if TagKeys != nil:
    query_594938.add "TagKeys", TagKeys
  add(query_594938, "Action", newJString(Action))
  add(query_594938, "Version", newJString(Version))
  add(query_594938, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_594938, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_594938.add "TagValues", TagValues
  result = call_594937.call(nil, query_594938, nil, nil, nil)

var getDescribeSnapshotCopyGrants* = Call_GetDescribeSnapshotCopyGrants_594919(
    name: "getDescribeSnapshotCopyGrants", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotCopyGrants",
    validator: validate_GetDescribeSnapshotCopyGrants_594920, base: "/",
    url: url_GetDescribeSnapshotCopyGrants_594921,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeSnapshotSchedules_594981 = ref object of OpenApiRestCall_592348
proc url_PostDescribeSnapshotSchedules_594983(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeSnapshotSchedules_594982(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594984 = query.getOrDefault("Action")
  valid_594984 = validateParameter(valid_594984, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_594984 != nil:
    section.add "Action", valid_594984
  var valid_594985 = query.getOrDefault("Version")
  valid_594985 = validateParameter(valid_594985, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594985 != nil:
    section.add "Version", valid_594985
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594986 = header.getOrDefault("X-Amz-Signature")
  valid_594986 = validateParameter(valid_594986, JString, required = false,
                                 default = nil)
  if valid_594986 != nil:
    section.add "X-Amz-Signature", valid_594986
  var valid_594987 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594987 = validateParameter(valid_594987, JString, required = false,
                                 default = nil)
  if valid_594987 != nil:
    section.add "X-Amz-Content-Sha256", valid_594987
  var valid_594988 = header.getOrDefault("X-Amz-Date")
  valid_594988 = validateParameter(valid_594988, JString, required = false,
                                 default = nil)
  if valid_594988 != nil:
    section.add "X-Amz-Date", valid_594988
  var valid_594989 = header.getOrDefault("X-Amz-Credential")
  valid_594989 = validateParameter(valid_594989, JString, required = false,
                                 default = nil)
  if valid_594989 != nil:
    section.add "X-Amz-Credential", valid_594989
  var valid_594990 = header.getOrDefault("X-Amz-Security-Token")
  valid_594990 = validateParameter(valid_594990, JString, required = false,
                                 default = nil)
  if valid_594990 != nil:
    section.add "X-Amz-Security-Token", valid_594990
  var valid_594991 = header.getOrDefault("X-Amz-Algorithm")
  valid_594991 = validateParameter(valid_594991, JString, required = false,
                                 default = nil)
  if valid_594991 != nil:
    section.add "X-Amz-Algorithm", valid_594991
  var valid_594992 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594992 = validateParameter(valid_594992, JString, required = false,
                                 default = nil)
  if valid_594992 != nil:
    section.add "X-Amz-SignedHeaders", valid_594992
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  section = newJObject()
  var valid_594993 = formData.getOrDefault("TagKeys")
  valid_594993 = validateParameter(valid_594993, JArray, required = false,
                                 default = nil)
  if valid_594993 != nil:
    section.add "TagKeys", valid_594993
  var valid_594994 = formData.getOrDefault("ClusterIdentifier")
  valid_594994 = validateParameter(valid_594994, JString, required = false,
                                 default = nil)
  if valid_594994 != nil:
    section.add "ClusterIdentifier", valid_594994
  var valid_594995 = formData.getOrDefault("MaxRecords")
  valid_594995 = validateParameter(valid_594995, JInt, required = false, default = nil)
  if valid_594995 != nil:
    section.add "MaxRecords", valid_594995
  var valid_594996 = formData.getOrDefault("Marker")
  valid_594996 = validateParameter(valid_594996, JString, required = false,
                                 default = nil)
  if valid_594996 != nil:
    section.add "Marker", valid_594996
  var valid_594997 = formData.getOrDefault("TagValues")
  valid_594997 = validateParameter(valid_594997, JArray, required = false,
                                 default = nil)
  if valid_594997 != nil:
    section.add "TagValues", valid_594997
  var valid_594998 = formData.getOrDefault("ScheduleIdentifier")
  valid_594998 = validateParameter(valid_594998, JString, required = false,
                                 default = nil)
  if valid_594998 != nil:
    section.add "ScheduleIdentifier", valid_594998
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594999: Call_PostDescribeSnapshotSchedules_594981; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_594999.validator(path, query, header, formData, body)
  let scheme = call_594999.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594999.url(scheme.get, call_594999.host, call_594999.base,
                         call_594999.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594999, url, valid)

proc call*(call_595000: Call_PostDescribeSnapshotSchedules_594981;
          TagKeys: JsonNode = nil; ClusterIdentifier: string = ""; MaxRecords: int = 0;
          Marker: string = ""; TagValues: JsonNode = nil;
          Action: string = "DescribeSnapshotSchedules";
          ScheduleIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   Version: string (required)
  var query_595001 = newJObject()
  var formData_595002 = newJObject()
  if TagKeys != nil:
    formData_595002.add "TagKeys", TagKeys
  add(formData_595002, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_595002, "MaxRecords", newJInt(MaxRecords))
  add(formData_595002, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_595002.add "TagValues", TagValues
  add(query_595001, "Action", newJString(Action))
  add(formData_595002, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_595001, "Version", newJString(Version))
  result = call_595000.call(nil, query_595001, nil, formData_595002, nil)

var postDescribeSnapshotSchedules* = Call_PostDescribeSnapshotSchedules_594981(
    name: "postDescribeSnapshotSchedules", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_PostDescribeSnapshotSchedules_594982, base: "/",
    url: url_PostDescribeSnapshotSchedules_594983,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeSnapshotSchedules_594960 = ref object of OpenApiRestCall_592348
proc url_GetDescribeSnapshotSchedules_594962(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeSnapshotSchedules_594961(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns a list of snapshot schedules. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ScheduleIdentifier: JString
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  section = newJObject()
  var valid_594963 = query.getOrDefault("Marker")
  valid_594963 = validateParameter(valid_594963, JString, required = false,
                                 default = nil)
  if valid_594963 != nil:
    section.add "Marker", valid_594963
  var valid_594964 = query.getOrDefault("ScheduleIdentifier")
  valid_594964 = validateParameter(valid_594964, JString, required = false,
                                 default = nil)
  if valid_594964 != nil:
    section.add "ScheduleIdentifier", valid_594964
  var valid_594965 = query.getOrDefault("TagKeys")
  valid_594965 = validateParameter(valid_594965, JArray, required = false,
                                 default = nil)
  if valid_594965 != nil:
    section.add "TagKeys", valid_594965
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_594966 = query.getOrDefault("Action")
  valid_594966 = validateParameter(valid_594966, JString, required = true, default = newJString(
      "DescribeSnapshotSchedules"))
  if valid_594966 != nil:
    section.add "Action", valid_594966
  var valid_594967 = query.getOrDefault("ClusterIdentifier")
  valid_594967 = validateParameter(valid_594967, JString, required = false,
                                 default = nil)
  if valid_594967 != nil:
    section.add "ClusterIdentifier", valid_594967
  var valid_594968 = query.getOrDefault("Version")
  valid_594968 = validateParameter(valid_594968, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_594968 != nil:
    section.add "Version", valid_594968
  var valid_594969 = query.getOrDefault("MaxRecords")
  valid_594969 = validateParameter(valid_594969, JInt, required = false, default = nil)
  if valid_594969 != nil:
    section.add "MaxRecords", valid_594969
  var valid_594970 = query.getOrDefault("TagValues")
  valid_594970 = validateParameter(valid_594970, JArray, required = false,
                                 default = nil)
  if valid_594970 != nil:
    section.add "TagValues", valid_594970
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_594971 = header.getOrDefault("X-Amz-Signature")
  valid_594971 = validateParameter(valid_594971, JString, required = false,
                                 default = nil)
  if valid_594971 != nil:
    section.add "X-Amz-Signature", valid_594971
  var valid_594972 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_594972 = validateParameter(valid_594972, JString, required = false,
                                 default = nil)
  if valid_594972 != nil:
    section.add "X-Amz-Content-Sha256", valid_594972
  var valid_594973 = header.getOrDefault("X-Amz-Date")
  valid_594973 = validateParameter(valid_594973, JString, required = false,
                                 default = nil)
  if valid_594973 != nil:
    section.add "X-Amz-Date", valid_594973
  var valid_594974 = header.getOrDefault("X-Amz-Credential")
  valid_594974 = validateParameter(valid_594974, JString, required = false,
                                 default = nil)
  if valid_594974 != nil:
    section.add "X-Amz-Credential", valid_594974
  var valid_594975 = header.getOrDefault("X-Amz-Security-Token")
  valid_594975 = validateParameter(valid_594975, JString, required = false,
                                 default = nil)
  if valid_594975 != nil:
    section.add "X-Amz-Security-Token", valid_594975
  var valid_594976 = header.getOrDefault("X-Amz-Algorithm")
  valid_594976 = validateParameter(valid_594976, JString, required = false,
                                 default = nil)
  if valid_594976 != nil:
    section.add "X-Amz-Algorithm", valid_594976
  var valid_594977 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_594977 = validateParameter(valid_594977, JString, required = false,
                                 default = nil)
  if valid_594977 != nil:
    section.add "X-Amz-SignedHeaders", valid_594977
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_594978: Call_GetDescribeSnapshotSchedules_594960; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns a list of snapshot schedules. 
  ## 
  let valid = call_594978.validator(path, query, header, formData, body)
  let scheme = call_594978.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_594978.url(scheme.get, call_594978.host, call_594978.base,
                         call_594978.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_594978, url, valid)

proc call*(call_594979: Call_GetDescribeSnapshotSchedules_594960;
          Marker: string = ""; ScheduleIdentifier: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeSnapshotSchedules";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeSnapshotSchedules
  ## Returns a list of snapshot schedules. 
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request.
  ##   ScheduleIdentifier: string
  ##                     : A unique identifier for a snapshot schedule.
  ##   TagKeys: JArray
  ##          : The key value for a snapshot schedule tag.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The unique identifier for the cluster whose snapshot schedules you want to view.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value.
  ##   TagValues: JArray
  ##            : The value corresponding to the key of the snapshot schedule tag.
  var query_594980 = newJObject()
  add(query_594980, "Marker", newJString(Marker))
  add(query_594980, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if TagKeys != nil:
    query_594980.add "TagKeys", TagKeys
  add(query_594980, "Action", newJString(Action))
  add(query_594980, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_594980, "Version", newJString(Version))
  add(query_594980, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_594980.add "TagValues", TagValues
  result = call_594979.call(nil, query_594980, nil, nil, nil)

var getDescribeSnapshotSchedules* = Call_GetDescribeSnapshotSchedules_594960(
    name: "getDescribeSnapshotSchedules", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeSnapshotSchedules",
    validator: validate_GetDescribeSnapshotSchedules_594961, base: "/",
    url: url_GetDescribeSnapshotSchedules_594962,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeStorage_595018 = ref object of OpenApiRestCall_592348
proc url_PostDescribeStorage_595020(protocol: Scheme; host: string; base: string;
                                   route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeStorage_595019(path: JsonNode; query: JsonNode;
                                        header: JsonNode; formData: JsonNode;
                                        body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595021 = query.getOrDefault("Action")
  valid_595021 = validateParameter(valid_595021, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_595021 != nil:
    section.add "Action", valid_595021
  var valid_595022 = query.getOrDefault("Version")
  valid_595022 = validateParameter(valid_595022, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595022 != nil:
    section.add "Version", valid_595022
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595023 = header.getOrDefault("X-Amz-Signature")
  valid_595023 = validateParameter(valid_595023, JString, required = false,
                                 default = nil)
  if valid_595023 != nil:
    section.add "X-Amz-Signature", valid_595023
  var valid_595024 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595024 = validateParameter(valid_595024, JString, required = false,
                                 default = nil)
  if valid_595024 != nil:
    section.add "X-Amz-Content-Sha256", valid_595024
  var valid_595025 = header.getOrDefault("X-Amz-Date")
  valid_595025 = validateParameter(valid_595025, JString, required = false,
                                 default = nil)
  if valid_595025 != nil:
    section.add "X-Amz-Date", valid_595025
  var valid_595026 = header.getOrDefault("X-Amz-Credential")
  valid_595026 = validateParameter(valid_595026, JString, required = false,
                                 default = nil)
  if valid_595026 != nil:
    section.add "X-Amz-Credential", valid_595026
  var valid_595027 = header.getOrDefault("X-Amz-Security-Token")
  valid_595027 = validateParameter(valid_595027, JString, required = false,
                                 default = nil)
  if valid_595027 != nil:
    section.add "X-Amz-Security-Token", valid_595027
  var valid_595028 = header.getOrDefault("X-Amz-Algorithm")
  valid_595028 = validateParameter(valid_595028, JString, required = false,
                                 default = nil)
  if valid_595028 != nil:
    section.add "X-Amz-Algorithm", valid_595028
  var valid_595029 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595029 = validateParameter(valid_595029, JString, required = false,
                                 default = nil)
  if valid_595029 != nil:
    section.add "X-Amz-SignedHeaders", valid_595029
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595030: Call_PostDescribeStorage_595018; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_595030.validator(path, query, header, formData, body)
  let scheme = call_595030.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595030.url(scheme.get, call_595030.host, call_595030.base,
                         call_595030.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595030, url, valid)

proc call*(call_595031: Call_PostDescribeStorage_595018;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## postDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595032 = newJObject()
  add(query_595032, "Action", newJString(Action))
  add(query_595032, "Version", newJString(Version))
  result = call_595031.call(nil, query_595032, nil, nil, nil)

var postDescribeStorage* = Call_PostDescribeStorage_595018(
    name: "postDescribeStorage", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_PostDescribeStorage_595019, base: "/",
    url: url_PostDescribeStorage_595020, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeStorage_595003 = ref object of OpenApiRestCall_592348
proc url_GetDescribeStorage_595005(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeStorage_595004(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595006 = query.getOrDefault("Action")
  valid_595006 = validateParameter(valid_595006, JString, required = true,
                                 default = newJString("DescribeStorage"))
  if valid_595006 != nil:
    section.add "Action", valid_595006
  var valid_595007 = query.getOrDefault("Version")
  valid_595007 = validateParameter(valid_595007, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595007 != nil:
    section.add "Version", valid_595007
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595008 = header.getOrDefault("X-Amz-Signature")
  valid_595008 = validateParameter(valid_595008, JString, required = false,
                                 default = nil)
  if valid_595008 != nil:
    section.add "X-Amz-Signature", valid_595008
  var valid_595009 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595009 = validateParameter(valid_595009, JString, required = false,
                                 default = nil)
  if valid_595009 != nil:
    section.add "X-Amz-Content-Sha256", valid_595009
  var valid_595010 = header.getOrDefault("X-Amz-Date")
  valid_595010 = validateParameter(valid_595010, JString, required = false,
                                 default = nil)
  if valid_595010 != nil:
    section.add "X-Amz-Date", valid_595010
  var valid_595011 = header.getOrDefault("X-Amz-Credential")
  valid_595011 = validateParameter(valid_595011, JString, required = false,
                                 default = nil)
  if valid_595011 != nil:
    section.add "X-Amz-Credential", valid_595011
  var valid_595012 = header.getOrDefault("X-Amz-Security-Token")
  valid_595012 = validateParameter(valid_595012, JString, required = false,
                                 default = nil)
  if valid_595012 != nil:
    section.add "X-Amz-Security-Token", valid_595012
  var valid_595013 = header.getOrDefault("X-Amz-Algorithm")
  valid_595013 = validateParameter(valid_595013, JString, required = false,
                                 default = nil)
  if valid_595013 != nil:
    section.add "X-Amz-Algorithm", valid_595013
  var valid_595014 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595014 = validateParameter(valid_595014, JString, required = false,
                                 default = nil)
  if valid_595014 != nil:
    section.add "X-Amz-SignedHeaders", valid_595014
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595015: Call_GetDescribeStorage_595003; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ## 
  let valid = call_595015.validator(path, query, header, formData, body)
  let scheme = call_595015.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595015.url(scheme.get, call_595015.host, call_595015.base,
                         call_595015.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595015, url, valid)

proc call*(call_595016: Call_GetDescribeStorage_595003;
          Action: string = "DescribeStorage"; Version: string = "2012-12-01"): Recallable =
  ## getDescribeStorage
  ## Returns the total amount of snapshot usage and provisioned storage in megabytes.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595017 = newJObject()
  add(query_595017, "Action", newJString(Action))
  add(query_595017, "Version", newJString(Version))
  result = call_595016.call(nil, query_595017, nil, nil, nil)

var getDescribeStorage* = Call_GetDescribeStorage_595003(
    name: "getDescribeStorage", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeStorage",
    validator: validate_GetDescribeStorage_595004, base: "/",
    url: url_GetDescribeStorage_595005, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTableRestoreStatus_595052 = ref object of OpenApiRestCall_592348
proc url_PostDescribeTableRestoreStatus_595054(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeTableRestoreStatus_595053(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595055 = query.getOrDefault("Action")
  valid_595055 = validateParameter(valid_595055, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_595055 != nil:
    section.add "Action", valid_595055
  var valid_595056 = query.getOrDefault("Version")
  valid_595056 = validateParameter(valid_595056, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595056 != nil:
    section.add "Version", valid_595056
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595057 = header.getOrDefault("X-Amz-Signature")
  valid_595057 = validateParameter(valid_595057, JString, required = false,
                                 default = nil)
  if valid_595057 != nil:
    section.add "X-Amz-Signature", valid_595057
  var valid_595058 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595058 = validateParameter(valid_595058, JString, required = false,
                                 default = nil)
  if valid_595058 != nil:
    section.add "X-Amz-Content-Sha256", valid_595058
  var valid_595059 = header.getOrDefault("X-Amz-Date")
  valid_595059 = validateParameter(valid_595059, JString, required = false,
                                 default = nil)
  if valid_595059 != nil:
    section.add "X-Amz-Date", valid_595059
  var valid_595060 = header.getOrDefault("X-Amz-Credential")
  valid_595060 = validateParameter(valid_595060, JString, required = false,
                                 default = nil)
  if valid_595060 != nil:
    section.add "X-Amz-Credential", valid_595060
  var valid_595061 = header.getOrDefault("X-Amz-Security-Token")
  valid_595061 = validateParameter(valid_595061, JString, required = false,
                                 default = nil)
  if valid_595061 != nil:
    section.add "X-Amz-Security-Token", valid_595061
  var valid_595062 = header.getOrDefault("X-Amz-Algorithm")
  valid_595062 = validateParameter(valid_595062, JString, required = false,
                                 default = nil)
  if valid_595062 != nil:
    section.add "X-Amz-Algorithm", valid_595062
  var valid_595063 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595063 = validateParameter(valid_595063, JString, required = false,
                                 default = nil)
  if valid_595063 != nil:
    section.add "X-Amz-SignedHeaders", valid_595063
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  section = newJObject()
  var valid_595064 = formData.getOrDefault("ClusterIdentifier")
  valid_595064 = validateParameter(valid_595064, JString, required = false,
                                 default = nil)
  if valid_595064 != nil:
    section.add "ClusterIdentifier", valid_595064
  var valid_595065 = formData.getOrDefault("TableRestoreRequestId")
  valid_595065 = validateParameter(valid_595065, JString, required = false,
                                 default = nil)
  if valid_595065 != nil:
    section.add "TableRestoreRequestId", valid_595065
  var valid_595066 = formData.getOrDefault("MaxRecords")
  valid_595066 = validateParameter(valid_595066, JInt, required = false, default = nil)
  if valid_595066 != nil:
    section.add "MaxRecords", valid_595066
  var valid_595067 = formData.getOrDefault("Marker")
  valid_595067 = validateParameter(valid_595067, JString, required = false,
                                 default = nil)
  if valid_595067 != nil:
    section.add "Marker", valid_595067
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595068: Call_PostDescribeTableRestoreStatus_595052; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_595068.validator(path, query, header, formData, body)
  let scheme = call_595068.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595068.url(scheme.get, call_595068.host, call_595068.base,
                         call_595068.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595068, url, valid)

proc call*(call_595069: Call_PostDescribeTableRestoreStatus_595052;
          ClusterIdentifier: string = ""; TableRestoreRequestId: string = "";
          MaxRecords: int = 0; Marker: string = "";
          Action: string = "DescribeTableRestoreStatus";
          Version: string = "2012-12-01"): Recallable =
  ## postDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595070 = newJObject()
  var formData_595071 = newJObject()
  add(formData_595071, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_595071, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(formData_595071, "MaxRecords", newJInt(MaxRecords))
  add(formData_595071, "Marker", newJString(Marker))
  add(query_595070, "Action", newJString(Action))
  add(query_595070, "Version", newJString(Version))
  result = call_595069.call(nil, query_595070, nil, formData_595071, nil)

var postDescribeTableRestoreStatus* = Call_PostDescribeTableRestoreStatus_595052(
    name: "postDescribeTableRestoreStatus", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_PostDescribeTableRestoreStatus_595053, base: "/",
    url: url_PostDescribeTableRestoreStatus_595054,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTableRestoreStatus_595033 = ref object of OpenApiRestCall_592348
proc url_GetDescribeTableRestoreStatus_595035(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeTableRestoreStatus_595034(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Version: JString (required)
  ##   TableRestoreRequestId: JString
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: JInt
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  section = newJObject()
  var valid_595036 = query.getOrDefault("Marker")
  valid_595036 = validateParameter(valid_595036, JString, required = false,
                                 default = nil)
  if valid_595036 != nil:
    section.add "Marker", valid_595036
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595037 = query.getOrDefault("Action")
  valid_595037 = validateParameter(valid_595037, JString, required = true, default = newJString(
      "DescribeTableRestoreStatus"))
  if valid_595037 != nil:
    section.add "Action", valid_595037
  var valid_595038 = query.getOrDefault("ClusterIdentifier")
  valid_595038 = validateParameter(valid_595038, JString, required = false,
                                 default = nil)
  if valid_595038 != nil:
    section.add "ClusterIdentifier", valid_595038
  var valid_595039 = query.getOrDefault("Version")
  valid_595039 = validateParameter(valid_595039, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595039 != nil:
    section.add "Version", valid_595039
  var valid_595040 = query.getOrDefault("TableRestoreRequestId")
  valid_595040 = validateParameter(valid_595040, JString, required = false,
                                 default = nil)
  if valid_595040 != nil:
    section.add "TableRestoreRequestId", valid_595040
  var valid_595041 = query.getOrDefault("MaxRecords")
  valid_595041 = validateParameter(valid_595041, JInt, required = false, default = nil)
  if valid_595041 != nil:
    section.add "MaxRecords", valid_595041
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595042 = header.getOrDefault("X-Amz-Signature")
  valid_595042 = validateParameter(valid_595042, JString, required = false,
                                 default = nil)
  if valid_595042 != nil:
    section.add "X-Amz-Signature", valid_595042
  var valid_595043 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595043 = validateParameter(valid_595043, JString, required = false,
                                 default = nil)
  if valid_595043 != nil:
    section.add "X-Amz-Content-Sha256", valid_595043
  var valid_595044 = header.getOrDefault("X-Amz-Date")
  valid_595044 = validateParameter(valid_595044, JString, required = false,
                                 default = nil)
  if valid_595044 != nil:
    section.add "X-Amz-Date", valid_595044
  var valid_595045 = header.getOrDefault("X-Amz-Credential")
  valid_595045 = validateParameter(valid_595045, JString, required = false,
                                 default = nil)
  if valid_595045 != nil:
    section.add "X-Amz-Credential", valid_595045
  var valid_595046 = header.getOrDefault("X-Amz-Security-Token")
  valid_595046 = validateParameter(valid_595046, JString, required = false,
                                 default = nil)
  if valid_595046 != nil:
    section.add "X-Amz-Security-Token", valid_595046
  var valid_595047 = header.getOrDefault("X-Amz-Algorithm")
  valid_595047 = validateParameter(valid_595047, JString, required = false,
                                 default = nil)
  if valid_595047 != nil:
    section.add "X-Amz-Algorithm", valid_595047
  var valid_595048 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595048 = validateParameter(valid_595048, JString, required = false,
                                 default = nil)
  if valid_595048 != nil:
    section.add "X-Amz-SignedHeaders", valid_595048
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595049: Call_GetDescribeTableRestoreStatus_595033; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ## 
  let valid = call_595049.validator(path, query, header, formData, body)
  let scheme = call_595049.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595049.url(scheme.get, call_595049.host, call_595049.base,
                         call_595049.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595049, url, valid)

proc call*(call_595050: Call_GetDescribeTableRestoreStatus_595033;
          Marker: string = ""; Action: string = "DescribeTableRestoreStatus";
          ClusterIdentifier: string = ""; Version: string = "2012-12-01";
          TableRestoreRequestId: string = ""; MaxRecords: int = 0): Recallable =
  ## getDescribeTableRestoreStatus
  ## Lists the status of one or more table restore requests made using the <a>RestoreTableFromClusterSnapshot</a> API action. If you don't specify a value for the <code>TableRestoreRequestId</code> parameter, then <code>DescribeTableRestoreStatus</code> returns the status of all table restore requests ordered by the date and time of the request in ascending order. Otherwise <code>DescribeTableRestoreStatus</code> returns the status of the table specified by <code>TableRestoreRequestId</code>.
  ##   Marker: string
  ##         : An optional pagination token provided by a previous <code>DescribeTableRestoreStatus</code> request. If this parameter is specified, the response includes only records beyond the marker, up to the value specified by the <code>MaxRecords</code> parameter.
  ##   Action: string (required)
  ##   ClusterIdentifier: string
  ##                    : The Amazon Redshift cluster that the table is being restored to.
  ##   Version: string (required)
  ##   TableRestoreRequestId: string
  ##                        : The identifier of the table restore request to return status for. If you don't specify a <code>TableRestoreRequestId</code> value, then <code>DescribeTableRestoreStatus</code> returns the status of all in-progress table restore requests.
  ##   MaxRecords: int
  ##             : The maximum number of records to include in the response. If more records exist than the specified <code>MaxRecords</code> value, a pagination token called a marker is included in the response so that the remaining results can be retrieved.
  var query_595051 = newJObject()
  add(query_595051, "Marker", newJString(Marker))
  add(query_595051, "Action", newJString(Action))
  add(query_595051, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595051, "Version", newJString(Version))
  add(query_595051, "TableRestoreRequestId", newJString(TableRestoreRequestId))
  add(query_595051, "MaxRecords", newJInt(MaxRecords))
  result = call_595050.call(nil, query_595051, nil, nil, nil)

var getDescribeTableRestoreStatus* = Call_GetDescribeTableRestoreStatus_595033(
    name: "getDescribeTableRestoreStatus", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DescribeTableRestoreStatus",
    validator: validate_GetDescribeTableRestoreStatus_595034, base: "/",
    url: url_GetDescribeTableRestoreStatus_595035,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDescribeTags_595093 = ref object of OpenApiRestCall_592348
proc url_PostDescribeTags_595095(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDescribeTags_595094(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595096 = query.getOrDefault("Action")
  valid_595096 = validateParameter(valid_595096, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_595096 != nil:
    section.add "Action", valid_595096
  var valid_595097 = query.getOrDefault("Version")
  valid_595097 = validateParameter(valid_595097, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595097 != nil:
    section.add "Version", valid_595097
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595098 = header.getOrDefault("X-Amz-Signature")
  valid_595098 = validateParameter(valid_595098, JString, required = false,
                                 default = nil)
  if valid_595098 != nil:
    section.add "X-Amz-Signature", valid_595098
  var valid_595099 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595099 = validateParameter(valid_595099, JString, required = false,
                                 default = nil)
  if valid_595099 != nil:
    section.add "X-Amz-Content-Sha256", valid_595099
  var valid_595100 = header.getOrDefault("X-Amz-Date")
  valid_595100 = validateParameter(valid_595100, JString, required = false,
                                 default = nil)
  if valid_595100 != nil:
    section.add "X-Amz-Date", valid_595100
  var valid_595101 = header.getOrDefault("X-Amz-Credential")
  valid_595101 = validateParameter(valid_595101, JString, required = false,
                                 default = nil)
  if valid_595101 != nil:
    section.add "X-Amz-Credential", valid_595101
  var valid_595102 = header.getOrDefault("X-Amz-Security-Token")
  valid_595102 = validateParameter(valid_595102, JString, required = false,
                                 default = nil)
  if valid_595102 != nil:
    section.add "X-Amz-Security-Token", valid_595102
  var valid_595103 = header.getOrDefault("X-Amz-Algorithm")
  valid_595103 = validateParameter(valid_595103, JString, required = false,
                                 default = nil)
  if valid_595103 != nil:
    section.add "X-Amz-Algorithm", valid_595103
  var valid_595104 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595104 = validateParameter(valid_595104, JString, required = false,
                                 default = nil)
  if valid_595104 != nil:
    section.add "X-Amz-SignedHeaders", valid_595104
  result.add "header", section
  ## parameters in `formData` object:
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  section = newJObject()
  var valid_595105 = formData.getOrDefault("TagKeys")
  valid_595105 = validateParameter(valid_595105, JArray, required = false,
                                 default = nil)
  if valid_595105 != nil:
    section.add "TagKeys", valid_595105
  var valid_595106 = formData.getOrDefault("MaxRecords")
  valid_595106 = validateParameter(valid_595106, JInt, required = false, default = nil)
  if valid_595106 != nil:
    section.add "MaxRecords", valid_595106
  var valid_595107 = formData.getOrDefault("ResourceType")
  valid_595107 = validateParameter(valid_595107, JString, required = false,
                                 default = nil)
  if valid_595107 != nil:
    section.add "ResourceType", valid_595107
  var valid_595108 = formData.getOrDefault("Marker")
  valid_595108 = validateParameter(valid_595108, JString, required = false,
                                 default = nil)
  if valid_595108 != nil:
    section.add "Marker", valid_595108
  var valid_595109 = formData.getOrDefault("TagValues")
  valid_595109 = validateParameter(valid_595109, JArray, required = false,
                                 default = nil)
  if valid_595109 != nil:
    section.add "TagValues", valid_595109
  var valid_595110 = formData.getOrDefault("ResourceName")
  valid_595110 = validateParameter(valid_595110, JString, required = false,
                                 default = nil)
  if valid_595110 != nil:
    section.add "ResourceName", valid_595110
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595111: Call_PostDescribeTags_595093; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595111.validator(path, query, header, formData, body)
  let scheme = call_595111.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595111.url(scheme.get, call_595111.host, call_595111.base,
                         call_595111.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595111, url, valid)

proc call*(call_595112: Call_PostDescribeTags_595093; TagKeys: JsonNode = nil;
          MaxRecords: int = 0; ResourceType: string = ""; Marker: string = "";
          TagValues: JsonNode = nil; Action: string = "DescribeTags";
          Version: string = "2012-12-01"; ResourceName: string = ""): Recallable =
  ## postDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  var query_595113 = newJObject()
  var formData_595114 = newJObject()
  if TagKeys != nil:
    formData_595114.add "TagKeys", TagKeys
  add(formData_595114, "MaxRecords", newJInt(MaxRecords))
  add(formData_595114, "ResourceType", newJString(ResourceType))
  add(formData_595114, "Marker", newJString(Marker))
  if TagValues != nil:
    formData_595114.add "TagValues", TagValues
  add(query_595113, "Action", newJString(Action))
  add(query_595113, "Version", newJString(Version))
  add(formData_595114, "ResourceName", newJString(ResourceName))
  result = call_595112.call(nil, query_595113, nil, formData_595114, nil)

var postDescribeTags* = Call_PostDescribeTags_595093(name: "postDescribeTags",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_PostDescribeTags_595094,
    base: "/", url: url_PostDescribeTags_595095,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDescribeTags_595072 = ref object of OpenApiRestCall_592348
proc url_GetDescribeTags_595074(protocol: Scheme; host: string; base: string;
                               route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDescribeTags_595073(path: JsonNode; query: JsonNode;
                                    header: JsonNode; formData: JsonNode;
                                    body: JsonNode): JsonNode =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: JString
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   ResourceType: JString
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  section = newJObject()
  var valid_595075 = query.getOrDefault("Marker")
  valid_595075 = validateParameter(valid_595075, JString, required = false,
                                 default = nil)
  if valid_595075 != nil:
    section.add "Marker", valid_595075
  var valid_595076 = query.getOrDefault("ResourceName")
  valid_595076 = validateParameter(valid_595076, JString, required = false,
                                 default = nil)
  if valid_595076 != nil:
    section.add "ResourceName", valid_595076
  var valid_595077 = query.getOrDefault("ResourceType")
  valid_595077 = validateParameter(valid_595077, JString, required = false,
                                 default = nil)
  if valid_595077 != nil:
    section.add "ResourceType", valid_595077
  var valid_595078 = query.getOrDefault("TagKeys")
  valid_595078 = validateParameter(valid_595078, JArray, required = false,
                                 default = nil)
  if valid_595078 != nil:
    section.add "TagKeys", valid_595078
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595079 = query.getOrDefault("Action")
  valid_595079 = validateParameter(valid_595079, JString, required = true,
                                 default = newJString("DescribeTags"))
  if valid_595079 != nil:
    section.add "Action", valid_595079
  var valid_595080 = query.getOrDefault("Version")
  valid_595080 = validateParameter(valid_595080, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595080 != nil:
    section.add "Version", valid_595080
  var valid_595081 = query.getOrDefault("MaxRecords")
  valid_595081 = validateParameter(valid_595081, JInt, required = false, default = nil)
  if valid_595081 != nil:
    section.add "MaxRecords", valid_595081
  var valid_595082 = query.getOrDefault("TagValues")
  valid_595082 = validateParameter(valid_595082, JArray, required = false,
                                 default = nil)
  if valid_595082 != nil:
    section.add "TagValues", valid_595082
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595083 = header.getOrDefault("X-Amz-Signature")
  valid_595083 = validateParameter(valid_595083, JString, required = false,
                                 default = nil)
  if valid_595083 != nil:
    section.add "X-Amz-Signature", valid_595083
  var valid_595084 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595084 = validateParameter(valid_595084, JString, required = false,
                                 default = nil)
  if valid_595084 != nil:
    section.add "X-Amz-Content-Sha256", valid_595084
  var valid_595085 = header.getOrDefault("X-Amz-Date")
  valid_595085 = validateParameter(valid_595085, JString, required = false,
                                 default = nil)
  if valid_595085 != nil:
    section.add "X-Amz-Date", valid_595085
  var valid_595086 = header.getOrDefault("X-Amz-Credential")
  valid_595086 = validateParameter(valid_595086, JString, required = false,
                                 default = nil)
  if valid_595086 != nil:
    section.add "X-Amz-Credential", valid_595086
  var valid_595087 = header.getOrDefault("X-Amz-Security-Token")
  valid_595087 = validateParameter(valid_595087, JString, required = false,
                                 default = nil)
  if valid_595087 != nil:
    section.add "X-Amz-Security-Token", valid_595087
  var valid_595088 = header.getOrDefault("X-Amz-Algorithm")
  valid_595088 = validateParameter(valid_595088, JString, required = false,
                                 default = nil)
  if valid_595088 != nil:
    section.add "X-Amz-Algorithm", valid_595088
  var valid_595089 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595089 = validateParameter(valid_595089, JString, required = false,
                                 default = nil)
  if valid_595089 != nil:
    section.add "X-Amz-SignedHeaders", valid_595089
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595090: Call_GetDescribeTags_595072; path: JsonNode; query: JsonNode;
          header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ## 
  let valid = call_595090.validator(path, query, header, formData, body)
  let scheme = call_595090.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595090.url(scheme.get, call_595090.host, call_595090.base,
                         call_595090.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595090, url, valid)

proc call*(call_595091: Call_GetDescribeTags_595072; Marker: string = "";
          ResourceName: string = ""; ResourceType: string = ""; TagKeys: JsonNode = nil;
          Action: string = "DescribeTags"; Version: string = "2012-12-01";
          MaxRecords: int = 0; TagValues: JsonNode = nil): Recallable =
  ## getDescribeTags
  ## <p>Returns a list of tags. You can return tags from a specific resource by specifying an ARN, or you can return all tags for a given type of resource, such as clusters, snapshots, and so on.</p> <p>The following are limitations for <code>DescribeTags</code>: </p> <ul> <li> <p>You cannot specify an ARN and a resource-type value together in the same request.</p> </li> <li> <p>You cannot use the <code>MaxRecords</code> and <code>Marker</code> parameters together with the ARN parameter.</p> </li> <li> <p>The <code>MaxRecords</code> parameter can be a range from 10 to 50 results to return in a request.</p> </li> </ul> <p>If you specify both tag keys and tag values in the same request, Amazon Redshift returns all resources that match any combination of the specified keys and values. For example, if you have <code>owner</code> and <code>environment</code> for tag keys, and <code>admin</code> and <code>test</code> for tag values, all resources that have any combination of those values are returned.</p> <p>If both tag keys and values are omitted from the request, resources are returned regardless of whether they have tag keys or values associated with them.</p>
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of response records in a subsequent request. If a value is returned in a response, you can retrieve the next set of records by providing this returned marker value in the <code>marker</code> parameter and retrying the command. If the <code>marker</code> field is empty, all response records have been retrieved for the request. 
  ##   ResourceName: string
  ##               : The Amazon Resource Name (ARN) for which you want to describe the tag or tags. For example, <code>arn:aws:redshift:us-east-1:123456789:cluster:t1</code>. 
  ##   ResourceType: string
  ##               : <p>The type of resource with which you want to view tags. Valid resource types are: </p> <ul> <li> <p>Cluster</p> </li> <li> <p>CIDR/IP</p> </li> <li> <p>EC2 security group</p> </li> <li> <p>Snapshot</p> </li> <li> <p>Cluster security group</p> </li> <li> <p>Subnet group</p> </li> <li> <p>HSM connection</p> </li> <li> <p>HSM certificate</p> </li> <li> <p>Parameter group</p> </li> <li> <p>Snapshot copy grant</p> </li> </ul> <p>For more information about Amazon Redshift resource types and constructing ARNs, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-overview.html#redshift-iam-access-control-specify-actions">Specifying Policy Elements: Actions, Effects, Resources, and Principals</a> in the Amazon Redshift Cluster Management Guide. </p>
  ##   TagKeys: JArray
  ##          : A tag key or keys for which you want to return all matching resources that are associated with the specified key or keys. For example, suppose that you have resources tagged with keys called <code>owner</code> and <code>environment</code>. If you specify both of these tag keys in the request, Amazon Redshift returns a response with all resources that have either or both of these tag keys associated with them.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : The maximum number or response records to return in each call. If the number of remaining response records exceeds the specified <code>MaxRecords</code> value, a value is returned in a <code>marker</code> field of the response. You can retrieve the next set of records by retrying the command with the returned <code>marker</code> value. 
  ##   TagValues: JArray
  ##            : A tag value or values for which you want to return all matching resources that are associated with the specified value or values. For example, suppose that you have resources tagged with values called <code>admin</code> and <code>test</code>. If you specify both of these tag values in the request, Amazon Redshift returns a response with all resources that have either or both of these tag values associated with them.
  var query_595092 = newJObject()
  add(query_595092, "Marker", newJString(Marker))
  add(query_595092, "ResourceName", newJString(ResourceName))
  add(query_595092, "ResourceType", newJString(ResourceType))
  if TagKeys != nil:
    query_595092.add "TagKeys", TagKeys
  add(query_595092, "Action", newJString(Action))
  add(query_595092, "Version", newJString(Version))
  add(query_595092, "MaxRecords", newJInt(MaxRecords))
  if TagValues != nil:
    query_595092.add "TagValues", TagValues
  result = call_595091.call(nil, query_595092, nil, nil, nil)

var getDescribeTags* = Call_GetDescribeTags_595072(name: "getDescribeTags",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DescribeTags", validator: validate_GetDescribeTags_595073,
    base: "/", url: url_GetDescribeTags_595074, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableLogging_595131 = ref object of OpenApiRestCall_592348
proc url_PostDisableLogging_595133(protocol: Scheme; host: string; base: string;
                                  route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDisableLogging_595132(path: JsonNode; query: JsonNode;
                                       header: JsonNode; formData: JsonNode;
                                       body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595134 = query.getOrDefault("Action")
  valid_595134 = validateParameter(valid_595134, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_595134 != nil:
    section.add "Action", valid_595134
  var valid_595135 = query.getOrDefault("Version")
  valid_595135 = validateParameter(valid_595135, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595135 != nil:
    section.add "Version", valid_595135
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595136 = header.getOrDefault("X-Amz-Signature")
  valid_595136 = validateParameter(valid_595136, JString, required = false,
                                 default = nil)
  if valid_595136 != nil:
    section.add "X-Amz-Signature", valid_595136
  var valid_595137 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595137 = validateParameter(valid_595137, JString, required = false,
                                 default = nil)
  if valid_595137 != nil:
    section.add "X-Amz-Content-Sha256", valid_595137
  var valid_595138 = header.getOrDefault("X-Amz-Date")
  valid_595138 = validateParameter(valid_595138, JString, required = false,
                                 default = nil)
  if valid_595138 != nil:
    section.add "X-Amz-Date", valid_595138
  var valid_595139 = header.getOrDefault("X-Amz-Credential")
  valid_595139 = validateParameter(valid_595139, JString, required = false,
                                 default = nil)
  if valid_595139 != nil:
    section.add "X-Amz-Credential", valid_595139
  var valid_595140 = header.getOrDefault("X-Amz-Security-Token")
  valid_595140 = validateParameter(valid_595140, JString, required = false,
                                 default = nil)
  if valid_595140 != nil:
    section.add "X-Amz-Security-Token", valid_595140
  var valid_595141 = header.getOrDefault("X-Amz-Algorithm")
  valid_595141 = validateParameter(valid_595141, JString, required = false,
                                 default = nil)
  if valid_595141 != nil:
    section.add "X-Amz-Algorithm", valid_595141
  var valid_595142 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595142 = validateParameter(valid_595142, JString, required = false,
                                 default = nil)
  if valid_595142 != nil:
    section.add "X-Amz-SignedHeaders", valid_595142
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595143 = formData.getOrDefault("ClusterIdentifier")
  valid_595143 = validateParameter(valid_595143, JString, required = true,
                                 default = nil)
  if valid_595143 != nil:
    section.add "ClusterIdentifier", valid_595143
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595144: Call_PostDisableLogging_595131; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_595144.validator(path, query, header, formData, body)
  let scheme = call_595144.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595144.url(scheme.get, call_595144.host, call_595144.base,
                         call_595144.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595144, url, valid)

proc call*(call_595145: Call_PostDisableLogging_595131; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## postDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595146 = newJObject()
  var formData_595147 = newJObject()
  add(formData_595147, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595146, "Action", newJString(Action))
  add(query_595146, "Version", newJString(Version))
  result = call_595145.call(nil, query_595146, nil, formData_595147, nil)

var postDisableLogging* = Call_PostDisableLogging_595131(
    name: "postDisableLogging", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableLogging",
    validator: validate_PostDisableLogging_595132, base: "/",
    url: url_PostDisableLogging_595133, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableLogging_595115 = ref object of OpenApiRestCall_592348
proc url_GetDisableLogging_595117(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDisableLogging_595116(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595118 = query.getOrDefault("Action")
  valid_595118 = validateParameter(valid_595118, JString, required = true,
                                 default = newJString("DisableLogging"))
  if valid_595118 != nil:
    section.add "Action", valid_595118
  var valid_595119 = query.getOrDefault("ClusterIdentifier")
  valid_595119 = validateParameter(valid_595119, JString, required = true,
                                 default = nil)
  if valid_595119 != nil:
    section.add "ClusterIdentifier", valid_595119
  var valid_595120 = query.getOrDefault("Version")
  valid_595120 = validateParameter(valid_595120, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595120 != nil:
    section.add "Version", valid_595120
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595121 = header.getOrDefault("X-Amz-Signature")
  valid_595121 = validateParameter(valid_595121, JString, required = false,
                                 default = nil)
  if valid_595121 != nil:
    section.add "X-Amz-Signature", valid_595121
  var valid_595122 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595122 = validateParameter(valid_595122, JString, required = false,
                                 default = nil)
  if valid_595122 != nil:
    section.add "X-Amz-Content-Sha256", valid_595122
  var valid_595123 = header.getOrDefault("X-Amz-Date")
  valid_595123 = validateParameter(valid_595123, JString, required = false,
                                 default = nil)
  if valid_595123 != nil:
    section.add "X-Amz-Date", valid_595123
  var valid_595124 = header.getOrDefault("X-Amz-Credential")
  valid_595124 = validateParameter(valid_595124, JString, required = false,
                                 default = nil)
  if valid_595124 != nil:
    section.add "X-Amz-Credential", valid_595124
  var valid_595125 = header.getOrDefault("X-Amz-Security-Token")
  valid_595125 = validateParameter(valid_595125, JString, required = false,
                                 default = nil)
  if valid_595125 != nil:
    section.add "X-Amz-Security-Token", valid_595125
  var valid_595126 = header.getOrDefault("X-Amz-Algorithm")
  valid_595126 = validateParameter(valid_595126, JString, required = false,
                                 default = nil)
  if valid_595126 != nil:
    section.add "X-Amz-Algorithm", valid_595126
  var valid_595127 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595127 = validateParameter(valid_595127, JString, required = false,
                                 default = nil)
  if valid_595127 != nil:
    section.add "X-Amz-SignedHeaders", valid_595127
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595128: Call_GetDisableLogging_595115; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_595128.validator(path, query, header, formData, body)
  let scheme = call_595128.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595128.url(scheme.get, call_595128.host, call_595128.base,
                         call_595128.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595128, url, valid)

proc call*(call_595129: Call_GetDisableLogging_595115; ClusterIdentifier: string;
          Action: string = "DisableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getDisableLogging
  ## Stops logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be stopped.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_595130 = newJObject()
  add(query_595130, "Action", newJString(Action))
  add(query_595130, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595130, "Version", newJString(Version))
  result = call_595129.call(nil, query_595130, nil, nil, nil)

var getDisableLogging* = Call_GetDisableLogging_595115(name: "getDisableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=DisableLogging", validator: validate_GetDisableLogging_595116,
    base: "/", url: url_GetDisableLogging_595117,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostDisableSnapshotCopy_595164 = ref object of OpenApiRestCall_592348
proc url_PostDisableSnapshotCopy_595166(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostDisableSnapshotCopy_595165(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595167 = query.getOrDefault("Action")
  valid_595167 = validateParameter(valid_595167, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_595167 != nil:
    section.add "Action", valid_595167
  var valid_595168 = query.getOrDefault("Version")
  valid_595168 = validateParameter(valid_595168, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595168 != nil:
    section.add "Version", valid_595168
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595169 = header.getOrDefault("X-Amz-Signature")
  valid_595169 = validateParameter(valid_595169, JString, required = false,
                                 default = nil)
  if valid_595169 != nil:
    section.add "X-Amz-Signature", valid_595169
  var valid_595170 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595170 = validateParameter(valid_595170, JString, required = false,
                                 default = nil)
  if valid_595170 != nil:
    section.add "X-Amz-Content-Sha256", valid_595170
  var valid_595171 = header.getOrDefault("X-Amz-Date")
  valid_595171 = validateParameter(valid_595171, JString, required = false,
                                 default = nil)
  if valid_595171 != nil:
    section.add "X-Amz-Date", valid_595171
  var valid_595172 = header.getOrDefault("X-Amz-Credential")
  valid_595172 = validateParameter(valid_595172, JString, required = false,
                                 default = nil)
  if valid_595172 != nil:
    section.add "X-Amz-Credential", valid_595172
  var valid_595173 = header.getOrDefault("X-Amz-Security-Token")
  valid_595173 = validateParameter(valid_595173, JString, required = false,
                                 default = nil)
  if valid_595173 != nil:
    section.add "X-Amz-Security-Token", valid_595173
  var valid_595174 = header.getOrDefault("X-Amz-Algorithm")
  valid_595174 = validateParameter(valid_595174, JString, required = false,
                                 default = nil)
  if valid_595174 != nil:
    section.add "X-Amz-Algorithm", valid_595174
  var valid_595175 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595175 = validateParameter(valid_595175, JString, required = false,
                                 default = nil)
  if valid_595175 != nil:
    section.add "X-Amz-SignedHeaders", valid_595175
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595176 = formData.getOrDefault("ClusterIdentifier")
  valid_595176 = validateParameter(valid_595176, JString, required = true,
                                 default = nil)
  if valid_595176 != nil:
    section.add "ClusterIdentifier", valid_595176
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595177: Call_PostDisableSnapshotCopy_595164; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_595177.validator(path, query, header, formData, body)
  let scheme = call_595177.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595177.url(scheme.get, call_595177.host, call_595177.base,
                         call_595177.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595177, url, valid)

proc call*(call_595178: Call_PostDisableSnapshotCopy_595164;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## postDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595179 = newJObject()
  var formData_595180 = newJObject()
  add(formData_595180, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595179, "Action", newJString(Action))
  add(query_595179, "Version", newJString(Version))
  result = call_595178.call(nil, query_595179, nil, formData_595180, nil)

var postDisableSnapshotCopy* = Call_PostDisableSnapshotCopy_595164(
    name: "postDisableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_PostDisableSnapshotCopy_595165, base: "/",
    url: url_PostDisableSnapshotCopy_595166, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetDisableSnapshotCopy_595148 = ref object of OpenApiRestCall_592348
proc url_GetDisableSnapshotCopy_595150(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetDisableSnapshotCopy_595149(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595151 = query.getOrDefault("Action")
  valid_595151 = validateParameter(valid_595151, JString, required = true,
                                 default = newJString("DisableSnapshotCopy"))
  if valid_595151 != nil:
    section.add "Action", valid_595151
  var valid_595152 = query.getOrDefault("ClusterIdentifier")
  valid_595152 = validateParameter(valid_595152, JString, required = true,
                                 default = nil)
  if valid_595152 != nil:
    section.add "ClusterIdentifier", valid_595152
  var valid_595153 = query.getOrDefault("Version")
  valid_595153 = validateParameter(valid_595153, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595153 != nil:
    section.add "Version", valid_595153
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595154 = header.getOrDefault("X-Amz-Signature")
  valid_595154 = validateParameter(valid_595154, JString, required = false,
                                 default = nil)
  if valid_595154 != nil:
    section.add "X-Amz-Signature", valid_595154
  var valid_595155 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595155 = validateParameter(valid_595155, JString, required = false,
                                 default = nil)
  if valid_595155 != nil:
    section.add "X-Amz-Content-Sha256", valid_595155
  var valid_595156 = header.getOrDefault("X-Amz-Date")
  valid_595156 = validateParameter(valid_595156, JString, required = false,
                                 default = nil)
  if valid_595156 != nil:
    section.add "X-Amz-Date", valid_595156
  var valid_595157 = header.getOrDefault("X-Amz-Credential")
  valid_595157 = validateParameter(valid_595157, JString, required = false,
                                 default = nil)
  if valid_595157 != nil:
    section.add "X-Amz-Credential", valid_595157
  var valid_595158 = header.getOrDefault("X-Amz-Security-Token")
  valid_595158 = validateParameter(valid_595158, JString, required = false,
                                 default = nil)
  if valid_595158 != nil:
    section.add "X-Amz-Security-Token", valid_595158
  var valid_595159 = header.getOrDefault("X-Amz-Algorithm")
  valid_595159 = validateParameter(valid_595159, JString, required = false,
                                 default = nil)
  if valid_595159 != nil:
    section.add "X-Amz-Algorithm", valid_595159
  var valid_595160 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595160 = validateParameter(valid_595160, JString, required = false,
                                 default = nil)
  if valid_595160 != nil:
    section.add "X-Amz-SignedHeaders", valid_595160
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595161: Call_GetDisableSnapshotCopy_595148; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ## 
  let valid = call_595161.validator(path, query, header, formData, body)
  let scheme = call_595161.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595161.url(scheme.get, call_595161.host, call_595161.base,
                         call_595161.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595161, url, valid)

proc call*(call_595162: Call_GetDisableSnapshotCopy_595148;
          ClusterIdentifier: string; Action: string = "DisableSnapshotCopy";
          Version: string = "2012-12-01"): Recallable =
  ## getDisableSnapshotCopy
  ## <p>Disables the automatic copying of snapshots from one region to another region for a specified cluster.</p> <p>If your cluster and its snapshots are encrypted using a customer master key (CMK) from AWS KMS, use <a>DeleteSnapshotCopyGrant</a> to delete the grant that grants Amazon Redshift permission to the CMK in the destination region. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster that you want to disable copying of snapshots to a destination region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  var query_595163 = newJObject()
  add(query_595163, "Action", newJString(Action))
  add(query_595163, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595163, "Version", newJString(Version))
  result = call_595162.call(nil, query_595163, nil, nil, nil)

var getDisableSnapshotCopy* = Call_GetDisableSnapshotCopy_595148(
    name: "getDisableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=DisableSnapshotCopy",
    validator: validate_GetDisableSnapshotCopy_595149, base: "/",
    url: url_GetDisableSnapshotCopy_595150, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableLogging_595199 = ref object of OpenApiRestCall_592348
proc url_PostEnableLogging_595201(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostEnableLogging_595200(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595202 = query.getOrDefault("Action")
  valid_595202 = validateParameter(valid_595202, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_595202 != nil:
    section.add "Action", valid_595202
  var valid_595203 = query.getOrDefault("Version")
  valid_595203 = validateParameter(valid_595203, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595203 != nil:
    section.add "Version", valid_595203
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595204 = header.getOrDefault("X-Amz-Signature")
  valid_595204 = validateParameter(valid_595204, JString, required = false,
                                 default = nil)
  if valid_595204 != nil:
    section.add "X-Amz-Signature", valid_595204
  var valid_595205 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595205 = validateParameter(valid_595205, JString, required = false,
                                 default = nil)
  if valid_595205 != nil:
    section.add "X-Amz-Content-Sha256", valid_595205
  var valid_595206 = header.getOrDefault("X-Amz-Date")
  valid_595206 = validateParameter(valid_595206, JString, required = false,
                                 default = nil)
  if valid_595206 != nil:
    section.add "X-Amz-Date", valid_595206
  var valid_595207 = header.getOrDefault("X-Amz-Credential")
  valid_595207 = validateParameter(valid_595207, JString, required = false,
                                 default = nil)
  if valid_595207 != nil:
    section.add "X-Amz-Credential", valid_595207
  var valid_595208 = header.getOrDefault("X-Amz-Security-Token")
  valid_595208 = validateParameter(valid_595208, JString, required = false,
                                 default = nil)
  if valid_595208 != nil:
    section.add "X-Amz-Security-Token", valid_595208
  var valid_595209 = header.getOrDefault("X-Amz-Algorithm")
  valid_595209 = validateParameter(valid_595209, JString, required = false,
                                 default = nil)
  if valid_595209 != nil:
    section.add "X-Amz-Algorithm", valid_595209
  var valid_595210 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595210 = validateParameter(valid_595210, JString, required = false,
                                 default = nil)
  if valid_595210 != nil:
    section.add "X-Amz-SignedHeaders", valid_595210
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595211 = formData.getOrDefault("ClusterIdentifier")
  valid_595211 = validateParameter(valid_595211, JString, required = true,
                                 default = nil)
  if valid_595211 != nil:
    section.add "ClusterIdentifier", valid_595211
  var valid_595212 = formData.getOrDefault("BucketName")
  valid_595212 = validateParameter(valid_595212, JString, required = true,
                                 default = nil)
  if valid_595212 != nil:
    section.add "BucketName", valid_595212
  var valid_595213 = formData.getOrDefault("S3KeyPrefix")
  valid_595213 = validateParameter(valid_595213, JString, required = false,
                                 default = nil)
  if valid_595213 != nil:
    section.add "S3KeyPrefix", valid_595213
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595214: Call_PostEnableLogging_595199; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_595214.validator(path, query, header, formData, body)
  let scheme = call_595214.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595214.url(scheme.get, call_595214.host, call_595214.base,
                         call_595214.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595214, url, valid)

proc call*(call_595215: Call_PostEnableLogging_595199; ClusterIdentifier: string;
          BucketName: string; Action: string = "EnableLogging";
          Version: string = "2012-12-01"; S3KeyPrefix: string = ""): Recallable =
  ## postEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   Version: string (required)
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  var query_595216 = newJObject()
  var formData_595217 = newJObject()
  add(formData_595217, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595216, "Action", newJString(Action))
  add(formData_595217, "BucketName", newJString(BucketName))
  add(query_595216, "Version", newJString(Version))
  add(formData_595217, "S3KeyPrefix", newJString(S3KeyPrefix))
  result = call_595215.call(nil, query_595216, nil, formData_595217, nil)

var postEnableLogging* = Call_PostEnableLogging_595199(name: "postEnableLogging",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_PostEnableLogging_595200,
    base: "/", url: url_PostEnableLogging_595201,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableLogging_595181 = ref object of OpenApiRestCall_592348
proc url_GetEnableLogging_595183(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetEnableLogging_595182(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   BucketName: JString (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: JString
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `BucketName` field"
  var valid_595184 = query.getOrDefault("BucketName")
  valid_595184 = validateParameter(valid_595184, JString, required = true,
                                 default = nil)
  if valid_595184 != nil:
    section.add "BucketName", valid_595184
  var valid_595185 = query.getOrDefault("S3KeyPrefix")
  valid_595185 = validateParameter(valid_595185, JString, required = false,
                                 default = nil)
  if valid_595185 != nil:
    section.add "S3KeyPrefix", valid_595185
  var valid_595186 = query.getOrDefault("Action")
  valid_595186 = validateParameter(valid_595186, JString, required = true,
                                 default = newJString("EnableLogging"))
  if valid_595186 != nil:
    section.add "Action", valid_595186
  var valid_595187 = query.getOrDefault("ClusterIdentifier")
  valid_595187 = validateParameter(valid_595187, JString, required = true,
                                 default = nil)
  if valid_595187 != nil:
    section.add "ClusterIdentifier", valid_595187
  var valid_595188 = query.getOrDefault("Version")
  valid_595188 = validateParameter(valid_595188, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595188 != nil:
    section.add "Version", valid_595188
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595189 = header.getOrDefault("X-Amz-Signature")
  valid_595189 = validateParameter(valid_595189, JString, required = false,
                                 default = nil)
  if valid_595189 != nil:
    section.add "X-Amz-Signature", valid_595189
  var valid_595190 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595190 = validateParameter(valid_595190, JString, required = false,
                                 default = nil)
  if valid_595190 != nil:
    section.add "X-Amz-Content-Sha256", valid_595190
  var valid_595191 = header.getOrDefault("X-Amz-Date")
  valid_595191 = validateParameter(valid_595191, JString, required = false,
                                 default = nil)
  if valid_595191 != nil:
    section.add "X-Amz-Date", valid_595191
  var valid_595192 = header.getOrDefault("X-Amz-Credential")
  valid_595192 = validateParameter(valid_595192, JString, required = false,
                                 default = nil)
  if valid_595192 != nil:
    section.add "X-Amz-Credential", valid_595192
  var valid_595193 = header.getOrDefault("X-Amz-Security-Token")
  valid_595193 = validateParameter(valid_595193, JString, required = false,
                                 default = nil)
  if valid_595193 != nil:
    section.add "X-Amz-Security-Token", valid_595193
  var valid_595194 = header.getOrDefault("X-Amz-Algorithm")
  valid_595194 = validateParameter(valid_595194, JString, required = false,
                                 default = nil)
  if valid_595194 != nil:
    section.add "X-Amz-Algorithm", valid_595194
  var valid_595195 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595195 = validateParameter(valid_595195, JString, required = false,
                                 default = nil)
  if valid_595195 != nil:
    section.add "X-Amz-SignedHeaders", valid_595195
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595196: Call_GetEnableLogging_595181; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ## 
  let valid = call_595196.validator(path, query, header, formData, body)
  let scheme = call_595196.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595196.url(scheme.get, call_595196.host, call_595196.base,
                         call_595196.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595196, url, valid)

proc call*(call_595197: Call_GetEnableLogging_595181; BucketName: string;
          ClusterIdentifier: string; S3KeyPrefix: string = "";
          Action: string = "EnableLogging"; Version: string = "2012-12-01"): Recallable =
  ## getEnableLogging
  ## Starts logging information, such as queries and connection attempts, for the specified Amazon Redshift cluster.
  ##   BucketName: string (required)
  ##             : <p>The name of an existing S3 bucket where the log files are to be stored.</p> <p>Constraints:</p> <ul> <li> <p>Must be in the same region as the cluster</p> </li> <li> <p>The cluster must have read bucket and put object permissions</p> </li> </ul>
  ##   S3KeyPrefix: string
  ##              : <p>The prefix applied to the log file names.</p> <p>Constraints:</p> <ul> <li> <p>Cannot exceed 512 characters</p> </li> <li> <p>Cannot contain spaces( ), double quotes ("), single quotes ('), a backslash (\), or control characters. The hexadecimal codes for invalid characters are: </p> <ul> <li> <p>x00 to x20</p> </li> <li> <p>x22</p> </li> <li> <p>x27</p> </li> <li> <p>x5c</p> </li> <li> <p>x7f or larger</p> </li> </ul> </li> </ul>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster on which logging is to be started.</p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_595198 = newJObject()
  add(query_595198, "BucketName", newJString(BucketName))
  add(query_595198, "S3KeyPrefix", newJString(S3KeyPrefix))
  add(query_595198, "Action", newJString(Action))
  add(query_595198, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595198, "Version", newJString(Version))
  result = call_595197.call(nil, query_595198, nil, nil, nil)

var getEnableLogging* = Call_GetEnableLogging_595181(name: "getEnableLogging",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=EnableLogging", validator: validate_GetEnableLogging_595182,
    base: "/", url: url_GetEnableLogging_595183,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostEnableSnapshotCopy_595238 = ref object of OpenApiRestCall_592348
proc url_PostEnableSnapshotCopy_595240(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostEnableSnapshotCopy_595239(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595241 = query.getOrDefault("Action")
  valid_595241 = validateParameter(valid_595241, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_595241 != nil:
    section.add "Action", valid_595241
  var valid_595242 = query.getOrDefault("Version")
  valid_595242 = validateParameter(valid_595242, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595242 != nil:
    section.add "Version", valid_595242
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595243 = header.getOrDefault("X-Amz-Signature")
  valid_595243 = validateParameter(valid_595243, JString, required = false,
                                 default = nil)
  if valid_595243 != nil:
    section.add "X-Amz-Signature", valid_595243
  var valid_595244 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595244 = validateParameter(valid_595244, JString, required = false,
                                 default = nil)
  if valid_595244 != nil:
    section.add "X-Amz-Content-Sha256", valid_595244
  var valid_595245 = header.getOrDefault("X-Amz-Date")
  valid_595245 = validateParameter(valid_595245, JString, required = false,
                                 default = nil)
  if valid_595245 != nil:
    section.add "X-Amz-Date", valid_595245
  var valid_595246 = header.getOrDefault("X-Amz-Credential")
  valid_595246 = validateParameter(valid_595246, JString, required = false,
                                 default = nil)
  if valid_595246 != nil:
    section.add "X-Amz-Credential", valid_595246
  var valid_595247 = header.getOrDefault("X-Amz-Security-Token")
  valid_595247 = validateParameter(valid_595247, JString, required = false,
                                 default = nil)
  if valid_595247 != nil:
    section.add "X-Amz-Security-Token", valid_595247
  var valid_595248 = header.getOrDefault("X-Amz-Algorithm")
  valid_595248 = validateParameter(valid_595248, JString, required = false,
                                 default = nil)
  if valid_595248 != nil:
    section.add "X-Amz-Algorithm", valid_595248
  var valid_595249 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595249 = validateParameter(valid_595249, JString, required = false,
                                 default = nil)
  if valid_595249 != nil:
    section.add "X-Amz-SignedHeaders", valid_595249
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595250 = formData.getOrDefault("ClusterIdentifier")
  valid_595250 = validateParameter(valid_595250, JString, required = true,
                                 default = nil)
  if valid_595250 != nil:
    section.add "ClusterIdentifier", valid_595250
  var valid_595251 = formData.getOrDefault("RetentionPeriod")
  valid_595251 = validateParameter(valid_595251, JInt, required = false, default = nil)
  if valid_595251 != nil:
    section.add "RetentionPeriod", valid_595251
  var valid_595252 = formData.getOrDefault("DestinationRegion")
  valid_595252 = validateParameter(valid_595252, JString, required = true,
                                 default = nil)
  if valid_595252 != nil:
    section.add "DestinationRegion", valid_595252
  var valid_595253 = formData.getOrDefault("SnapshotCopyGrantName")
  valid_595253 = validateParameter(valid_595253, JString, required = false,
                                 default = nil)
  if valid_595253 != nil:
    section.add "SnapshotCopyGrantName", valid_595253
  var valid_595254 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_595254 = validateParameter(valid_595254, JInt, required = false, default = nil)
  if valid_595254 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_595254
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595255: Call_PostEnableSnapshotCopy_595238; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_595255.validator(path, query, header, formData, body)
  let scheme = call_595255.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595255.url(scheme.get, call_595255.host, call_595255.base,
                         call_595255.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595255, url, valid)

proc call*(call_595256: Call_PostEnableSnapshotCopy_595238;
          ClusterIdentifier: string; DestinationRegion: string;
          RetentionPeriod: int = 0; Action: string = "EnableSnapshotCopy";
          SnapshotCopyGrantName: string = ""; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_595257 = newJObject()
  var formData_595258 = newJObject()
  add(formData_595258, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_595258, "RetentionPeriod", newJInt(RetentionPeriod))
  add(formData_595258, "DestinationRegion", newJString(DestinationRegion))
  add(query_595257, "Action", newJString(Action))
  add(formData_595258, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  add(query_595257, "Version", newJString(Version))
  add(formData_595258, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_595256.call(nil, query_595257, nil, formData_595258, nil)

var postEnableSnapshotCopy* = Call_PostEnableSnapshotCopy_595238(
    name: "postEnableSnapshotCopy", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_PostEnableSnapshotCopy_595239, base: "/",
    url: url_PostEnableSnapshotCopy_595240, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetEnableSnapshotCopy_595218 = ref object of OpenApiRestCall_592348
proc url_GetEnableSnapshotCopy_595220(protocol: Scheme; host: string; base: string;
                                     route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetEnableSnapshotCopy_595219(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   DestinationRegion: JString (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  ##   RetentionPeriod: JInt
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: JString
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  section = newJObject()
  var valid_595221 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_595221 = validateParameter(valid_595221, JInt, required = false, default = nil)
  if valid_595221 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_595221
  assert query != nil,
        "query argument is necessary due to required `DestinationRegion` field"
  var valid_595222 = query.getOrDefault("DestinationRegion")
  valid_595222 = validateParameter(valid_595222, JString, required = true,
                                 default = nil)
  if valid_595222 != nil:
    section.add "DestinationRegion", valid_595222
  var valid_595223 = query.getOrDefault("Action")
  valid_595223 = validateParameter(valid_595223, JString, required = true,
                                 default = newJString("EnableSnapshotCopy"))
  if valid_595223 != nil:
    section.add "Action", valid_595223
  var valid_595224 = query.getOrDefault("ClusterIdentifier")
  valid_595224 = validateParameter(valid_595224, JString, required = true,
                                 default = nil)
  if valid_595224 != nil:
    section.add "ClusterIdentifier", valid_595224
  var valid_595225 = query.getOrDefault("Version")
  valid_595225 = validateParameter(valid_595225, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595225 != nil:
    section.add "Version", valid_595225
  var valid_595226 = query.getOrDefault("RetentionPeriod")
  valid_595226 = validateParameter(valid_595226, JInt, required = false, default = nil)
  if valid_595226 != nil:
    section.add "RetentionPeriod", valid_595226
  var valid_595227 = query.getOrDefault("SnapshotCopyGrantName")
  valid_595227 = validateParameter(valid_595227, JString, required = false,
                                 default = nil)
  if valid_595227 != nil:
    section.add "SnapshotCopyGrantName", valid_595227
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595228 = header.getOrDefault("X-Amz-Signature")
  valid_595228 = validateParameter(valid_595228, JString, required = false,
                                 default = nil)
  if valid_595228 != nil:
    section.add "X-Amz-Signature", valid_595228
  var valid_595229 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595229 = validateParameter(valid_595229, JString, required = false,
                                 default = nil)
  if valid_595229 != nil:
    section.add "X-Amz-Content-Sha256", valid_595229
  var valid_595230 = header.getOrDefault("X-Amz-Date")
  valid_595230 = validateParameter(valid_595230, JString, required = false,
                                 default = nil)
  if valid_595230 != nil:
    section.add "X-Amz-Date", valid_595230
  var valid_595231 = header.getOrDefault("X-Amz-Credential")
  valid_595231 = validateParameter(valid_595231, JString, required = false,
                                 default = nil)
  if valid_595231 != nil:
    section.add "X-Amz-Credential", valid_595231
  var valid_595232 = header.getOrDefault("X-Amz-Security-Token")
  valid_595232 = validateParameter(valid_595232, JString, required = false,
                                 default = nil)
  if valid_595232 != nil:
    section.add "X-Amz-Security-Token", valid_595232
  var valid_595233 = header.getOrDefault("X-Amz-Algorithm")
  valid_595233 = validateParameter(valid_595233, JString, required = false,
                                 default = nil)
  if valid_595233 != nil:
    section.add "X-Amz-Algorithm", valid_595233
  var valid_595234 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595234 = validateParameter(valid_595234, JString, required = false,
                                 default = nil)
  if valid_595234 != nil:
    section.add "X-Amz-SignedHeaders", valid_595234
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595235: Call_GetEnableSnapshotCopy_595218; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ## 
  let valid = call_595235.validator(path, query, header, formData, body)
  let scheme = call_595235.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595235.url(scheme.get, call_595235.host, call_595235.base,
                         call_595235.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595235, url, valid)

proc call*(call_595236: Call_GetEnableSnapshotCopy_595218;
          DestinationRegion: string; ClusterIdentifier: string;
          ManualSnapshotRetentionPeriod: int = 0;
          Action: string = "EnableSnapshotCopy"; Version: string = "2012-12-01";
          RetentionPeriod: int = 0; SnapshotCopyGrantName: string = ""): Recallable =
  ## getEnableSnapshotCopy
  ## Enables the automatic copy of snapshots from one region to another region for a specified cluster.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely. </p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   DestinationRegion: string (required)
  ##                    : <p>The destination AWS Region that you want to copy snapshots to.</p> <p>Constraints: Must be the name of a valid AWS Region. For more information, see <a 
  ## href="https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region">Regions and Endpoints</a> in the Amazon Web Services General Reference. </p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the source cluster to copy snapshots from.</p> <p>Constraints: Must be the valid name of an existing cluster that does not already have cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  ##   RetentionPeriod: int
  ##                  : <p>The number of days to retain automated snapshots in the destination region after they are copied from the source region.</p> <p>Default: 7.</p> <p>Constraints: Must be at least 1 and no more than 35.</p>
  ##   SnapshotCopyGrantName: string
  ##                        : The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
  var query_595237 = newJObject()
  add(query_595237, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_595237, "DestinationRegion", newJString(DestinationRegion))
  add(query_595237, "Action", newJString(Action))
  add(query_595237, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595237, "Version", newJString(Version))
  add(query_595237, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_595237, "SnapshotCopyGrantName", newJString(SnapshotCopyGrantName))
  result = call_595236.call(nil, query_595237, nil, nil, nil)

var getEnableSnapshotCopy* = Call_GetEnableSnapshotCopy_595218(
    name: "getEnableSnapshotCopy", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=EnableSnapshotCopy",
    validator: validate_GetEnableSnapshotCopy_595219, base: "/",
    url: url_GetEnableSnapshotCopy_595220, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetClusterCredentials_595280 = ref object of OpenApiRestCall_592348
proc url_PostGetClusterCredentials_595282(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostGetClusterCredentials_595281(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595283 = query.getOrDefault("Action")
  valid_595283 = validateParameter(valid_595283, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_595283 != nil:
    section.add "Action", valid_595283
  var valid_595284 = query.getOrDefault("Version")
  valid_595284 = validateParameter(valid_595284, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595284 != nil:
    section.add "Version", valid_595284
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595285 = header.getOrDefault("X-Amz-Signature")
  valid_595285 = validateParameter(valid_595285, JString, required = false,
                                 default = nil)
  if valid_595285 != nil:
    section.add "X-Amz-Signature", valid_595285
  var valid_595286 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595286 = validateParameter(valid_595286, JString, required = false,
                                 default = nil)
  if valid_595286 != nil:
    section.add "X-Amz-Content-Sha256", valid_595286
  var valid_595287 = header.getOrDefault("X-Amz-Date")
  valid_595287 = validateParameter(valid_595287, JString, required = false,
                                 default = nil)
  if valid_595287 != nil:
    section.add "X-Amz-Date", valid_595287
  var valid_595288 = header.getOrDefault("X-Amz-Credential")
  valid_595288 = validateParameter(valid_595288, JString, required = false,
                                 default = nil)
  if valid_595288 != nil:
    section.add "X-Amz-Credential", valid_595288
  var valid_595289 = header.getOrDefault("X-Amz-Security-Token")
  valid_595289 = validateParameter(valid_595289, JString, required = false,
                                 default = nil)
  if valid_595289 != nil:
    section.add "X-Amz-Security-Token", valid_595289
  var valid_595290 = header.getOrDefault("X-Amz-Algorithm")
  valid_595290 = validateParameter(valid_595290, JString, required = false,
                                 default = nil)
  if valid_595290 != nil:
    section.add "X-Amz-Algorithm", valid_595290
  var valid_595291 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595291 = validateParameter(valid_595291, JString, required = false,
                                 default = nil)
  if valid_595291 != nil:
    section.add "X-Amz-SignedHeaders", valid_595291
  result.add "header", section
  ## parameters in `formData` object:
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `DbUser` field"
  var valid_595292 = formData.getOrDefault("DbUser")
  valid_595292 = validateParameter(valid_595292, JString, required = true,
                                 default = nil)
  if valid_595292 != nil:
    section.add "DbUser", valid_595292
  var valid_595293 = formData.getOrDefault("ClusterIdentifier")
  valid_595293 = validateParameter(valid_595293, JString, required = true,
                                 default = nil)
  if valid_595293 != nil:
    section.add "ClusterIdentifier", valid_595293
  var valid_595294 = formData.getOrDefault("DurationSeconds")
  valid_595294 = validateParameter(valid_595294, JInt, required = false, default = nil)
  if valid_595294 != nil:
    section.add "DurationSeconds", valid_595294
  var valid_595295 = formData.getOrDefault("DbGroups")
  valid_595295 = validateParameter(valid_595295, JArray, required = false,
                                 default = nil)
  if valid_595295 != nil:
    section.add "DbGroups", valid_595295
  var valid_595296 = formData.getOrDefault("DbName")
  valid_595296 = validateParameter(valid_595296, JString, required = false,
                                 default = nil)
  if valid_595296 != nil:
    section.add "DbName", valid_595296
  var valid_595297 = formData.getOrDefault("AutoCreate")
  valid_595297 = validateParameter(valid_595297, JBool, required = false, default = nil)
  if valid_595297 != nil:
    section.add "AutoCreate", valid_595297
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595298: Call_PostGetClusterCredentials_595280; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_595298.validator(path, query, header, formData, body)
  let scheme = call_595298.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595298.url(scheme.get, call_595298.host, call_595298.base,
                         call_595298.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595298, url, valid)

proc call*(call_595299: Call_PostGetClusterCredentials_595280; DbUser: string;
          ClusterIdentifier: string; DurationSeconds: int = 0;
          DbGroups: JsonNode = nil; Action: string = "GetClusterCredentials";
          DbName: string = ""; AutoCreate: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   Action: string (required)
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Version: string (required)
  var query_595300 = newJObject()
  var formData_595301 = newJObject()
  add(formData_595301, "DbUser", newJString(DbUser))
  add(formData_595301, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_595301, "DurationSeconds", newJInt(DurationSeconds))
  if DbGroups != nil:
    formData_595301.add "DbGroups", DbGroups
  add(query_595300, "Action", newJString(Action))
  add(formData_595301, "DbName", newJString(DbName))
  add(formData_595301, "AutoCreate", newJBool(AutoCreate))
  add(query_595300, "Version", newJString(Version))
  result = call_595299.call(nil, query_595300, nil, formData_595301, nil)

var postGetClusterCredentials* = Call_PostGetClusterCredentials_595280(
    name: "postGetClusterCredentials", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_PostGetClusterCredentials_595281, base: "/",
    url: url_PostGetClusterCredentials_595282,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetClusterCredentials_595259 = ref object of OpenApiRestCall_592348
proc url_GetGetClusterCredentials_595261(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetGetClusterCredentials_595260(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DbName: JString
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbUser: JString (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: JBool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   Version: JString (required)
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: JInt
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  section = newJObject()
  var valid_595262 = query.getOrDefault("DbName")
  valid_595262 = validateParameter(valid_595262, JString, required = false,
                                 default = nil)
  if valid_595262 != nil:
    section.add "DbName", valid_595262
  assert query != nil, "query argument is necessary due to required `DbUser` field"
  var valid_595263 = query.getOrDefault("DbUser")
  valid_595263 = validateParameter(valid_595263, JString, required = true,
                                 default = nil)
  if valid_595263 != nil:
    section.add "DbUser", valid_595263
  var valid_595264 = query.getOrDefault("AutoCreate")
  valid_595264 = validateParameter(valid_595264, JBool, required = false, default = nil)
  if valid_595264 != nil:
    section.add "AutoCreate", valid_595264
  var valid_595265 = query.getOrDefault("Action")
  valid_595265 = validateParameter(valid_595265, JString, required = true,
                                 default = newJString("GetClusterCredentials"))
  if valid_595265 != nil:
    section.add "Action", valid_595265
  var valid_595266 = query.getOrDefault("ClusterIdentifier")
  valid_595266 = validateParameter(valid_595266, JString, required = true,
                                 default = nil)
  if valid_595266 != nil:
    section.add "ClusterIdentifier", valid_595266
  var valid_595267 = query.getOrDefault("Version")
  valid_595267 = validateParameter(valid_595267, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595267 != nil:
    section.add "Version", valid_595267
  var valid_595268 = query.getOrDefault("DbGroups")
  valid_595268 = validateParameter(valid_595268, JArray, required = false,
                                 default = nil)
  if valid_595268 != nil:
    section.add "DbGroups", valid_595268
  var valid_595269 = query.getOrDefault("DurationSeconds")
  valid_595269 = validateParameter(valid_595269, JInt, required = false, default = nil)
  if valid_595269 != nil:
    section.add "DurationSeconds", valid_595269
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595270 = header.getOrDefault("X-Amz-Signature")
  valid_595270 = validateParameter(valid_595270, JString, required = false,
                                 default = nil)
  if valid_595270 != nil:
    section.add "X-Amz-Signature", valid_595270
  var valid_595271 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595271 = validateParameter(valid_595271, JString, required = false,
                                 default = nil)
  if valid_595271 != nil:
    section.add "X-Amz-Content-Sha256", valid_595271
  var valid_595272 = header.getOrDefault("X-Amz-Date")
  valid_595272 = validateParameter(valid_595272, JString, required = false,
                                 default = nil)
  if valid_595272 != nil:
    section.add "X-Amz-Date", valid_595272
  var valid_595273 = header.getOrDefault("X-Amz-Credential")
  valid_595273 = validateParameter(valid_595273, JString, required = false,
                                 default = nil)
  if valid_595273 != nil:
    section.add "X-Amz-Credential", valid_595273
  var valid_595274 = header.getOrDefault("X-Amz-Security-Token")
  valid_595274 = validateParameter(valid_595274, JString, required = false,
                                 default = nil)
  if valid_595274 != nil:
    section.add "X-Amz-Security-Token", valid_595274
  var valid_595275 = header.getOrDefault("X-Amz-Algorithm")
  valid_595275 = validateParameter(valid_595275, JString, required = false,
                                 default = nil)
  if valid_595275 != nil:
    section.add "X-Amz-Algorithm", valid_595275
  var valid_595276 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595276 = validateParameter(valid_595276, JString, required = false,
                                 default = nil)
  if valid_595276 != nil:
    section.add "X-Amz-SignedHeaders", valid_595276
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595277: Call_GetGetClusterCredentials_595259; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ## 
  let valid = call_595277.validator(path, query, header, formData, body)
  let scheme = call_595277.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595277.url(scheme.get, call_595277.host, call_595277.base,
                         call_595277.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595277, url, valid)

proc call*(call_595278: Call_GetGetClusterCredentials_595259; DbUser: string;
          ClusterIdentifier: string; DbName: string = ""; AutoCreate: bool = false;
          Action: string = "GetClusterCredentials"; Version: string = "2012-12-01";
          DbGroups: JsonNode = nil; DurationSeconds: int = 0): Recallable =
  ## getGetClusterCredentials
  ## <p>Returns a database user name and temporary password with temporary authorization to log on to an Amazon Redshift database. The action returns the database user name prefixed with <code>IAM:</code> if <code>AutoCreate</code> is <code>False</code> or <code>IAMA:</code> if <code>AutoCreate</code> is <code>True</code>. You can optionally specify one or more database user groups that the user will join at log on. By default, the temporary credentials expire in 900 seconds. You can optionally specify a duration between 900 seconds (15 minutes) and 3600 seconds (60 minutes). For more information, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/generating-user-credentials.html">Using IAM Authentication to Generate Database User Credentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>The AWS Identity and Access Management (IAM)user or role that executes GetClusterCredentials must have an IAM policy attached that allows access to all necessary actions and resources. For more information about permissions, see <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/redshift-iam-access-control-identity-based.html#redshift-policy-resources.getclustercredentials-resources">Resource Policies for GetClusterCredentials</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If the <code>DbGroups</code> parameter is specified, the IAM policy must allow the <code>redshift:JoinGroup</code> action with access to the listed <code>dbgroups</code>. </p> <p>In addition, if the <code>AutoCreate</code> parameter is set to <code>True</code>, then the policy must include the <code>redshift:CreateClusterUser</code> privilege.</p> <p>If the <code>DbName</code> parameter is specified, the IAM policy must allow access to the resource <code>dbname</code> for the specified database name. </p>
  ##   DbName: string
  ##         : <p>The name of a database that <code>DbUser</code> is authorized to log on to. If <code>DbName</code> is not specified, <code>DbUser</code> can log on to any existing database.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DbUser: string (required)
  ##         : <p>The name of a database user. If a user name matching <code>DbUser</code> exists in the database, the temporary user credentials have the same permissions as the existing user. If <code>DbUser</code> doesn't exist in the database and <code>Autocreate</code> is <code>True</code>, a new user is created using the value for <code>DbUser</code> with PUBLIC permissions. If a database user matching the value for <code>DbUser</code> doesn't exist and <code>Autocreate</code> is <code>False</code>, then the command succeeds but the connection attempt will fail because the user doesn't exist in the database.</p> <p>For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html">CREATE USER</a> in the Amazon Redshift Database Developer Guide. </p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens. The user name can't be <code>PUBLIC</code>.</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   AutoCreate: bool
  ##             : Create a database user with the name specified for the user named in <code>DbUser</code> if one does not exist.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster that contains the database for which your are requesting credentials. This parameter is case sensitive.
  ##   Version: string (required)
  ##   DbGroups: JArray
  ##           : <p>A list of the names of existing database groups that the user named in <code>DbUser</code> will join for the current session, in addition to any group memberships for an existing user. If not specified, a new user is added only to PUBLIC.</p> <p>Database group name constraints</p> <ul> <li> <p>Must be 1 to 64 alphanumeric characters or hyphens</p> </li> <li> <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Must not contain a colon ( : ) or slash ( / ). </p> </li> <li> <p>Cannot be a reserved word. A list of reserved words can be found in <a 
  ## href="http://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p> </li> </ul>
  ##   DurationSeconds: int
  ##                  : <p>The number of seconds until the returned temporary password expires.</p> <p>Constraint: minimum 900, maximum 3600.</p> <p>Default: 900</p>
  var query_595279 = newJObject()
  add(query_595279, "DbName", newJString(DbName))
  add(query_595279, "DbUser", newJString(DbUser))
  add(query_595279, "AutoCreate", newJBool(AutoCreate))
  add(query_595279, "Action", newJString(Action))
  add(query_595279, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595279, "Version", newJString(Version))
  if DbGroups != nil:
    query_595279.add "DbGroups", DbGroups
  add(query_595279, "DurationSeconds", newJInt(DurationSeconds))
  result = call_595278.call(nil, query_595279, nil, nil, nil)

var getGetClusterCredentials* = Call_GetGetClusterCredentials_595259(
    name: "getGetClusterCredentials", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=GetClusterCredentials",
    validator: validate_GetGetClusterCredentials_595260, base: "/",
    url: url_GetGetClusterCredentials_595261, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostGetReservedNodeExchangeOfferings_595320 = ref object of OpenApiRestCall_592348
proc url_PostGetReservedNodeExchangeOfferings_595322(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostGetReservedNodeExchangeOfferings_595321(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595323 = query.getOrDefault("Action")
  valid_595323 = validateParameter(valid_595323, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_595323 != nil:
    section.add "Action", valid_595323
  var valid_595324 = query.getOrDefault("Version")
  valid_595324 = validateParameter(valid_595324, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595324 != nil:
    section.add "Version", valid_595324
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595325 = header.getOrDefault("X-Amz-Signature")
  valid_595325 = validateParameter(valid_595325, JString, required = false,
                                 default = nil)
  if valid_595325 != nil:
    section.add "X-Amz-Signature", valid_595325
  var valid_595326 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595326 = validateParameter(valid_595326, JString, required = false,
                                 default = nil)
  if valid_595326 != nil:
    section.add "X-Amz-Content-Sha256", valid_595326
  var valid_595327 = header.getOrDefault("X-Amz-Date")
  valid_595327 = validateParameter(valid_595327, JString, required = false,
                                 default = nil)
  if valid_595327 != nil:
    section.add "X-Amz-Date", valid_595327
  var valid_595328 = header.getOrDefault("X-Amz-Credential")
  valid_595328 = validateParameter(valid_595328, JString, required = false,
                                 default = nil)
  if valid_595328 != nil:
    section.add "X-Amz-Credential", valid_595328
  var valid_595329 = header.getOrDefault("X-Amz-Security-Token")
  valid_595329 = validateParameter(valid_595329, JString, required = false,
                                 default = nil)
  if valid_595329 != nil:
    section.add "X-Amz-Security-Token", valid_595329
  var valid_595330 = header.getOrDefault("X-Amz-Algorithm")
  valid_595330 = validateParameter(valid_595330, JString, required = false,
                                 default = nil)
  if valid_595330 != nil:
    section.add "X-Amz-Algorithm", valid_595330
  var valid_595331 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595331 = validateParameter(valid_595331, JString, required = false,
                                 default = nil)
  if valid_595331 != nil:
    section.add "X-Amz-SignedHeaders", valid_595331
  result.add "header", section
  ## parameters in `formData` object:
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `ReservedNodeId` field"
  var valid_595332 = formData.getOrDefault("ReservedNodeId")
  valid_595332 = validateParameter(valid_595332, JString, required = true,
                                 default = nil)
  if valid_595332 != nil:
    section.add "ReservedNodeId", valid_595332
  var valid_595333 = formData.getOrDefault("MaxRecords")
  valid_595333 = validateParameter(valid_595333, JInt, required = false, default = nil)
  if valid_595333 != nil:
    section.add "MaxRecords", valid_595333
  var valid_595334 = formData.getOrDefault("Marker")
  valid_595334 = validateParameter(valid_595334, JString, required = false,
                                 default = nil)
  if valid_595334 != nil:
    section.add "Marker", valid_595334
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595335: Call_PostGetReservedNodeExchangeOfferings_595320;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_595335.validator(path, query, header, formData, body)
  let scheme = call_595335.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595335.url(scheme.get, call_595335.host, call_595335.base,
                         call_595335.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595335, url, valid)

proc call*(call_595336: Call_PostGetReservedNodeExchangeOfferings_595320;
          ReservedNodeId: string; MaxRecords: int = 0; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings";
          Version: string = "2012-12-01"): Recallable =
  ## postGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595337 = newJObject()
  var formData_595338 = newJObject()
  add(formData_595338, "ReservedNodeId", newJString(ReservedNodeId))
  add(formData_595338, "MaxRecords", newJInt(MaxRecords))
  add(formData_595338, "Marker", newJString(Marker))
  add(query_595337, "Action", newJString(Action))
  add(query_595337, "Version", newJString(Version))
  result = call_595336.call(nil, query_595337, nil, formData_595338, nil)

var postGetReservedNodeExchangeOfferings* = Call_PostGetReservedNodeExchangeOfferings_595320(
    name: "postGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_PostGetReservedNodeExchangeOfferings_595321, base: "/",
    url: url_PostGetReservedNodeExchangeOfferings_595322,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetGetReservedNodeExchangeOfferings_595302 = ref object of OpenApiRestCall_592348
proc url_GetGetReservedNodeExchangeOfferings_595304(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetGetReservedNodeExchangeOfferings_595303(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Marker: JString
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: JString (required)
  ##   ReservedNodeId: JString (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Version: JString (required)
  ##   MaxRecords: JInt
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  section = newJObject()
  var valid_595305 = query.getOrDefault("Marker")
  valid_595305 = validateParameter(valid_595305, JString, required = false,
                                 default = nil)
  if valid_595305 != nil:
    section.add "Marker", valid_595305
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595306 = query.getOrDefault("Action")
  valid_595306 = validateParameter(valid_595306, JString, required = true, default = newJString(
      "GetReservedNodeExchangeOfferings"))
  if valid_595306 != nil:
    section.add "Action", valid_595306
  var valid_595307 = query.getOrDefault("ReservedNodeId")
  valid_595307 = validateParameter(valid_595307, JString, required = true,
                                 default = nil)
  if valid_595307 != nil:
    section.add "ReservedNodeId", valid_595307
  var valid_595308 = query.getOrDefault("Version")
  valid_595308 = validateParameter(valid_595308, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595308 != nil:
    section.add "Version", valid_595308
  var valid_595309 = query.getOrDefault("MaxRecords")
  valid_595309 = validateParameter(valid_595309, JInt, required = false, default = nil)
  if valid_595309 != nil:
    section.add "MaxRecords", valid_595309
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595310 = header.getOrDefault("X-Amz-Signature")
  valid_595310 = validateParameter(valid_595310, JString, required = false,
                                 default = nil)
  if valid_595310 != nil:
    section.add "X-Amz-Signature", valid_595310
  var valid_595311 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595311 = validateParameter(valid_595311, JString, required = false,
                                 default = nil)
  if valid_595311 != nil:
    section.add "X-Amz-Content-Sha256", valid_595311
  var valid_595312 = header.getOrDefault("X-Amz-Date")
  valid_595312 = validateParameter(valid_595312, JString, required = false,
                                 default = nil)
  if valid_595312 != nil:
    section.add "X-Amz-Date", valid_595312
  var valid_595313 = header.getOrDefault("X-Amz-Credential")
  valid_595313 = validateParameter(valid_595313, JString, required = false,
                                 default = nil)
  if valid_595313 != nil:
    section.add "X-Amz-Credential", valid_595313
  var valid_595314 = header.getOrDefault("X-Amz-Security-Token")
  valid_595314 = validateParameter(valid_595314, JString, required = false,
                                 default = nil)
  if valid_595314 != nil:
    section.add "X-Amz-Security-Token", valid_595314
  var valid_595315 = header.getOrDefault("X-Amz-Algorithm")
  valid_595315 = validateParameter(valid_595315, JString, required = false,
                                 default = nil)
  if valid_595315 != nil:
    section.add "X-Amz-Algorithm", valid_595315
  var valid_595316 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595316 = validateParameter(valid_595316, JString, required = false,
                                 default = nil)
  if valid_595316 != nil:
    section.add "X-Amz-SignedHeaders", valid_595316
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595317: Call_GetGetReservedNodeExchangeOfferings_595302;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ## 
  let valid = call_595317.validator(path, query, header, formData, body)
  let scheme = call_595317.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595317.url(scheme.get, call_595317.host, call_595317.base,
                         call_595317.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595317, url, valid)

proc call*(call_595318: Call_GetGetReservedNodeExchangeOfferings_595302;
          ReservedNodeId: string; Marker: string = "";
          Action: string = "GetReservedNodeExchangeOfferings";
          Version: string = "2012-12-01"; MaxRecords: int = 0): Recallable =
  ## getGetReservedNodeExchangeOfferings
  ## Returns an array of DC2 ReservedNodeOfferings that matches the payment type, term, and usage price of the given DC1 reserved node.
  ##   Marker: string
  ##         : A value that indicates the starting point for the next set of ReservedNodeOfferings.
  ##   Action: string (required)
  ##   ReservedNodeId: string (required)
  ##                 : A string representing the node identifier for the DC1 Reserved Node to be exchanged.
  ##   Version: string (required)
  ##   MaxRecords: int
  ##             : An integer setting the maximum number of ReservedNodeOfferings to retrieve.
  var query_595319 = newJObject()
  add(query_595319, "Marker", newJString(Marker))
  add(query_595319, "Action", newJString(Action))
  add(query_595319, "ReservedNodeId", newJString(ReservedNodeId))
  add(query_595319, "Version", newJString(Version))
  add(query_595319, "MaxRecords", newJInt(MaxRecords))
  result = call_595318.call(nil, query_595319, nil, nil, nil)

var getGetReservedNodeExchangeOfferings* = Call_GetGetReservedNodeExchangeOfferings_595302(
    name: "getGetReservedNodeExchangeOfferings", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=GetReservedNodeExchangeOfferings",
    validator: validate_GetGetReservedNodeExchangeOfferings_595303, base: "/",
    url: url_GetGetReservedNodeExchangeOfferings_595304,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyCluster_595376 = ref object of OpenApiRestCall_592348
proc url_PostModifyCluster_595378(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyCluster_595377(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595379 = query.getOrDefault("Action")
  valid_595379 = validateParameter(valid_595379, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_595379 != nil:
    section.add "Action", valid_595379
  var valid_595380 = query.getOrDefault("Version")
  valid_595380 = validateParameter(valid_595380, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595380 != nil:
    section.add "Version", valid_595380
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595381 = header.getOrDefault("X-Amz-Signature")
  valid_595381 = validateParameter(valid_595381, JString, required = false,
                                 default = nil)
  if valid_595381 != nil:
    section.add "X-Amz-Signature", valid_595381
  var valid_595382 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595382 = validateParameter(valid_595382, JString, required = false,
                                 default = nil)
  if valid_595382 != nil:
    section.add "X-Amz-Content-Sha256", valid_595382
  var valid_595383 = header.getOrDefault("X-Amz-Date")
  valid_595383 = validateParameter(valid_595383, JString, required = false,
                                 default = nil)
  if valid_595383 != nil:
    section.add "X-Amz-Date", valid_595383
  var valid_595384 = header.getOrDefault("X-Amz-Credential")
  valid_595384 = validateParameter(valid_595384, JString, required = false,
                                 default = nil)
  if valid_595384 != nil:
    section.add "X-Amz-Credential", valid_595384
  var valid_595385 = header.getOrDefault("X-Amz-Security-Token")
  valid_595385 = validateParameter(valid_595385, JString, required = false,
                                 default = nil)
  if valid_595385 != nil:
    section.add "X-Amz-Security-Token", valid_595385
  var valid_595386 = header.getOrDefault("X-Amz-Algorithm")
  valid_595386 = validateParameter(valid_595386, JString, required = false,
                                 default = nil)
  if valid_595386 != nil:
    section.add "X-Amz-Algorithm", valid_595386
  var valid_595387 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595387 = validateParameter(valid_595387, JString, required = false,
                                 default = nil)
  if valid_595387 != nil:
    section.add "X-Amz-SignedHeaders", valid_595387
  result.add "header", section
  ## parameters in `formData` object:
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  section = newJObject()
  var valid_595388 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_595388 = validateParameter(valid_595388, JString, required = false,
                                 default = nil)
  if valid_595388 != nil:
    section.add "PreferredMaintenanceWindow", valid_595388
  var valid_595389 = formData.getOrDefault("NodeType")
  valid_595389 = validateParameter(valid_595389, JString, required = false,
                                 default = nil)
  if valid_595389 != nil:
    section.add "NodeType", valid_595389
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595390 = formData.getOrDefault("ClusterIdentifier")
  valid_595390 = validateParameter(valid_595390, JString, required = true,
                                 default = nil)
  if valid_595390 != nil:
    section.add "ClusterIdentifier", valid_595390
  var valid_595391 = formData.getOrDefault("MasterUserPassword")
  valid_595391 = validateParameter(valid_595391, JString, required = false,
                                 default = nil)
  if valid_595391 != nil:
    section.add "MasterUserPassword", valid_595391
  var valid_595392 = formData.getOrDefault("MaintenanceTrackName")
  valid_595392 = validateParameter(valid_595392, JString, required = false,
                                 default = nil)
  if valid_595392 != nil:
    section.add "MaintenanceTrackName", valid_595392
  var valid_595393 = formData.getOrDefault("ClusterSecurityGroups")
  valid_595393 = validateParameter(valid_595393, JArray, required = false,
                                 default = nil)
  if valid_595393 != nil:
    section.add "ClusterSecurityGroups", valid_595393
  var valid_595394 = formData.getOrDefault("NumberOfNodes")
  valid_595394 = validateParameter(valid_595394, JInt, required = false, default = nil)
  if valid_595394 != nil:
    section.add "NumberOfNodes", valid_595394
  var valid_595395 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_595395 = validateParameter(valid_595395, JArray, required = false,
                                 default = nil)
  if valid_595395 != nil:
    section.add "VpcSecurityGroupIds", valid_595395
  var valid_595396 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_595396 = validateParameter(valid_595396, JInt, required = false, default = nil)
  if valid_595396 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_595396
  var valid_595397 = formData.getOrDefault("NewClusterIdentifier")
  valid_595397 = validateParameter(valid_595397, JString, required = false,
                                 default = nil)
  if valid_595397 != nil:
    section.add "NewClusterIdentifier", valid_595397
  var valid_595398 = formData.getOrDefault("EnhancedVpcRouting")
  valid_595398 = validateParameter(valid_595398, JBool, required = false, default = nil)
  if valid_595398 != nil:
    section.add "EnhancedVpcRouting", valid_595398
  var valid_595399 = formData.getOrDefault("KmsKeyId")
  valid_595399 = validateParameter(valid_595399, JString, required = false,
                                 default = nil)
  if valid_595399 != nil:
    section.add "KmsKeyId", valid_595399
  var valid_595400 = formData.getOrDefault("AllowVersionUpgrade")
  valid_595400 = validateParameter(valid_595400, JBool, required = false, default = nil)
  if valid_595400 != nil:
    section.add "AllowVersionUpgrade", valid_595400
  var valid_595401 = formData.getOrDefault("PubliclyAccessible")
  valid_595401 = validateParameter(valid_595401, JBool, required = false, default = nil)
  if valid_595401 != nil:
    section.add "PubliclyAccessible", valid_595401
  var valid_595402 = formData.getOrDefault("ClusterParameterGroupName")
  valid_595402 = validateParameter(valid_595402, JString, required = false,
                                 default = nil)
  if valid_595402 != nil:
    section.add "ClusterParameterGroupName", valid_595402
  var valid_595403 = formData.getOrDefault("ClusterVersion")
  valid_595403 = validateParameter(valid_595403, JString, required = false,
                                 default = nil)
  if valid_595403 != nil:
    section.add "ClusterVersion", valid_595403
  var valid_595404 = formData.getOrDefault("ClusterType")
  valid_595404 = validateParameter(valid_595404, JString, required = false,
                                 default = nil)
  if valid_595404 != nil:
    section.add "ClusterType", valid_595404
  var valid_595405 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_595405 = validateParameter(valid_595405, JString, required = false,
                                 default = nil)
  if valid_595405 != nil:
    section.add "HsmClientCertificateIdentifier", valid_595405
  var valid_595406 = formData.getOrDefault("Encrypted")
  valid_595406 = validateParameter(valid_595406, JBool, required = false, default = nil)
  if valid_595406 != nil:
    section.add "Encrypted", valid_595406
  var valid_595407 = formData.getOrDefault("ElasticIp")
  valid_595407 = validateParameter(valid_595407, JString, required = false,
                                 default = nil)
  if valid_595407 != nil:
    section.add "ElasticIp", valid_595407
  var valid_595408 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_595408 = validateParameter(valid_595408, JString, required = false,
                                 default = nil)
  if valid_595408 != nil:
    section.add "HsmConfigurationIdentifier", valid_595408
  var valid_595409 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_595409 = validateParameter(valid_595409, JInt, required = false, default = nil)
  if valid_595409 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_595409
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595410: Call_PostModifyCluster_595376; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_595410.validator(path, query, header, formData, body)
  let scheme = call_595410.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595410.url(scheme.get, call_595410.host, call_595410.base,
                         call_595410.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595410, url, valid)

proc call*(call_595411: Call_PostModifyCluster_595376; ClusterIdentifier: string;
          PreferredMaintenanceWindow: string = ""; NodeType: string = "";
          MasterUserPassword: string = ""; MaintenanceTrackName: string = "";
          ClusterSecurityGroups: JsonNode = nil; NumberOfNodes: int = 0;
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0;
          NewClusterIdentifier: string = ""; EnhancedVpcRouting: bool = false;
          KmsKeyId: string = ""; AllowVersionUpgrade: bool = false;
          PubliclyAccessible: bool = false; Action: string = "ModifyCluster";
          ClusterParameterGroupName: string = ""; ClusterVersion: string = "";
          ClusterType: string = ""; HsmClientCertificateIdentifier: string = "";
          Encrypted: bool = false; Version: string = "2012-12-01";
          ElasticIp: string = ""; HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  var query_595412 = newJObject()
  var formData_595413 = newJObject()
  add(formData_595413, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_595413, "NodeType", newJString(NodeType))
  add(formData_595413, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_595413, "MasterUserPassword", newJString(MasterUserPassword))
  add(formData_595413, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if ClusterSecurityGroups != nil:
    formData_595413.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(formData_595413, "NumberOfNodes", newJInt(NumberOfNodes))
  if VpcSecurityGroupIds != nil:
    formData_595413.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_595413, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_595413, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(formData_595413, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_595413, "KmsKeyId", newJString(KmsKeyId))
  add(formData_595413, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_595413, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_595412, "Action", newJString(Action))
  add(formData_595413, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_595413, "ClusterVersion", newJString(ClusterVersion))
  add(formData_595413, "ClusterType", newJString(ClusterType))
  add(formData_595413, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_595413, "Encrypted", newJBool(Encrypted))
  add(query_595412, "Version", newJString(Version))
  add(formData_595413, "ElasticIp", newJString(ElasticIp))
  add(formData_595413, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_595413, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_595411.call(nil, query_595412, nil, formData_595413, nil)

var postModifyCluster* = Call_PostModifyCluster_595376(name: "postModifyCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_PostModifyCluster_595377,
    base: "/", url: url_PostModifyCluster_595378,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyCluster_595339 = ref object of OpenApiRestCall_592348
proc url_GetModifyCluster_595341(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyCluster_595340(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   MaintenanceTrackName: JString
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   Encrypted: JBool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   NodeType: JString
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: JString
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: JString
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   NumberOfNodes: JInt
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   ElasticIp: JString
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   NewClusterIdentifier: JString
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: JString
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  section = newJObject()
  var valid_595342 = query.getOrDefault("MaintenanceTrackName")
  valid_595342 = validateParameter(valid_595342, JString, required = false,
                                 default = nil)
  if valid_595342 != nil:
    section.add "MaintenanceTrackName", valid_595342
  var valid_595343 = query.getOrDefault("Encrypted")
  valid_595343 = validateParameter(valid_595343, JBool, required = false, default = nil)
  if valid_595343 != nil:
    section.add "Encrypted", valid_595343
  var valid_595344 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_595344 = validateParameter(valid_595344, JInt, required = false, default = nil)
  if valid_595344 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_595344
  var valid_595345 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_595345 = validateParameter(valid_595345, JString, required = false,
                                 default = nil)
  if valid_595345 != nil:
    section.add "HsmClientCertificateIdentifier", valid_595345
  var valid_595346 = query.getOrDefault("ClusterSecurityGroups")
  valid_595346 = validateParameter(valid_595346, JArray, required = false,
                                 default = nil)
  if valid_595346 != nil:
    section.add "ClusterSecurityGroups", valid_595346
  var valid_595347 = query.getOrDefault("KmsKeyId")
  valid_595347 = validateParameter(valid_595347, JString, required = false,
                                 default = nil)
  if valid_595347 != nil:
    section.add "KmsKeyId", valid_595347
  var valid_595348 = query.getOrDefault("ClusterParameterGroupName")
  valid_595348 = validateParameter(valid_595348, JString, required = false,
                                 default = nil)
  if valid_595348 != nil:
    section.add "ClusterParameterGroupName", valid_595348
  var valid_595349 = query.getOrDefault("NodeType")
  valid_595349 = validateParameter(valid_595349, JString, required = false,
                                 default = nil)
  if valid_595349 != nil:
    section.add "NodeType", valid_595349
  var valid_595350 = query.getOrDefault("ClusterVersion")
  valid_595350 = validateParameter(valid_595350, JString, required = false,
                                 default = nil)
  if valid_595350 != nil:
    section.add "ClusterVersion", valid_595350
  var valid_595351 = query.getOrDefault("ClusterType")
  valid_595351 = validateParameter(valid_595351, JString, required = false,
                                 default = nil)
  if valid_595351 != nil:
    section.add "ClusterType", valid_595351
  var valid_595352 = query.getOrDefault("NumberOfNodes")
  valid_595352 = validateParameter(valid_595352, JInt, required = false, default = nil)
  if valid_595352 != nil:
    section.add "NumberOfNodes", valid_595352
  var valid_595353 = query.getOrDefault("AllowVersionUpgrade")
  valid_595353 = validateParameter(valid_595353, JBool, required = false, default = nil)
  if valid_595353 != nil:
    section.add "AllowVersionUpgrade", valid_595353
  var valid_595354 = query.getOrDefault("ElasticIp")
  valid_595354 = validateParameter(valid_595354, JString, required = false,
                                 default = nil)
  if valid_595354 != nil:
    section.add "ElasticIp", valid_595354
  var valid_595355 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_595355 = validateParameter(valid_595355, JInt, required = false, default = nil)
  if valid_595355 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_595355
  var valid_595356 = query.getOrDefault("EnhancedVpcRouting")
  valid_595356 = validateParameter(valid_595356, JBool, required = false, default = nil)
  if valid_595356 != nil:
    section.add "EnhancedVpcRouting", valid_595356
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595357 = query.getOrDefault("Action")
  valid_595357 = validateParameter(valid_595357, JString, required = true,
                                 default = newJString("ModifyCluster"))
  if valid_595357 != nil:
    section.add "Action", valid_595357
  var valid_595358 = query.getOrDefault("ClusterIdentifier")
  valid_595358 = validateParameter(valid_595358, JString, required = true,
                                 default = nil)
  if valid_595358 != nil:
    section.add "ClusterIdentifier", valid_595358
  var valid_595359 = query.getOrDefault("VpcSecurityGroupIds")
  valid_595359 = validateParameter(valid_595359, JArray, required = false,
                                 default = nil)
  if valid_595359 != nil:
    section.add "VpcSecurityGroupIds", valid_595359
  var valid_595360 = query.getOrDefault("NewClusterIdentifier")
  valid_595360 = validateParameter(valid_595360, JString, required = false,
                                 default = nil)
  if valid_595360 != nil:
    section.add "NewClusterIdentifier", valid_595360
  var valid_595361 = query.getOrDefault("MasterUserPassword")
  valid_595361 = validateParameter(valid_595361, JString, required = false,
                                 default = nil)
  if valid_595361 != nil:
    section.add "MasterUserPassword", valid_595361
  var valid_595362 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_595362 = validateParameter(valid_595362, JString, required = false,
                                 default = nil)
  if valid_595362 != nil:
    section.add "HsmConfigurationIdentifier", valid_595362
  var valid_595363 = query.getOrDefault("Version")
  valid_595363 = validateParameter(valid_595363, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595363 != nil:
    section.add "Version", valid_595363
  var valid_595364 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_595364 = validateParameter(valid_595364, JString, required = false,
                                 default = nil)
  if valid_595364 != nil:
    section.add "PreferredMaintenanceWindow", valid_595364
  var valid_595365 = query.getOrDefault("PubliclyAccessible")
  valid_595365 = validateParameter(valid_595365, JBool, required = false, default = nil)
  if valid_595365 != nil:
    section.add "PubliclyAccessible", valid_595365
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595366 = header.getOrDefault("X-Amz-Signature")
  valid_595366 = validateParameter(valid_595366, JString, required = false,
                                 default = nil)
  if valid_595366 != nil:
    section.add "X-Amz-Signature", valid_595366
  var valid_595367 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595367 = validateParameter(valid_595367, JString, required = false,
                                 default = nil)
  if valid_595367 != nil:
    section.add "X-Amz-Content-Sha256", valid_595367
  var valid_595368 = header.getOrDefault("X-Amz-Date")
  valid_595368 = validateParameter(valid_595368, JString, required = false,
                                 default = nil)
  if valid_595368 != nil:
    section.add "X-Amz-Date", valid_595368
  var valid_595369 = header.getOrDefault("X-Amz-Credential")
  valid_595369 = validateParameter(valid_595369, JString, required = false,
                                 default = nil)
  if valid_595369 != nil:
    section.add "X-Amz-Credential", valid_595369
  var valid_595370 = header.getOrDefault("X-Amz-Security-Token")
  valid_595370 = validateParameter(valid_595370, JString, required = false,
                                 default = nil)
  if valid_595370 != nil:
    section.add "X-Amz-Security-Token", valid_595370
  var valid_595371 = header.getOrDefault("X-Amz-Algorithm")
  valid_595371 = validateParameter(valid_595371, JString, required = false,
                                 default = nil)
  if valid_595371 != nil:
    section.add "X-Amz-Algorithm", valid_595371
  var valid_595372 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595372 = validateParameter(valid_595372, JString, required = false,
                                 default = nil)
  if valid_595372 != nil:
    section.add "X-Amz-SignedHeaders", valid_595372
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595373: Call_GetModifyCluster_595339; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ## 
  let valid = call_595373.validator(path, query, header, formData, body)
  let scheme = call_595373.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595373.url(scheme.get, call_595373.host, call_595373.base,
                         call_595373.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595373, url, valid)

proc call*(call_595374: Call_GetModifyCluster_595339; ClusterIdentifier: string;
          MaintenanceTrackName: string = ""; Encrypted: bool = false;
          ManualSnapshotRetentionPeriod: int = 0;
          HsmClientCertificateIdentifier: string = "";
          ClusterSecurityGroups: JsonNode = nil; KmsKeyId: string = "";
          ClusterParameterGroupName: string = ""; NodeType: string = "";
          ClusterVersion: string = ""; ClusterType: string = ""; NumberOfNodes: int = 0;
          AllowVersionUpgrade: bool = false; ElasticIp: string = "";
          AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false; Action: string = "ModifyCluster";
          VpcSecurityGroupIds: JsonNode = nil; NewClusterIdentifier: string = "";
          MasterUserPassword: string = ""; HsmConfigurationIdentifier: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getModifyCluster
  ## <p>Modifies the settings for a cluster. For example, you can add another security or parameter group, update the preferred maintenance window, or change the master user password. Resetting a cluster password or modifying the security groups associated with a cluster do not need a reboot. However, modifying a parameter group requires a reboot for parameters to take effect. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>You can also change node type and the number of nodes to scale up or down the cluster. When resizing a cluster, you must specify both the number of nodes and the node type even if one of the parameters does not change.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the <code>PendingModifiedValues</code> for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
  ##   Encrypted: bool
  ##            : Indicates whether the cluster is encrypted. If the cluster is encrypted and you provide a value for the <code>KmsKeyId</code> parameter, we will encrypt the cluster with the provided <code>KmsKeyId</code>. If you don't provide a <code>KmsKeyId</code>, we will encrypt with the default key. In the China region we will use legacy encryption if you specify that the cluster is encrypted.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default for number of days that a newly created manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely. This value doesn't retroactively change the retention periods of existing manual snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p> <p>The default value is -1.</p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of cluster security groups to be authorized on this cluster. This change is asynchronously applied as soon as possible.</p> <p>Security groups currently associated with the cluster, and not in the list of groups to apply, will be revoked from the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens</p> </li> <li> <p>First character must be a letter</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens</p> </li> </ul>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the cluster parameter group to apply to this cluster. This change is applied only after the cluster is rebooted. To reboot a cluster use <a>RebootCluster</a>. </p> <p>Default: Uses existing setting.</p> <p>Constraints: The cluster parameter group must be in the same parameter group family that matches the cluster version.</p>
  ##   NodeType: string
  ##           : <p>The new node type of the cluster. If you specify a new node type, you must also specify the number of nodes parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code>ds2.xlarge</code> | <code>ds2.8xlarge</code> | <code>dc1.large</code> | <code>dc1.8xlarge</code> | <code>dc2.large</code> | <code>dc2.8xlarge</code> </p>
  ##   ClusterVersion: string
  ##                 : <p>The new version number of the Amazon Redshift engine to upgrade to.</p> <p>For major version upgrades, if a non-default cluster parameter group is currently in use, a new cluster parameter group in the cluster parameter group family for the new version must be specified. The new cluster parameter group can be the default for that cluster parameter group family. For more information about parameters and parameter groups, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p> <p>Example: <code>1.0</code> </p>
  ##   ClusterType: string
  ##              : <p>The new cluster type.</p> <p>When you submit your cluster resize request, your existing cluster goes into a read-only mode. After Amazon Redshift provisions a new cluster based on your resize requirements, there will be outage for a period while the old cluster is deleted and your connection is switched to the new cluster. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: <code> multi-node | single-node </code> </p>
  ##   NumberOfNodes: int
  ##                : <p>The new number of nodes of the cluster. If you specify a new number of nodes, you must also specify the node type parameter.</p> <p>When you submit your request to resize a cluster, Amazon Redshift sets access permissions for the cluster to read-only. After Amazon Redshift provisions a new cluster according to your resize requirements, there will be a temporary outage while the old cluster is deleted and your connection is switched to the new cluster. When the new connection is complete, the original access permissions for the cluster are restored. You can use <a>DescribeResize</a> to track the progress of the resize request. </p> <p>Valid Values: Integer greater than <code>0</code>.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades will be applied automatically to the cluster during the maintenance window. </p> <p>Default: <code>false</code> </p>
  ##   ElasticIp: string
  ##            : <p>The Elastic IP (EIP) address for the cluster.</p> <p>Constraints: The cluster must be provisioned in EC2-VPC and publicly-accessible through an Internet gateway. For more information about provisioning clusters in EC2-VPC, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#cluster-platforms">Supported Platforms to Launch Your Cluster</a> in the Amazon Redshift Cluster Management Guide.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>If you decrease the automated snapshot retention period from its current value, existing automated snapshots that fall outside of the new retention period will be immediately deleted.</p> <p>Default: Uses existing setting.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster to be modified.</p> <p>Example: <code>examplecluster</code> </p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : A list of virtual private cloud (VPC) security groups to be associated with the cluster. This change is asynchronously applied as soon as possible.
  ##   NewClusterIdentifier: string
  ##                       : <p>The new identifier for the cluster.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul> <p>Example: <code>examplecluster</code> </p>
  ##   MasterUserPassword: string
  ##                     : <p>The new password for the cluster master user. This change is asynchronously applied as soon as possible. Between the time of the request and the completion of the request, the <code>MasterUserPassword</code> element exists in the <code>PendingModifiedValues</code> element of the operation response. </p> <note> <p>Operations never return the password, so this operation provides a way to regain access to the master user account for a cluster if the password is lost.</p> </note> <p>Default: Uses existing setting.</p> <p>Constraints:</p> <ul> <li> <p>Must be between 8 and 64 characters in length.</p> </li> <li> <p>Must contain at least one uppercase letter.</p> </li> <li> <p>Must contain at least one lowercase letter.</p> </li> <li> <p>Must contain one number.</p> </li> <li> <p>Can be any printable ASCII character (ASCII code 33 to 126) except ' (single quote), " (double quote), \, /, @, or space.</p> </li> </ul>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which system maintenance can occur, if necessary. If system maintenance is necessary during the window, it may result in an outage.</p> <p>This maintenance window change is made immediately. If the new maintenance window indicates the current time, there must be at least 120 minutes between the current time and end of the window in order to ensure that pending changes are applied.</p> <p>Default: Uses existing setting.</p> <p>Format: ddd:hh24:mi-ddd:hh24:mi, for example <code>wed:07:30-wed:08:00</code>.</p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Must be at least 30 minutes.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. Only clusters in VPCs can be set to be publicly available.
  var query_595375 = newJObject()
  add(query_595375, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_595375, "Encrypted", newJBool(Encrypted))
  add(query_595375, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_595375, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  if ClusterSecurityGroups != nil:
    query_595375.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_595375, "KmsKeyId", newJString(KmsKeyId))
  add(query_595375, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_595375, "NodeType", newJString(NodeType))
  add(query_595375, "ClusterVersion", newJString(ClusterVersion))
  add(query_595375, "ClusterType", newJString(ClusterType))
  add(query_595375, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_595375, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_595375, "ElasticIp", newJString(ElasticIp))
  add(query_595375, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_595375, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_595375, "Action", newJString(Action))
  add(query_595375, "ClusterIdentifier", newJString(ClusterIdentifier))
  if VpcSecurityGroupIds != nil:
    query_595375.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_595375, "NewClusterIdentifier", newJString(NewClusterIdentifier))
  add(query_595375, "MasterUserPassword", newJString(MasterUserPassword))
  add(query_595375, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_595375, "Version", newJString(Version))
  add(query_595375, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_595375, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_595374.call(nil, query_595375, nil, nil, nil)

var getModifyCluster* = Call_GetModifyCluster_595339(name: "getModifyCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ModifyCluster", validator: validate_GetModifyCluster_595340,
    base: "/", url: url_GetModifyCluster_595341,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterDbRevision_595431 = ref object of OpenApiRestCall_592348
proc url_PostModifyClusterDbRevision_595433(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterDbRevision_595432(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595434 = query.getOrDefault("Action")
  valid_595434 = validateParameter(valid_595434, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_595434 != nil:
    section.add "Action", valid_595434
  var valid_595435 = query.getOrDefault("Version")
  valid_595435 = validateParameter(valid_595435, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595435 != nil:
    section.add "Version", valid_595435
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595436 = header.getOrDefault("X-Amz-Signature")
  valid_595436 = validateParameter(valid_595436, JString, required = false,
                                 default = nil)
  if valid_595436 != nil:
    section.add "X-Amz-Signature", valid_595436
  var valid_595437 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595437 = validateParameter(valid_595437, JString, required = false,
                                 default = nil)
  if valid_595437 != nil:
    section.add "X-Amz-Content-Sha256", valid_595437
  var valid_595438 = header.getOrDefault("X-Amz-Date")
  valid_595438 = validateParameter(valid_595438, JString, required = false,
                                 default = nil)
  if valid_595438 != nil:
    section.add "X-Amz-Date", valid_595438
  var valid_595439 = header.getOrDefault("X-Amz-Credential")
  valid_595439 = validateParameter(valid_595439, JString, required = false,
                                 default = nil)
  if valid_595439 != nil:
    section.add "X-Amz-Credential", valid_595439
  var valid_595440 = header.getOrDefault("X-Amz-Security-Token")
  valid_595440 = validateParameter(valid_595440, JString, required = false,
                                 default = nil)
  if valid_595440 != nil:
    section.add "X-Amz-Security-Token", valid_595440
  var valid_595441 = header.getOrDefault("X-Amz-Algorithm")
  valid_595441 = validateParameter(valid_595441, JString, required = false,
                                 default = nil)
  if valid_595441 != nil:
    section.add "X-Amz-Algorithm", valid_595441
  var valid_595442 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595442 = validateParameter(valid_595442, JString, required = false,
                                 default = nil)
  if valid_595442 != nil:
    section.add "X-Amz-SignedHeaders", valid_595442
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595443 = formData.getOrDefault("ClusterIdentifier")
  valid_595443 = validateParameter(valid_595443, JString, required = true,
                                 default = nil)
  if valid_595443 != nil:
    section.add "ClusterIdentifier", valid_595443
  var valid_595444 = formData.getOrDefault("RevisionTarget")
  valid_595444 = validateParameter(valid_595444, JString, required = true,
                                 default = nil)
  if valid_595444 != nil:
    section.add "RevisionTarget", valid_595444
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595445: Call_PostModifyClusterDbRevision_595431; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_595445.validator(path, query, header, formData, body)
  let scheme = call_595445.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595445.url(scheme.get, call_595445.host, call_595445.base,
                         call_595445.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595445, url, valid)

proc call*(call_595446: Call_PostModifyClusterDbRevision_595431;
          ClusterIdentifier: string; RevisionTarget: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Action: string (required)
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Version: string (required)
  var query_595447 = newJObject()
  var formData_595448 = newJObject()
  add(formData_595448, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595447, "Action", newJString(Action))
  add(formData_595448, "RevisionTarget", newJString(RevisionTarget))
  add(query_595447, "Version", newJString(Version))
  result = call_595446.call(nil, query_595447, nil, formData_595448, nil)

var postModifyClusterDbRevision* = Call_PostModifyClusterDbRevision_595431(
    name: "postModifyClusterDbRevision", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_PostModifyClusterDbRevision_595432, base: "/",
    url: url_PostModifyClusterDbRevision_595433,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterDbRevision_595414 = ref object of OpenApiRestCall_592348
proc url_GetModifyClusterDbRevision_595416(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterDbRevision_595415(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   RevisionTarget: JString (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `RevisionTarget` field"
  var valid_595417 = query.getOrDefault("RevisionTarget")
  valid_595417 = validateParameter(valid_595417, JString, required = true,
                                 default = nil)
  if valid_595417 != nil:
    section.add "RevisionTarget", valid_595417
  var valid_595418 = query.getOrDefault("Action")
  valid_595418 = validateParameter(valid_595418, JString, required = true, default = newJString(
      "ModifyClusterDbRevision"))
  if valid_595418 != nil:
    section.add "Action", valid_595418
  var valid_595419 = query.getOrDefault("ClusterIdentifier")
  valid_595419 = validateParameter(valid_595419, JString, required = true,
                                 default = nil)
  if valid_595419 != nil:
    section.add "ClusterIdentifier", valid_595419
  var valid_595420 = query.getOrDefault("Version")
  valid_595420 = validateParameter(valid_595420, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595420 != nil:
    section.add "Version", valid_595420
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595421 = header.getOrDefault("X-Amz-Signature")
  valid_595421 = validateParameter(valid_595421, JString, required = false,
                                 default = nil)
  if valid_595421 != nil:
    section.add "X-Amz-Signature", valid_595421
  var valid_595422 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595422 = validateParameter(valid_595422, JString, required = false,
                                 default = nil)
  if valid_595422 != nil:
    section.add "X-Amz-Content-Sha256", valid_595422
  var valid_595423 = header.getOrDefault("X-Amz-Date")
  valid_595423 = validateParameter(valid_595423, JString, required = false,
                                 default = nil)
  if valid_595423 != nil:
    section.add "X-Amz-Date", valid_595423
  var valid_595424 = header.getOrDefault("X-Amz-Credential")
  valid_595424 = validateParameter(valid_595424, JString, required = false,
                                 default = nil)
  if valid_595424 != nil:
    section.add "X-Amz-Credential", valid_595424
  var valid_595425 = header.getOrDefault("X-Amz-Security-Token")
  valid_595425 = validateParameter(valid_595425, JString, required = false,
                                 default = nil)
  if valid_595425 != nil:
    section.add "X-Amz-Security-Token", valid_595425
  var valid_595426 = header.getOrDefault("X-Amz-Algorithm")
  valid_595426 = validateParameter(valid_595426, JString, required = false,
                                 default = nil)
  if valid_595426 != nil:
    section.add "X-Amz-Algorithm", valid_595426
  var valid_595427 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595427 = validateParameter(valid_595427, JString, required = false,
                                 default = nil)
  if valid_595427 != nil:
    section.add "X-Amz-SignedHeaders", valid_595427
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595428: Call_GetModifyClusterDbRevision_595414; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ## 
  let valid = call_595428.validator(path, query, header, formData, body)
  let scheme = call_595428.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595428.url(scheme.get, call_595428.host, call_595428.base,
                         call_595428.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595428, url, valid)

proc call*(call_595429: Call_GetModifyClusterDbRevision_595414;
          RevisionTarget: string; ClusterIdentifier: string;
          Action: string = "ModifyClusterDbRevision"; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterDbRevision
  ## Modifies the database revision of a cluster. The database revision is a unique revision of the database running in a cluster.
  ##   RevisionTarget: string (required)
  ##                 : The identifier of the database revision. You can retrieve this value from the response to the <a>DescribeClusterDbRevisions</a> request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of a cluster whose database revision you want to modify. </p> <p>Example: <code>examplecluster</code> </p>
  ##   Version: string (required)
  var query_595430 = newJObject()
  add(query_595430, "RevisionTarget", newJString(RevisionTarget))
  add(query_595430, "Action", newJString(Action))
  add(query_595430, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595430, "Version", newJString(Version))
  result = call_595429.call(nil, query_595430, nil, nil, nil)

var getModifyClusterDbRevision* = Call_GetModifyClusterDbRevision_595414(
    name: "getModifyClusterDbRevision", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterDbRevision",
    validator: validate_GetModifyClusterDbRevision_595415, base: "/",
    url: url_GetModifyClusterDbRevision_595416,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterIamRoles_595467 = ref object of OpenApiRestCall_592348
proc url_PostModifyClusterIamRoles_595469(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterIamRoles_595468(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595470 = query.getOrDefault("Action")
  valid_595470 = validateParameter(valid_595470, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_595470 != nil:
    section.add "Action", valid_595470
  var valid_595471 = query.getOrDefault("Version")
  valid_595471 = validateParameter(valid_595471, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595471 != nil:
    section.add "Version", valid_595471
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595472 = header.getOrDefault("X-Amz-Signature")
  valid_595472 = validateParameter(valid_595472, JString, required = false,
                                 default = nil)
  if valid_595472 != nil:
    section.add "X-Amz-Signature", valid_595472
  var valid_595473 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595473 = validateParameter(valid_595473, JString, required = false,
                                 default = nil)
  if valid_595473 != nil:
    section.add "X-Amz-Content-Sha256", valid_595473
  var valid_595474 = header.getOrDefault("X-Amz-Date")
  valid_595474 = validateParameter(valid_595474, JString, required = false,
                                 default = nil)
  if valid_595474 != nil:
    section.add "X-Amz-Date", valid_595474
  var valid_595475 = header.getOrDefault("X-Amz-Credential")
  valid_595475 = validateParameter(valid_595475, JString, required = false,
                                 default = nil)
  if valid_595475 != nil:
    section.add "X-Amz-Credential", valid_595475
  var valid_595476 = header.getOrDefault("X-Amz-Security-Token")
  valid_595476 = validateParameter(valid_595476, JString, required = false,
                                 default = nil)
  if valid_595476 != nil:
    section.add "X-Amz-Security-Token", valid_595476
  var valid_595477 = header.getOrDefault("X-Amz-Algorithm")
  valid_595477 = validateParameter(valid_595477, JString, required = false,
                                 default = nil)
  if valid_595477 != nil:
    section.add "X-Amz-Algorithm", valid_595477
  var valid_595478 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595478 = validateParameter(valid_595478, JString, required = false,
                                 default = nil)
  if valid_595478 != nil:
    section.add "X-Amz-SignedHeaders", valid_595478
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595479 = formData.getOrDefault("ClusterIdentifier")
  valid_595479 = validateParameter(valid_595479, JString, required = true,
                                 default = nil)
  if valid_595479 != nil:
    section.add "ClusterIdentifier", valid_595479
  var valid_595480 = formData.getOrDefault("RemoveIamRoles")
  valid_595480 = validateParameter(valid_595480, JArray, required = false,
                                 default = nil)
  if valid_595480 != nil:
    section.add "RemoveIamRoles", valid_595480
  var valid_595481 = formData.getOrDefault("AddIamRoles")
  valid_595481 = validateParameter(valid_595481, JArray, required = false,
                                 default = nil)
  if valid_595481 != nil:
    section.add "AddIamRoles", valid_595481
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595482: Call_PostModifyClusterIamRoles_595467; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_595482.validator(path, query, header, formData, body)
  let scheme = call_595482.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595482.url(scheme.get, call_595482.host, call_595482.base,
                         call_595482.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595482, url, valid)

proc call*(call_595483: Call_PostModifyClusterIamRoles_595467;
          ClusterIdentifier: string; RemoveIamRoles: JsonNode = nil;
          Action: string = "ModifyClusterIamRoles"; AddIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Action: string (required)
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Version: string (required)
  var query_595484 = newJObject()
  var formData_595485 = newJObject()
  add(formData_595485, "ClusterIdentifier", newJString(ClusterIdentifier))
  if RemoveIamRoles != nil:
    formData_595485.add "RemoveIamRoles", RemoveIamRoles
  add(query_595484, "Action", newJString(Action))
  if AddIamRoles != nil:
    formData_595485.add "AddIamRoles", AddIamRoles
  add(query_595484, "Version", newJString(Version))
  result = call_595483.call(nil, query_595484, nil, formData_595485, nil)

var postModifyClusterIamRoles* = Call_PostModifyClusterIamRoles_595467(
    name: "postModifyClusterIamRoles", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_PostModifyClusterIamRoles_595468, base: "/",
    url: url_PostModifyClusterIamRoles_595469,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterIamRoles_595449 = ref object of OpenApiRestCall_592348
proc url_GetModifyClusterIamRoles_595451(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterIamRoles_595450(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595452 = query.getOrDefault("AddIamRoles")
  valid_595452 = validateParameter(valid_595452, JArray, required = false,
                                 default = nil)
  if valid_595452 != nil:
    section.add "AddIamRoles", valid_595452
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595453 = query.getOrDefault("Action")
  valid_595453 = validateParameter(valid_595453, JString, required = true,
                                 default = newJString("ModifyClusterIamRoles"))
  if valid_595453 != nil:
    section.add "Action", valid_595453
  var valid_595454 = query.getOrDefault("ClusterIdentifier")
  valid_595454 = validateParameter(valid_595454, JString, required = true,
                                 default = nil)
  if valid_595454 != nil:
    section.add "ClusterIdentifier", valid_595454
  var valid_595455 = query.getOrDefault("RemoveIamRoles")
  valid_595455 = validateParameter(valid_595455, JArray, required = false,
                                 default = nil)
  if valid_595455 != nil:
    section.add "RemoveIamRoles", valid_595455
  var valid_595456 = query.getOrDefault("Version")
  valid_595456 = validateParameter(valid_595456, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595456 != nil:
    section.add "Version", valid_595456
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595457 = header.getOrDefault("X-Amz-Signature")
  valid_595457 = validateParameter(valid_595457, JString, required = false,
                                 default = nil)
  if valid_595457 != nil:
    section.add "X-Amz-Signature", valid_595457
  var valid_595458 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595458 = validateParameter(valid_595458, JString, required = false,
                                 default = nil)
  if valid_595458 != nil:
    section.add "X-Amz-Content-Sha256", valid_595458
  var valid_595459 = header.getOrDefault("X-Amz-Date")
  valid_595459 = validateParameter(valid_595459, JString, required = false,
                                 default = nil)
  if valid_595459 != nil:
    section.add "X-Amz-Date", valid_595459
  var valid_595460 = header.getOrDefault("X-Amz-Credential")
  valid_595460 = validateParameter(valid_595460, JString, required = false,
                                 default = nil)
  if valid_595460 != nil:
    section.add "X-Amz-Credential", valid_595460
  var valid_595461 = header.getOrDefault("X-Amz-Security-Token")
  valid_595461 = validateParameter(valid_595461, JString, required = false,
                                 default = nil)
  if valid_595461 != nil:
    section.add "X-Amz-Security-Token", valid_595461
  var valid_595462 = header.getOrDefault("X-Amz-Algorithm")
  valid_595462 = validateParameter(valid_595462, JString, required = false,
                                 default = nil)
  if valid_595462 != nil:
    section.add "X-Amz-Algorithm", valid_595462
  var valid_595463 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595463 = validateParameter(valid_595463, JString, required = false,
                                 default = nil)
  if valid_595463 != nil:
    section.add "X-Amz-SignedHeaders", valid_595463
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595464: Call_GetModifyClusterIamRoles_595449; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ## 
  let valid = call_595464.validator(path, query, header, formData, body)
  let scheme = call_595464.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595464.url(scheme.get, call_595464.host, call_595464.base,
                         call_595464.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595464, url, valid)

proc call*(call_595465: Call_GetModifyClusterIamRoles_595449;
          ClusterIdentifier: string; AddIamRoles: JsonNode = nil;
          Action: string = "ModifyClusterIamRoles"; RemoveIamRoles: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterIamRoles
  ## <p>Modifies the list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   AddIamRoles: JArray
  ##              : Zero or more IAM roles to associate with the cluster. The roles must be in their Amazon Resource Name (ARN) format. You can associate up to 10 IAM roles with a single cluster in a single request.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier of the cluster for which you want to associate or disassociate IAM roles.
  ##   RemoveIamRoles: JArray
  ##                 : Zero or more IAM roles in ARN format to disassociate from the cluster. You can disassociate up to 10 IAM roles from a single cluster in a single request.
  ##   Version: string (required)
  var query_595466 = newJObject()
  if AddIamRoles != nil:
    query_595466.add "AddIamRoles", AddIamRoles
  add(query_595466, "Action", newJString(Action))
  add(query_595466, "ClusterIdentifier", newJString(ClusterIdentifier))
  if RemoveIamRoles != nil:
    query_595466.add "RemoveIamRoles", RemoveIamRoles
  add(query_595466, "Version", newJString(Version))
  result = call_595465.call(nil, query_595466, nil, nil, nil)

var getModifyClusterIamRoles* = Call_GetModifyClusterIamRoles_595449(
    name: "getModifyClusterIamRoles", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterIamRoles",
    validator: validate_GetModifyClusterIamRoles_595450, base: "/",
    url: url_GetModifyClusterIamRoles_595451, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterMaintenance_595507 = ref object of OpenApiRestCall_592348
proc url_PostModifyClusterMaintenance_595509(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterMaintenance_595508(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595510 = query.getOrDefault("Action")
  valid_595510 = validateParameter(valid_595510, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_595510 != nil:
    section.add "Action", valid_595510
  var valid_595511 = query.getOrDefault("Version")
  valid_595511 = validateParameter(valid_595511, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595511 != nil:
    section.add "Version", valid_595511
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595512 = header.getOrDefault("X-Amz-Signature")
  valid_595512 = validateParameter(valid_595512, JString, required = false,
                                 default = nil)
  if valid_595512 != nil:
    section.add "X-Amz-Signature", valid_595512
  var valid_595513 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595513 = validateParameter(valid_595513, JString, required = false,
                                 default = nil)
  if valid_595513 != nil:
    section.add "X-Amz-Content-Sha256", valid_595513
  var valid_595514 = header.getOrDefault("X-Amz-Date")
  valid_595514 = validateParameter(valid_595514, JString, required = false,
                                 default = nil)
  if valid_595514 != nil:
    section.add "X-Amz-Date", valid_595514
  var valid_595515 = header.getOrDefault("X-Amz-Credential")
  valid_595515 = validateParameter(valid_595515, JString, required = false,
                                 default = nil)
  if valid_595515 != nil:
    section.add "X-Amz-Credential", valid_595515
  var valid_595516 = header.getOrDefault("X-Amz-Security-Token")
  valid_595516 = validateParameter(valid_595516, JString, required = false,
                                 default = nil)
  if valid_595516 != nil:
    section.add "X-Amz-Security-Token", valid_595516
  var valid_595517 = header.getOrDefault("X-Amz-Algorithm")
  valid_595517 = validateParameter(valid_595517, JString, required = false,
                                 default = nil)
  if valid_595517 != nil:
    section.add "X-Amz-Algorithm", valid_595517
  var valid_595518 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595518 = validateParameter(valid_595518, JString, required = false,
                                 default = nil)
  if valid_595518 != nil:
    section.add "X-Amz-SignedHeaders", valid_595518
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595519 = formData.getOrDefault("ClusterIdentifier")
  valid_595519 = validateParameter(valid_595519, JString, required = true,
                                 default = nil)
  if valid_595519 != nil:
    section.add "ClusterIdentifier", valid_595519
  var valid_595520 = formData.getOrDefault("DeferMaintenanceStartTime")
  valid_595520 = validateParameter(valid_595520, JString, required = false,
                                 default = nil)
  if valid_595520 != nil:
    section.add "DeferMaintenanceStartTime", valid_595520
  var valid_595521 = formData.getOrDefault("DeferMaintenance")
  valid_595521 = validateParameter(valid_595521, JBool, required = false, default = nil)
  if valid_595521 != nil:
    section.add "DeferMaintenance", valid_595521
  var valid_595522 = formData.getOrDefault("DeferMaintenanceDuration")
  valid_595522 = validateParameter(valid_595522, JInt, required = false, default = nil)
  if valid_595522 != nil:
    section.add "DeferMaintenanceDuration", valid_595522
  var valid_595523 = formData.getOrDefault("DeferMaintenanceEndTime")
  valid_595523 = validateParameter(valid_595523, JString, required = false,
                                 default = nil)
  if valid_595523 != nil:
    section.add "DeferMaintenanceEndTime", valid_595523
  var valid_595524 = formData.getOrDefault("DeferMaintenanceIdentifier")
  valid_595524 = validateParameter(valid_595524, JString, required = false,
                                 default = nil)
  if valid_595524 != nil:
    section.add "DeferMaintenanceIdentifier", valid_595524
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595525: Call_PostModifyClusterMaintenance_595507; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_595525.validator(path, query, header, formData, body)
  let scheme = call_595525.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595525.url(scheme.get, call_595525.host, call_595525.base,
                         call_595525.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595525, url, valid)

proc call*(call_595526: Call_PostModifyClusterMaintenance_595507;
          ClusterIdentifier: string; DeferMaintenanceStartTime: string = "";
          DeferMaintenance: bool = false; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceEndTime: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenanceIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: string (required)
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   Version: string (required)
  var query_595527 = newJObject()
  var formData_595528 = newJObject()
  add(formData_595528, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_595528, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  add(formData_595528, "DeferMaintenance", newJBool(DeferMaintenance))
  add(formData_595528, "DeferMaintenanceDuration",
      newJInt(DeferMaintenanceDuration))
  add(formData_595528, "DeferMaintenanceEndTime",
      newJString(DeferMaintenanceEndTime))
  add(query_595527, "Action", newJString(Action))
  add(formData_595528, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_595527, "Version", newJString(Version))
  result = call_595526.call(nil, query_595527, nil, formData_595528, nil)

var postModifyClusterMaintenance* = Call_PostModifyClusterMaintenance_595507(
    name: "postModifyClusterMaintenance", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_PostModifyClusterMaintenance_595508, base: "/",
    url: url_PostModifyClusterMaintenance_595509,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterMaintenance_595486 = ref object of OpenApiRestCall_592348
proc url_GetModifyClusterMaintenance_595488(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterMaintenance_595487(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   DeferMaintenanceDuration: JInt
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: JString
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceEndTime: JString
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: JString (required)
  ##   DeferMaintenance: JBool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: JString (required)
  ##   DeferMaintenanceStartTime: JString
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  section = newJObject()
  var valid_595489 = query.getOrDefault("DeferMaintenanceDuration")
  valid_595489 = validateParameter(valid_595489, JInt, required = false, default = nil)
  if valid_595489 != nil:
    section.add "DeferMaintenanceDuration", valid_595489
  var valid_595490 = query.getOrDefault("DeferMaintenanceIdentifier")
  valid_595490 = validateParameter(valid_595490, JString, required = false,
                                 default = nil)
  if valid_595490 != nil:
    section.add "DeferMaintenanceIdentifier", valid_595490
  var valid_595491 = query.getOrDefault("DeferMaintenanceEndTime")
  valid_595491 = validateParameter(valid_595491, JString, required = false,
                                 default = nil)
  if valid_595491 != nil:
    section.add "DeferMaintenanceEndTime", valid_595491
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595492 = query.getOrDefault("Action")
  valid_595492 = validateParameter(valid_595492, JString, required = true, default = newJString(
      "ModifyClusterMaintenance"))
  if valid_595492 != nil:
    section.add "Action", valid_595492
  var valid_595493 = query.getOrDefault("DeferMaintenance")
  valid_595493 = validateParameter(valid_595493, JBool, required = false, default = nil)
  if valid_595493 != nil:
    section.add "DeferMaintenance", valid_595493
  var valid_595494 = query.getOrDefault("ClusterIdentifier")
  valid_595494 = validateParameter(valid_595494, JString, required = true,
                                 default = nil)
  if valid_595494 != nil:
    section.add "ClusterIdentifier", valid_595494
  var valid_595495 = query.getOrDefault("Version")
  valid_595495 = validateParameter(valid_595495, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595495 != nil:
    section.add "Version", valid_595495
  var valid_595496 = query.getOrDefault("DeferMaintenanceStartTime")
  valid_595496 = validateParameter(valid_595496, JString, required = false,
                                 default = nil)
  if valid_595496 != nil:
    section.add "DeferMaintenanceStartTime", valid_595496
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595497 = header.getOrDefault("X-Amz-Signature")
  valid_595497 = validateParameter(valid_595497, JString, required = false,
                                 default = nil)
  if valid_595497 != nil:
    section.add "X-Amz-Signature", valid_595497
  var valid_595498 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595498 = validateParameter(valid_595498, JString, required = false,
                                 default = nil)
  if valid_595498 != nil:
    section.add "X-Amz-Content-Sha256", valid_595498
  var valid_595499 = header.getOrDefault("X-Amz-Date")
  valid_595499 = validateParameter(valid_595499, JString, required = false,
                                 default = nil)
  if valid_595499 != nil:
    section.add "X-Amz-Date", valid_595499
  var valid_595500 = header.getOrDefault("X-Amz-Credential")
  valid_595500 = validateParameter(valid_595500, JString, required = false,
                                 default = nil)
  if valid_595500 != nil:
    section.add "X-Amz-Credential", valid_595500
  var valid_595501 = header.getOrDefault("X-Amz-Security-Token")
  valid_595501 = validateParameter(valid_595501, JString, required = false,
                                 default = nil)
  if valid_595501 != nil:
    section.add "X-Amz-Security-Token", valid_595501
  var valid_595502 = header.getOrDefault("X-Amz-Algorithm")
  valid_595502 = validateParameter(valid_595502, JString, required = false,
                                 default = nil)
  if valid_595502 != nil:
    section.add "X-Amz-Algorithm", valid_595502
  var valid_595503 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595503 = validateParameter(valid_595503, JString, required = false,
                                 default = nil)
  if valid_595503 != nil:
    section.add "X-Amz-SignedHeaders", valid_595503
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595504: Call_GetModifyClusterMaintenance_595486; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ## 
  let valid = call_595504.validator(path, query, header, formData, body)
  let scheme = call_595504.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595504.url(scheme.get, call_595504.host, call_595504.base,
                         call_595504.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595504, url, valid)

proc call*(call_595505: Call_GetModifyClusterMaintenance_595486;
          ClusterIdentifier: string; DeferMaintenanceDuration: int = 0;
          DeferMaintenanceIdentifier: string = "";
          DeferMaintenanceEndTime: string = "";
          Action: string = "ModifyClusterMaintenance";
          DeferMaintenance: bool = false; Version: string = "2012-12-01";
          DeferMaintenanceStartTime: string = ""): Recallable =
  ## getModifyClusterMaintenance
  ## Modifies the maintenance settings of a cluster. For example, you can defer a maintenance window. You can also update or cancel a deferment. 
  ##   DeferMaintenanceDuration: int
  ##                           : An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
  ##   DeferMaintenanceIdentifier: string
  ##                             : A unique identifier for the deferred maintenance window.
  ##   DeferMaintenanceEndTime: string
  ##                          : A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
  ##   Action: string (required)
  ##   DeferMaintenance: bool
  ##                   : A boolean indicating whether to enable the deferred maintenance window. 
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster.
  ##   Version: string (required)
  ##   DeferMaintenanceStartTime: string
  ##                            : A timestamp indicating the start time for the deferred maintenance window.
  var query_595506 = newJObject()
  add(query_595506, "DeferMaintenanceDuration", newJInt(DeferMaintenanceDuration))
  add(query_595506, "DeferMaintenanceIdentifier",
      newJString(DeferMaintenanceIdentifier))
  add(query_595506, "DeferMaintenanceEndTime", newJString(DeferMaintenanceEndTime))
  add(query_595506, "Action", newJString(Action))
  add(query_595506, "DeferMaintenance", newJBool(DeferMaintenance))
  add(query_595506, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595506, "Version", newJString(Version))
  add(query_595506, "DeferMaintenanceStartTime",
      newJString(DeferMaintenanceStartTime))
  result = call_595505.call(nil, query_595506, nil, nil, nil)

var getModifyClusterMaintenance* = Call_GetModifyClusterMaintenance_595486(
    name: "getModifyClusterMaintenance", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterMaintenance",
    validator: validate_GetModifyClusterMaintenance_595487, base: "/",
    url: url_GetModifyClusterMaintenance_595488,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterParameterGroup_595546 = ref object of OpenApiRestCall_592348
proc url_PostModifyClusterParameterGroup_595548(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterParameterGroup_595547(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595549 = query.getOrDefault("Action")
  valid_595549 = validateParameter(valid_595549, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_595549 != nil:
    section.add "Action", valid_595549
  var valid_595550 = query.getOrDefault("Version")
  valid_595550 = validateParameter(valid_595550, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595550 != nil:
    section.add "Version", valid_595550
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595551 = header.getOrDefault("X-Amz-Signature")
  valid_595551 = validateParameter(valid_595551, JString, required = false,
                                 default = nil)
  if valid_595551 != nil:
    section.add "X-Amz-Signature", valid_595551
  var valid_595552 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595552 = validateParameter(valid_595552, JString, required = false,
                                 default = nil)
  if valid_595552 != nil:
    section.add "X-Amz-Content-Sha256", valid_595552
  var valid_595553 = header.getOrDefault("X-Amz-Date")
  valid_595553 = validateParameter(valid_595553, JString, required = false,
                                 default = nil)
  if valid_595553 != nil:
    section.add "X-Amz-Date", valid_595553
  var valid_595554 = header.getOrDefault("X-Amz-Credential")
  valid_595554 = validateParameter(valid_595554, JString, required = false,
                                 default = nil)
  if valid_595554 != nil:
    section.add "X-Amz-Credential", valid_595554
  var valid_595555 = header.getOrDefault("X-Amz-Security-Token")
  valid_595555 = validateParameter(valid_595555, JString, required = false,
                                 default = nil)
  if valid_595555 != nil:
    section.add "X-Amz-Security-Token", valid_595555
  var valid_595556 = header.getOrDefault("X-Amz-Algorithm")
  valid_595556 = validateParameter(valid_595556, JString, required = false,
                                 default = nil)
  if valid_595556 != nil:
    section.add "X-Amz-Algorithm", valid_595556
  var valid_595557 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595557 = validateParameter(valid_595557, JString, required = false,
                                 default = nil)
  if valid_595557 != nil:
    section.add "X-Amz-SignedHeaders", valid_595557
  result.add "header", section
  ## parameters in `formData` object:
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  section = newJObject()
  assert formData != nil,
        "formData argument is necessary due to required `Parameters` field"
  var valid_595558 = formData.getOrDefault("Parameters")
  valid_595558 = validateParameter(valid_595558, JArray, required = true, default = nil)
  if valid_595558 != nil:
    section.add "Parameters", valid_595558
  var valid_595559 = formData.getOrDefault("ParameterGroupName")
  valid_595559 = validateParameter(valid_595559, JString, required = true,
                                 default = nil)
  if valid_595559 != nil:
    section.add "ParameterGroupName", valid_595559
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595560: Call_PostModifyClusterParameterGroup_595546;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_595560.validator(path, query, header, formData, body)
  let scheme = call_595560.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595560.url(scheme.get, call_595560.host, call_595560.base,
                         call_595560.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595560, url, valid)

proc call*(call_595561: Call_PostModifyClusterParameterGroup_595546;
          Parameters: JsonNode; ParameterGroupName: string;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Action: string (required)
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: string (required)
  var query_595562 = newJObject()
  var formData_595563 = newJObject()
  add(query_595562, "Action", newJString(Action))
  if Parameters != nil:
    formData_595563.add "Parameters", Parameters
  add(formData_595563, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_595562, "Version", newJString(Version))
  result = call_595561.call(nil, query_595562, nil, formData_595563, nil)

var postModifyClusterParameterGroup* = Call_PostModifyClusterParameterGroup_595546(
    name: "postModifyClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_PostModifyClusterParameterGroup_595547, base: "/",
    url: url_PostModifyClusterParameterGroup_595548,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterParameterGroup_595529 = ref object of OpenApiRestCall_592348
proc url_GetModifyClusterParameterGroup_595531(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterParameterGroup_595530(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil,
        "query argument is necessary due to required `Parameters` field"
  var valid_595532 = query.getOrDefault("Parameters")
  valid_595532 = validateParameter(valid_595532, JArray, required = true, default = nil)
  if valid_595532 != nil:
    section.add "Parameters", valid_595532
  var valid_595533 = query.getOrDefault("Action")
  valid_595533 = validateParameter(valid_595533, JString, required = true, default = newJString(
      "ModifyClusterParameterGroup"))
  if valid_595533 != nil:
    section.add "Action", valid_595533
  var valid_595534 = query.getOrDefault("ParameterGroupName")
  valid_595534 = validateParameter(valid_595534, JString, required = true,
                                 default = nil)
  if valid_595534 != nil:
    section.add "ParameterGroupName", valid_595534
  var valid_595535 = query.getOrDefault("Version")
  valid_595535 = validateParameter(valid_595535, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595535 != nil:
    section.add "Version", valid_595535
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595536 = header.getOrDefault("X-Amz-Signature")
  valid_595536 = validateParameter(valid_595536, JString, required = false,
                                 default = nil)
  if valid_595536 != nil:
    section.add "X-Amz-Signature", valid_595536
  var valid_595537 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595537 = validateParameter(valid_595537, JString, required = false,
                                 default = nil)
  if valid_595537 != nil:
    section.add "X-Amz-Content-Sha256", valid_595537
  var valid_595538 = header.getOrDefault("X-Amz-Date")
  valid_595538 = validateParameter(valid_595538, JString, required = false,
                                 default = nil)
  if valid_595538 != nil:
    section.add "X-Amz-Date", valid_595538
  var valid_595539 = header.getOrDefault("X-Amz-Credential")
  valid_595539 = validateParameter(valid_595539, JString, required = false,
                                 default = nil)
  if valid_595539 != nil:
    section.add "X-Amz-Credential", valid_595539
  var valid_595540 = header.getOrDefault("X-Amz-Security-Token")
  valid_595540 = validateParameter(valid_595540, JString, required = false,
                                 default = nil)
  if valid_595540 != nil:
    section.add "X-Amz-Security-Token", valid_595540
  var valid_595541 = header.getOrDefault("X-Amz-Algorithm")
  valid_595541 = validateParameter(valid_595541, JString, required = false,
                                 default = nil)
  if valid_595541 != nil:
    section.add "X-Amz-Algorithm", valid_595541
  var valid_595542 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595542 = validateParameter(valid_595542, JString, required = false,
                                 default = nil)
  if valid_595542 != nil:
    section.add "X-Amz-SignedHeaders", valid_595542
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595543: Call_GetModifyClusterParameterGroup_595529; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_595543.validator(path, query, header, formData, body)
  let scheme = call_595543.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595543.url(scheme.get, call_595543.host, call_595543.base,
                         call_595543.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595543, url, valid)

proc call*(call_595544: Call_GetModifyClusterParameterGroup_595529;
          Parameters: JsonNode; ParameterGroupName: string;
          Action: string = "ModifyClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterParameterGroup
  ## <p>Modifies the parameters of a parameter group.</p> <p> For more information about parameters and parameter groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Amazon Redshift Parameter Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Parameters: JArray (required)
  ##             : <p>An array of parameters to be modified. A maximum of 20 parameters can be modified in a single request.</p> <p>For each parameter to be modified, you must supply at least the parameter name and parameter value; other name-value pairs of the parameter are optional.</p> <p>For the workload management (WLM) configuration, you must supply all the name-value pairs in the wlm_json_configuration parameter.</p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of the parameter group to be modified.
  ##   Version: string (required)
  var query_595545 = newJObject()
  if Parameters != nil:
    query_595545.add "Parameters", Parameters
  add(query_595545, "Action", newJString(Action))
  add(query_595545, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_595545, "Version", newJString(Version))
  result = call_595544.call(nil, query_595545, nil, nil, nil)

var getModifyClusterParameterGroup* = Call_GetModifyClusterParameterGroup_595529(
    name: "getModifyClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterParameterGroup",
    validator: validate_GetModifyClusterParameterGroup_595530, base: "/",
    url: url_GetModifyClusterParameterGroup_595531,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshot_595582 = ref object of OpenApiRestCall_592348
proc url_PostModifyClusterSnapshot_595584(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterSnapshot_595583(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595585 = query.getOrDefault("Action")
  valid_595585 = validateParameter(valid_595585, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_595585 != nil:
    section.add "Action", valid_595585
  var valid_595586 = query.getOrDefault("Version")
  valid_595586 = validateParameter(valid_595586, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595586 != nil:
    section.add "Version", valid_595586
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595587 = header.getOrDefault("X-Amz-Signature")
  valid_595587 = validateParameter(valid_595587, JString, required = false,
                                 default = nil)
  if valid_595587 != nil:
    section.add "X-Amz-Signature", valid_595587
  var valid_595588 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595588 = validateParameter(valid_595588, JString, required = false,
                                 default = nil)
  if valid_595588 != nil:
    section.add "X-Amz-Content-Sha256", valid_595588
  var valid_595589 = header.getOrDefault("X-Amz-Date")
  valid_595589 = validateParameter(valid_595589, JString, required = false,
                                 default = nil)
  if valid_595589 != nil:
    section.add "X-Amz-Date", valid_595589
  var valid_595590 = header.getOrDefault("X-Amz-Credential")
  valid_595590 = validateParameter(valid_595590, JString, required = false,
                                 default = nil)
  if valid_595590 != nil:
    section.add "X-Amz-Credential", valid_595590
  var valid_595591 = header.getOrDefault("X-Amz-Security-Token")
  valid_595591 = validateParameter(valid_595591, JString, required = false,
                                 default = nil)
  if valid_595591 != nil:
    section.add "X-Amz-Security-Token", valid_595591
  var valid_595592 = header.getOrDefault("X-Amz-Algorithm")
  valid_595592 = validateParameter(valid_595592, JString, required = false,
                                 default = nil)
  if valid_595592 != nil:
    section.add "X-Amz-Algorithm", valid_595592
  var valid_595593 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595593 = validateParameter(valid_595593, JString, required = false,
                                 default = nil)
  if valid_595593 != nil:
    section.add "X-Amz-SignedHeaders", valid_595593
  result.add "header", section
  ## parameters in `formData` object:
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_595594 = formData.getOrDefault("Force")
  valid_595594 = validateParameter(valid_595594, JBool, required = false, default = nil)
  if valid_595594 != nil:
    section.add "Force", valid_595594
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_595595 = formData.getOrDefault("SnapshotIdentifier")
  valid_595595 = validateParameter(valid_595595, JString, required = true,
                                 default = nil)
  if valid_595595 != nil:
    section.add "SnapshotIdentifier", valid_595595
  var valid_595596 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_595596 = validateParameter(valid_595596, JInt, required = false, default = nil)
  if valid_595596 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_595596
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595597: Call_PostModifyClusterSnapshot_595582; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_595597.validator(path, query, header, formData, body)
  let scheme = call_595597.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595597.url(scheme.get, call_595597.host, call_595597.base,
                         call_595597.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595597, url, valid)

proc call*(call_595598: Call_PostModifyClusterSnapshot_595582;
          SnapshotIdentifier: string; Force: bool = false;
          Action: string = "ModifyClusterSnapshot"; Version: string = "2012-12-01";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_595599 = newJObject()
  var formData_595600 = newJObject()
  add(formData_595600, "Force", newJBool(Force))
  add(formData_595600, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_595599, "Action", newJString(Action))
  add(query_595599, "Version", newJString(Version))
  add(formData_595600, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_595598.call(nil, query_595599, nil, formData_595600, nil)

var postModifyClusterSnapshot* = Call_PostModifyClusterSnapshot_595582(
    name: "postModifyClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_PostModifyClusterSnapshot_595583, base: "/",
    url: url_PostModifyClusterSnapshot_595584,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshot_595564 = ref object of OpenApiRestCall_592348
proc url_GetModifyClusterSnapshot_595566(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterSnapshot_595565(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the settings for a snapshot.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: JBool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_595567 = query.getOrDefault("SnapshotIdentifier")
  valid_595567 = validateParameter(valid_595567, JString, required = true,
                                 default = nil)
  if valid_595567 != nil:
    section.add "SnapshotIdentifier", valid_595567
  var valid_595568 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_595568 = validateParameter(valid_595568, JInt, required = false, default = nil)
  if valid_595568 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_595568
  var valid_595569 = query.getOrDefault("Force")
  valid_595569 = validateParameter(valid_595569, JBool, required = false, default = nil)
  if valid_595569 != nil:
    section.add "Force", valid_595569
  var valid_595570 = query.getOrDefault("Action")
  valid_595570 = validateParameter(valid_595570, JString, required = true,
                                 default = newJString("ModifyClusterSnapshot"))
  if valid_595570 != nil:
    section.add "Action", valid_595570
  var valid_595571 = query.getOrDefault("Version")
  valid_595571 = validateParameter(valid_595571, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595571 != nil:
    section.add "Version", valid_595571
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595572 = header.getOrDefault("X-Amz-Signature")
  valid_595572 = validateParameter(valid_595572, JString, required = false,
                                 default = nil)
  if valid_595572 != nil:
    section.add "X-Amz-Signature", valid_595572
  var valid_595573 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595573 = validateParameter(valid_595573, JString, required = false,
                                 default = nil)
  if valid_595573 != nil:
    section.add "X-Amz-Content-Sha256", valid_595573
  var valid_595574 = header.getOrDefault("X-Amz-Date")
  valid_595574 = validateParameter(valid_595574, JString, required = false,
                                 default = nil)
  if valid_595574 != nil:
    section.add "X-Amz-Date", valid_595574
  var valid_595575 = header.getOrDefault("X-Amz-Credential")
  valid_595575 = validateParameter(valid_595575, JString, required = false,
                                 default = nil)
  if valid_595575 != nil:
    section.add "X-Amz-Credential", valid_595575
  var valid_595576 = header.getOrDefault("X-Amz-Security-Token")
  valid_595576 = validateParameter(valid_595576, JString, required = false,
                                 default = nil)
  if valid_595576 != nil:
    section.add "X-Amz-Security-Token", valid_595576
  var valid_595577 = header.getOrDefault("X-Amz-Algorithm")
  valid_595577 = validateParameter(valid_595577, JString, required = false,
                                 default = nil)
  if valid_595577 != nil:
    section.add "X-Amz-Algorithm", valid_595577
  var valid_595578 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595578 = validateParameter(valid_595578, JString, required = false,
                                 default = nil)
  if valid_595578 != nil:
    section.add "X-Amz-SignedHeaders", valid_595578
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595579: Call_GetModifyClusterSnapshot_595564; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies the settings for a snapshot.
  ## 
  let valid = call_595579.validator(path, query, header, formData, body)
  let scheme = call_595579.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595579.url(scheme.get, call_595579.host, call_595579.base,
                         call_595579.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595579, url, valid)

proc call*(call_595580: Call_GetModifyClusterSnapshot_595564;
          SnapshotIdentifier: string; ManualSnapshotRetentionPeriod: int = 0;
          Force: bool = false; Action: string = "ModifyClusterSnapshot";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshot
  ## Modifies the settings for a snapshot.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot whose setting you want to modify.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The number of days that a manual snapshot is retained. If the value is -1, the manual snapshot is retained indefinitely.</p> <p>If the manual snapshot falls outside of the new retention period, you can specify the force option to immediately delete the snapshot.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   Force: bool
  ##        : A Boolean option to override an exception if the retention period has already passed.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595581 = newJObject()
  add(query_595581, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_595581, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  add(query_595581, "Force", newJBool(Force))
  add(query_595581, "Action", newJString(Action))
  add(query_595581, "Version", newJString(Version))
  result = call_595580.call(nil, query_595581, nil, nil, nil)

var getModifyClusterSnapshot* = Call_GetModifyClusterSnapshot_595564(
    name: "getModifyClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSnapshot",
    validator: validate_GetModifyClusterSnapshot_595565, base: "/",
    url: url_GetModifyClusterSnapshot_595566, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSnapshotSchedule_595619 = ref object of OpenApiRestCall_592348
proc url_PostModifyClusterSnapshotSchedule_595621(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterSnapshotSchedule_595620(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595622 = query.getOrDefault("Action")
  valid_595622 = validateParameter(valid_595622, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_595622 != nil:
    section.add "Action", valid_595622
  var valid_595623 = query.getOrDefault("Version")
  valid_595623 = validateParameter(valid_595623, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595623 != nil:
    section.add "Version", valid_595623
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595624 = header.getOrDefault("X-Amz-Signature")
  valid_595624 = validateParameter(valid_595624, JString, required = false,
                                 default = nil)
  if valid_595624 != nil:
    section.add "X-Amz-Signature", valid_595624
  var valid_595625 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595625 = validateParameter(valid_595625, JString, required = false,
                                 default = nil)
  if valid_595625 != nil:
    section.add "X-Amz-Content-Sha256", valid_595625
  var valid_595626 = header.getOrDefault("X-Amz-Date")
  valid_595626 = validateParameter(valid_595626, JString, required = false,
                                 default = nil)
  if valid_595626 != nil:
    section.add "X-Amz-Date", valid_595626
  var valid_595627 = header.getOrDefault("X-Amz-Credential")
  valid_595627 = validateParameter(valid_595627, JString, required = false,
                                 default = nil)
  if valid_595627 != nil:
    section.add "X-Amz-Credential", valid_595627
  var valid_595628 = header.getOrDefault("X-Amz-Security-Token")
  valid_595628 = validateParameter(valid_595628, JString, required = false,
                                 default = nil)
  if valid_595628 != nil:
    section.add "X-Amz-Security-Token", valid_595628
  var valid_595629 = header.getOrDefault("X-Amz-Algorithm")
  valid_595629 = validateParameter(valid_595629, JString, required = false,
                                 default = nil)
  if valid_595629 != nil:
    section.add "X-Amz-Algorithm", valid_595629
  var valid_595630 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595630 = validateParameter(valid_595630, JString, required = false,
                                 default = nil)
  if valid_595630 != nil:
    section.add "X-Amz-SignedHeaders", valid_595630
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595631 = formData.getOrDefault("ClusterIdentifier")
  valid_595631 = validateParameter(valid_595631, JString, required = true,
                                 default = nil)
  if valid_595631 != nil:
    section.add "ClusterIdentifier", valid_595631
  var valid_595632 = formData.getOrDefault("ScheduleIdentifier")
  valid_595632 = validateParameter(valid_595632, JString, required = false,
                                 default = nil)
  if valid_595632 != nil:
    section.add "ScheduleIdentifier", valid_595632
  var valid_595633 = formData.getOrDefault("DisassociateSchedule")
  valid_595633 = validateParameter(valid_595633, JBool, required = false, default = nil)
  if valid_595633 != nil:
    section.add "DisassociateSchedule", valid_595633
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595634: Call_PostModifyClusterSnapshotSchedule_595619;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_595634.validator(path, query, header, formData, body)
  let scheme = call_595634.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595634.url(scheme.get, call_595634.host, call_595634.base,
                         call_595634.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595634, url, valid)

proc call*(call_595635: Call_PostModifyClusterSnapshotSchedule_595619;
          ClusterIdentifier: string;
          Action: string = "ModifyClusterSnapshotSchedule";
          ScheduleIdentifier: string = ""; DisassociateSchedule: bool = false;
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Action: string (required)
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   Version: string (required)
  var query_595636 = newJObject()
  var formData_595637 = newJObject()
  add(formData_595637, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595636, "Action", newJString(Action))
  add(formData_595637, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(formData_595637, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_595636, "Version", newJString(Version))
  result = call_595635.call(nil, query_595636, nil, formData_595637, nil)

var postModifyClusterSnapshotSchedule* = Call_PostModifyClusterSnapshotSchedule_595619(
    name: "postModifyClusterSnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_PostModifyClusterSnapshotSchedule_595620, base: "/",
    url: url_PostModifyClusterSnapshotSchedule_595621,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSnapshotSchedule_595601 = ref object of OpenApiRestCall_592348
proc url_GetModifyClusterSnapshotSchedule_595603(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterSnapshotSchedule_595602(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Action: JString (required)
  ##   DisassociateSchedule: JBool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: JString (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Version: JString (required)
  section = newJObject()
  var valid_595604 = query.getOrDefault("ScheduleIdentifier")
  valid_595604 = validateParameter(valid_595604, JString, required = false,
                                 default = nil)
  if valid_595604 != nil:
    section.add "ScheduleIdentifier", valid_595604
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595605 = query.getOrDefault("Action")
  valid_595605 = validateParameter(valid_595605, JString, required = true, default = newJString(
      "ModifyClusterSnapshotSchedule"))
  if valid_595605 != nil:
    section.add "Action", valid_595605
  var valid_595606 = query.getOrDefault("DisassociateSchedule")
  valid_595606 = validateParameter(valid_595606, JBool, required = false, default = nil)
  if valid_595606 != nil:
    section.add "DisassociateSchedule", valid_595606
  var valid_595607 = query.getOrDefault("ClusterIdentifier")
  valid_595607 = validateParameter(valid_595607, JString, required = true,
                                 default = nil)
  if valid_595607 != nil:
    section.add "ClusterIdentifier", valid_595607
  var valid_595608 = query.getOrDefault("Version")
  valid_595608 = validateParameter(valid_595608, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595608 != nil:
    section.add "Version", valid_595608
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595609 = header.getOrDefault("X-Amz-Signature")
  valid_595609 = validateParameter(valid_595609, JString, required = false,
                                 default = nil)
  if valid_595609 != nil:
    section.add "X-Amz-Signature", valid_595609
  var valid_595610 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595610 = validateParameter(valid_595610, JString, required = false,
                                 default = nil)
  if valid_595610 != nil:
    section.add "X-Amz-Content-Sha256", valid_595610
  var valid_595611 = header.getOrDefault("X-Amz-Date")
  valid_595611 = validateParameter(valid_595611, JString, required = false,
                                 default = nil)
  if valid_595611 != nil:
    section.add "X-Amz-Date", valid_595611
  var valid_595612 = header.getOrDefault("X-Amz-Credential")
  valid_595612 = validateParameter(valid_595612, JString, required = false,
                                 default = nil)
  if valid_595612 != nil:
    section.add "X-Amz-Credential", valid_595612
  var valid_595613 = header.getOrDefault("X-Amz-Security-Token")
  valid_595613 = validateParameter(valid_595613, JString, required = false,
                                 default = nil)
  if valid_595613 != nil:
    section.add "X-Amz-Security-Token", valid_595613
  var valid_595614 = header.getOrDefault("X-Amz-Algorithm")
  valid_595614 = validateParameter(valid_595614, JString, required = false,
                                 default = nil)
  if valid_595614 != nil:
    section.add "X-Amz-Algorithm", valid_595614
  var valid_595615 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595615 = validateParameter(valid_595615, JString, required = false,
                                 default = nil)
  if valid_595615 != nil:
    section.add "X-Amz-SignedHeaders", valid_595615
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595616: Call_GetModifyClusterSnapshotSchedule_595601;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies a snapshot schedule for a cluster.
  ## 
  let valid = call_595616.validator(path, query, header, formData, body)
  let scheme = call_595616.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595616.url(scheme.get, call_595616.host, call_595616.base,
                         call_595616.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595616, url, valid)

proc call*(call_595617: Call_GetModifyClusterSnapshotSchedule_595601;
          ClusterIdentifier: string; ScheduleIdentifier: string = "";
          Action: string = "ModifyClusterSnapshotSchedule";
          DisassociateSchedule: bool = false; Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSnapshotSchedule
  ## Modifies a snapshot schedule for a cluster.
  ##   ScheduleIdentifier: string
  ##                     : A unique alphanumeric identifier for the schedule that you want to associate with the cluster.
  ##   Action: string (required)
  ##   DisassociateSchedule: bool
  ##                       : A boolean to indicate whether to remove the assoiciation between the cluster and the schedule.
  ##   ClusterIdentifier: string (required)
  ##                    : A unique identifier for the cluster whose snapshot schedule you want to modify. 
  ##   Version: string (required)
  var query_595618 = newJObject()
  add(query_595618, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_595618, "Action", newJString(Action))
  add(query_595618, "DisassociateSchedule", newJBool(DisassociateSchedule))
  add(query_595618, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595618, "Version", newJString(Version))
  result = call_595617.call(nil, query_595618, nil, nil, nil)

var getModifyClusterSnapshotSchedule* = Call_GetModifyClusterSnapshotSchedule_595601(
    name: "getModifyClusterSnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifyClusterSnapshotSchedule",
    validator: validate_GetModifyClusterSnapshotSchedule_595602, base: "/",
    url: url_GetModifyClusterSnapshotSchedule_595603,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyClusterSubnetGroup_595656 = ref object of OpenApiRestCall_592348
proc url_PostModifyClusterSubnetGroup_595658(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyClusterSubnetGroup_595657(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595659 = query.getOrDefault("Action")
  valid_595659 = validateParameter(valid_595659, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_595659 != nil:
    section.add "Action", valid_595659
  var valid_595660 = query.getOrDefault("Version")
  valid_595660 = validateParameter(valid_595660, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595660 != nil:
    section.add "Version", valid_595660
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595661 = header.getOrDefault("X-Amz-Signature")
  valid_595661 = validateParameter(valid_595661, JString, required = false,
                                 default = nil)
  if valid_595661 != nil:
    section.add "X-Amz-Signature", valid_595661
  var valid_595662 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595662 = validateParameter(valid_595662, JString, required = false,
                                 default = nil)
  if valid_595662 != nil:
    section.add "X-Amz-Content-Sha256", valid_595662
  var valid_595663 = header.getOrDefault("X-Amz-Date")
  valid_595663 = validateParameter(valid_595663, JString, required = false,
                                 default = nil)
  if valid_595663 != nil:
    section.add "X-Amz-Date", valid_595663
  var valid_595664 = header.getOrDefault("X-Amz-Credential")
  valid_595664 = validateParameter(valid_595664, JString, required = false,
                                 default = nil)
  if valid_595664 != nil:
    section.add "X-Amz-Credential", valid_595664
  var valid_595665 = header.getOrDefault("X-Amz-Security-Token")
  valid_595665 = validateParameter(valid_595665, JString, required = false,
                                 default = nil)
  if valid_595665 != nil:
    section.add "X-Amz-Security-Token", valid_595665
  var valid_595666 = header.getOrDefault("X-Amz-Algorithm")
  valid_595666 = validateParameter(valid_595666, JString, required = false,
                                 default = nil)
  if valid_595666 != nil:
    section.add "X-Amz-Algorithm", valid_595666
  var valid_595667 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595667 = validateParameter(valid_595667, JString, required = false,
                                 default = nil)
  if valid_595667 != nil:
    section.add "X-Amz-SignedHeaders", valid_595667
  result.add "header", section
  ## parameters in `formData` object:
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  section = newJObject()
  var valid_595668 = formData.getOrDefault("Description")
  valid_595668 = validateParameter(valid_595668, JString, required = false,
                                 default = nil)
  if valid_595668 != nil:
    section.add "Description", valid_595668
  assert formData != nil, "formData argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_595669 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_595669 = validateParameter(valid_595669, JString, required = true,
                                 default = nil)
  if valid_595669 != nil:
    section.add "ClusterSubnetGroupName", valid_595669
  var valid_595670 = formData.getOrDefault("SubnetIds")
  valid_595670 = validateParameter(valid_595670, JArray, required = true, default = nil)
  if valid_595670 != nil:
    section.add "SubnetIds", valid_595670
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595671: Call_PostModifyClusterSubnetGroup_595656; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_595671.validator(path, query, header, formData, body)
  let scheme = call_595671.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595671.url(scheme.get, call_595671.host, call_595671.base,
                         call_595671.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595671, url, valid)

proc call*(call_595672: Call_PostModifyClusterSubnetGroup_595656;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Description: string = ""; Action: string = "ModifyClusterSubnetGroup";
          Version: string = "2012-12-01"): Recallable =
  ## postModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  var query_595673 = newJObject()
  var formData_595674 = newJObject()
  add(formData_595674, "Description", newJString(Description))
  add(formData_595674, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(query_595673, "Action", newJString(Action))
  add(query_595673, "Version", newJString(Version))
  if SubnetIds != nil:
    formData_595674.add "SubnetIds", SubnetIds
  result = call_595672.call(nil, query_595673, nil, formData_595674, nil)

var postModifyClusterSubnetGroup* = Call_PostModifyClusterSubnetGroup_595656(
    name: "postModifyClusterSubnetGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_PostModifyClusterSubnetGroup_595657, base: "/",
    url: url_PostModifyClusterSubnetGroup_595658,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyClusterSubnetGroup_595638 = ref object of OpenApiRestCall_592348
proc url_GetModifyClusterSubnetGroup_595640(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyClusterSubnetGroup_595639(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: JString (required)
  ##   Description: JString
  ##              : A text description of the subnet group to be modified.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ClusterSubnetGroupName` field"
  var valid_595641 = query.getOrDefault("ClusterSubnetGroupName")
  valid_595641 = validateParameter(valid_595641, JString, required = true,
                                 default = nil)
  if valid_595641 != nil:
    section.add "ClusterSubnetGroupName", valid_595641
  var valid_595642 = query.getOrDefault("SubnetIds")
  valid_595642 = validateParameter(valid_595642, JArray, required = true, default = nil)
  if valid_595642 != nil:
    section.add "SubnetIds", valid_595642
  var valid_595643 = query.getOrDefault("Action")
  valid_595643 = validateParameter(valid_595643, JString, required = true, default = newJString(
      "ModifyClusterSubnetGroup"))
  if valid_595643 != nil:
    section.add "Action", valid_595643
  var valid_595644 = query.getOrDefault("Description")
  valid_595644 = validateParameter(valid_595644, JString, required = false,
                                 default = nil)
  if valid_595644 != nil:
    section.add "Description", valid_595644
  var valid_595645 = query.getOrDefault("Version")
  valid_595645 = validateParameter(valid_595645, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595645 != nil:
    section.add "Version", valid_595645
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595646 = header.getOrDefault("X-Amz-Signature")
  valid_595646 = validateParameter(valid_595646, JString, required = false,
                                 default = nil)
  if valid_595646 != nil:
    section.add "X-Amz-Signature", valid_595646
  var valid_595647 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595647 = validateParameter(valid_595647, JString, required = false,
                                 default = nil)
  if valid_595647 != nil:
    section.add "X-Amz-Content-Sha256", valid_595647
  var valid_595648 = header.getOrDefault("X-Amz-Date")
  valid_595648 = validateParameter(valid_595648, JString, required = false,
                                 default = nil)
  if valid_595648 != nil:
    section.add "X-Amz-Date", valid_595648
  var valid_595649 = header.getOrDefault("X-Amz-Credential")
  valid_595649 = validateParameter(valid_595649, JString, required = false,
                                 default = nil)
  if valid_595649 != nil:
    section.add "X-Amz-Credential", valid_595649
  var valid_595650 = header.getOrDefault("X-Amz-Security-Token")
  valid_595650 = validateParameter(valid_595650, JString, required = false,
                                 default = nil)
  if valid_595650 != nil:
    section.add "X-Amz-Security-Token", valid_595650
  var valid_595651 = header.getOrDefault("X-Amz-Algorithm")
  valid_595651 = validateParameter(valid_595651, JString, required = false,
                                 default = nil)
  if valid_595651 != nil:
    section.add "X-Amz-Algorithm", valid_595651
  var valid_595652 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595652 = validateParameter(valid_595652, JString, required = false,
                                 default = nil)
  if valid_595652 != nil:
    section.add "X-Amz-SignedHeaders", valid_595652
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595653: Call_GetModifyClusterSubnetGroup_595638; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ## 
  let valid = call_595653.validator(path, query, header, formData, body)
  let scheme = call_595653.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595653.url(scheme.get, call_595653.host, call_595653.base,
                         call_595653.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595653, url, valid)

proc call*(call_595654: Call_GetModifyClusterSubnetGroup_595638;
          ClusterSubnetGroupName: string; SubnetIds: JsonNode;
          Action: string = "ModifyClusterSubnetGroup"; Description: string = "";
          Version: string = "2012-12-01"): Recallable =
  ## getModifyClusterSubnetGroup
  ## Modifies a cluster subnet group to include the specified list of VPC subnets. The operation replaces the existing list of subnets with the new list of subnets.
  ##   ClusterSubnetGroupName: string (required)
  ##                         : The name of the subnet group to be modified.
  ##   SubnetIds: JArray (required)
  ##            : An array of VPC subnet IDs. A maximum of 20 subnets can be modified in a single request.
  ##   Action: string (required)
  ##   Description: string
  ##              : A text description of the subnet group to be modified.
  ##   Version: string (required)
  var query_595655 = newJObject()
  add(query_595655, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  if SubnetIds != nil:
    query_595655.add "SubnetIds", SubnetIds
  add(query_595655, "Action", newJString(Action))
  add(query_595655, "Description", newJString(Description))
  add(query_595655, "Version", newJString(Version))
  result = call_595654.call(nil, query_595655, nil, nil, nil)

var getModifyClusterSubnetGroup* = Call_GetModifyClusterSubnetGroup_595638(
    name: "getModifyClusterSubnetGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyClusterSubnetGroup",
    validator: validate_GetModifyClusterSubnetGroup_595639, base: "/",
    url: url_GetModifyClusterSubnetGroup_595640,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifyEventSubscription_595697 = ref object of OpenApiRestCall_592348
proc url_PostModifyEventSubscription_595699(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifyEventSubscription_595698(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595700 = query.getOrDefault("Action")
  valid_595700 = validateParameter(valid_595700, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_595700 != nil:
    section.add "Action", valid_595700
  var valid_595701 = query.getOrDefault("Version")
  valid_595701 = validateParameter(valid_595701, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595701 != nil:
    section.add "Version", valid_595701
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595702 = header.getOrDefault("X-Amz-Signature")
  valid_595702 = validateParameter(valid_595702, JString, required = false,
                                 default = nil)
  if valid_595702 != nil:
    section.add "X-Amz-Signature", valid_595702
  var valid_595703 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595703 = validateParameter(valid_595703, JString, required = false,
                                 default = nil)
  if valid_595703 != nil:
    section.add "X-Amz-Content-Sha256", valid_595703
  var valid_595704 = header.getOrDefault("X-Amz-Date")
  valid_595704 = validateParameter(valid_595704, JString, required = false,
                                 default = nil)
  if valid_595704 != nil:
    section.add "X-Amz-Date", valid_595704
  var valid_595705 = header.getOrDefault("X-Amz-Credential")
  valid_595705 = validateParameter(valid_595705, JString, required = false,
                                 default = nil)
  if valid_595705 != nil:
    section.add "X-Amz-Credential", valid_595705
  var valid_595706 = header.getOrDefault("X-Amz-Security-Token")
  valid_595706 = validateParameter(valid_595706, JString, required = false,
                                 default = nil)
  if valid_595706 != nil:
    section.add "X-Amz-Security-Token", valid_595706
  var valid_595707 = header.getOrDefault("X-Amz-Algorithm")
  valid_595707 = validateParameter(valid_595707, JString, required = false,
                                 default = nil)
  if valid_595707 != nil:
    section.add "X-Amz-Algorithm", valid_595707
  var valid_595708 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595708 = validateParameter(valid_595708, JString, required = false,
                                 default = nil)
  if valid_595708 != nil:
    section.add "X-Amz-SignedHeaders", valid_595708
  result.add "header", section
  ## parameters in `formData` object:
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  section = newJObject()
  var valid_595709 = formData.getOrDefault("SourceIds")
  valid_595709 = validateParameter(valid_595709, JArray, required = false,
                                 default = nil)
  if valid_595709 != nil:
    section.add "SourceIds", valid_595709
  var valid_595710 = formData.getOrDefault("SnsTopicArn")
  valid_595710 = validateParameter(valid_595710, JString, required = false,
                                 default = nil)
  if valid_595710 != nil:
    section.add "SnsTopicArn", valid_595710
  var valid_595711 = formData.getOrDefault("Enabled")
  valid_595711 = validateParameter(valid_595711, JBool, required = false, default = nil)
  if valid_595711 != nil:
    section.add "Enabled", valid_595711
  assert formData != nil, "formData argument is necessary due to required `SubscriptionName` field"
  var valid_595712 = formData.getOrDefault("SubscriptionName")
  valid_595712 = validateParameter(valid_595712, JString, required = true,
                                 default = nil)
  if valid_595712 != nil:
    section.add "SubscriptionName", valid_595712
  var valid_595713 = formData.getOrDefault("SourceType")
  valid_595713 = validateParameter(valid_595713, JString, required = false,
                                 default = nil)
  if valid_595713 != nil:
    section.add "SourceType", valid_595713
  var valid_595714 = formData.getOrDefault("Severity")
  valid_595714 = validateParameter(valid_595714, JString, required = false,
                                 default = nil)
  if valid_595714 != nil:
    section.add "Severity", valid_595714
  var valid_595715 = formData.getOrDefault("EventCategories")
  valid_595715 = validateParameter(valid_595715, JArray, required = false,
                                 default = nil)
  if valid_595715 != nil:
    section.add "EventCategories", valid_595715
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595716: Call_PostModifyEventSubscription_595697; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_595716.validator(path, query, header, formData, body)
  let scheme = call_595716.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595716.url(scheme.get, call_595716.host, call_595716.base,
                         call_595716.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595716, url, valid)

proc call*(call_595717: Call_PostModifyEventSubscription_595697;
          SubscriptionName: string; SourceIds: JsonNode = nil;
          SnsTopicArn: string = ""; Enabled: bool = false; SourceType: string = "";
          Severity: string = ""; EventCategories: JsonNode = nil;
          Action: string = "ModifyEventSubscription"; Version: string = "2012-12-01"): Recallable =
  ## postModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595718 = newJObject()
  var formData_595719 = newJObject()
  if SourceIds != nil:
    formData_595719.add "SourceIds", SourceIds
  add(formData_595719, "SnsTopicArn", newJString(SnsTopicArn))
  add(formData_595719, "Enabled", newJBool(Enabled))
  add(formData_595719, "SubscriptionName", newJString(SubscriptionName))
  add(formData_595719, "SourceType", newJString(SourceType))
  add(formData_595719, "Severity", newJString(Severity))
  if EventCategories != nil:
    formData_595719.add "EventCategories", EventCategories
  add(query_595718, "Action", newJString(Action))
  add(query_595718, "Version", newJString(Version))
  result = call_595717.call(nil, query_595718, nil, formData_595719, nil)

var postModifyEventSubscription* = Call_PostModifyEventSubscription_595697(
    name: "postModifyEventSubscription", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_PostModifyEventSubscription_595698, base: "/",
    url: url_PostModifyEventSubscription_595699,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifyEventSubscription_595675 = ref object of OpenApiRestCall_592348
proc url_GetModifyEventSubscription_595677(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifyEventSubscription_595676(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SourceType: JString
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Enabled: JBool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Severity: JString
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: JString (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: JString (required)
  ##   SnsTopicArn: JString
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595678 = query.getOrDefault("SourceType")
  valid_595678 = validateParameter(valid_595678, JString, required = false,
                                 default = nil)
  if valid_595678 != nil:
    section.add "SourceType", valid_595678
  var valid_595679 = query.getOrDefault("Enabled")
  valid_595679 = validateParameter(valid_595679, JBool, required = false, default = nil)
  if valid_595679 != nil:
    section.add "Enabled", valid_595679
  var valid_595680 = query.getOrDefault("Severity")
  valid_595680 = validateParameter(valid_595680, JString, required = false,
                                 default = nil)
  if valid_595680 != nil:
    section.add "Severity", valid_595680
  assert query != nil,
        "query argument is necessary due to required `SubscriptionName` field"
  var valid_595681 = query.getOrDefault("SubscriptionName")
  valid_595681 = validateParameter(valid_595681, JString, required = true,
                                 default = nil)
  if valid_595681 != nil:
    section.add "SubscriptionName", valid_595681
  var valid_595682 = query.getOrDefault("EventCategories")
  valid_595682 = validateParameter(valid_595682, JArray, required = false,
                                 default = nil)
  if valid_595682 != nil:
    section.add "EventCategories", valid_595682
  var valid_595683 = query.getOrDefault("SourceIds")
  valid_595683 = validateParameter(valid_595683, JArray, required = false,
                                 default = nil)
  if valid_595683 != nil:
    section.add "SourceIds", valid_595683
  var valid_595684 = query.getOrDefault("Action")
  valid_595684 = validateParameter(valid_595684, JString, required = true, default = newJString(
      "ModifyEventSubscription"))
  if valid_595684 != nil:
    section.add "Action", valid_595684
  var valid_595685 = query.getOrDefault("SnsTopicArn")
  valid_595685 = validateParameter(valid_595685, JString, required = false,
                                 default = nil)
  if valid_595685 != nil:
    section.add "SnsTopicArn", valid_595685
  var valid_595686 = query.getOrDefault("Version")
  valid_595686 = validateParameter(valid_595686, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595686 != nil:
    section.add "Version", valid_595686
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595687 = header.getOrDefault("X-Amz-Signature")
  valid_595687 = validateParameter(valid_595687, JString, required = false,
                                 default = nil)
  if valid_595687 != nil:
    section.add "X-Amz-Signature", valid_595687
  var valid_595688 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595688 = validateParameter(valid_595688, JString, required = false,
                                 default = nil)
  if valid_595688 != nil:
    section.add "X-Amz-Content-Sha256", valid_595688
  var valid_595689 = header.getOrDefault("X-Amz-Date")
  valid_595689 = validateParameter(valid_595689, JString, required = false,
                                 default = nil)
  if valid_595689 != nil:
    section.add "X-Amz-Date", valid_595689
  var valid_595690 = header.getOrDefault("X-Amz-Credential")
  valid_595690 = validateParameter(valid_595690, JString, required = false,
                                 default = nil)
  if valid_595690 != nil:
    section.add "X-Amz-Credential", valid_595690
  var valid_595691 = header.getOrDefault("X-Amz-Security-Token")
  valid_595691 = validateParameter(valid_595691, JString, required = false,
                                 default = nil)
  if valid_595691 != nil:
    section.add "X-Amz-Security-Token", valid_595691
  var valid_595692 = header.getOrDefault("X-Amz-Algorithm")
  valid_595692 = validateParameter(valid_595692, JString, required = false,
                                 default = nil)
  if valid_595692 != nil:
    section.add "X-Amz-Algorithm", valid_595692
  var valid_595693 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595693 = validateParameter(valid_595693, JString, required = false,
                                 default = nil)
  if valid_595693 != nil:
    section.add "X-Amz-SignedHeaders", valid_595693
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595694: Call_GetModifyEventSubscription_595675; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies an existing Amazon Redshift event notification subscription.
  ## 
  let valid = call_595694.validator(path, query, header, formData, body)
  let scheme = call_595694.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595694.url(scheme.get, call_595694.host, call_595694.base,
                         call_595694.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595694, url, valid)

proc call*(call_595695: Call_GetModifyEventSubscription_595675;
          SubscriptionName: string; SourceType: string = ""; Enabled: bool = false;
          Severity: string = ""; EventCategories: JsonNode = nil;
          SourceIds: JsonNode = nil; Action: string = "ModifyEventSubscription";
          SnsTopicArn: string = ""; Version: string = "2012-12-01"): Recallable =
  ## getModifyEventSubscription
  ## Modifies an existing Amazon Redshift event notification subscription.
  ##   SourceType: string
  ##             : <p>The type of source that will be generating the events. For example, if you want to be notified of events generated by a cluster, you would set this parameter to cluster. If this value is not specified, events are returned for all Amazon Redshift objects in your AWS account. You must specify a source type in order to specify source IDs.</p> <p>Valid values: cluster, cluster-parameter-group, cluster-security-group, and cluster-snapshot.</p>
  ##   Enabled: bool
  ##          : A Boolean value indicating if the subscription is enabled. <code>true</code> indicates the subscription is enabled 
  ##   Severity: string
  ##           : <p>Specifies the Amazon Redshift event severity to be published by the event notification subscription.</p> <p>Values: ERROR, INFO</p>
  ##   SubscriptionName: string (required)
  ##                   : The name of the modified Amazon Redshift event notification subscription.
  ##   EventCategories: JArray
  ##                  : <p>Specifies the Amazon Redshift event categories to be published by the event notification subscription.</p> <p>Values: configuration, management, monitoring, security</p>
  ##   SourceIds: JArray
  ##            : <p>A list of one or more identifiers of Amazon Redshift source objects. All of the objects must be of the same type as was specified in the source type parameter. The event subscription will return only events generated by the specified objects. If not specified, then events are returned for all objects within the source type specified.</p> <p>Example: my-cluster-1, my-cluster-2</p> <p>Example: my-snapshot-20131010</p>
  ##   Action: string (required)
  ##   SnsTopicArn: string
  ##              : The Amazon Resource Name (ARN) of the SNS topic to be used by the event notification subscription.
  ##   Version: string (required)
  var query_595696 = newJObject()
  add(query_595696, "SourceType", newJString(SourceType))
  add(query_595696, "Enabled", newJBool(Enabled))
  add(query_595696, "Severity", newJString(Severity))
  add(query_595696, "SubscriptionName", newJString(SubscriptionName))
  if EventCategories != nil:
    query_595696.add "EventCategories", EventCategories
  if SourceIds != nil:
    query_595696.add "SourceIds", SourceIds
  add(query_595696, "Action", newJString(Action))
  add(query_595696, "SnsTopicArn", newJString(SnsTopicArn))
  add(query_595696, "Version", newJString(Version))
  result = call_595695.call(nil, query_595696, nil, nil, nil)

var getModifyEventSubscription* = Call_GetModifyEventSubscription_595675(
    name: "getModifyEventSubscription", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifyEventSubscription",
    validator: validate_GetModifyEventSubscription_595676, base: "/",
    url: url_GetModifyEventSubscription_595677,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotCopyRetentionPeriod_595738 = ref object of OpenApiRestCall_592348
proc url_PostModifySnapshotCopyRetentionPeriod_595740(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifySnapshotCopyRetentionPeriod_595739(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595741 = query.getOrDefault("Action")
  valid_595741 = validateParameter(valid_595741, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_595741 != nil:
    section.add "Action", valid_595741
  var valid_595742 = query.getOrDefault("Version")
  valid_595742 = validateParameter(valid_595742, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595742 != nil:
    section.add "Version", valid_595742
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595743 = header.getOrDefault("X-Amz-Signature")
  valid_595743 = validateParameter(valid_595743, JString, required = false,
                                 default = nil)
  if valid_595743 != nil:
    section.add "X-Amz-Signature", valid_595743
  var valid_595744 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595744 = validateParameter(valid_595744, JString, required = false,
                                 default = nil)
  if valid_595744 != nil:
    section.add "X-Amz-Content-Sha256", valid_595744
  var valid_595745 = header.getOrDefault("X-Amz-Date")
  valid_595745 = validateParameter(valid_595745, JString, required = false,
                                 default = nil)
  if valid_595745 != nil:
    section.add "X-Amz-Date", valid_595745
  var valid_595746 = header.getOrDefault("X-Amz-Credential")
  valid_595746 = validateParameter(valid_595746, JString, required = false,
                                 default = nil)
  if valid_595746 != nil:
    section.add "X-Amz-Credential", valid_595746
  var valid_595747 = header.getOrDefault("X-Amz-Security-Token")
  valid_595747 = validateParameter(valid_595747, JString, required = false,
                                 default = nil)
  if valid_595747 != nil:
    section.add "X-Amz-Security-Token", valid_595747
  var valid_595748 = header.getOrDefault("X-Amz-Algorithm")
  valid_595748 = validateParameter(valid_595748, JString, required = false,
                                 default = nil)
  if valid_595748 != nil:
    section.add "X-Amz-Algorithm", valid_595748
  var valid_595749 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595749 = validateParameter(valid_595749, JString, required = false,
                                 default = nil)
  if valid_595749 != nil:
    section.add "X-Amz-SignedHeaders", valid_595749
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595750 = formData.getOrDefault("ClusterIdentifier")
  valid_595750 = validateParameter(valid_595750, JString, required = true,
                                 default = nil)
  if valid_595750 != nil:
    section.add "ClusterIdentifier", valid_595750
  var valid_595751 = formData.getOrDefault("RetentionPeriod")
  valid_595751 = validateParameter(valid_595751, JInt, required = true, default = nil)
  if valid_595751 != nil:
    section.add "RetentionPeriod", valid_595751
  var valid_595752 = formData.getOrDefault("Manual")
  valid_595752 = validateParameter(valid_595752, JBool, required = false, default = nil)
  if valid_595752 != nil:
    section.add "Manual", valid_595752
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595753: Call_PostModifySnapshotCopyRetentionPeriod_595738;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_595753.validator(path, query, header, formData, body)
  let scheme = call_595753.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595753.url(scheme.get, call_595753.host, call_595753.base,
                         call_595753.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595753, url, valid)

proc call*(call_595754: Call_PostModifySnapshotCopyRetentionPeriod_595738;
          ClusterIdentifier: string; RetentionPeriod: int;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Manual: bool = false; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  ##   Action: string (required)
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Version: string (required)
  var query_595755 = newJObject()
  var formData_595756 = newJObject()
  add(formData_595756, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_595756, "RetentionPeriod", newJInt(RetentionPeriod))
  add(query_595755, "Action", newJString(Action))
  add(formData_595756, "Manual", newJBool(Manual))
  add(query_595755, "Version", newJString(Version))
  result = call_595754.call(nil, query_595755, nil, formData_595756, nil)

var postModifySnapshotCopyRetentionPeriod* = Call_PostModifySnapshotCopyRetentionPeriod_595738(
    name: "postModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_PostModifySnapshotCopyRetentionPeriod_595739, base: "/",
    url: url_PostModifySnapshotCopyRetentionPeriod_595740,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotCopyRetentionPeriod_595720 = ref object of OpenApiRestCall_592348
proc url_GetModifySnapshotCopyRetentionPeriod_595722(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifySnapshotCopyRetentionPeriod_595721(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Manual: JBool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: JString (required)
  ##   RetentionPeriod: JInt (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  section = newJObject()
  var valid_595723 = query.getOrDefault("Manual")
  valid_595723 = validateParameter(valid_595723, JBool, required = false, default = nil)
  if valid_595723 != nil:
    section.add "Manual", valid_595723
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595724 = query.getOrDefault("Action")
  valid_595724 = validateParameter(valid_595724, JString, required = true, default = newJString(
      "ModifySnapshotCopyRetentionPeriod"))
  if valid_595724 != nil:
    section.add "Action", valid_595724
  var valid_595725 = query.getOrDefault("ClusterIdentifier")
  valid_595725 = validateParameter(valid_595725, JString, required = true,
                                 default = nil)
  if valid_595725 != nil:
    section.add "ClusterIdentifier", valid_595725
  var valid_595726 = query.getOrDefault("Version")
  valid_595726 = validateParameter(valid_595726, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595726 != nil:
    section.add "Version", valid_595726
  var valid_595727 = query.getOrDefault("RetentionPeriod")
  valid_595727 = validateParameter(valid_595727, JInt, required = true, default = nil)
  if valid_595727 != nil:
    section.add "RetentionPeriod", valid_595727
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595728 = header.getOrDefault("X-Amz-Signature")
  valid_595728 = validateParameter(valid_595728, JString, required = false,
                                 default = nil)
  if valid_595728 != nil:
    section.add "X-Amz-Signature", valid_595728
  var valid_595729 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595729 = validateParameter(valid_595729, JString, required = false,
                                 default = nil)
  if valid_595729 != nil:
    section.add "X-Amz-Content-Sha256", valid_595729
  var valid_595730 = header.getOrDefault("X-Amz-Date")
  valid_595730 = validateParameter(valid_595730, JString, required = false,
                                 default = nil)
  if valid_595730 != nil:
    section.add "X-Amz-Date", valid_595730
  var valid_595731 = header.getOrDefault("X-Amz-Credential")
  valid_595731 = validateParameter(valid_595731, JString, required = false,
                                 default = nil)
  if valid_595731 != nil:
    section.add "X-Amz-Credential", valid_595731
  var valid_595732 = header.getOrDefault("X-Amz-Security-Token")
  valid_595732 = validateParameter(valid_595732, JString, required = false,
                                 default = nil)
  if valid_595732 != nil:
    section.add "X-Amz-Security-Token", valid_595732
  var valid_595733 = header.getOrDefault("X-Amz-Algorithm")
  valid_595733 = validateParameter(valid_595733, JString, required = false,
                                 default = nil)
  if valid_595733 != nil:
    section.add "X-Amz-Algorithm", valid_595733
  var valid_595734 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595734 = validateParameter(valid_595734, JString, required = false,
                                 default = nil)
  if valid_595734 != nil:
    section.add "X-Amz-SignedHeaders", valid_595734
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595735: Call_GetModifySnapshotCopyRetentionPeriod_595720;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ## 
  let valid = call_595735.validator(path, query, header, formData, body)
  let scheme = call_595735.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595735.url(scheme.get, call_595735.host, call_595735.base,
                         call_595735.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595735, url, valid)

proc call*(call_595736: Call_GetModifySnapshotCopyRetentionPeriod_595720;
          ClusterIdentifier: string; RetentionPeriod: int; Manual: bool = false;
          Action: string = "ModifySnapshotCopyRetentionPeriod";
          Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotCopyRetentionPeriod
  ## Modifies the number of days to retain snapshots in the destination AWS Region after they are copied from the source AWS Region. By default, this operation only changes the retention period of copied automated snapshots. The retention periods for both new and existing copied automated snapshots are updated with the new retention period. You can set the manual option to change only the retention periods of copied manual snapshots. If you set this option, only newly copied manual snapshots have the new retention period. 
  ##   Manual: bool
  ##         : Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster for which you want to change the retention period for either automated or manual snapshots that are copied to a destination AWS Region.</p> <p>Constraints: Must be the valid name of an existing cluster that has cross-region snapshot copy enabled.</p>
  ##   Version: string (required)
  ##   RetentionPeriod: int (required)
  ##                  : <p>The number of days to retain automated snapshots in the destination AWS Region after they are copied from the source AWS Region.</p> <p>By default, this only changes the retention period of copied automated snapshots. </p> <p>If you decrease the retention period for automated snapshots that are copied to a destination AWS Region, Amazon Redshift deletes any existing automated snapshots that were copied to the destination AWS Region and that fall outside of the new retention period.</p> <p>Constraints: Must be at least 1 and no more than 35 for automated snapshots. </p> <p>If you specify the <code>manual</code> option, only newly copied manual snapshots will have the new retention period. </p> <p>If you specify the value of -1 newly copied manual snapshots are retained indefinitely.</p> <p>Constraints: The number of days must be either -1 or an integer between 1 and 3,653 for manual snapshots.</p>
  var query_595737 = newJObject()
  add(query_595737, "Manual", newJBool(Manual))
  add(query_595737, "Action", newJString(Action))
  add(query_595737, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595737, "Version", newJString(Version))
  add(query_595737, "RetentionPeriod", newJInt(RetentionPeriod))
  result = call_595736.call(nil, query_595737, nil, nil, nil)

var getModifySnapshotCopyRetentionPeriod* = Call_GetModifySnapshotCopyRetentionPeriod_595720(
    name: "getModifySnapshotCopyRetentionPeriod", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=ModifySnapshotCopyRetentionPeriod",
    validator: validate_GetModifySnapshotCopyRetentionPeriod_595721, base: "/",
    url: url_GetModifySnapshotCopyRetentionPeriod_595722,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostModifySnapshotSchedule_595774 = ref object of OpenApiRestCall_592348
proc url_PostModifySnapshotSchedule_595776(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostModifySnapshotSchedule_595775(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595777 = query.getOrDefault("Action")
  valid_595777 = validateParameter(valid_595777, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_595777 != nil:
    section.add "Action", valid_595777
  var valid_595778 = query.getOrDefault("Version")
  valid_595778 = validateParameter(valid_595778, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595778 != nil:
    section.add "Version", valid_595778
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595779 = header.getOrDefault("X-Amz-Signature")
  valid_595779 = validateParameter(valid_595779, JString, required = false,
                                 default = nil)
  if valid_595779 != nil:
    section.add "X-Amz-Signature", valid_595779
  var valid_595780 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595780 = validateParameter(valid_595780, JString, required = false,
                                 default = nil)
  if valid_595780 != nil:
    section.add "X-Amz-Content-Sha256", valid_595780
  var valid_595781 = header.getOrDefault("X-Amz-Date")
  valid_595781 = validateParameter(valid_595781, JString, required = false,
                                 default = nil)
  if valid_595781 != nil:
    section.add "X-Amz-Date", valid_595781
  var valid_595782 = header.getOrDefault("X-Amz-Credential")
  valid_595782 = validateParameter(valid_595782, JString, required = false,
                                 default = nil)
  if valid_595782 != nil:
    section.add "X-Amz-Credential", valid_595782
  var valid_595783 = header.getOrDefault("X-Amz-Security-Token")
  valid_595783 = validateParameter(valid_595783, JString, required = false,
                                 default = nil)
  if valid_595783 != nil:
    section.add "X-Amz-Security-Token", valid_595783
  var valid_595784 = header.getOrDefault("X-Amz-Algorithm")
  valid_595784 = validateParameter(valid_595784, JString, required = false,
                                 default = nil)
  if valid_595784 != nil:
    section.add "X-Amz-Algorithm", valid_595784
  var valid_595785 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595785 = validateParameter(valid_595785, JString, required = false,
                                 default = nil)
  if valid_595785 != nil:
    section.add "X-Amz-SignedHeaders", valid_595785
  result.add "header", section
  ## parameters in `formData` object:
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ScheduleDefinitions` field"
  var valid_595786 = formData.getOrDefault("ScheduleDefinitions")
  valid_595786 = validateParameter(valid_595786, JArray, required = true, default = nil)
  if valid_595786 != nil:
    section.add "ScheduleDefinitions", valid_595786
  var valid_595787 = formData.getOrDefault("ScheduleIdentifier")
  valid_595787 = validateParameter(valid_595787, JString, required = true,
                                 default = nil)
  if valid_595787 != nil:
    section.add "ScheduleIdentifier", valid_595787
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595788: Call_PostModifySnapshotSchedule_595774; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_595788.validator(path, query, header, formData, body)
  let scheme = call_595788.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595788.url(scheme.get, call_595788.host, call_595788.base,
                         call_595788.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595788, url, valid)

proc call*(call_595789: Call_PostModifySnapshotSchedule_595774;
          ScheduleDefinitions: JsonNode; ScheduleIdentifier: string;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## postModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   Version: string (required)
  var query_595790 = newJObject()
  var formData_595791 = newJObject()
  if ScheduleDefinitions != nil:
    formData_595791.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_595790, "Action", newJString(Action))
  add(formData_595791, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  add(query_595790, "Version", newJString(Version))
  result = call_595789.call(nil, query_595790, nil, formData_595791, nil)

var postModifySnapshotSchedule* = Call_PostModifySnapshotSchedule_595774(
    name: "postModifySnapshotSchedule", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_PostModifySnapshotSchedule_595775, base: "/",
    url: url_PostModifySnapshotSchedule_595776,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetModifySnapshotSchedule_595757 = ref object of OpenApiRestCall_592348
proc url_GetModifySnapshotSchedule_595759(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetModifySnapshotSchedule_595758(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ScheduleIdentifier: JString (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ScheduleIdentifier` field"
  var valid_595760 = query.getOrDefault("ScheduleIdentifier")
  valid_595760 = validateParameter(valid_595760, JString, required = true,
                                 default = nil)
  if valid_595760 != nil:
    section.add "ScheduleIdentifier", valid_595760
  var valid_595761 = query.getOrDefault("ScheduleDefinitions")
  valid_595761 = validateParameter(valid_595761, JArray, required = true, default = nil)
  if valid_595761 != nil:
    section.add "ScheduleDefinitions", valid_595761
  var valid_595762 = query.getOrDefault("Action")
  valid_595762 = validateParameter(valid_595762, JString, required = true,
                                 default = newJString("ModifySnapshotSchedule"))
  if valid_595762 != nil:
    section.add "Action", valid_595762
  var valid_595763 = query.getOrDefault("Version")
  valid_595763 = validateParameter(valid_595763, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595763 != nil:
    section.add "Version", valid_595763
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595764 = header.getOrDefault("X-Amz-Signature")
  valid_595764 = validateParameter(valid_595764, JString, required = false,
                                 default = nil)
  if valid_595764 != nil:
    section.add "X-Amz-Signature", valid_595764
  var valid_595765 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595765 = validateParameter(valid_595765, JString, required = false,
                                 default = nil)
  if valid_595765 != nil:
    section.add "X-Amz-Content-Sha256", valid_595765
  var valid_595766 = header.getOrDefault("X-Amz-Date")
  valid_595766 = validateParameter(valid_595766, JString, required = false,
                                 default = nil)
  if valid_595766 != nil:
    section.add "X-Amz-Date", valid_595766
  var valid_595767 = header.getOrDefault("X-Amz-Credential")
  valid_595767 = validateParameter(valid_595767, JString, required = false,
                                 default = nil)
  if valid_595767 != nil:
    section.add "X-Amz-Credential", valid_595767
  var valid_595768 = header.getOrDefault("X-Amz-Security-Token")
  valid_595768 = validateParameter(valid_595768, JString, required = false,
                                 default = nil)
  if valid_595768 != nil:
    section.add "X-Amz-Security-Token", valid_595768
  var valid_595769 = header.getOrDefault("X-Amz-Algorithm")
  valid_595769 = validateParameter(valid_595769, JString, required = false,
                                 default = nil)
  if valid_595769 != nil:
    section.add "X-Amz-Algorithm", valid_595769
  var valid_595770 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595770 = validateParameter(valid_595770, JString, required = false,
                                 default = nil)
  if valid_595770 != nil:
    section.add "X-Amz-SignedHeaders", valid_595770
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595771: Call_GetModifySnapshotSchedule_595757; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ## 
  let valid = call_595771.validator(path, query, header, formData, body)
  let scheme = call_595771.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595771.url(scheme.get, call_595771.host, call_595771.base,
                         call_595771.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595771, url, valid)

proc call*(call_595772: Call_GetModifySnapshotSchedule_595757;
          ScheduleIdentifier: string; ScheduleDefinitions: JsonNode;
          Action: string = "ModifySnapshotSchedule"; Version: string = "2012-12-01"): Recallable =
  ## getModifySnapshotSchedule
  ## Modifies a snapshot schedule. Any schedule associated with a cluster is modified asynchronously.
  ##   ScheduleIdentifier: string (required)
  ##                     : A unique alphanumeric identifier of the schedule to modify.
  ##   ScheduleDefinitions: JArray (required)
  ##                      : An updated list of schedule definitions. A schedule definition is made up of schedule expressions, for example, "cron(30 12 *)" or "rate(12 hours)".
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595773 = newJObject()
  add(query_595773, "ScheduleIdentifier", newJString(ScheduleIdentifier))
  if ScheduleDefinitions != nil:
    query_595773.add "ScheduleDefinitions", ScheduleDefinitions
  add(query_595773, "Action", newJString(Action))
  add(query_595773, "Version", newJString(Version))
  result = call_595772.call(nil, query_595773, nil, nil, nil)

var getModifySnapshotSchedule* = Call_GetModifySnapshotSchedule_595757(
    name: "getModifySnapshotSchedule", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ModifySnapshotSchedule",
    validator: validate_GetModifySnapshotSchedule_595758, base: "/",
    url: url_GetModifySnapshotSchedule_595759,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostPurchaseReservedNodeOffering_595809 = ref object of OpenApiRestCall_592348
proc url_PostPurchaseReservedNodeOffering_595811(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostPurchaseReservedNodeOffering_595810(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595812 = query.getOrDefault("Action")
  valid_595812 = validateParameter(valid_595812, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_595812 != nil:
    section.add "Action", valid_595812
  var valid_595813 = query.getOrDefault("Version")
  valid_595813 = validateParameter(valid_595813, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595813 != nil:
    section.add "Version", valid_595813
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595814 = header.getOrDefault("X-Amz-Signature")
  valid_595814 = validateParameter(valid_595814, JString, required = false,
                                 default = nil)
  if valid_595814 != nil:
    section.add "X-Amz-Signature", valid_595814
  var valid_595815 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595815 = validateParameter(valid_595815, JString, required = false,
                                 default = nil)
  if valid_595815 != nil:
    section.add "X-Amz-Content-Sha256", valid_595815
  var valid_595816 = header.getOrDefault("X-Amz-Date")
  valid_595816 = validateParameter(valid_595816, JString, required = false,
                                 default = nil)
  if valid_595816 != nil:
    section.add "X-Amz-Date", valid_595816
  var valid_595817 = header.getOrDefault("X-Amz-Credential")
  valid_595817 = validateParameter(valid_595817, JString, required = false,
                                 default = nil)
  if valid_595817 != nil:
    section.add "X-Amz-Credential", valid_595817
  var valid_595818 = header.getOrDefault("X-Amz-Security-Token")
  valid_595818 = validateParameter(valid_595818, JString, required = false,
                                 default = nil)
  if valid_595818 != nil:
    section.add "X-Amz-Security-Token", valid_595818
  var valid_595819 = header.getOrDefault("X-Amz-Algorithm")
  valid_595819 = validateParameter(valid_595819, JString, required = false,
                                 default = nil)
  if valid_595819 != nil:
    section.add "X-Amz-Algorithm", valid_595819
  var valid_595820 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595820 = validateParameter(valid_595820, JString, required = false,
                                 default = nil)
  if valid_595820 != nil:
    section.add "X-Amz-SignedHeaders", valid_595820
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  section = newJObject()
  var valid_595821 = formData.getOrDefault("NodeCount")
  valid_595821 = validateParameter(valid_595821, JInt, required = false, default = nil)
  if valid_595821 != nil:
    section.add "NodeCount", valid_595821
  assert formData != nil, "formData argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_595822 = formData.getOrDefault("ReservedNodeOfferingId")
  valid_595822 = validateParameter(valid_595822, JString, required = true,
                                 default = nil)
  if valid_595822 != nil:
    section.add "ReservedNodeOfferingId", valid_595822
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595823: Call_PostPurchaseReservedNodeOffering_595809;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_595823.validator(path, query, header, formData, body)
  let scheme = call_595823.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595823.url(scheme.get, call_595823.host, call_595823.base,
                         call_595823.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595823, url, valid)

proc call*(call_595824: Call_PostPurchaseReservedNodeOffering_595809;
          ReservedNodeOfferingId: string; NodeCount: int = 0;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"): Recallable =
  ## postPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595825 = newJObject()
  var formData_595826 = newJObject()
  add(formData_595826, "NodeCount", newJInt(NodeCount))
  add(formData_595826, "ReservedNodeOfferingId",
      newJString(ReservedNodeOfferingId))
  add(query_595825, "Action", newJString(Action))
  add(query_595825, "Version", newJString(Version))
  result = call_595824.call(nil, query_595825, nil, formData_595826, nil)

var postPurchaseReservedNodeOffering* = Call_PostPurchaseReservedNodeOffering_595809(
    name: "postPurchaseReservedNodeOffering", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_PostPurchaseReservedNodeOffering_595810, base: "/",
    url: url_PostPurchaseReservedNodeOffering_595811,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetPurchaseReservedNodeOffering_595792 = ref object of OpenApiRestCall_592348
proc url_GetPurchaseReservedNodeOffering_595794(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetPurchaseReservedNodeOffering_595793(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ReservedNodeOfferingId: JString (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   NodeCount: JInt
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `ReservedNodeOfferingId` field"
  var valid_595795 = query.getOrDefault("ReservedNodeOfferingId")
  valid_595795 = validateParameter(valid_595795, JString, required = true,
                                 default = nil)
  if valid_595795 != nil:
    section.add "ReservedNodeOfferingId", valid_595795
  var valid_595796 = query.getOrDefault("Action")
  valid_595796 = validateParameter(valid_595796, JString, required = true, default = newJString(
      "PurchaseReservedNodeOffering"))
  if valid_595796 != nil:
    section.add "Action", valid_595796
  var valid_595797 = query.getOrDefault("Version")
  valid_595797 = validateParameter(valid_595797, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595797 != nil:
    section.add "Version", valid_595797
  var valid_595798 = query.getOrDefault("NodeCount")
  valid_595798 = validateParameter(valid_595798, JInt, required = false, default = nil)
  if valid_595798 != nil:
    section.add "NodeCount", valid_595798
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595799 = header.getOrDefault("X-Amz-Signature")
  valid_595799 = validateParameter(valid_595799, JString, required = false,
                                 default = nil)
  if valid_595799 != nil:
    section.add "X-Amz-Signature", valid_595799
  var valid_595800 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595800 = validateParameter(valid_595800, JString, required = false,
                                 default = nil)
  if valid_595800 != nil:
    section.add "X-Amz-Content-Sha256", valid_595800
  var valid_595801 = header.getOrDefault("X-Amz-Date")
  valid_595801 = validateParameter(valid_595801, JString, required = false,
                                 default = nil)
  if valid_595801 != nil:
    section.add "X-Amz-Date", valid_595801
  var valid_595802 = header.getOrDefault("X-Amz-Credential")
  valid_595802 = validateParameter(valid_595802, JString, required = false,
                                 default = nil)
  if valid_595802 != nil:
    section.add "X-Amz-Credential", valid_595802
  var valid_595803 = header.getOrDefault("X-Amz-Security-Token")
  valid_595803 = validateParameter(valid_595803, JString, required = false,
                                 default = nil)
  if valid_595803 != nil:
    section.add "X-Amz-Security-Token", valid_595803
  var valid_595804 = header.getOrDefault("X-Amz-Algorithm")
  valid_595804 = validateParameter(valid_595804, JString, required = false,
                                 default = nil)
  if valid_595804 != nil:
    section.add "X-Amz-Algorithm", valid_595804
  var valid_595805 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595805 = validateParameter(valid_595805, JString, required = false,
                                 default = nil)
  if valid_595805 != nil:
    section.add "X-Amz-SignedHeaders", valid_595805
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595806: Call_GetPurchaseReservedNodeOffering_595792;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_595806.validator(path, query, header, formData, body)
  let scheme = call_595806.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595806.url(scheme.get, call_595806.host, call_595806.base,
                         call_595806.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595806, url, valid)

proc call*(call_595807: Call_GetPurchaseReservedNodeOffering_595792;
          ReservedNodeOfferingId: string;
          Action: string = "PurchaseReservedNodeOffering";
          Version: string = "2012-12-01"; NodeCount: int = 0): Recallable =
  ## getPurchaseReservedNodeOffering
  ## <p>Allows you to purchase reserved nodes. Amazon Redshift offers a predefined set of reserved node offerings. You can purchase one or more of the offerings. You can call the <a>DescribeReservedNodeOfferings</a> API to obtain the available reserved node offerings. You can call this API by providing a specific reserved node offering and the number of nodes you want to reserve. </p> <p> For more information about reserved node offerings, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/purchase-reserved-node-instance.html">Purchasing Reserved Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ReservedNodeOfferingId: string (required)
  ##                         : The unique identifier of the reserved node offering you want to purchase.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   NodeCount: int
  ##            : <p>The number of reserved nodes that you want to purchase.</p> <p>Default: <code>1</code> </p>
  var query_595808 = newJObject()
  add(query_595808, "ReservedNodeOfferingId", newJString(ReservedNodeOfferingId))
  add(query_595808, "Action", newJString(Action))
  add(query_595808, "Version", newJString(Version))
  add(query_595808, "NodeCount", newJInt(NodeCount))
  result = call_595807.call(nil, query_595808, nil, nil, nil)

var getPurchaseReservedNodeOffering* = Call_GetPurchaseReservedNodeOffering_595792(
    name: "getPurchaseReservedNodeOffering", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=PurchaseReservedNodeOffering",
    validator: validate_GetPurchaseReservedNodeOffering_595793, base: "/",
    url: url_GetPurchaseReservedNodeOffering_595794,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRebootCluster_595843 = ref object of OpenApiRestCall_592348
proc url_PostRebootCluster_595845(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRebootCluster_595844(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595846 = query.getOrDefault("Action")
  valid_595846 = validateParameter(valid_595846, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_595846 != nil:
    section.add "Action", valid_595846
  var valid_595847 = query.getOrDefault("Version")
  valid_595847 = validateParameter(valid_595847, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595847 != nil:
    section.add "Version", valid_595847
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595848 = header.getOrDefault("X-Amz-Signature")
  valid_595848 = validateParameter(valid_595848, JString, required = false,
                                 default = nil)
  if valid_595848 != nil:
    section.add "X-Amz-Signature", valid_595848
  var valid_595849 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595849 = validateParameter(valid_595849, JString, required = false,
                                 default = nil)
  if valid_595849 != nil:
    section.add "X-Amz-Content-Sha256", valid_595849
  var valid_595850 = header.getOrDefault("X-Amz-Date")
  valid_595850 = validateParameter(valid_595850, JString, required = false,
                                 default = nil)
  if valid_595850 != nil:
    section.add "X-Amz-Date", valid_595850
  var valid_595851 = header.getOrDefault("X-Amz-Credential")
  valid_595851 = validateParameter(valid_595851, JString, required = false,
                                 default = nil)
  if valid_595851 != nil:
    section.add "X-Amz-Credential", valid_595851
  var valid_595852 = header.getOrDefault("X-Amz-Security-Token")
  valid_595852 = validateParameter(valid_595852, JString, required = false,
                                 default = nil)
  if valid_595852 != nil:
    section.add "X-Amz-Security-Token", valid_595852
  var valid_595853 = header.getOrDefault("X-Amz-Algorithm")
  valid_595853 = validateParameter(valid_595853, JString, required = false,
                                 default = nil)
  if valid_595853 != nil:
    section.add "X-Amz-Algorithm", valid_595853
  var valid_595854 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595854 = validateParameter(valid_595854, JString, required = false,
                                 default = nil)
  if valid_595854 != nil:
    section.add "X-Amz-SignedHeaders", valid_595854
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595855 = formData.getOrDefault("ClusterIdentifier")
  valid_595855 = validateParameter(valid_595855, JString, required = true,
                                 default = nil)
  if valid_595855 != nil:
    section.add "ClusterIdentifier", valid_595855
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595856: Call_PostRebootCluster_595843; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_595856.validator(path, query, header, formData, body)
  let scheme = call_595856.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595856.url(scheme.get, call_595856.host, call_595856.base,
                         call_595856.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595856, url, valid)

proc call*(call_595857: Call_PostRebootCluster_595843; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## postRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Action: string (required)
  ##   Version: string (required)
  var query_595858 = newJObject()
  var formData_595859 = newJObject()
  add(formData_595859, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595858, "Action", newJString(Action))
  add(query_595858, "Version", newJString(Version))
  result = call_595857.call(nil, query_595858, nil, formData_595859, nil)

var postRebootCluster* = Call_PostRebootCluster_595843(name: "postRebootCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_PostRebootCluster_595844,
    base: "/", url: url_PostRebootCluster_595845,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRebootCluster_595827 = ref object of OpenApiRestCall_592348
proc url_GetRebootCluster_595829(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRebootCluster_595828(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The cluster identifier.
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595830 = query.getOrDefault("Action")
  valid_595830 = validateParameter(valid_595830, JString, required = true,
                                 default = newJString("RebootCluster"))
  if valid_595830 != nil:
    section.add "Action", valid_595830
  var valid_595831 = query.getOrDefault("ClusterIdentifier")
  valid_595831 = validateParameter(valid_595831, JString, required = true,
                                 default = nil)
  if valid_595831 != nil:
    section.add "ClusterIdentifier", valid_595831
  var valid_595832 = query.getOrDefault("Version")
  valid_595832 = validateParameter(valid_595832, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595832 != nil:
    section.add "Version", valid_595832
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595833 = header.getOrDefault("X-Amz-Signature")
  valid_595833 = validateParameter(valid_595833, JString, required = false,
                                 default = nil)
  if valid_595833 != nil:
    section.add "X-Amz-Signature", valid_595833
  var valid_595834 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595834 = validateParameter(valid_595834, JString, required = false,
                                 default = nil)
  if valid_595834 != nil:
    section.add "X-Amz-Content-Sha256", valid_595834
  var valid_595835 = header.getOrDefault("X-Amz-Date")
  valid_595835 = validateParameter(valid_595835, JString, required = false,
                                 default = nil)
  if valid_595835 != nil:
    section.add "X-Amz-Date", valid_595835
  var valid_595836 = header.getOrDefault("X-Amz-Credential")
  valid_595836 = validateParameter(valid_595836, JString, required = false,
                                 default = nil)
  if valid_595836 != nil:
    section.add "X-Amz-Credential", valid_595836
  var valid_595837 = header.getOrDefault("X-Amz-Security-Token")
  valid_595837 = validateParameter(valid_595837, JString, required = false,
                                 default = nil)
  if valid_595837 != nil:
    section.add "X-Amz-Security-Token", valid_595837
  var valid_595838 = header.getOrDefault("X-Amz-Algorithm")
  valid_595838 = validateParameter(valid_595838, JString, required = false,
                                 default = nil)
  if valid_595838 != nil:
    section.add "X-Amz-Algorithm", valid_595838
  var valid_595839 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595839 = validateParameter(valid_595839, JString, required = false,
                                 default = nil)
  if valid_595839 != nil:
    section.add "X-Amz-SignedHeaders", valid_595839
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595840: Call_GetRebootCluster_595827; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_595840.validator(path, query, header, formData, body)
  let scheme = call_595840.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595840.url(scheme.get, call_595840.host, call_595840.base,
                         call_595840.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595840, url, valid)

proc call*(call_595841: Call_GetRebootCluster_595827; ClusterIdentifier: string;
          Action: string = "RebootCluster"; Version: string = "2012-12-01"): Recallable =
  ## getRebootCluster
  ## Reboots a cluster. This action is taken as soon as possible. It results in a momentary outage to the cluster, during which the cluster status is set to <code>rebooting</code>. A cluster event is created when the reboot is completed. Any pending cluster modifications (see <a>ModifyCluster</a>) are applied at this reboot. For more information about managing clusters, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html">Amazon Redshift Clusters</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The cluster identifier.
  ##   Version: string (required)
  var query_595842 = newJObject()
  add(query_595842, "Action", newJString(Action))
  add(query_595842, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595842, "Version", newJString(Version))
  result = call_595841.call(nil, query_595842, nil, nil, nil)

var getRebootCluster* = Call_GetRebootCluster_595827(name: "getRebootCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=RebootCluster", validator: validate_GetRebootCluster_595828,
    base: "/", url: url_GetRebootCluster_595829,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResetClusterParameterGroup_595878 = ref object of OpenApiRestCall_592348
proc url_PostResetClusterParameterGroup_595880(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostResetClusterParameterGroup_595879(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595881 = query.getOrDefault("Action")
  valid_595881 = validateParameter(valid_595881, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_595881 != nil:
    section.add "Action", valid_595881
  var valid_595882 = query.getOrDefault("Version")
  valid_595882 = validateParameter(valid_595882, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595882 != nil:
    section.add "Version", valid_595882
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595883 = header.getOrDefault("X-Amz-Signature")
  valid_595883 = validateParameter(valid_595883, JString, required = false,
                                 default = nil)
  if valid_595883 != nil:
    section.add "X-Amz-Signature", valid_595883
  var valid_595884 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595884 = validateParameter(valid_595884, JString, required = false,
                                 default = nil)
  if valid_595884 != nil:
    section.add "X-Amz-Content-Sha256", valid_595884
  var valid_595885 = header.getOrDefault("X-Amz-Date")
  valid_595885 = validateParameter(valid_595885, JString, required = false,
                                 default = nil)
  if valid_595885 != nil:
    section.add "X-Amz-Date", valid_595885
  var valid_595886 = header.getOrDefault("X-Amz-Credential")
  valid_595886 = validateParameter(valid_595886, JString, required = false,
                                 default = nil)
  if valid_595886 != nil:
    section.add "X-Amz-Credential", valid_595886
  var valid_595887 = header.getOrDefault("X-Amz-Security-Token")
  valid_595887 = validateParameter(valid_595887, JString, required = false,
                                 default = nil)
  if valid_595887 != nil:
    section.add "X-Amz-Security-Token", valid_595887
  var valid_595888 = header.getOrDefault("X-Amz-Algorithm")
  valid_595888 = validateParameter(valid_595888, JString, required = false,
                                 default = nil)
  if valid_595888 != nil:
    section.add "X-Amz-Algorithm", valid_595888
  var valid_595889 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595889 = validateParameter(valid_595889, JString, required = false,
                                 default = nil)
  if valid_595889 != nil:
    section.add "X-Amz-SignedHeaders", valid_595889
  result.add "header", section
  ## parameters in `formData` object:
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  section = newJObject()
  var valid_595890 = formData.getOrDefault("ResetAllParameters")
  valid_595890 = validateParameter(valid_595890, JBool, required = false, default = nil)
  if valid_595890 != nil:
    section.add "ResetAllParameters", valid_595890
  var valid_595891 = formData.getOrDefault("Parameters")
  valid_595891 = validateParameter(valid_595891, JArray, required = false,
                                 default = nil)
  if valid_595891 != nil:
    section.add "Parameters", valid_595891
  assert formData != nil, "formData argument is necessary due to required `ParameterGroupName` field"
  var valid_595892 = formData.getOrDefault("ParameterGroupName")
  valid_595892 = validateParameter(valid_595892, JString, required = true,
                                 default = nil)
  if valid_595892 != nil:
    section.add "ParameterGroupName", valid_595892
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595893: Call_PostResetClusterParameterGroup_595878; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_595893.validator(path, query, header, formData, body)
  let scheme = call_595893.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595893.url(scheme.get, call_595893.host, call_595893.base,
                         call_595893.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595893, url, valid)

proc call*(call_595894: Call_PostResetClusterParameterGroup_595878;
          ParameterGroupName: string; ResetAllParameters: bool = false;
          Action: string = "ResetClusterParameterGroup"; Parameters: JsonNode = nil;
          Version: string = "2012-12-01"): Recallable =
  ## postResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: string (required)
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: string (required)
  var query_595895 = newJObject()
  var formData_595896 = newJObject()
  add(formData_595896, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_595895, "Action", newJString(Action))
  if Parameters != nil:
    formData_595896.add "Parameters", Parameters
  add(formData_595896, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_595895, "Version", newJString(Version))
  result = call_595894.call(nil, query_595895, nil, formData_595896, nil)

var postResetClusterParameterGroup* = Call_PostResetClusterParameterGroup_595878(
    name: "postResetClusterParameterGroup", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_PostResetClusterParameterGroup_595879, base: "/",
    url: url_PostResetClusterParameterGroup_595880,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResetClusterParameterGroup_595860 = ref object of OpenApiRestCall_592348
proc url_GetResetClusterParameterGroup_595862(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetResetClusterParameterGroup_595861(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: JBool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: JString (required)
  ##   ParameterGroupName: JString (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595863 = query.getOrDefault("Parameters")
  valid_595863 = validateParameter(valid_595863, JArray, required = false,
                                 default = nil)
  if valid_595863 != nil:
    section.add "Parameters", valid_595863
  var valid_595864 = query.getOrDefault("ResetAllParameters")
  valid_595864 = validateParameter(valid_595864, JBool, required = false, default = nil)
  if valid_595864 != nil:
    section.add "ResetAllParameters", valid_595864
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595865 = query.getOrDefault("Action")
  valid_595865 = validateParameter(valid_595865, JString, required = true, default = newJString(
      "ResetClusterParameterGroup"))
  if valid_595865 != nil:
    section.add "Action", valid_595865
  var valid_595866 = query.getOrDefault("ParameterGroupName")
  valid_595866 = validateParameter(valid_595866, JString, required = true,
                                 default = nil)
  if valid_595866 != nil:
    section.add "ParameterGroupName", valid_595866
  var valid_595867 = query.getOrDefault("Version")
  valid_595867 = validateParameter(valid_595867, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595867 != nil:
    section.add "Version", valid_595867
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595868 = header.getOrDefault("X-Amz-Signature")
  valid_595868 = validateParameter(valid_595868, JString, required = false,
                                 default = nil)
  if valid_595868 != nil:
    section.add "X-Amz-Signature", valid_595868
  var valid_595869 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595869 = validateParameter(valid_595869, JString, required = false,
                                 default = nil)
  if valid_595869 != nil:
    section.add "X-Amz-Content-Sha256", valid_595869
  var valid_595870 = header.getOrDefault("X-Amz-Date")
  valid_595870 = validateParameter(valid_595870, JString, required = false,
                                 default = nil)
  if valid_595870 != nil:
    section.add "X-Amz-Date", valid_595870
  var valid_595871 = header.getOrDefault("X-Amz-Credential")
  valid_595871 = validateParameter(valid_595871, JString, required = false,
                                 default = nil)
  if valid_595871 != nil:
    section.add "X-Amz-Credential", valid_595871
  var valid_595872 = header.getOrDefault("X-Amz-Security-Token")
  valid_595872 = validateParameter(valid_595872, JString, required = false,
                                 default = nil)
  if valid_595872 != nil:
    section.add "X-Amz-Security-Token", valid_595872
  var valid_595873 = header.getOrDefault("X-Amz-Algorithm")
  valid_595873 = validateParameter(valid_595873, JString, required = false,
                                 default = nil)
  if valid_595873 != nil:
    section.add "X-Amz-Algorithm", valid_595873
  var valid_595874 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595874 = validateParameter(valid_595874, JString, required = false,
                                 default = nil)
  if valid_595874 != nil:
    section.add "X-Amz-SignedHeaders", valid_595874
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595875: Call_GetResetClusterParameterGroup_595860; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ## 
  let valid = call_595875.validator(path, query, header, formData, body)
  let scheme = call_595875.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595875.url(scheme.get, call_595875.host, call_595875.base,
                         call_595875.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595875, url, valid)

proc call*(call_595876: Call_GetResetClusterParameterGroup_595860;
          ParameterGroupName: string; Parameters: JsonNode = nil;
          ResetAllParameters: bool = false;
          Action: string = "ResetClusterParameterGroup";
          Version: string = "2012-12-01"): Recallable =
  ## getResetClusterParameterGroup
  ## Sets one or more parameters of the specified parameter group to their default values and sets the source values of the parameters to "engine-default". To reset the entire parameter group specify the <i>ResetAllParameters</i> parameter. For parameter changes to take effect you must reboot any associated clusters. 
  ##   Parameters: JArray
  ##             : <p>An array of names of parameters to be reset. If <i>ResetAllParameters</i> option is not used, then at least one parameter name must be supplied. </p> <p>Constraints: A maximum of 20 parameters can be reset in a single request.</p>
  ##   ResetAllParameters: bool
  ##                     : <p>If <code>true</code>, all parameters in the specified parameter group will be reset to their default values. </p> <p>Default: <code>true</code> </p>
  ##   Action: string (required)
  ##   ParameterGroupName: string (required)
  ##                     : The name of the cluster parameter group to be reset.
  ##   Version: string (required)
  var query_595877 = newJObject()
  if Parameters != nil:
    query_595877.add "Parameters", Parameters
  add(query_595877, "ResetAllParameters", newJBool(ResetAllParameters))
  add(query_595877, "Action", newJString(Action))
  add(query_595877, "ParameterGroupName", newJString(ParameterGroupName))
  add(query_595877, "Version", newJString(Version))
  result = call_595876.call(nil, query_595877, nil, nil, nil)

var getResetClusterParameterGroup* = Call_GetResetClusterParameterGroup_595860(
    name: "getResetClusterParameterGroup", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=ResetClusterParameterGroup",
    validator: validate_GetResetClusterParameterGroup_595861, base: "/",
    url: url_GetResetClusterParameterGroup_595862,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostResizeCluster_595917 = ref object of OpenApiRestCall_592348
proc url_PostResizeCluster_595919(protocol: Scheme; host: string; base: string;
                                 route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostResizeCluster_595918(path: JsonNode; query: JsonNode;
                                      header: JsonNode; formData: JsonNode;
                                      body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595920 = query.getOrDefault("Action")
  valid_595920 = validateParameter(valid_595920, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_595920 != nil:
    section.add "Action", valid_595920
  var valid_595921 = query.getOrDefault("Version")
  valid_595921 = validateParameter(valid_595921, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595921 != nil:
    section.add "Version", valid_595921
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595922 = header.getOrDefault("X-Amz-Signature")
  valid_595922 = validateParameter(valid_595922, JString, required = false,
                                 default = nil)
  if valid_595922 != nil:
    section.add "X-Amz-Signature", valid_595922
  var valid_595923 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595923 = validateParameter(valid_595923, JString, required = false,
                                 default = nil)
  if valid_595923 != nil:
    section.add "X-Amz-Content-Sha256", valid_595923
  var valid_595924 = header.getOrDefault("X-Amz-Date")
  valid_595924 = validateParameter(valid_595924, JString, required = false,
                                 default = nil)
  if valid_595924 != nil:
    section.add "X-Amz-Date", valid_595924
  var valid_595925 = header.getOrDefault("X-Amz-Credential")
  valid_595925 = validateParameter(valid_595925, JString, required = false,
                                 default = nil)
  if valid_595925 != nil:
    section.add "X-Amz-Credential", valid_595925
  var valid_595926 = header.getOrDefault("X-Amz-Security-Token")
  valid_595926 = validateParameter(valid_595926, JString, required = false,
                                 default = nil)
  if valid_595926 != nil:
    section.add "X-Amz-Security-Token", valid_595926
  var valid_595927 = header.getOrDefault("X-Amz-Algorithm")
  valid_595927 = validateParameter(valid_595927, JString, required = false,
                                 default = nil)
  if valid_595927 != nil:
    section.add "X-Amz-Algorithm", valid_595927
  var valid_595928 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595928 = validateParameter(valid_595928, JString, required = false,
                                 default = nil)
  if valid_595928 != nil:
    section.add "X-Amz-SignedHeaders", valid_595928
  result.add "header", section
  ## parameters in `formData` object:
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  section = newJObject()
  var valid_595929 = formData.getOrDefault("NodeType")
  valid_595929 = validateParameter(valid_595929, JString, required = false,
                                 default = nil)
  if valid_595929 != nil:
    section.add "NodeType", valid_595929
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595930 = formData.getOrDefault("ClusterIdentifier")
  valid_595930 = validateParameter(valid_595930, JString, required = true,
                                 default = nil)
  if valid_595930 != nil:
    section.add "ClusterIdentifier", valid_595930
  var valid_595931 = formData.getOrDefault("NumberOfNodes")
  valid_595931 = validateParameter(valid_595931, JInt, required = true, default = nil)
  if valid_595931 != nil:
    section.add "NumberOfNodes", valid_595931
  var valid_595932 = formData.getOrDefault("ClusterType")
  valid_595932 = validateParameter(valid_595932, JString, required = false,
                                 default = nil)
  if valid_595932 != nil:
    section.add "ClusterType", valid_595932
  var valid_595933 = formData.getOrDefault("Classic")
  valid_595933 = validateParameter(valid_595933, JBool, required = false, default = nil)
  if valid_595933 != nil:
    section.add "Classic", valid_595933
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595934: Call_PostResizeCluster_595917; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_595934.validator(path, query, header, formData, body)
  let scheme = call_595934.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595934.url(scheme.get, call_595934.host, call_595934.base,
                         call_595934.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595934, url, valid)

proc call*(call_595935: Call_PostResizeCluster_595917; ClusterIdentifier: string;
          NumberOfNodes: int; NodeType: string = ""; Action: string = "ResizeCluster";
          ClusterType: string = ""; Version: string = "2012-12-01";
          Classic: bool = false): Recallable =
  ## postResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Action: string (required)
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   Version: string (required)
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  var query_595936 = newJObject()
  var formData_595937 = newJObject()
  add(formData_595937, "NodeType", newJString(NodeType))
  add(formData_595937, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_595937, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_595936, "Action", newJString(Action))
  add(formData_595937, "ClusterType", newJString(ClusterType))
  add(query_595936, "Version", newJString(Version))
  add(formData_595937, "Classic", newJBool(Classic))
  result = call_595935.call(nil, query_595936, nil, formData_595937, nil)

var postResizeCluster* = Call_PostResizeCluster_595917(name: "postResizeCluster",
    meth: HttpMethod.HttpPost, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_PostResizeCluster_595918,
    base: "/", url: url_PostResizeCluster_595919,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetResizeCluster_595897 = ref object of OpenApiRestCall_592348
proc url_GetResizeCluster_595899(protocol: Scheme; host: string; base: string;
                                route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetResizeCluster_595898(path: JsonNode; query: JsonNode;
                                     header: JsonNode; formData: JsonNode;
                                     body: JsonNode): JsonNode =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   NodeType: JString
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterType: JString
  ##              : The new cluster type for the specified cluster.
  ##   NumberOfNodes: JInt (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: JBool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Version: JString (required)
  section = newJObject()
  var valid_595900 = query.getOrDefault("NodeType")
  valid_595900 = validateParameter(valid_595900, JString, required = false,
                                 default = nil)
  if valid_595900 != nil:
    section.add "NodeType", valid_595900
  var valid_595901 = query.getOrDefault("ClusterType")
  valid_595901 = validateParameter(valid_595901, JString, required = false,
                                 default = nil)
  if valid_595901 != nil:
    section.add "ClusterType", valid_595901
  assert query != nil,
        "query argument is necessary due to required `NumberOfNodes` field"
  var valid_595902 = query.getOrDefault("NumberOfNodes")
  valid_595902 = validateParameter(valid_595902, JInt, required = true, default = nil)
  if valid_595902 != nil:
    section.add "NumberOfNodes", valid_595902
  var valid_595903 = query.getOrDefault("Classic")
  valid_595903 = validateParameter(valid_595903, JBool, required = false, default = nil)
  if valid_595903 != nil:
    section.add "Classic", valid_595903
  var valid_595904 = query.getOrDefault("Action")
  valid_595904 = validateParameter(valid_595904, JString, required = true,
                                 default = newJString("ResizeCluster"))
  if valid_595904 != nil:
    section.add "Action", valid_595904
  var valid_595905 = query.getOrDefault("ClusterIdentifier")
  valid_595905 = validateParameter(valid_595905, JString, required = true,
                                 default = nil)
  if valid_595905 != nil:
    section.add "ClusterIdentifier", valid_595905
  var valid_595906 = query.getOrDefault("Version")
  valid_595906 = validateParameter(valid_595906, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595906 != nil:
    section.add "Version", valid_595906
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595907 = header.getOrDefault("X-Amz-Signature")
  valid_595907 = validateParameter(valid_595907, JString, required = false,
                                 default = nil)
  if valid_595907 != nil:
    section.add "X-Amz-Signature", valid_595907
  var valid_595908 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595908 = validateParameter(valid_595908, JString, required = false,
                                 default = nil)
  if valid_595908 != nil:
    section.add "X-Amz-Content-Sha256", valid_595908
  var valid_595909 = header.getOrDefault("X-Amz-Date")
  valid_595909 = validateParameter(valid_595909, JString, required = false,
                                 default = nil)
  if valid_595909 != nil:
    section.add "X-Amz-Date", valid_595909
  var valid_595910 = header.getOrDefault("X-Amz-Credential")
  valid_595910 = validateParameter(valid_595910, JString, required = false,
                                 default = nil)
  if valid_595910 != nil:
    section.add "X-Amz-Credential", valid_595910
  var valid_595911 = header.getOrDefault("X-Amz-Security-Token")
  valid_595911 = validateParameter(valid_595911, JString, required = false,
                                 default = nil)
  if valid_595911 != nil:
    section.add "X-Amz-Security-Token", valid_595911
  var valid_595912 = header.getOrDefault("X-Amz-Algorithm")
  valid_595912 = validateParameter(valid_595912, JString, required = false,
                                 default = nil)
  if valid_595912 != nil:
    section.add "X-Amz-Algorithm", valid_595912
  var valid_595913 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595913 = validateParameter(valid_595913, JString, required = false,
                                 default = nil)
  if valid_595913 != nil:
    section.add "X-Amz-SignedHeaders", valid_595913
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595914: Call_GetResizeCluster_595897; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ## 
  let valid = call_595914.validator(path, query, header, formData, body)
  let scheme = call_595914.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595914.url(scheme.get, call_595914.host, call_595914.base,
                         call_595914.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595914, url, valid)

proc call*(call_595915: Call_GetResizeCluster_595897; NumberOfNodes: int;
          ClusterIdentifier: string; NodeType: string = ""; ClusterType: string = "";
          Classic: bool = false; Action: string = "ResizeCluster";
          Version: string = "2012-12-01"): Recallable =
  ## getResizeCluster
  ## <p>Changes the size of the cluster. You can change the cluster's type, or change the number or type of nodes. The default behavior is to use the elastic resize method. With an elastic resize, your cluster is available for read and write operations more quickly than with the classic resize method. </p> <p>Elastic resize operations have the following restrictions:</p> <ul> <li> <p>You can only resize clusters of the following types:</p> <ul> <li> <p>dc2.large</p> </li> <li> <p>dc2.8xlarge</p> </li> <li> <p>ds2.xlarge</p> </li> <li> <p>ds2.8xlarge</p> </li> </ul> </li> <li> <p>The type of nodes that you add must match the node type for the cluster.</p> </li> </ul>
  ##   NodeType: string
  ##           : The new node type for the nodes you are adding. If not specified, the cluster's current node type is used.
  ##   ClusterType: string
  ##              : The new cluster type for the specified cluster.
  ##   NumberOfNodes: int (required)
  ##                : The new number of nodes for the cluster.
  ##   Classic: bool
  ##          : A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to <code>false</code>, the resize type is elastic. 
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The unique identifier for the cluster to resize.
  ##   Version: string (required)
  var query_595916 = newJObject()
  add(query_595916, "NodeType", newJString(NodeType))
  add(query_595916, "ClusterType", newJString(ClusterType))
  add(query_595916, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_595916, "Classic", newJBool(Classic))
  add(query_595916, "Action", newJString(Action))
  add(query_595916, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595916, "Version", newJString(Version))
  result = call_595915.call(nil, query_595916, nil, nil, nil)

var getResizeCluster* = Call_GetResizeCluster_595897(name: "getResizeCluster",
    meth: HttpMethod.HttpGet, host: "redshift.amazonaws.com",
    route: "/#Action=ResizeCluster", validator: validate_GetResizeCluster_595898,
    base: "/", url: url_GetResizeCluster_595899,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreFromClusterSnapshot_595979 = ref object of OpenApiRestCall_592348
proc url_PostRestoreFromClusterSnapshot_595981(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRestoreFromClusterSnapshot_595980(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_595982 = query.getOrDefault("Action")
  valid_595982 = validateParameter(valid_595982, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_595982 != nil:
    section.add "Action", valid_595982
  var valid_595983 = query.getOrDefault("Version")
  valid_595983 = validateParameter(valid_595983, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595983 != nil:
    section.add "Version", valid_595983
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595984 = header.getOrDefault("X-Amz-Signature")
  valid_595984 = validateParameter(valid_595984, JString, required = false,
                                 default = nil)
  if valid_595984 != nil:
    section.add "X-Amz-Signature", valid_595984
  var valid_595985 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595985 = validateParameter(valid_595985, JString, required = false,
                                 default = nil)
  if valid_595985 != nil:
    section.add "X-Amz-Content-Sha256", valid_595985
  var valid_595986 = header.getOrDefault("X-Amz-Date")
  valid_595986 = validateParameter(valid_595986, JString, required = false,
                                 default = nil)
  if valid_595986 != nil:
    section.add "X-Amz-Date", valid_595986
  var valid_595987 = header.getOrDefault("X-Amz-Credential")
  valid_595987 = validateParameter(valid_595987, JString, required = false,
                                 default = nil)
  if valid_595987 != nil:
    section.add "X-Amz-Credential", valid_595987
  var valid_595988 = header.getOrDefault("X-Amz-Security-Token")
  valid_595988 = validateParameter(valid_595988, JString, required = false,
                                 default = nil)
  if valid_595988 != nil:
    section.add "X-Amz-Security-Token", valid_595988
  var valid_595989 = header.getOrDefault("X-Amz-Algorithm")
  valid_595989 = validateParameter(valid_595989, JString, required = false,
                                 default = nil)
  if valid_595989 != nil:
    section.add "X-Amz-Algorithm", valid_595989
  var valid_595990 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595990 = validateParameter(valid_595990, JString, required = false,
                                 default = nil)
  if valid_595990 != nil:
    section.add "X-Amz-SignedHeaders", valid_595990
  result.add "header", section
  ## parameters in `formData` object:
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  section = newJObject()
  var valid_595991 = formData.getOrDefault("Port")
  valid_595991 = validateParameter(valid_595991, JInt, required = false, default = nil)
  if valid_595991 != nil:
    section.add "Port", valid_595991
  var valid_595992 = formData.getOrDefault("PreferredMaintenanceWindow")
  valid_595992 = validateParameter(valid_595992, JString, required = false,
                                 default = nil)
  if valid_595992 != nil:
    section.add "PreferredMaintenanceWindow", valid_595992
  var valid_595993 = formData.getOrDefault("NodeType")
  valid_595993 = validateParameter(valid_595993, JString, required = false,
                                 default = nil)
  if valid_595993 != nil:
    section.add "NodeType", valid_595993
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_595994 = formData.getOrDefault("ClusterIdentifier")
  valid_595994 = validateParameter(valid_595994, JString, required = true,
                                 default = nil)
  if valid_595994 != nil:
    section.add "ClusterIdentifier", valid_595994
  var valid_595995 = formData.getOrDefault("MaintenanceTrackName")
  valid_595995 = validateParameter(valid_595995, JString, required = false,
                                 default = nil)
  if valid_595995 != nil:
    section.add "MaintenanceTrackName", valid_595995
  var valid_595996 = formData.getOrDefault("ClusterSecurityGroups")
  valid_595996 = validateParameter(valid_595996, JArray, required = false,
                                 default = nil)
  if valid_595996 != nil:
    section.add "ClusterSecurityGroups", valid_595996
  var valid_595997 = formData.getOrDefault("IamRoles")
  valid_595997 = validateParameter(valid_595997, JArray, required = false,
                                 default = nil)
  if valid_595997 != nil:
    section.add "IamRoles", valid_595997
  var valid_595998 = formData.getOrDefault("OwnerAccount")
  valid_595998 = validateParameter(valid_595998, JString, required = false,
                                 default = nil)
  if valid_595998 != nil:
    section.add "OwnerAccount", valid_595998
  var valid_595999 = formData.getOrDefault("VpcSecurityGroupIds")
  valid_595999 = validateParameter(valid_595999, JArray, required = false,
                                 default = nil)
  if valid_595999 != nil:
    section.add "VpcSecurityGroupIds", valid_595999
  var valid_596000 = formData.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_596000 = validateParameter(valid_596000, JInt, required = false, default = nil)
  if valid_596000 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_596000
  var valid_596001 = formData.getOrDefault("AvailabilityZone")
  valid_596001 = validateParameter(valid_596001, JString, required = false,
                                 default = nil)
  if valid_596001 != nil:
    section.add "AvailabilityZone", valid_596001
  var valid_596002 = formData.getOrDefault("EnhancedVpcRouting")
  valid_596002 = validateParameter(valid_596002, JBool, required = false, default = nil)
  if valid_596002 != nil:
    section.add "EnhancedVpcRouting", valid_596002
  var valid_596003 = formData.getOrDefault("KmsKeyId")
  valid_596003 = validateParameter(valid_596003, JString, required = false,
                                 default = nil)
  if valid_596003 != nil:
    section.add "KmsKeyId", valid_596003
  var valid_596004 = formData.getOrDefault("NumberOfNodes")
  valid_596004 = validateParameter(valid_596004, JInt, required = false, default = nil)
  if valid_596004 != nil:
    section.add "NumberOfNodes", valid_596004
  var valid_596005 = formData.getOrDefault("ClusterSubnetGroupName")
  valid_596005 = validateParameter(valid_596005, JString, required = false,
                                 default = nil)
  if valid_596005 != nil:
    section.add "ClusterSubnetGroupName", valid_596005
  var valid_596006 = formData.getOrDefault("AllowVersionUpgrade")
  valid_596006 = validateParameter(valid_596006, JBool, required = false, default = nil)
  if valid_596006 != nil:
    section.add "AllowVersionUpgrade", valid_596006
  var valid_596007 = formData.getOrDefault("SnapshotIdentifier")
  valid_596007 = validateParameter(valid_596007, JString, required = true,
                                 default = nil)
  if valid_596007 != nil:
    section.add "SnapshotIdentifier", valid_596007
  var valid_596008 = formData.getOrDefault("PubliclyAccessible")
  valid_596008 = validateParameter(valid_596008, JBool, required = false, default = nil)
  if valid_596008 != nil:
    section.add "PubliclyAccessible", valid_596008
  var valid_596009 = formData.getOrDefault("ClusterParameterGroupName")
  valid_596009 = validateParameter(valid_596009, JString, required = false,
                                 default = nil)
  if valid_596009 != nil:
    section.add "ClusterParameterGroupName", valid_596009
  var valid_596010 = formData.getOrDefault("HsmClientCertificateIdentifier")
  valid_596010 = validateParameter(valid_596010, JString, required = false,
                                 default = nil)
  if valid_596010 != nil:
    section.add "HsmClientCertificateIdentifier", valid_596010
  var valid_596011 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_596011 = validateParameter(valid_596011, JString, required = false,
                                 default = nil)
  if valid_596011 != nil:
    section.add "SnapshotClusterIdentifier", valid_596011
  var valid_596012 = formData.getOrDefault("AdditionalInfo")
  valid_596012 = validateParameter(valid_596012, JString, required = false,
                                 default = nil)
  if valid_596012 != nil:
    section.add "AdditionalInfo", valid_596012
  var valid_596013 = formData.getOrDefault("SnapshotScheduleIdentifier")
  valid_596013 = validateParameter(valid_596013, JString, required = false,
                                 default = nil)
  if valid_596013 != nil:
    section.add "SnapshotScheduleIdentifier", valid_596013
  var valid_596014 = formData.getOrDefault("ElasticIp")
  valid_596014 = validateParameter(valid_596014, JString, required = false,
                                 default = nil)
  if valid_596014 != nil:
    section.add "ElasticIp", valid_596014
  var valid_596015 = formData.getOrDefault("HsmConfigurationIdentifier")
  valid_596015 = validateParameter(valid_596015, JString, required = false,
                                 default = nil)
  if valid_596015 != nil:
    section.add "HsmConfigurationIdentifier", valid_596015
  var valid_596016 = formData.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_596016 = validateParameter(valid_596016, JInt, required = false, default = nil)
  if valid_596016 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_596016
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596017: Call_PostRestoreFromClusterSnapshot_595979; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_596017.validator(path, query, header, formData, body)
  let scheme = call_596017.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596017.url(scheme.get, call_596017.host, call_596017.base,
                         call_596017.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596017, url, valid)

proc call*(call_596018: Call_PostRestoreFromClusterSnapshot_595979;
          ClusterIdentifier: string; SnapshotIdentifier: string; Port: int = 0;
          PreferredMaintenanceWindow: string = ""; NodeType: string = "";
          MaintenanceTrackName: string = ""; ClusterSecurityGroups: JsonNode = nil;
          IamRoles: JsonNode = nil; OwnerAccount: string = "";
          VpcSecurityGroupIds: JsonNode = nil;
          AutomatedSnapshotRetentionPeriod: int = 0; AvailabilityZone: string = "";
          EnhancedVpcRouting: bool = false; KmsKeyId: string = "";
          NumberOfNodes: int = 0; ClusterSubnetGroupName: string = "";
          AllowVersionUpgrade: bool = false; PubliclyAccessible: bool = false;
          Action: string = "RestoreFromClusterSnapshot";
          ClusterParameterGroupName: string = "";
          HsmClientCertificateIdentifier: string = "";
          SnapshotClusterIdentifier: string = ""; AdditionalInfo: string = "";
          SnapshotScheduleIdentifier: string = ""; Version: string = "2012-12-01";
          ElasticIp: string = ""; HsmConfigurationIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0): Recallable =
  ## postRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  ##   Action: string (required)
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   Version: string (required)
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  var query_596019 = newJObject()
  var formData_596020 = newJObject()
  add(formData_596020, "Port", newJInt(Port))
  add(formData_596020, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(formData_596020, "NodeType", newJString(NodeType))
  add(formData_596020, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_596020, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  if ClusterSecurityGroups != nil:
    formData_596020.add "ClusterSecurityGroups", ClusterSecurityGroups
  if IamRoles != nil:
    formData_596020.add "IamRoles", IamRoles
  add(formData_596020, "OwnerAccount", newJString(OwnerAccount))
  if VpcSecurityGroupIds != nil:
    formData_596020.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(formData_596020, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(formData_596020, "AvailabilityZone", newJString(AvailabilityZone))
  add(formData_596020, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(formData_596020, "KmsKeyId", newJString(KmsKeyId))
  add(formData_596020, "NumberOfNodes", newJInt(NumberOfNodes))
  add(formData_596020, "ClusterSubnetGroupName",
      newJString(ClusterSubnetGroupName))
  add(formData_596020, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(formData_596020, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_596020, "PubliclyAccessible", newJBool(PubliclyAccessible))
  add(query_596019, "Action", newJString(Action))
  add(formData_596020, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(formData_596020, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(formData_596020, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(formData_596020, "AdditionalInfo", newJString(AdditionalInfo))
  add(formData_596020, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  add(query_596019, "Version", newJString(Version))
  add(formData_596020, "ElasticIp", newJString(ElasticIp))
  add(formData_596020, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(formData_596020, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  result = call_596018.call(nil, query_596019, nil, formData_596020, nil)

var postRestoreFromClusterSnapshot* = Call_PostRestoreFromClusterSnapshot_595979(
    name: "postRestoreFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_PostRestoreFromClusterSnapshot_595980, base: "/",
    url: url_PostRestoreFromClusterSnapshot_595981,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreFromClusterSnapshot_595938 = ref object of OpenApiRestCall_592348
proc url_GetRestoreFromClusterSnapshot_595940(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRestoreFromClusterSnapshot_595939(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   ClusterSubnetGroupName: JString
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   MaintenanceTrackName: JString
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   SnapshotIdentifier: JString (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmClientCertificateIdentifier: JString
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ManualSnapshotRetentionPeriod: JInt
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   KmsKeyId: JString
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterParameterGroupName: JString
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: JString
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   SnapshotScheduleIdentifier: JString
  ##                             : A unique identifier for the snapshot schedule.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   NumberOfNodes: JInt
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   AdditionalInfo: JString
  ##                 : Reserved.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AllowVersionUpgrade: JBool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: JString
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AutomatedSnapshotRetentionPeriod: JInt
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: JBool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Port: JInt
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AvailabilityZone: JString
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   HsmConfigurationIdentifier: JString
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: JString
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: JString (required)
  ##   PreferredMaintenanceWindow: JString
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: JBool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  section = newJObject()
  var valid_595941 = query.getOrDefault("ClusterSubnetGroupName")
  valid_595941 = validateParameter(valid_595941, JString, required = false,
                                 default = nil)
  if valid_595941 != nil:
    section.add "ClusterSubnetGroupName", valid_595941
  var valid_595942 = query.getOrDefault("MaintenanceTrackName")
  valid_595942 = validateParameter(valid_595942, JString, required = false,
                                 default = nil)
  if valid_595942 != nil:
    section.add "MaintenanceTrackName", valid_595942
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_595943 = query.getOrDefault("SnapshotIdentifier")
  valid_595943 = validateParameter(valid_595943, JString, required = true,
                                 default = nil)
  if valid_595943 != nil:
    section.add "SnapshotIdentifier", valid_595943
  var valid_595944 = query.getOrDefault("HsmClientCertificateIdentifier")
  valid_595944 = validateParameter(valid_595944, JString, required = false,
                                 default = nil)
  if valid_595944 != nil:
    section.add "HsmClientCertificateIdentifier", valid_595944
  var valid_595945 = query.getOrDefault("ManualSnapshotRetentionPeriod")
  valid_595945 = validateParameter(valid_595945, JInt, required = false, default = nil)
  if valid_595945 != nil:
    section.add "ManualSnapshotRetentionPeriod", valid_595945
  var valid_595946 = query.getOrDefault("ClusterSecurityGroups")
  valid_595946 = validateParameter(valid_595946, JArray, required = false,
                                 default = nil)
  if valid_595946 != nil:
    section.add "ClusterSecurityGroups", valid_595946
  var valid_595947 = query.getOrDefault("KmsKeyId")
  valid_595947 = validateParameter(valid_595947, JString, required = false,
                                 default = nil)
  if valid_595947 != nil:
    section.add "KmsKeyId", valid_595947
  var valid_595948 = query.getOrDefault("ClusterParameterGroupName")
  valid_595948 = validateParameter(valid_595948, JString, required = false,
                                 default = nil)
  if valid_595948 != nil:
    section.add "ClusterParameterGroupName", valid_595948
  var valid_595949 = query.getOrDefault("NodeType")
  valid_595949 = validateParameter(valid_595949, JString, required = false,
                                 default = nil)
  if valid_595949 != nil:
    section.add "NodeType", valid_595949
  var valid_595950 = query.getOrDefault("SnapshotScheduleIdentifier")
  valid_595950 = validateParameter(valid_595950, JString, required = false,
                                 default = nil)
  if valid_595950 != nil:
    section.add "SnapshotScheduleIdentifier", valid_595950
  var valid_595951 = query.getOrDefault("IamRoles")
  valid_595951 = validateParameter(valid_595951, JArray, required = false,
                                 default = nil)
  if valid_595951 != nil:
    section.add "IamRoles", valid_595951
  var valid_595952 = query.getOrDefault("NumberOfNodes")
  valid_595952 = validateParameter(valid_595952, JInt, required = false, default = nil)
  if valid_595952 != nil:
    section.add "NumberOfNodes", valid_595952
  var valid_595953 = query.getOrDefault("AdditionalInfo")
  valid_595953 = validateParameter(valid_595953, JString, required = false,
                                 default = nil)
  if valid_595953 != nil:
    section.add "AdditionalInfo", valid_595953
  var valid_595954 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_595954 = validateParameter(valid_595954, JString, required = false,
                                 default = nil)
  if valid_595954 != nil:
    section.add "SnapshotClusterIdentifier", valid_595954
  var valid_595955 = query.getOrDefault("AllowVersionUpgrade")
  valid_595955 = validateParameter(valid_595955, JBool, required = false, default = nil)
  if valid_595955 != nil:
    section.add "AllowVersionUpgrade", valid_595955
  var valid_595956 = query.getOrDefault("ElasticIp")
  valid_595956 = validateParameter(valid_595956, JString, required = false,
                                 default = nil)
  if valid_595956 != nil:
    section.add "ElasticIp", valid_595956
  var valid_595957 = query.getOrDefault("AutomatedSnapshotRetentionPeriod")
  valid_595957 = validateParameter(valid_595957, JInt, required = false, default = nil)
  if valid_595957 != nil:
    section.add "AutomatedSnapshotRetentionPeriod", valid_595957
  var valid_595958 = query.getOrDefault("EnhancedVpcRouting")
  valid_595958 = validateParameter(valid_595958, JBool, required = false, default = nil)
  if valid_595958 != nil:
    section.add "EnhancedVpcRouting", valid_595958
  var valid_595959 = query.getOrDefault("Action")
  valid_595959 = validateParameter(valid_595959, JString, required = true, default = newJString(
      "RestoreFromClusterSnapshot"))
  if valid_595959 != nil:
    section.add "Action", valid_595959
  var valid_595960 = query.getOrDefault("ClusterIdentifier")
  valid_595960 = validateParameter(valid_595960, JString, required = true,
                                 default = nil)
  if valid_595960 != nil:
    section.add "ClusterIdentifier", valid_595960
  var valid_595961 = query.getOrDefault("Port")
  valid_595961 = validateParameter(valid_595961, JInt, required = false, default = nil)
  if valid_595961 != nil:
    section.add "Port", valid_595961
  var valid_595962 = query.getOrDefault("VpcSecurityGroupIds")
  valid_595962 = validateParameter(valid_595962, JArray, required = false,
                                 default = nil)
  if valid_595962 != nil:
    section.add "VpcSecurityGroupIds", valid_595962
  var valid_595963 = query.getOrDefault("AvailabilityZone")
  valid_595963 = validateParameter(valid_595963, JString, required = false,
                                 default = nil)
  if valid_595963 != nil:
    section.add "AvailabilityZone", valid_595963
  var valid_595964 = query.getOrDefault("HsmConfigurationIdentifier")
  valid_595964 = validateParameter(valid_595964, JString, required = false,
                                 default = nil)
  if valid_595964 != nil:
    section.add "HsmConfigurationIdentifier", valid_595964
  var valid_595965 = query.getOrDefault("OwnerAccount")
  valid_595965 = validateParameter(valid_595965, JString, required = false,
                                 default = nil)
  if valid_595965 != nil:
    section.add "OwnerAccount", valid_595965
  var valid_595966 = query.getOrDefault("Version")
  valid_595966 = validateParameter(valid_595966, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_595966 != nil:
    section.add "Version", valid_595966
  var valid_595967 = query.getOrDefault("PreferredMaintenanceWindow")
  valid_595967 = validateParameter(valid_595967, JString, required = false,
                                 default = nil)
  if valid_595967 != nil:
    section.add "PreferredMaintenanceWindow", valid_595967
  var valid_595968 = query.getOrDefault("PubliclyAccessible")
  valid_595968 = validateParameter(valid_595968, JBool, required = false, default = nil)
  if valid_595968 != nil:
    section.add "PubliclyAccessible", valid_595968
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_595969 = header.getOrDefault("X-Amz-Signature")
  valid_595969 = validateParameter(valid_595969, JString, required = false,
                                 default = nil)
  if valid_595969 != nil:
    section.add "X-Amz-Signature", valid_595969
  var valid_595970 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_595970 = validateParameter(valid_595970, JString, required = false,
                                 default = nil)
  if valid_595970 != nil:
    section.add "X-Amz-Content-Sha256", valid_595970
  var valid_595971 = header.getOrDefault("X-Amz-Date")
  valid_595971 = validateParameter(valid_595971, JString, required = false,
                                 default = nil)
  if valid_595971 != nil:
    section.add "X-Amz-Date", valid_595971
  var valid_595972 = header.getOrDefault("X-Amz-Credential")
  valid_595972 = validateParameter(valid_595972, JString, required = false,
                                 default = nil)
  if valid_595972 != nil:
    section.add "X-Amz-Credential", valid_595972
  var valid_595973 = header.getOrDefault("X-Amz-Security-Token")
  valid_595973 = validateParameter(valid_595973, JString, required = false,
                                 default = nil)
  if valid_595973 != nil:
    section.add "X-Amz-Security-Token", valid_595973
  var valid_595974 = header.getOrDefault("X-Amz-Algorithm")
  valid_595974 = validateParameter(valid_595974, JString, required = false,
                                 default = nil)
  if valid_595974 != nil:
    section.add "X-Amz-Algorithm", valid_595974
  var valid_595975 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_595975 = validateParameter(valid_595975, JString, required = false,
                                 default = nil)
  if valid_595975 != nil:
    section.add "X-Amz-SignedHeaders", valid_595975
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_595976: Call_GetRestoreFromClusterSnapshot_595938; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_595976.validator(path, query, header, formData, body)
  let scheme = call_595976.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_595976.url(scheme.get, call_595976.host, call_595976.base,
                         call_595976.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_595976, url, valid)

proc call*(call_595977: Call_GetRestoreFromClusterSnapshot_595938;
          SnapshotIdentifier: string; ClusterIdentifier: string;
          ClusterSubnetGroupName: string = ""; MaintenanceTrackName: string = "";
          HsmClientCertificateIdentifier: string = "";
          ManualSnapshotRetentionPeriod: int = 0;
          ClusterSecurityGroups: JsonNode = nil; KmsKeyId: string = "";
          ClusterParameterGroupName: string = ""; NodeType: string = "";
          SnapshotScheduleIdentifier: string = ""; IamRoles: JsonNode = nil;
          NumberOfNodes: int = 0; AdditionalInfo: string = "";
          SnapshotClusterIdentifier: string = ""; AllowVersionUpgrade: bool = false;
          ElasticIp: string = ""; AutomatedSnapshotRetentionPeriod: int = 0;
          EnhancedVpcRouting: bool = false;
          Action: string = "RestoreFromClusterSnapshot"; Port: int = 0;
          VpcSecurityGroupIds: JsonNode = nil; AvailabilityZone: string = "";
          HsmConfigurationIdentifier: string = ""; OwnerAccount: string = "";
          Version: string = "2012-12-01"; PreferredMaintenanceWindow: string = "";
          PubliclyAccessible: bool = false): Recallable =
  ## getRestoreFromClusterSnapshot
  ## <p>Creates a new cluster from a snapshot. By default, Amazon Redshift creates the resulting cluster with the same configuration as the original cluster from which the snapshot was created, except that the new cluster is created with the default cluster security and parameter groups. After Amazon Redshift creates the cluster, you can use the <a>ModifyCluster</a> API to associate a different security group and different parameter group with the restored cluster. If you are using a DS node type, you can also choose to change to another DS node type of the same size during restore.</p> <p>If you restore a cluster into a VPC, you must provide a cluster subnet group where you want the cluster restored.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   ClusterSubnetGroupName: string
  ##                         : <p>The name of the subnet group where you want to cluster restored.</p> <p>A snapshot of cluster in VPC can be restored only in VPC. Therefore, you must provide subnet group name where you want the cluster restored.</p>
  ##   MaintenanceTrackName: string
  ##                       : The name of the maintenance track for the restored cluster. When you take a snapshot, the snapshot inherits the <code>MaintenanceTrack</code> value from the cluster. The snapshot might be on a different track than the cluster that was the source for the snapshot. For example, suppose that you take a snapshot of a cluster that is on the current track and then change the cluster to be on the trailing track. In this case, the snapshot and the source cluster are on different tracks.
  ##   SnapshotIdentifier: string (required)
  ##                     : <p>The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.</p> <p>Example: <code>my-snapshot-id</code> </p>
  ##   HsmClientCertificateIdentifier: string
  ##                                 : Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM.
  ##   ManualSnapshotRetentionPeriod: int
  ##                                : <p>The default number of days to retain a manual snapshot. If the value is -1, the snapshot is retained indefinitely. This setting doesn't change the retention period of existing snapshots.</p> <p>The value must be either -1 or an integer between 1 and 3,653.</p>
  ##   ClusterSecurityGroups: JArray
  ##                        : <p>A list of security groups to be associated with this cluster.</p> <p>Default: The default cluster security group for Amazon Redshift.</p> <p>Cluster security groups only apply to clusters outside of VPCs.</p>
  ##   KmsKeyId: string
  ##           : The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster that you restore from a shared snapshot.
  ##   ClusterParameterGroupName: string
  ##                            : <p>The name of the parameter group to be associated with this cluster.</p> <p>Default: The default Amazon Redshift cluster parameter group. For information about the default parameter group, go to <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html">Working with Amazon Redshift Parameter Groups</a>.</p> <p>Constraints:</p> <ul> <li> <p>Must be 1 to 255 alphanumeric characters or hyphens.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> </ul>
  ##   NodeType: string
  ##           : <p>The node type that the restored cluster will be provisioned with.</p> <p>Default: The node type of the cluster from which the snapshot was taken. You can modify this if you are using any DS node type. In that case, you can choose to restore into another DS node type of the same size. For example, you can restore ds1.8xlarge into ds2.8xlarge, or ds1.xlarge into ds2.xlarge. If you have a DC instance type, you must restore into that same instance type and size. In other words, you can only restore a dc1.large instance type into another dc1.large instance type or dc2.large instance type. You can't restore dc1.8xlarge to dc2.8xlarge. First restore to a dc1.8xlareg cluster, then resize to a dc2.8large cluster. For more information about node types, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-about-clusters-and-nodes"> About Clusters and Nodes</a> in the <i>Amazon Redshift Cluster Management Guide</i>. </p>
  ##   SnapshotScheduleIdentifier: string
  ##                             : A unique identifier for the snapshot schedule.
  ##   IamRoles: JArray
  ##           : <p>A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request.</p> <p>A cluster can have up to 10 IAM roles associated at any time.</p>
  ##   NumberOfNodes: int
  ##                : The number of nodes specified when provisioning the restored cluster.
  ##   AdditionalInfo: string
  ##                 : Reserved.
  ##   SnapshotClusterIdentifier: string
  ##                            : The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   AllowVersionUpgrade: bool
  ##                      : <p>If <code>true</code>, major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. </p> <p>Default: <code>true</code> </p>
  ##   ElasticIp: string
  ##            : The elastic IP (EIP) address for the cluster.
  ##   AutomatedSnapshotRetentionPeriod: int
  ##                                   : <p>The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with <a>CreateClusterSnapshot</a>. </p> <p>Default: The value selected for the cluster from which the snapshot was taken.</p> <p>Constraints: Must be a value from 0 to 35.</p>
  ##   EnhancedVpcRouting: bool
  ##                     : <p>An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/enhanced-vpc-routing.html">Enhanced VPC Routing</a> in the Amazon Redshift Cluster Management Guide.</p> <p>If this option is <code>true</code>, enhanced VPC routing is enabled. </p> <p>Default: false</p>
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The identifier of the cluster that will be created from restoring the snapshot.</p> <p>Constraints:</p> <ul> <li> <p>Must contain from 1 to 63 alphanumeric characters or hyphens.</p> </li> <li> <p>Alphabetic characters must be lowercase.</p> </li> <li> <p>First character must be a letter.</p> </li> <li> <p>Cannot end with a hyphen or contain two consecutive hyphens.</p> </li> <li> <p>Must be unique for all clusters within an AWS account.</p> </li> </ul>
  ##   Port: int
  ##       : <p>The port number on which the cluster accepts connections.</p> <p>Default: The same port as the original cluster.</p> <p>Constraints: Must be between <code>1115</code> and <code>65535</code>.</p>
  ##   VpcSecurityGroupIds: JArray
  ##                      : <p>A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.</p> <p>Default: The default VPC security group is associated with the cluster.</p> <p>VPC security groups only apply to clusters in VPCs.</p>
  ##   AvailabilityZone: string
  ##                   : <p>The Amazon EC2 Availability Zone in which to restore the cluster.</p> <p>Default: A random, system-chosen Availability Zone.</p> <p>Example: <code>us-east-1a</code> </p>
  ##   HsmConfigurationIdentifier: string
  ##                             : Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  ##   OwnerAccount: string
  ##               : The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
  ##   Version: string (required)
  ##   PreferredMaintenanceWindow: string
  ##                             : <p>The weekly time range (in UTC) during which automated cluster maintenance can occur.</p> <p> Format: <code>ddd:hh24:mi-ddd:hh24:mi</code> </p> <p> Default: The value selected for the cluster from which the snapshot was taken. For more information about the time blocks for each region, see <a 
  ## href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-clusters.html#rs-maintenance-windows">Maintenance Windows</a> in Amazon Redshift Cluster Management Guide. </p> <p>Valid Days: Mon | Tue | Wed | Thu | Fri | Sat | Sun</p> <p>Constraints: Minimum 30-minute window.</p>
  ##   PubliclyAccessible: bool
  ##                     : If <code>true</code>, the cluster can be accessed from a public network. 
  var query_595978 = newJObject()
  add(query_595978, "ClusterSubnetGroupName", newJString(ClusterSubnetGroupName))
  add(query_595978, "MaintenanceTrackName", newJString(MaintenanceTrackName))
  add(query_595978, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_595978, "HsmClientCertificateIdentifier",
      newJString(HsmClientCertificateIdentifier))
  add(query_595978, "ManualSnapshotRetentionPeriod",
      newJInt(ManualSnapshotRetentionPeriod))
  if ClusterSecurityGroups != nil:
    query_595978.add "ClusterSecurityGroups", ClusterSecurityGroups
  add(query_595978, "KmsKeyId", newJString(KmsKeyId))
  add(query_595978, "ClusterParameterGroupName",
      newJString(ClusterParameterGroupName))
  add(query_595978, "NodeType", newJString(NodeType))
  add(query_595978, "SnapshotScheduleIdentifier",
      newJString(SnapshotScheduleIdentifier))
  if IamRoles != nil:
    query_595978.add "IamRoles", IamRoles
  add(query_595978, "NumberOfNodes", newJInt(NumberOfNodes))
  add(query_595978, "AdditionalInfo", newJString(AdditionalInfo))
  add(query_595978, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_595978, "AllowVersionUpgrade", newJBool(AllowVersionUpgrade))
  add(query_595978, "ElasticIp", newJString(ElasticIp))
  add(query_595978, "AutomatedSnapshotRetentionPeriod",
      newJInt(AutomatedSnapshotRetentionPeriod))
  add(query_595978, "EnhancedVpcRouting", newJBool(EnhancedVpcRouting))
  add(query_595978, "Action", newJString(Action))
  add(query_595978, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_595978, "Port", newJInt(Port))
  if VpcSecurityGroupIds != nil:
    query_595978.add "VpcSecurityGroupIds", VpcSecurityGroupIds
  add(query_595978, "AvailabilityZone", newJString(AvailabilityZone))
  add(query_595978, "HsmConfigurationIdentifier",
      newJString(HsmConfigurationIdentifier))
  add(query_595978, "OwnerAccount", newJString(OwnerAccount))
  add(query_595978, "Version", newJString(Version))
  add(query_595978, "PreferredMaintenanceWindow",
      newJString(PreferredMaintenanceWindow))
  add(query_595978, "PubliclyAccessible", newJBool(PubliclyAccessible))
  result = call_595977.call(nil, query_595978, nil, nil, nil)

var getRestoreFromClusterSnapshot* = Call_GetRestoreFromClusterSnapshot_595938(
    name: "getRestoreFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RestoreFromClusterSnapshot",
    validator: validate_GetRestoreFromClusterSnapshot_595939, base: "/",
    url: url_GetRestoreFromClusterSnapshot_595940,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRestoreTableFromClusterSnapshot_596044 = ref object of OpenApiRestCall_592348
proc url_PostRestoreTableFromClusterSnapshot_596046(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRestoreTableFromClusterSnapshot_596045(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596047 = query.getOrDefault("Action")
  valid_596047 = validateParameter(valid_596047, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_596047 != nil:
    section.add "Action", valid_596047
  var valid_596048 = query.getOrDefault("Version")
  valid_596048 = validateParameter(valid_596048, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596048 != nil:
    section.add "Version", valid_596048
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596049 = header.getOrDefault("X-Amz-Signature")
  valid_596049 = validateParameter(valid_596049, JString, required = false,
                                 default = nil)
  if valid_596049 != nil:
    section.add "X-Amz-Signature", valid_596049
  var valid_596050 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596050 = validateParameter(valid_596050, JString, required = false,
                                 default = nil)
  if valid_596050 != nil:
    section.add "X-Amz-Content-Sha256", valid_596050
  var valid_596051 = header.getOrDefault("X-Amz-Date")
  valid_596051 = validateParameter(valid_596051, JString, required = false,
                                 default = nil)
  if valid_596051 != nil:
    section.add "X-Amz-Date", valid_596051
  var valid_596052 = header.getOrDefault("X-Amz-Credential")
  valid_596052 = validateParameter(valid_596052, JString, required = false,
                                 default = nil)
  if valid_596052 != nil:
    section.add "X-Amz-Credential", valid_596052
  var valid_596053 = header.getOrDefault("X-Amz-Security-Token")
  valid_596053 = validateParameter(valid_596053, JString, required = false,
                                 default = nil)
  if valid_596053 != nil:
    section.add "X-Amz-Security-Token", valid_596053
  var valid_596054 = header.getOrDefault("X-Amz-Algorithm")
  valid_596054 = validateParameter(valid_596054, JString, required = false,
                                 default = nil)
  if valid_596054 != nil:
    section.add "X-Amz-Algorithm", valid_596054
  var valid_596055 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596055 = validateParameter(valid_596055, JString, required = false,
                                 default = nil)
  if valid_596055 != nil:
    section.add "X-Amz-SignedHeaders", valid_596055
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_596056 = formData.getOrDefault("ClusterIdentifier")
  valid_596056 = validateParameter(valid_596056, JString, required = true,
                                 default = nil)
  if valid_596056 != nil:
    section.add "ClusterIdentifier", valid_596056
  var valid_596057 = formData.getOrDefault("NewTableName")
  valid_596057 = validateParameter(valid_596057, JString, required = true,
                                 default = nil)
  if valid_596057 != nil:
    section.add "NewTableName", valid_596057
  var valid_596058 = formData.getOrDefault("TargetSchemaName")
  valid_596058 = validateParameter(valid_596058, JString, required = false,
                                 default = nil)
  if valid_596058 != nil:
    section.add "TargetSchemaName", valid_596058
  var valid_596059 = formData.getOrDefault("TargetDatabaseName")
  valid_596059 = validateParameter(valid_596059, JString, required = false,
                                 default = nil)
  if valid_596059 != nil:
    section.add "TargetDatabaseName", valid_596059
  var valid_596060 = formData.getOrDefault("SnapshotIdentifier")
  valid_596060 = validateParameter(valid_596060, JString, required = true,
                                 default = nil)
  if valid_596060 != nil:
    section.add "SnapshotIdentifier", valid_596060
  var valid_596061 = formData.getOrDefault("SourceDatabaseName")
  valid_596061 = validateParameter(valid_596061, JString, required = true,
                                 default = nil)
  if valid_596061 != nil:
    section.add "SourceDatabaseName", valid_596061
  var valid_596062 = formData.getOrDefault("SourceSchemaName")
  valid_596062 = validateParameter(valid_596062, JString, required = false,
                                 default = nil)
  if valid_596062 != nil:
    section.add "SourceSchemaName", valid_596062
  var valid_596063 = formData.getOrDefault("SourceTableName")
  valid_596063 = validateParameter(valid_596063, JString, required = true,
                                 default = nil)
  if valid_596063 != nil:
    section.add "SourceTableName", valid_596063
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596064: Call_PostRestoreTableFromClusterSnapshot_596044;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_596064.validator(path, query, header, formData, body)
  let scheme = call_596064.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596064.url(scheme.get, call_596064.host, call_596064.base,
                         call_596064.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596064, url, valid)

proc call*(call_596065: Call_PostRestoreTableFromClusterSnapshot_596044;
          ClusterIdentifier: string; NewTableName: string;
          SnapshotIdentifier: string; SourceDatabaseName: string;
          SourceTableName: string; TargetSchemaName: string = "";
          TargetDatabaseName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          Version: string = "2012-12-01"; SourceSchemaName: string = ""): Recallable =
  ## postRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  var query_596066 = newJObject()
  var formData_596067 = newJObject()
  add(formData_596067, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(formData_596067, "NewTableName", newJString(NewTableName))
  add(formData_596067, "TargetSchemaName", newJString(TargetSchemaName))
  add(formData_596067, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(formData_596067, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(formData_596067, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_596066, "Action", newJString(Action))
  add(query_596066, "Version", newJString(Version))
  add(formData_596067, "SourceSchemaName", newJString(SourceSchemaName))
  add(formData_596067, "SourceTableName", newJString(SourceTableName))
  result = call_596065.call(nil, query_596066, nil, formData_596067, nil)

var postRestoreTableFromClusterSnapshot* = Call_PostRestoreTableFromClusterSnapshot_596044(
    name: "postRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_PostRestoreTableFromClusterSnapshot_596045, base: "/",
    url: url_PostRestoreTableFromClusterSnapshot_596046,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRestoreTableFromClusterSnapshot_596021 = ref object of OpenApiRestCall_592348
proc url_GetRestoreTableFromClusterSnapshot_596023(protocol: Scheme; host: string;
    base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRestoreTableFromClusterSnapshot_596022(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceTableName: JString (required)
  ##                  : The name of the source table to restore from.
  ##   SourceDatabaseName: JString (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   TargetSchemaName: JString
  ##                   : The name of the schema to restore the table to.
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceSchemaName: JString
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   Version: JString (required)
  ##   TargetDatabaseName: JString
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: JString (required)
  ##               : The name of the table to create as a result of the current request.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_596024 = query.getOrDefault("SnapshotIdentifier")
  valid_596024 = validateParameter(valid_596024, JString, required = true,
                                 default = nil)
  if valid_596024 != nil:
    section.add "SnapshotIdentifier", valid_596024
  var valid_596025 = query.getOrDefault("SourceTableName")
  valid_596025 = validateParameter(valid_596025, JString, required = true,
                                 default = nil)
  if valid_596025 != nil:
    section.add "SourceTableName", valid_596025
  var valid_596026 = query.getOrDefault("SourceDatabaseName")
  valid_596026 = validateParameter(valid_596026, JString, required = true,
                                 default = nil)
  if valid_596026 != nil:
    section.add "SourceDatabaseName", valid_596026
  var valid_596027 = query.getOrDefault("TargetSchemaName")
  valid_596027 = validateParameter(valid_596027, JString, required = false,
                                 default = nil)
  if valid_596027 != nil:
    section.add "TargetSchemaName", valid_596027
  var valid_596028 = query.getOrDefault("Action")
  valid_596028 = validateParameter(valid_596028, JString, required = true, default = newJString(
      "RestoreTableFromClusterSnapshot"))
  if valid_596028 != nil:
    section.add "Action", valid_596028
  var valid_596029 = query.getOrDefault("ClusterIdentifier")
  valid_596029 = validateParameter(valid_596029, JString, required = true,
                                 default = nil)
  if valid_596029 != nil:
    section.add "ClusterIdentifier", valid_596029
  var valid_596030 = query.getOrDefault("SourceSchemaName")
  valid_596030 = validateParameter(valid_596030, JString, required = false,
                                 default = nil)
  if valid_596030 != nil:
    section.add "SourceSchemaName", valid_596030
  var valid_596031 = query.getOrDefault("Version")
  valid_596031 = validateParameter(valid_596031, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596031 != nil:
    section.add "Version", valid_596031
  var valid_596032 = query.getOrDefault("TargetDatabaseName")
  valid_596032 = validateParameter(valid_596032, JString, required = false,
                                 default = nil)
  if valid_596032 != nil:
    section.add "TargetDatabaseName", valid_596032
  var valid_596033 = query.getOrDefault("NewTableName")
  valid_596033 = validateParameter(valid_596033, JString, required = true,
                                 default = nil)
  if valid_596033 != nil:
    section.add "NewTableName", valid_596033
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596034 = header.getOrDefault("X-Amz-Signature")
  valid_596034 = validateParameter(valid_596034, JString, required = false,
                                 default = nil)
  if valid_596034 != nil:
    section.add "X-Amz-Signature", valid_596034
  var valid_596035 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596035 = validateParameter(valid_596035, JString, required = false,
                                 default = nil)
  if valid_596035 != nil:
    section.add "X-Amz-Content-Sha256", valid_596035
  var valid_596036 = header.getOrDefault("X-Amz-Date")
  valid_596036 = validateParameter(valid_596036, JString, required = false,
                                 default = nil)
  if valid_596036 != nil:
    section.add "X-Amz-Date", valid_596036
  var valid_596037 = header.getOrDefault("X-Amz-Credential")
  valid_596037 = validateParameter(valid_596037, JString, required = false,
                                 default = nil)
  if valid_596037 != nil:
    section.add "X-Amz-Credential", valid_596037
  var valid_596038 = header.getOrDefault("X-Amz-Security-Token")
  valid_596038 = validateParameter(valid_596038, JString, required = false,
                                 default = nil)
  if valid_596038 != nil:
    section.add "X-Amz-Security-Token", valid_596038
  var valid_596039 = header.getOrDefault("X-Amz-Algorithm")
  valid_596039 = validateParameter(valid_596039, JString, required = false,
                                 default = nil)
  if valid_596039 != nil:
    section.add "X-Amz-Algorithm", valid_596039
  var valid_596040 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596040 = validateParameter(valid_596040, JString, required = false,
                                 default = nil)
  if valid_596040 != nil:
    section.add "X-Amz-SignedHeaders", valid_596040
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596041: Call_GetRestoreTableFromClusterSnapshot_596021;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ## 
  let valid = call_596041.validator(path, query, header, formData, body)
  let scheme = call_596041.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596041.url(scheme.get, call_596041.host, call_596041.base,
                         call_596041.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596041, url, valid)

proc call*(call_596042: Call_GetRestoreTableFromClusterSnapshot_596021;
          SnapshotIdentifier: string; SourceTableName: string;
          SourceDatabaseName: string; ClusterIdentifier: string;
          NewTableName: string; TargetSchemaName: string = "";
          Action: string = "RestoreTableFromClusterSnapshot";
          SourceSchemaName: string = ""; Version: string = "2012-12-01";
          TargetDatabaseName: string = ""): Recallable =
  ## getRestoreTableFromClusterSnapshot
  ## <p>Creates a new table from a table in an Amazon Redshift cluster snapshot. You must create the new table within the Amazon Redshift cluster that the snapshot was taken from.</p> <p>You cannot use <code>RestoreTableFromClusterSnapshot</code> to restore a table with the same name as an existing table in an Amazon Redshift cluster. That is, you cannot overwrite an existing table in a cluster with a restored table. If you want to replace your original table with a new, restored table, then rename or drop your original table before you call <code>RestoreTableFromClusterSnapshot</code>. When you have renamed your original table, then you can pass the original name of the table as the <code>NewTableName</code> parameter value in the call to <code>RestoreTableFromClusterSnapshot</code>. This way, you can replace the original table with the table created from the snapshot.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot to restore the table from. This snapshot must have been created from the Amazon Redshift cluster specified by the <code>ClusterIdentifier</code> parameter.
  ##   SourceTableName: string (required)
  ##                  : The name of the source table to restore from.
  ##   SourceDatabaseName: string (required)
  ##                     : The name of the source database that contains the table to restore from.
  ##   TargetSchemaName: string
  ##                   : The name of the schema to restore the table to.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : The identifier of the Amazon Redshift cluster to restore the table to.
  ##   SourceSchemaName: string
  ##                   : The name of the source schema that contains the table to restore from. If you do not specify a <code>SourceSchemaName</code> value, the default is <code>public</code>.
  ##   Version: string (required)
  ##   TargetDatabaseName: string
  ##                     : The name of the database to restore the table to.
  ##   NewTableName: string (required)
  ##               : The name of the table to create as a result of the current request.
  var query_596043 = newJObject()
  add(query_596043, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_596043, "SourceTableName", newJString(SourceTableName))
  add(query_596043, "SourceDatabaseName", newJString(SourceDatabaseName))
  add(query_596043, "TargetSchemaName", newJString(TargetSchemaName))
  add(query_596043, "Action", newJString(Action))
  add(query_596043, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596043, "SourceSchemaName", newJString(SourceSchemaName))
  add(query_596043, "Version", newJString(Version))
  add(query_596043, "TargetDatabaseName", newJString(TargetDatabaseName))
  add(query_596043, "NewTableName", newJString(NewTableName))
  result = call_596042.call(nil, query_596043, nil, nil, nil)

var getRestoreTableFromClusterSnapshot* = Call_GetRestoreTableFromClusterSnapshot_596021(
    name: "getRestoreTableFromClusterSnapshot", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RestoreTableFromClusterSnapshot",
    validator: validate_GetRestoreTableFromClusterSnapshot_596022, base: "/",
    url: url_GetRestoreTableFromClusterSnapshot_596023,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeClusterSecurityGroupIngress_596087 = ref object of OpenApiRestCall_592348
proc url_PostRevokeClusterSecurityGroupIngress_596089(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRevokeClusterSecurityGroupIngress_596088(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596090 = query.getOrDefault("Action")
  valid_596090 = validateParameter(valid_596090, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_596090 != nil:
    section.add "Action", valid_596090
  var valid_596091 = query.getOrDefault("Version")
  valid_596091 = validateParameter(valid_596091, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596091 != nil:
    section.add "Version", valid_596091
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596092 = header.getOrDefault("X-Amz-Signature")
  valid_596092 = validateParameter(valid_596092, JString, required = false,
                                 default = nil)
  if valid_596092 != nil:
    section.add "X-Amz-Signature", valid_596092
  var valid_596093 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596093 = validateParameter(valid_596093, JString, required = false,
                                 default = nil)
  if valid_596093 != nil:
    section.add "X-Amz-Content-Sha256", valid_596093
  var valid_596094 = header.getOrDefault("X-Amz-Date")
  valid_596094 = validateParameter(valid_596094, JString, required = false,
                                 default = nil)
  if valid_596094 != nil:
    section.add "X-Amz-Date", valid_596094
  var valid_596095 = header.getOrDefault("X-Amz-Credential")
  valid_596095 = validateParameter(valid_596095, JString, required = false,
                                 default = nil)
  if valid_596095 != nil:
    section.add "X-Amz-Credential", valid_596095
  var valid_596096 = header.getOrDefault("X-Amz-Security-Token")
  valid_596096 = validateParameter(valid_596096, JString, required = false,
                                 default = nil)
  if valid_596096 != nil:
    section.add "X-Amz-Security-Token", valid_596096
  var valid_596097 = header.getOrDefault("X-Amz-Algorithm")
  valid_596097 = validateParameter(valid_596097, JString, required = false,
                                 default = nil)
  if valid_596097 != nil:
    section.add "X-Amz-Algorithm", valid_596097
  var valid_596098 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596098 = validateParameter(valid_596098, JString, required = false,
                                 default = nil)
  if valid_596098 != nil:
    section.add "X-Amz-SignedHeaders", valid_596098
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_596099 = formData.getOrDefault("ClusterSecurityGroupName")
  valid_596099 = validateParameter(valid_596099, JString, required = true,
                                 default = nil)
  if valid_596099 != nil:
    section.add "ClusterSecurityGroupName", valid_596099
  var valid_596100 = formData.getOrDefault("EC2SecurityGroupName")
  valid_596100 = validateParameter(valid_596100, JString, required = false,
                                 default = nil)
  if valid_596100 != nil:
    section.add "EC2SecurityGroupName", valid_596100
  var valid_596101 = formData.getOrDefault("EC2SecurityGroupOwnerId")
  valid_596101 = validateParameter(valid_596101, JString, required = false,
                                 default = nil)
  if valid_596101 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_596101
  var valid_596102 = formData.getOrDefault("CIDRIP")
  valid_596102 = validateParameter(valid_596102, JString, required = false,
                                 default = nil)
  if valid_596102 != nil:
    section.add "CIDRIP", valid_596102
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596103: Call_PostRevokeClusterSecurityGroupIngress_596087;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_596103.validator(path, query, header, formData, body)
  let scheme = call_596103.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596103.url(scheme.get, call_596103.host, call_596103.base,
                         call_596103.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596103, url, valid)

proc call*(call_596104: Call_PostRevokeClusterSecurityGroupIngress_596087;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = ""; CIDRIP: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"): Recallable =
  ## postRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  ##   Action: string (required)
  ##   Version: string (required)
  var query_596105 = newJObject()
  var formData_596106 = newJObject()
  add(formData_596106, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(formData_596106, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(formData_596106, "EC2SecurityGroupOwnerId",
      newJString(EC2SecurityGroupOwnerId))
  add(formData_596106, "CIDRIP", newJString(CIDRIP))
  add(query_596105, "Action", newJString(Action))
  add(query_596105, "Version", newJString(Version))
  result = call_596104.call(nil, query_596105, nil, formData_596106, nil)

var postRevokeClusterSecurityGroupIngress* = Call_PostRevokeClusterSecurityGroupIngress_596087(
    name: "postRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_PostRevokeClusterSecurityGroupIngress_596088, base: "/",
    url: url_PostRevokeClusterSecurityGroupIngress_596089,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeClusterSecurityGroupIngress_596068 = ref object of OpenApiRestCall_592348
proc url_GetRevokeClusterSecurityGroupIngress_596070(protocol: Scheme;
    host: string; base: string; route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRevokeClusterSecurityGroupIngress_596069(path: JsonNode;
    query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   EC2SecurityGroupName: JString
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: JString
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: JString (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   CIDRIP: JString
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  section = newJObject()
  var valid_596071 = query.getOrDefault("EC2SecurityGroupName")
  valid_596071 = validateParameter(valid_596071, JString, required = false,
                                 default = nil)
  if valid_596071 != nil:
    section.add "EC2SecurityGroupName", valid_596071
  var valid_596072 = query.getOrDefault("EC2SecurityGroupOwnerId")
  valid_596072 = validateParameter(valid_596072, JString, required = false,
                                 default = nil)
  if valid_596072 != nil:
    section.add "EC2SecurityGroupOwnerId", valid_596072
  assert query != nil, "query argument is necessary due to required `ClusterSecurityGroupName` field"
  var valid_596073 = query.getOrDefault("ClusterSecurityGroupName")
  valid_596073 = validateParameter(valid_596073, JString, required = true,
                                 default = nil)
  if valid_596073 != nil:
    section.add "ClusterSecurityGroupName", valid_596073
  var valid_596074 = query.getOrDefault("Action")
  valid_596074 = validateParameter(valid_596074, JString, required = true, default = newJString(
      "RevokeClusterSecurityGroupIngress"))
  if valid_596074 != nil:
    section.add "Action", valid_596074
  var valid_596075 = query.getOrDefault("Version")
  valid_596075 = validateParameter(valid_596075, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596075 != nil:
    section.add "Version", valid_596075
  var valid_596076 = query.getOrDefault("CIDRIP")
  valid_596076 = validateParameter(valid_596076, JString, required = false,
                                 default = nil)
  if valid_596076 != nil:
    section.add "CIDRIP", valid_596076
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596077 = header.getOrDefault("X-Amz-Signature")
  valid_596077 = validateParameter(valid_596077, JString, required = false,
                                 default = nil)
  if valid_596077 != nil:
    section.add "X-Amz-Signature", valid_596077
  var valid_596078 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596078 = validateParameter(valid_596078, JString, required = false,
                                 default = nil)
  if valid_596078 != nil:
    section.add "X-Amz-Content-Sha256", valid_596078
  var valid_596079 = header.getOrDefault("X-Amz-Date")
  valid_596079 = validateParameter(valid_596079, JString, required = false,
                                 default = nil)
  if valid_596079 != nil:
    section.add "X-Amz-Date", valid_596079
  var valid_596080 = header.getOrDefault("X-Amz-Credential")
  valid_596080 = validateParameter(valid_596080, JString, required = false,
                                 default = nil)
  if valid_596080 != nil:
    section.add "X-Amz-Credential", valid_596080
  var valid_596081 = header.getOrDefault("X-Amz-Security-Token")
  valid_596081 = validateParameter(valid_596081, JString, required = false,
                                 default = nil)
  if valid_596081 != nil:
    section.add "X-Amz-Security-Token", valid_596081
  var valid_596082 = header.getOrDefault("X-Amz-Algorithm")
  valid_596082 = validateParameter(valid_596082, JString, required = false,
                                 default = nil)
  if valid_596082 != nil:
    section.add "X-Amz-Algorithm", valid_596082
  var valid_596083 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596083 = validateParameter(valid_596083, JString, required = false,
                                 default = nil)
  if valid_596083 != nil:
    section.add "X-Amz-SignedHeaders", valid_596083
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596084: Call_GetRevokeClusterSecurityGroupIngress_596068;
          path: JsonNode; query: JsonNode; header: JsonNode; formData: JsonNode;
          body: JsonNode): Recallable =
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ## 
  let valid = call_596084.validator(path, query, header, formData, body)
  let scheme = call_596084.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596084.url(scheme.get, call_596084.host, call_596084.base,
                         call_596084.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596084, url, valid)

proc call*(call_596085: Call_GetRevokeClusterSecurityGroupIngress_596068;
          ClusterSecurityGroupName: string; EC2SecurityGroupName: string = "";
          EC2SecurityGroupOwnerId: string = "";
          Action: string = "RevokeClusterSecurityGroupIngress";
          Version: string = "2012-12-01"; CIDRIP: string = ""): Recallable =
  ## getRevokeClusterSecurityGroupIngress
  ## Revokes an ingress rule in an Amazon Redshift security group for a previously authorized IP range or Amazon EC2 security group. To add an ingress rule, see <a>AuthorizeClusterSecurityGroupIngress</a>. For information about managing security groups, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-security-groups.html">Amazon Redshift Cluster Security Groups</a> in the <i>Amazon Redshift Cluster Management Guide</i>. 
  ##   EC2SecurityGroupName: string
  ##                       : The name of the EC2 Security Group whose access is to be revoked. If <code>EC2SecurityGroupName</code> is specified, <code>EC2SecurityGroupOwnerId</code> must also be provided and <code>CIDRIP</code> cannot be provided. 
  ##   EC2SecurityGroupOwnerId: string
  ##                          : <p>The AWS account number of the owner of the security group specified in the <code>EC2SecurityGroupName</code> parameter. The AWS access key ID is not an acceptable value. If <code>EC2SecurityGroupOwnerId</code> is specified, <code>EC2SecurityGroupName</code> must also be provided. and <code>CIDRIP</code> cannot be provided. </p> <p>Example: <code>111122223333</code> </p>
  ##   ClusterSecurityGroupName: string (required)
  ##                           : The name of the security Group from which to revoke the ingress rule.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   CIDRIP: string
  ##         : The IP range for which to revoke access. This range must be a valid Classless Inter-Domain Routing (CIDR) block of IP addresses. If <code>CIDRIP</code> is specified, <code>EC2SecurityGroupName</code> and <code>EC2SecurityGroupOwnerId</code> cannot be provided. 
  var query_596086 = newJObject()
  add(query_596086, "EC2SecurityGroupName", newJString(EC2SecurityGroupName))
  add(query_596086, "EC2SecurityGroupOwnerId", newJString(EC2SecurityGroupOwnerId))
  add(query_596086, "ClusterSecurityGroupName",
      newJString(ClusterSecurityGroupName))
  add(query_596086, "Action", newJString(Action))
  add(query_596086, "Version", newJString(Version))
  add(query_596086, "CIDRIP", newJString(CIDRIP))
  result = call_596085.call(nil, query_596086, nil, nil, nil)

var getRevokeClusterSecurityGroupIngress* = Call_GetRevokeClusterSecurityGroupIngress_596068(
    name: "getRevokeClusterSecurityGroupIngress", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com",
    route: "/#Action=RevokeClusterSecurityGroupIngress",
    validator: validate_GetRevokeClusterSecurityGroupIngress_596069, base: "/",
    url: url_GetRevokeClusterSecurityGroupIngress_596070,
    schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRevokeSnapshotAccess_596125 = ref object of OpenApiRestCall_592348
proc url_PostRevokeSnapshotAccess_596127(protocol: Scheme; host: string;
                                        base: string; route: string; path: JsonNode;
                                        query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRevokeSnapshotAccess_596126(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596128 = query.getOrDefault("Action")
  valid_596128 = validateParameter(valid_596128, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_596128 != nil:
    section.add "Action", valid_596128
  var valid_596129 = query.getOrDefault("Version")
  valid_596129 = validateParameter(valid_596129, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596129 != nil:
    section.add "Version", valid_596129
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596130 = header.getOrDefault("X-Amz-Signature")
  valid_596130 = validateParameter(valid_596130, JString, required = false,
                                 default = nil)
  if valid_596130 != nil:
    section.add "X-Amz-Signature", valid_596130
  var valid_596131 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596131 = validateParameter(valid_596131, JString, required = false,
                                 default = nil)
  if valid_596131 != nil:
    section.add "X-Amz-Content-Sha256", valid_596131
  var valid_596132 = header.getOrDefault("X-Amz-Date")
  valid_596132 = validateParameter(valid_596132, JString, required = false,
                                 default = nil)
  if valid_596132 != nil:
    section.add "X-Amz-Date", valid_596132
  var valid_596133 = header.getOrDefault("X-Amz-Credential")
  valid_596133 = validateParameter(valid_596133, JString, required = false,
                                 default = nil)
  if valid_596133 != nil:
    section.add "X-Amz-Credential", valid_596133
  var valid_596134 = header.getOrDefault("X-Amz-Security-Token")
  valid_596134 = validateParameter(valid_596134, JString, required = false,
                                 default = nil)
  if valid_596134 != nil:
    section.add "X-Amz-Security-Token", valid_596134
  var valid_596135 = header.getOrDefault("X-Amz-Algorithm")
  valid_596135 = validateParameter(valid_596135, JString, required = false,
                                 default = nil)
  if valid_596135 != nil:
    section.add "X-Amz-Algorithm", valid_596135
  var valid_596136 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596136 = validateParameter(valid_596136, JString, required = false,
                                 default = nil)
  if valid_596136 != nil:
    section.add "X-Amz-SignedHeaders", valid_596136
  result.add "header", section
  ## parameters in `formData` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `SnapshotIdentifier` field"
  var valid_596137 = formData.getOrDefault("SnapshotIdentifier")
  valid_596137 = validateParameter(valid_596137, JString, required = true,
                                 default = nil)
  if valid_596137 != nil:
    section.add "SnapshotIdentifier", valid_596137
  var valid_596138 = formData.getOrDefault("AccountWithRestoreAccess")
  valid_596138 = validateParameter(valid_596138, JString, required = true,
                                 default = nil)
  if valid_596138 != nil:
    section.add "AccountWithRestoreAccess", valid_596138
  var valid_596139 = formData.getOrDefault("SnapshotClusterIdentifier")
  valid_596139 = validateParameter(valid_596139, JString, required = false,
                                 default = nil)
  if valid_596139 != nil:
    section.add "SnapshotClusterIdentifier", valid_596139
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596140: Call_PostRevokeSnapshotAccess_596125; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_596140.validator(path, query, header, formData, body)
  let scheme = call_596140.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596140.url(scheme.get, call_596140.host, call_596140.base,
                         call_596140.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596140, url, valid)

proc call*(call_596141: Call_PostRevokeSnapshotAccess_596125;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          Action: string = "RevokeSnapshotAccess";
          SnapshotClusterIdentifier: string = ""; Version: string = "2012-12-01"): Recallable =
  ## postRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   Action: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Version: string (required)
  var query_596142 = newJObject()
  var formData_596143 = newJObject()
  add(formData_596143, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_596142, "Action", newJString(Action))
  add(formData_596143, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  add(formData_596143, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_596142, "Version", newJString(Version))
  result = call_596141.call(nil, query_596142, nil, formData_596143, nil)

var postRevokeSnapshotAccess* = Call_PostRevokeSnapshotAccess_596125(
    name: "postRevokeSnapshotAccess", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_PostRevokeSnapshotAccess_596126, base: "/",
    url: url_PostRevokeSnapshotAccess_596127, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRevokeSnapshotAccess_596107 = ref object of OpenApiRestCall_592348
proc url_GetRevokeSnapshotAccess_596109(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRevokeSnapshotAccess_596108(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   SnapshotIdentifier: JString (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   SnapshotClusterIdentifier: JString
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: JString (required)
  ##   Version: JString (required)
  ##   AccountWithRestoreAccess: JString (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `SnapshotIdentifier` field"
  var valid_596110 = query.getOrDefault("SnapshotIdentifier")
  valid_596110 = validateParameter(valid_596110, JString, required = true,
                                 default = nil)
  if valid_596110 != nil:
    section.add "SnapshotIdentifier", valid_596110
  var valid_596111 = query.getOrDefault("SnapshotClusterIdentifier")
  valid_596111 = validateParameter(valid_596111, JString, required = false,
                                 default = nil)
  if valid_596111 != nil:
    section.add "SnapshotClusterIdentifier", valid_596111
  var valid_596112 = query.getOrDefault("Action")
  valid_596112 = validateParameter(valid_596112, JString, required = true,
                                 default = newJString("RevokeSnapshotAccess"))
  if valid_596112 != nil:
    section.add "Action", valid_596112
  var valid_596113 = query.getOrDefault("Version")
  valid_596113 = validateParameter(valid_596113, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596113 != nil:
    section.add "Version", valid_596113
  var valid_596114 = query.getOrDefault("AccountWithRestoreAccess")
  valid_596114 = validateParameter(valid_596114, JString, required = true,
                                 default = nil)
  if valid_596114 != nil:
    section.add "AccountWithRestoreAccess", valid_596114
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596115 = header.getOrDefault("X-Amz-Signature")
  valid_596115 = validateParameter(valid_596115, JString, required = false,
                                 default = nil)
  if valid_596115 != nil:
    section.add "X-Amz-Signature", valid_596115
  var valid_596116 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596116 = validateParameter(valid_596116, JString, required = false,
                                 default = nil)
  if valid_596116 != nil:
    section.add "X-Amz-Content-Sha256", valid_596116
  var valid_596117 = header.getOrDefault("X-Amz-Date")
  valid_596117 = validateParameter(valid_596117, JString, required = false,
                                 default = nil)
  if valid_596117 != nil:
    section.add "X-Amz-Date", valid_596117
  var valid_596118 = header.getOrDefault("X-Amz-Credential")
  valid_596118 = validateParameter(valid_596118, JString, required = false,
                                 default = nil)
  if valid_596118 != nil:
    section.add "X-Amz-Credential", valid_596118
  var valid_596119 = header.getOrDefault("X-Amz-Security-Token")
  valid_596119 = validateParameter(valid_596119, JString, required = false,
                                 default = nil)
  if valid_596119 != nil:
    section.add "X-Amz-Security-Token", valid_596119
  var valid_596120 = header.getOrDefault("X-Amz-Algorithm")
  valid_596120 = validateParameter(valid_596120, JString, required = false,
                                 default = nil)
  if valid_596120 != nil:
    section.add "X-Amz-Algorithm", valid_596120
  var valid_596121 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596121 = validateParameter(valid_596121, JString, required = false,
                                 default = nil)
  if valid_596121 != nil:
    section.add "X-Amz-SignedHeaders", valid_596121
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596122: Call_GetRevokeSnapshotAccess_596107; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ## 
  let valid = call_596122.validator(path, query, header, formData, body)
  let scheme = call_596122.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596122.url(scheme.get, call_596122.host, call_596122.base,
                         call_596122.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596122, url, valid)

proc call*(call_596123: Call_GetRevokeSnapshotAccess_596107;
          SnapshotIdentifier: string; AccountWithRestoreAccess: string;
          SnapshotClusterIdentifier: string = "";
          Action: string = "RevokeSnapshotAccess"; Version: string = "2012-12-01"): Recallable =
  ## getRevokeSnapshotAccess
  ## <p>Removes the ability of the specified AWS customer account to restore the specified snapshot. If the account is currently restoring the snapshot, the restore will run to completion.</p> <p> For more information about working with snapshots, go to <a href="https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-snapshots.html">Amazon Redshift Snapshots</a> in the <i>Amazon Redshift Cluster Management Guide</i>.</p>
  ##   SnapshotIdentifier: string (required)
  ##                     : The identifier of the snapshot that the account can no longer access.
  ##   SnapshotClusterIdentifier: string
  ##                            : The identifier of the cluster the snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
  ##   Action: string (required)
  ##   Version: string (required)
  ##   AccountWithRestoreAccess: string (required)
  ##                           : The identifier of the AWS customer account that can no longer restore the specified snapshot.
  var query_596124 = newJObject()
  add(query_596124, "SnapshotIdentifier", newJString(SnapshotIdentifier))
  add(query_596124, "SnapshotClusterIdentifier",
      newJString(SnapshotClusterIdentifier))
  add(query_596124, "Action", newJString(Action))
  add(query_596124, "Version", newJString(Version))
  add(query_596124, "AccountWithRestoreAccess",
      newJString(AccountWithRestoreAccess))
  result = call_596123.call(nil, query_596124, nil, nil, nil)

var getRevokeSnapshotAccess* = Call_GetRevokeSnapshotAccess_596107(
    name: "getRevokeSnapshotAccess", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RevokeSnapshotAccess",
    validator: validate_GetRevokeSnapshotAccess_596108, base: "/",
    url: url_GetRevokeSnapshotAccess_596109, schemes: {Scheme.Https, Scheme.Http})
type
  Call_PostRotateEncryptionKey_596160 = ref object of OpenApiRestCall_592348
proc url_PostRotateEncryptionKey_596162(protocol: Scheme; host: string; base: string;
                                       route: string; path: JsonNode;
                                       query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_PostRotateEncryptionKey_596161(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596163 = query.getOrDefault("Action")
  valid_596163 = validateParameter(valid_596163, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_596163 != nil:
    section.add "Action", valid_596163
  var valid_596164 = query.getOrDefault("Version")
  valid_596164 = validateParameter(valid_596164, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596164 != nil:
    section.add "Version", valid_596164
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596165 = header.getOrDefault("X-Amz-Signature")
  valid_596165 = validateParameter(valid_596165, JString, required = false,
                                 default = nil)
  if valid_596165 != nil:
    section.add "X-Amz-Signature", valid_596165
  var valid_596166 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596166 = validateParameter(valid_596166, JString, required = false,
                                 default = nil)
  if valid_596166 != nil:
    section.add "X-Amz-Content-Sha256", valid_596166
  var valid_596167 = header.getOrDefault("X-Amz-Date")
  valid_596167 = validateParameter(valid_596167, JString, required = false,
                                 default = nil)
  if valid_596167 != nil:
    section.add "X-Amz-Date", valid_596167
  var valid_596168 = header.getOrDefault("X-Amz-Credential")
  valid_596168 = validateParameter(valid_596168, JString, required = false,
                                 default = nil)
  if valid_596168 != nil:
    section.add "X-Amz-Credential", valid_596168
  var valid_596169 = header.getOrDefault("X-Amz-Security-Token")
  valid_596169 = validateParameter(valid_596169, JString, required = false,
                                 default = nil)
  if valid_596169 != nil:
    section.add "X-Amz-Security-Token", valid_596169
  var valid_596170 = header.getOrDefault("X-Amz-Algorithm")
  valid_596170 = validateParameter(valid_596170, JString, required = false,
                                 default = nil)
  if valid_596170 != nil:
    section.add "X-Amz-Algorithm", valid_596170
  var valid_596171 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596171 = validateParameter(valid_596171, JString, required = false,
                                 default = nil)
  if valid_596171 != nil:
    section.add "X-Amz-SignedHeaders", valid_596171
  result.add "header", section
  ## parameters in `formData` object:
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  section = newJObject()
  assert formData != nil, "formData argument is necessary due to required `ClusterIdentifier` field"
  var valid_596172 = formData.getOrDefault("ClusterIdentifier")
  valid_596172 = validateParameter(valid_596172, JString, required = true,
                                 default = nil)
  if valid_596172 != nil:
    section.add "ClusterIdentifier", valid_596172
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596173: Call_PostRotateEncryptionKey_596160; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_596173.validator(path, query, header, formData, body)
  let scheme = call_596173.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596173.url(scheme.get, call_596173.host, call_596173.base,
                         call_596173.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596173, url, valid)

proc call*(call_596174: Call_PostRotateEncryptionKey_596160;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## postRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Action: string (required)
  ##   Version: string (required)
  var query_596175 = newJObject()
  var formData_596176 = newJObject()
  add(formData_596176, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596175, "Action", newJString(Action))
  add(query_596175, "Version", newJString(Version))
  result = call_596174.call(nil, query_596175, nil, formData_596176, nil)

var postRotateEncryptionKey* = Call_PostRotateEncryptionKey_596160(
    name: "postRotateEncryptionKey", meth: HttpMethod.HttpPost,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_PostRotateEncryptionKey_596161, base: "/",
    url: url_PostRotateEncryptionKey_596162, schemes: {Scheme.Https, Scheme.Http})
type
  Call_GetRotateEncryptionKey_596144 = ref object of OpenApiRestCall_592348
proc url_GetRotateEncryptionKey_596146(protocol: Scheme; host: string; base: string;
                                      route: string; path: JsonNode; query: JsonNode): Uri =
  result.scheme = $protocol
  result.hostname = host
  result.query = $queryString(query)
  result.path = base & route

proc validate_GetRotateEncryptionKey_596145(path: JsonNode; query: JsonNode;
    header: JsonNode; formData: JsonNode; body: JsonNode): JsonNode =
  ## Rotates the encryption keys for a cluster.
  ## 
  var section: JsonNode
  result = newJObject()
  section = newJObject()
  result.add "path", section
  ## parameters in `query` object:
  ##   Action: JString (required)
  ##   ClusterIdentifier: JString (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: JString (required)
  section = newJObject()
  assert query != nil, "query argument is necessary due to required `Action` field"
  var valid_596147 = query.getOrDefault("Action")
  valid_596147 = validateParameter(valid_596147, JString, required = true,
                                 default = newJString("RotateEncryptionKey"))
  if valid_596147 != nil:
    section.add "Action", valid_596147
  var valid_596148 = query.getOrDefault("ClusterIdentifier")
  valid_596148 = validateParameter(valid_596148, JString, required = true,
                                 default = nil)
  if valid_596148 != nil:
    section.add "ClusterIdentifier", valid_596148
  var valid_596149 = query.getOrDefault("Version")
  valid_596149 = validateParameter(valid_596149, JString, required = true,
                                 default = newJString("2012-12-01"))
  if valid_596149 != nil:
    section.add "Version", valid_596149
  result.add "query", section
  ## parameters in `header` object:
  ##   X-Amz-Signature: JString
  ##   X-Amz-Content-Sha256: JString
  ##   X-Amz-Date: JString
  ##   X-Amz-Credential: JString
  ##   X-Amz-Security-Token: JString
  ##   X-Amz-Algorithm: JString
  ##   X-Amz-SignedHeaders: JString
  section = newJObject()
  var valid_596150 = header.getOrDefault("X-Amz-Signature")
  valid_596150 = validateParameter(valid_596150, JString, required = false,
                                 default = nil)
  if valid_596150 != nil:
    section.add "X-Amz-Signature", valid_596150
  var valid_596151 = header.getOrDefault("X-Amz-Content-Sha256")
  valid_596151 = validateParameter(valid_596151, JString, required = false,
                                 default = nil)
  if valid_596151 != nil:
    section.add "X-Amz-Content-Sha256", valid_596151
  var valid_596152 = header.getOrDefault("X-Amz-Date")
  valid_596152 = validateParameter(valid_596152, JString, required = false,
                                 default = nil)
  if valid_596152 != nil:
    section.add "X-Amz-Date", valid_596152
  var valid_596153 = header.getOrDefault("X-Amz-Credential")
  valid_596153 = validateParameter(valid_596153, JString, required = false,
                                 default = nil)
  if valid_596153 != nil:
    section.add "X-Amz-Credential", valid_596153
  var valid_596154 = header.getOrDefault("X-Amz-Security-Token")
  valid_596154 = validateParameter(valid_596154, JString, required = false,
                                 default = nil)
  if valid_596154 != nil:
    section.add "X-Amz-Security-Token", valid_596154
  var valid_596155 = header.getOrDefault("X-Amz-Algorithm")
  valid_596155 = validateParameter(valid_596155, JString, required = false,
                                 default = nil)
  if valid_596155 != nil:
    section.add "X-Amz-Algorithm", valid_596155
  var valid_596156 = header.getOrDefault("X-Amz-SignedHeaders")
  valid_596156 = validateParameter(valid_596156, JString, required = false,
                                 default = nil)
  if valid_596156 != nil:
    section.add "X-Amz-SignedHeaders", valid_596156
  result.add "header", section
  section = newJObject()
  result.add "formData", section
  if body != nil:
    result.add "body", body

proc call*(call_596157: Call_GetRotateEncryptionKey_596144; path: JsonNode;
          query: JsonNode; header: JsonNode; formData: JsonNode; body: JsonNode): Recallable =
  ## Rotates the encryption keys for a cluster.
  ## 
  let valid = call_596157.validator(path, query, header, formData, body)
  let scheme = call_596157.pickScheme
  if scheme.isNone:
    raise newException(IOError, "unable to find a supported scheme")
  let url = call_596157.url(scheme.get, call_596157.host, call_596157.base,
                         call_596157.route, valid.getOrDefault("path"),
                         valid.getOrDefault("query"))
  result = hook(call_596157, url, valid)

proc call*(call_596158: Call_GetRotateEncryptionKey_596144;
          ClusterIdentifier: string; Action: string = "RotateEncryptionKey";
          Version: string = "2012-12-01"): Recallable =
  ## getRotateEncryptionKey
  ## Rotates the encryption keys for a cluster.
  ##   Action: string (required)
  ##   ClusterIdentifier: string (required)
  ##                    : <p>The unique identifier of the cluster that you want to rotate the encryption keys for.</p> <p>Constraints: Must be the name of valid cluster that has encryption enabled.</p>
  ##   Version: string (required)
  var query_596159 = newJObject()
  add(query_596159, "Action", newJString(Action))
  add(query_596159, "ClusterIdentifier", newJString(ClusterIdentifier))
  add(query_596159, "Version", newJString(Version))
  result = call_596158.call(nil, query_596159, nil, nil, nil)

var getRotateEncryptionKey* = Call_GetRotateEncryptionKey_596144(
    name: "getRotateEncryptionKey", meth: HttpMethod.HttpGet,
    host: "redshift.amazonaws.com", route: "/#Action=RotateEncryptionKey",
    validator: validate_GetRotateEncryptionKey_596145, base: "/",
    url: url_GetRotateEncryptionKey_596146, schemes: {Scheme.Https, Scheme.Http})
export
  rest

proc sign(recall: var Recallable; query: JsonNode; algo: SigningAlgo = SHA256) =
  let
    date = makeDateTime()
    access = os.getEnv("AWS_ACCESS_KEY_ID", "")
    secret = os.getEnv("AWS_SECRET_ACCESS_KEY", "")
    region = os.getEnv("AWS_REGION", "")
  assert secret != "", "need secret key in env"
  assert access != "", "need access key in env"
  assert region != "", "need region in env"
  var
    normal: PathNormal
    url = normalizeUrl(recall.url, query, normalize = normal)
    scheme = parseEnum[Scheme](url.scheme)
  assert scheme in awsServers, "unknown scheme `" & $scheme & "`"
  assert region in awsServers[scheme], "unknown region `" & region & "`"
  url.hostname = awsServers[scheme][region]
  case awsServiceName.toLowerAscii
  of "s3":
    normal = PathNormal.S3
  else:
    normal = PathNormal.Default
  recall.headers["Host"] = url.hostname
  recall.headers["X-Amz-Date"] = date
  let
    algo = SHA256
    scope = credentialScope(region = region, service = awsServiceName, date = date)
    request = canonicalRequest(recall.meth, $url, query, recall.headers, recall.body,
                             normalize = normal, digest = algo)
    sts = stringToSign(request.hash(algo), scope, date = date, digest = algo)
    signature = calculateSignature(secret = secret, date = date, region = region,
                                 service = awsServiceName, sts, digest = algo)
  var auth = $algo & " "
  auth &= "Credential=" & access / scope & ", "
  auth &= "SignedHeaders=" & recall.headers.signedHeaders & ", "
  auth &= "Signature=" & signature
  recall.headers["Authorization"] = auth
  recall.headers.del "Host"
  recall.url = $url

method hook(call: OpenApiRestCall; url: Uri; input: JsonNode): Recallable {.base.} =
  let headers = massageHeaders(input.getOrDefault("header"))
  result = newRecallable(call, url, headers, input.getOrDefault("body").getStr)
  result.sign(input.getOrDefault("query"), SHA256)
